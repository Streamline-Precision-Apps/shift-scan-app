
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model CostCode
 * 
 */
export type CostCode = $Result.DefaultSelection<Prisma.$CostCodePayload>
/**
 * Model CCTag
 * 
 */
export type CCTag = $Result.DefaultSelection<Prisma.$CCTagPayload>
/**
 * Model Crew
 * 
 */
export type Crew = $Result.DefaultSelection<Prisma.$CrewPayload>
/**
 * Model PdfDocument
 * 
 */
export type PdfDocument = $Result.DefaultSelection<Prisma.$PdfDocumentPayload>
/**
 * Model DocumentTag
 * 
 */
export type DocumentTag = $Result.DefaultSelection<Prisma.$DocumentTagPayload>
/**
 * Model Equipment
 * 
 */
export type Equipment = $Result.DefaultSelection<Prisma.$EquipmentPayload>
/**
 * Model EmployeeEquipmentLog
 * 
 */
export type EmployeeEquipmentLog = $Result.DefaultSelection<Prisma.$EmployeeEquipmentLogPayload>
/**
 * Model FormTemplate
 * 
 */
export type FormTemplate = $Result.DefaultSelection<Prisma.$FormTemplatePayload>
/**
 * Model FormGrouping
 * 
 */
export type FormGrouping = $Result.DefaultSelection<Prisma.$FormGroupingPayload>
/**
 * Model FormField
 * 
 */
export type FormField = $Result.DefaultSelection<Prisma.$FormFieldPayload>
/**
 * Model FormFieldOption
 * 
 */
export type FormFieldOption = $Result.DefaultSelection<Prisma.$FormFieldOptionPayload>
/**
 * Model FormSubmission
 * 
 */
export type FormSubmission = $Result.DefaultSelection<Prisma.$FormSubmissionPayload>
/**
 * Model FormApproval
 * 
 */
export type FormApproval = $Result.DefaultSelection<Prisma.$FormApprovalPayload>
/**
 * Model Jobsite
 * 
 */
export type Jobsite = $Result.DefaultSelection<Prisma.$JobsitePayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model ReportRun
 * 
 */
export type ReportRun = $Result.DefaultSelection<Prisma.$ReportRunPayload>
/**
 * Model TimeSheet
 * 
 */
export type TimeSheet = $Result.DefaultSelection<Prisma.$TimeSheetPayload>
/**
 * Model mechanicProjects
 * 
 */
export type mechanicProjects = $Result.DefaultSelection<Prisma.$mechanicProjectsPayload>
/**
 * Model MaintenanceLog
 * 
 */
export type MaintenanceLog = $Result.DefaultSelection<Prisma.$MaintenanceLogPayload>
/**
 * Model Maintenance
 * 
 */
export type Maintenance = $Result.DefaultSelection<Prisma.$MaintenancePayload>
/**
 * Model TascoLog
 * 
 */
export type TascoLog = $Result.DefaultSelection<Prisma.$TascoLogPayload>
/**
 * Model TascoFLoads
 * 
 */
export type TascoFLoads = $Result.DefaultSelection<Prisma.$TascoFLoadsPayload>
/**
 * Model TascoMaterialTypes
 * 
 */
export type TascoMaterialTypes = $Result.DefaultSelection<Prisma.$TascoMaterialTypesPayload>
/**
 * Model TruckingLog
 * 
 */
export type TruckingLog = $Result.DefaultSelection<Prisma.$TruckingLogPayload>
/**
 * Model StateMileage
 * 
 */
export type StateMileage = $Result.DefaultSelection<Prisma.$StateMileagePayload>
/**
 * Model Material
 * 
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>
/**
 * Model RefuelLog
 * 
 */
export type RefuelLog = $Result.DefaultSelection<Prisma.$RefuelLogPayload>
/**
 * Model EquipmentHauled
 * 
 */
export type EquipmentHauled = $Result.DefaultSelection<Prisma.$EquipmentHauledPayload>
/**
 * Model TimeSheetChangeLog
 * 
 */
export type TimeSheetChangeLog = $Result.DefaultSelection<Prisma.$TimeSheetChangeLogPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserSettings
 * 
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model Contacts
 * 
 */
export type Contacts = $Result.DefaultSelection<Prisma.$ContactsPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model AccountSetupToken
 * 
 */
export type AccountSetupToken = $Result.DefaultSelection<Prisma.$AccountSetupTokenPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model FCMToken
 * 
 */
export type FCMToken = $Result.DefaultSelection<Prisma.$FCMTokenPayload>
/**
 * Model TopicSubscription
 * 
 */
export type TopicSubscription = $Result.DefaultSelection<Prisma.$TopicSubscriptionPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationResponse
 * 
 */
export type NotificationResponse = $Result.DefaultSelection<Prisma.$NotificationResponsePayload>
/**
 * Model NotificationRead
 * 
 */
export type NotificationRead = $Result.DefaultSelection<Prisma.$NotificationReadPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Condition: {
  NEW: 'NEW',
  USED: 'USED'
};

export type Condition = (typeof Condition)[keyof typeof Condition]


export const EquipmentState: {
  AVAILABLE: 'AVAILABLE',
  IN_USE: 'IN_USE',
  MAINTENANCE: 'MAINTENANCE',
  NEEDS_REPAIR: 'NEEDS_REPAIR',
  RETIRED: 'RETIRED'
};

export type EquipmentState = (typeof EquipmentState)[keyof typeof EquipmentState]


export const EquipmentTags: {
  TRUCK: 'TRUCK',
  TRAILER: 'TRAILER',
  VEHICLE: 'VEHICLE',
  EQUIPMENT: 'EQUIPMENT'
};

export type EquipmentTags = (typeof EquipmentTags)[keyof typeof EquipmentTags]


export const OwnershipType: {
  OWNED: 'OWNED',
  LEASED: 'LEASED',
  RENTAL: 'RENTAL'
};

export type OwnershipType = (typeof OwnershipType)[keyof typeof OwnershipType]


export const materialUnit: {
  TONS: 'TONS',
  YARDS: 'YARDS'
};

export type materialUnit = (typeof materialUnit)[keyof typeof materialUnit]


export const Permission: {
  USER: 'USER',
  MANAGER: 'MANAGER',
  ADMIN: 'ADMIN',
  SUPERADMIN: 'SUPERADMIN'
};

export type Permission = (typeof Permission)[keyof typeof Permission]


export const IsActive: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type IsActive = (typeof IsActive)[keyof typeof IsActive]


export const WorkType: {
  MECHANIC: 'MECHANIC',
  TRUCK_DRIVER: 'TRUCK_DRIVER',
  LABOR: 'LABOR',
  TASCO: 'TASCO'
};

export type WorkType = (typeof WorkType)[keyof typeof WorkType]


export const Priority: {
  PENDING: 'PENDING',
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  TODAY: 'TODAY'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const LoadType: {
  UNSCREENED: 'UNSCREENED',
  SCREENED: 'SCREENED'
};

export type LoadType = (typeof LoadType)[keyof typeof LoadType]


export const EquipmentUsageType: {
  TASCO: 'TASCO',
  TRUCKING: 'TRUCKING',
  MAINTENANCE: 'MAINTENANCE',
  LABOR: 'LABOR',
  GENERAL: 'GENERAL'
};

export type EquipmentUsageType = (typeof EquipmentUsageType)[keyof typeof EquipmentUsageType]


export const ApprovalStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type ApprovalStatus = (typeof ApprovalStatus)[keyof typeof ApprovalStatus]


export const ReportStatus: {
  PENDING: 'PENDING',
  RUNNING: 'RUNNING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELED: 'CANCELED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const ReportVisibility: {
  PRIVATE: 'PRIVATE',
  MANAGEMENT: 'MANAGEMENT',
  COMPANY: 'COMPANY'
};

export type ReportVisibility = (typeof ReportVisibility)[keyof typeof ReportVisibility]


export const FormStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  DENIED: 'DENIED'
};

export type FormStatus = (typeof FormStatus)[keyof typeof FormStatus]


export const FormTemplateStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  ARCHIVED: 'ARCHIVED'
};

export type FormTemplateStatus = (typeof FormTemplateStatus)[keyof typeof FormTemplateStatus]


export const ActiveStatus: {
  ACTIVE: 'ACTIVE',
  ARCHIVED: 'ARCHIVED'
};

export type ActiveStatus = (typeof ActiveStatus)[keyof typeof ActiveStatus]


export const FieldType: {
  TEXT: 'TEXT',
  TEXTAREA: 'TEXTAREA',
  NUMBER: 'NUMBER',
  DATE: 'DATE',
  DATE_TIME: 'DATE_TIME',
  TIME: 'TIME',
  DROPDOWN: 'DROPDOWN',
  CHECKBOX: 'CHECKBOX',
  HEADER: 'HEADER',
  PARAGRAPH: 'PARAGRAPH',
  MULTISELECT: 'MULTISELECT',
  RADIO: 'RADIO',
  SEARCH_PERSON: 'SEARCH_PERSON',
  SEARCH_ASSET: 'SEARCH_ASSET'
};

export type FieldType = (typeof FieldType)[keyof typeof FieldType]


export const AssetType: {
  EQUIPMENT: 'EQUIPMENT',
  JOBSITES: 'JOBSITES',
  COST_CODES: 'COST_CODES',
  CLIENTS: 'CLIENTS'
};

export type AssetType = (typeof AssetType)[keyof typeof AssetType]


export const FormTemplateCategory: {
  GENERAL: 'GENERAL',
  MAINTENANCE: 'MAINTENANCE',
  SAFETY: 'SAFETY',
  INSPECTION: 'INSPECTION',
  INCIDENT: 'INCIDENT',
  FINANCE: 'FINANCE',
  OTHER: 'OTHER',
  HR: 'HR',
  OPERATIONS: 'OPERATIONS',
  COMPLIANCE: 'COMPLIANCE',
  CLIENTS: 'CLIENTS',
  IT: 'IT'
};

export type FormTemplateCategory = (typeof FormTemplateCategory)[keyof typeof FormTemplateCategory]


export const CreatedVia: {
  ADMIN: 'ADMIN',
  MOBILE: 'MOBILE'
};

export type CreatedVia = (typeof CreatedVia)[keyof typeof CreatedVia]

}

export type Condition = $Enums.Condition

export const Condition: typeof $Enums.Condition

export type EquipmentState = $Enums.EquipmentState

export const EquipmentState: typeof $Enums.EquipmentState

export type EquipmentTags = $Enums.EquipmentTags

export const EquipmentTags: typeof $Enums.EquipmentTags

export type OwnershipType = $Enums.OwnershipType

export const OwnershipType: typeof $Enums.OwnershipType

export type materialUnit = $Enums.materialUnit

export const materialUnit: typeof $Enums.materialUnit

export type Permission = $Enums.Permission

export const Permission: typeof $Enums.Permission

export type IsActive = $Enums.IsActive

export const IsActive: typeof $Enums.IsActive

export type WorkType = $Enums.WorkType

export const WorkType: typeof $Enums.WorkType

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type LoadType = $Enums.LoadType

export const LoadType: typeof $Enums.LoadType

export type EquipmentUsageType = $Enums.EquipmentUsageType

export const EquipmentUsageType: typeof $Enums.EquipmentUsageType

export type ApprovalStatus = $Enums.ApprovalStatus

export const ApprovalStatus: typeof $Enums.ApprovalStatus

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type ReportVisibility = $Enums.ReportVisibility

export const ReportVisibility: typeof $Enums.ReportVisibility

export type FormStatus = $Enums.FormStatus

export const FormStatus: typeof $Enums.FormStatus

export type FormTemplateStatus = $Enums.FormTemplateStatus

export const FormTemplateStatus: typeof $Enums.FormTemplateStatus

export type ActiveStatus = $Enums.ActiveStatus

export const ActiveStatus: typeof $Enums.ActiveStatus

export type FieldType = $Enums.FieldType

export const FieldType: typeof $Enums.FieldType

export type AssetType = $Enums.AssetType

export const AssetType: typeof $Enums.AssetType

export type FormTemplateCategory = $Enums.FormTemplateCategory

export const FormTemplateCategory: typeof $Enums.FormTemplateCategory

export type CreatedVia = $Enums.CreatedVia

export const CreatedVia: typeof $Enums.CreatedVia

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Companies
 * const companies = await prisma.company.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Companies
   * const companies = await prisma.company.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.costCode`: Exposes CRUD operations for the **CostCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostCodes
    * const costCodes = await prisma.costCode.findMany()
    * ```
    */
  get costCode(): Prisma.CostCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cCTag`: Exposes CRUD operations for the **CCTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CCTags
    * const cCTags = await prisma.cCTag.findMany()
    * ```
    */
  get cCTag(): Prisma.CCTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.crew`: Exposes CRUD operations for the **Crew** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Crews
    * const crews = await prisma.crew.findMany()
    * ```
    */
  get crew(): Prisma.CrewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pdfDocument`: Exposes CRUD operations for the **PdfDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PdfDocuments
    * const pdfDocuments = await prisma.pdfDocument.findMany()
    * ```
    */
  get pdfDocument(): Prisma.PdfDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentTag`: Exposes CRUD operations for the **DocumentTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentTags
    * const documentTags = await prisma.documentTag.findMany()
    * ```
    */
  get documentTag(): Prisma.DocumentTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **Equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.EquipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeEquipmentLog`: Exposes CRUD operations for the **EmployeeEquipmentLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeEquipmentLogs
    * const employeeEquipmentLogs = await prisma.employeeEquipmentLog.findMany()
    * ```
    */
  get employeeEquipmentLog(): Prisma.EmployeeEquipmentLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formTemplate`: Exposes CRUD operations for the **FormTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormTemplates
    * const formTemplates = await prisma.formTemplate.findMany()
    * ```
    */
  get formTemplate(): Prisma.FormTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formGrouping`: Exposes CRUD operations for the **FormGrouping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormGroupings
    * const formGroupings = await prisma.formGrouping.findMany()
    * ```
    */
  get formGrouping(): Prisma.FormGroupingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formField`: Exposes CRUD operations for the **FormField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormFields
    * const formFields = await prisma.formField.findMany()
    * ```
    */
  get formField(): Prisma.FormFieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formFieldOption`: Exposes CRUD operations for the **FormFieldOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormFieldOptions
    * const formFieldOptions = await prisma.formFieldOption.findMany()
    * ```
    */
  get formFieldOption(): Prisma.FormFieldOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formSubmission`: Exposes CRUD operations for the **FormSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormSubmissions
    * const formSubmissions = await prisma.formSubmission.findMany()
    * ```
    */
  get formSubmission(): Prisma.FormSubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formApproval`: Exposes CRUD operations for the **FormApproval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormApprovals
    * const formApprovals = await prisma.formApproval.findMany()
    * ```
    */
  get formApproval(): Prisma.FormApprovalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobsite`: Exposes CRUD operations for the **Jobsite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobsites
    * const jobsites = await prisma.jobsite.findMany()
    * ```
    */
  get jobsite(): Prisma.JobsiteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportRun`: Exposes CRUD operations for the **ReportRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportRuns
    * const reportRuns = await prisma.reportRun.findMany()
    * ```
    */
  get reportRun(): Prisma.ReportRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeSheet`: Exposes CRUD operations for the **TimeSheet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeSheets
    * const timeSheets = await prisma.timeSheet.findMany()
    * ```
    */
  get timeSheet(): Prisma.TimeSheetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mechanicProjects`: Exposes CRUD operations for the **mechanicProjects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MechanicProjects
    * const mechanicProjects = await prisma.mechanicProjects.findMany()
    * ```
    */
  get mechanicProjects(): Prisma.mechanicProjectsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenanceLog`: Exposes CRUD operations for the **MaintenanceLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceLogs
    * const maintenanceLogs = await prisma.maintenanceLog.findMany()
    * ```
    */
  get maintenanceLog(): Prisma.MaintenanceLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenance`: Exposes CRUD operations for the **Maintenance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maintenances
    * const maintenances = await prisma.maintenance.findMany()
    * ```
    */
  get maintenance(): Prisma.MaintenanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tascoLog`: Exposes CRUD operations for the **TascoLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TascoLogs
    * const tascoLogs = await prisma.tascoLog.findMany()
    * ```
    */
  get tascoLog(): Prisma.TascoLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tascoFLoads`: Exposes CRUD operations for the **TascoFLoads** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TascoFLoads
    * const tascoFLoads = await prisma.tascoFLoads.findMany()
    * ```
    */
  get tascoFLoads(): Prisma.TascoFLoadsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tascoMaterialTypes`: Exposes CRUD operations for the **TascoMaterialTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TascoMaterialTypes
    * const tascoMaterialTypes = await prisma.tascoMaterialTypes.findMany()
    * ```
    */
  get tascoMaterialTypes(): Prisma.TascoMaterialTypesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.truckingLog`: Exposes CRUD operations for the **TruckingLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TruckingLogs
    * const truckingLogs = await prisma.truckingLog.findMany()
    * ```
    */
  get truckingLog(): Prisma.TruckingLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stateMileage`: Exposes CRUD operations for the **StateMileage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StateMileages
    * const stateMileages = await prisma.stateMileage.findMany()
    * ```
    */
  get stateMileage(): Prisma.StateMileageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refuelLog`: Exposes CRUD operations for the **RefuelLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefuelLogs
    * const refuelLogs = await prisma.refuelLog.findMany()
    * ```
    */
  get refuelLog(): Prisma.RefuelLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipmentHauled`: Exposes CRUD operations for the **EquipmentHauled** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EquipmentHauleds
    * const equipmentHauleds = await prisma.equipmentHauled.findMany()
    * ```
    */
  get equipmentHauled(): Prisma.EquipmentHauledDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.timeSheetChangeLog`: Exposes CRUD operations for the **TimeSheetChangeLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeSheetChangeLogs
    * const timeSheetChangeLogs = await prisma.timeSheetChangeLog.findMany()
    * ```
    */
  get timeSheetChangeLog(): Prisma.TimeSheetChangeLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contacts`: Exposes CRUD operations for the **Contacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contacts.findMany()
    * ```
    */
  get contacts(): Prisma.ContactsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountSetupToken`: Exposes CRUD operations for the **AccountSetupToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountSetupTokens
    * const accountSetupTokens = await prisma.accountSetupToken.findMany()
    * ```
    */
  get accountSetupToken(): Prisma.AccountSetupTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fCMToken`: Exposes CRUD operations for the **FCMToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FCMTokens
    * const fCMTokens = await prisma.fCMToken.findMany()
    * ```
    */
  get fCMToken(): Prisma.FCMTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topicSubscription`: Exposes CRUD operations for the **TopicSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TopicSubscriptions
    * const topicSubscriptions = await prisma.topicSubscription.findMany()
    * ```
    */
  get topicSubscription(): Prisma.TopicSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationResponse`: Exposes CRUD operations for the **NotificationResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationResponses
    * const notificationResponses = await prisma.notificationResponse.findMany()
    * ```
    */
  get notificationResponse(): Prisma.NotificationResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationRead`: Exposes CRUD operations for the **NotificationRead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationReads
    * const notificationReads = await prisma.notificationRead.findMany()
    * ```
    */
  get notificationRead(): Prisma.NotificationReadDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Company: 'Company',
    CostCode: 'CostCode',
    CCTag: 'CCTag',
    Crew: 'Crew',
    PdfDocument: 'PdfDocument',
    DocumentTag: 'DocumentTag',
    Equipment: 'Equipment',
    EmployeeEquipmentLog: 'EmployeeEquipmentLog',
    FormTemplate: 'FormTemplate',
    FormGrouping: 'FormGrouping',
    FormField: 'FormField',
    FormFieldOption: 'FormFieldOption',
    FormSubmission: 'FormSubmission',
    FormApproval: 'FormApproval',
    Jobsite: 'Jobsite',
    Report: 'Report',
    ReportRun: 'ReportRun',
    TimeSheet: 'TimeSheet',
    mechanicProjects: 'mechanicProjects',
    MaintenanceLog: 'MaintenanceLog',
    Maintenance: 'Maintenance',
    TascoLog: 'TascoLog',
    TascoFLoads: 'TascoFLoads',
    TascoMaterialTypes: 'TascoMaterialTypes',
    TruckingLog: 'TruckingLog',
    StateMileage: 'StateMileage',
    Material: 'Material',
    RefuelLog: 'RefuelLog',
    EquipmentHauled: 'EquipmentHauled',
    TimeSheetChangeLog: 'TimeSheetChangeLog',
    User: 'User',
    UserSettings: 'UserSettings',
    Contacts: 'Contacts',
    PasswordResetToken: 'PasswordResetToken',
    AccountSetupToken: 'AccountSetupToken',
    Address: 'Address',
    FCMToken: 'FCMToken',
    TopicSubscription: 'TopicSubscription',
    Notification: 'Notification',
    NotificationResponse: 'NotificationResponse',
    NotificationRead: 'NotificationRead'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "company" | "costCode" | "cCTag" | "crew" | "pdfDocument" | "documentTag" | "equipment" | "employeeEquipmentLog" | "formTemplate" | "formGrouping" | "formField" | "formFieldOption" | "formSubmission" | "formApproval" | "jobsite" | "report" | "reportRun" | "timeSheet" | "mechanicProjects" | "maintenanceLog" | "maintenance" | "tascoLog" | "tascoFLoads" | "tascoMaterialTypes" | "truckingLog" | "stateMileage" | "material" | "refuelLog" | "equipmentHauled" | "timeSheetChangeLog" | "user" | "userSettings" | "contacts" | "passwordResetToken" | "accountSetupToken" | "address" | "fCMToken" | "topicSubscription" | "notification" | "notificationResponse" | "notificationRead"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      CostCode: {
        payload: Prisma.$CostCodePayload<ExtArgs>
        fields: Prisma.CostCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCodePayload>
          }
          findFirst: {
            args: Prisma.CostCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCodePayload>
          }
          findMany: {
            args: Prisma.CostCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCodePayload>[]
          }
          create: {
            args: Prisma.CostCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCodePayload>
          }
          createMany: {
            args: Prisma.CostCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCodePayload>[]
          }
          delete: {
            args: Prisma.CostCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCodePayload>
          }
          update: {
            args: Prisma.CostCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCodePayload>
          }
          deleteMany: {
            args: Prisma.CostCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CostCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCodePayload>[]
          }
          upsert: {
            args: Prisma.CostCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostCodePayload>
          }
          aggregate: {
            args: Prisma.CostCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostCode>
          }
          groupBy: {
            args: Prisma.CostCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostCodeCountArgs<ExtArgs>
            result: $Utils.Optional<CostCodeCountAggregateOutputType> | number
          }
        }
      }
      CCTag: {
        payload: Prisma.$CCTagPayload<ExtArgs>
        fields: Prisma.CCTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CCTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CCTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CCTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CCTagPayload>
          }
          findFirst: {
            args: Prisma.CCTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CCTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CCTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CCTagPayload>
          }
          findMany: {
            args: Prisma.CCTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CCTagPayload>[]
          }
          create: {
            args: Prisma.CCTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CCTagPayload>
          }
          createMany: {
            args: Prisma.CCTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CCTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CCTagPayload>[]
          }
          delete: {
            args: Prisma.CCTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CCTagPayload>
          }
          update: {
            args: Prisma.CCTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CCTagPayload>
          }
          deleteMany: {
            args: Prisma.CCTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CCTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CCTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CCTagPayload>[]
          }
          upsert: {
            args: Prisma.CCTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CCTagPayload>
          }
          aggregate: {
            args: Prisma.CCTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCCTag>
          }
          groupBy: {
            args: Prisma.CCTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<CCTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.CCTagCountArgs<ExtArgs>
            result: $Utils.Optional<CCTagCountAggregateOutputType> | number
          }
        }
      }
      Crew: {
        payload: Prisma.$CrewPayload<ExtArgs>
        fields: Prisma.CrewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CrewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CrewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          findFirst: {
            args: Prisma.CrewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CrewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          findMany: {
            args: Prisma.CrewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>[]
          }
          create: {
            args: Prisma.CrewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          createMany: {
            args: Prisma.CrewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CrewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>[]
          }
          delete: {
            args: Prisma.CrewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          update: {
            args: Prisma.CrewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          deleteMany: {
            args: Prisma.CrewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CrewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CrewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>[]
          }
          upsert: {
            args: Prisma.CrewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CrewPayload>
          }
          aggregate: {
            args: Prisma.CrewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCrew>
          }
          groupBy: {
            args: Prisma.CrewGroupByArgs<ExtArgs>
            result: $Utils.Optional<CrewGroupByOutputType>[]
          }
          count: {
            args: Prisma.CrewCountArgs<ExtArgs>
            result: $Utils.Optional<CrewCountAggregateOutputType> | number
          }
        }
      }
      PdfDocument: {
        payload: Prisma.$PdfDocumentPayload<ExtArgs>
        fields: Prisma.PdfDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PdfDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PdfDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfDocumentPayload>
          }
          findFirst: {
            args: Prisma.PdfDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PdfDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfDocumentPayload>
          }
          findMany: {
            args: Prisma.PdfDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfDocumentPayload>[]
          }
          create: {
            args: Prisma.PdfDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfDocumentPayload>
          }
          createMany: {
            args: Prisma.PdfDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PdfDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfDocumentPayload>[]
          }
          delete: {
            args: Prisma.PdfDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfDocumentPayload>
          }
          update: {
            args: Prisma.PdfDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfDocumentPayload>
          }
          deleteMany: {
            args: Prisma.PdfDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PdfDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PdfDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfDocumentPayload>[]
          }
          upsert: {
            args: Prisma.PdfDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PdfDocumentPayload>
          }
          aggregate: {
            args: Prisma.PdfDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePdfDocument>
          }
          groupBy: {
            args: Prisma.PdfDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PdfDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PdfDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<PdfDocumentCountAggregateOutputType> | number
          }
        }
      }
      DocumentTag: {
        payload: Prisma.$DocumentTagPayload<ExtArgs>
        fields: Prisma.DocumentTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          findFirst: {
            args: Prisma.DocumentTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          findMany: {
            args: Prisma.DocumentTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>[]
          }
          create: {
            args: Prisma.DocumentTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          createMany: {
            args: Prisma.DocumentTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>[]
          }
          delete: {
            args: Prisma.DocumentTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          update: {
            args: Prisma.DocumentTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          deleteMany: {
            args: Prisma.DocumentTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>[]
          }
          upsert: {
            args: Prisma.DocumentTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          aggregate: {
            args: Prisma.DocumentTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentTag>
          }
          groupBy: {
            args: Prisma.DocumentTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentTagCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentTagCountAggregateOutputType> | number
          }
        }
      }
      Equipment: {
        payload: Prisma.$EquipmentPayload<ExtArgs>
        fields: Prisma.EquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findFirst: {
            args: Prisma.EquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findMany: {
            args: Prisma.EquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          create: {
            args: Prisma.EquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          createMany: {
            args: Prisma.EquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          delete: {
            args: Prisma.EquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          update: {
            args: Prisma.EquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          upsert: {
            args: Prisma.EquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          aggregate: {
            args: Prisma.EquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipment>
          }
          groupBy: {
            args: Prisma.EquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCountAggregateOutputType> | number
          }
        }
      }
      EmployeeEquipmentLog: {
        payload: Prisma.$EmployeeEquipmentLogPayload<ExtArgs>
        fields: Prisma.EmployeeEquipmentLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeEquipmentLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeEquipmentLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeEquipmentLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeEquipmentLogPayload>
          }
          findFirst: {
            args: Prisma.EmployeeEquipmentLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeEquipmentLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeEquipmentLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeEquipmentLogPayload>
          }
          findMany: {
            args: Prisma.EmployeeEquipmentLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeEquipmentLogPayload>[]
          }
          create: {
            args: Prisma.EmployeeEquipmentLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeEquipmentLogPayload>
          }
          createMany: {
            args: Prisma.EmployeeEquipmentLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeEquipmentLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeEquipmentLogPayload>[]
          }
          delete: {
            args: Prisma.EmployeeEquipmentLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeEquipmentLogPayload>
          }
          update: {
            args: Prisma.EmployeeEquipmentLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeEquipmentLogPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeEquipmentLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeEquipmentLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeEquipmentLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeEquipmentLogPayload>[]
          }
          upsert: {
            args: Prisma.EmployeeEquipmentLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeEquipmentLogPayload>
          }
          aggregate: {
            args: Prisma.EmployeeEquipmentLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeEquipmentLog>
          }
          groupBy: {
            args: Prisma.EmployeeEquipmentLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeEquipmentLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeEquipmentLogCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeEquipmentLogCountAggregateOutputType> | number
          }
        }
      }
      FormTemplate: {
        payload: Prisma.$FormTemplatePayload<ExtArgs>
        fields: Prisma.FormTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          findFirst: {
            args: Prisma.FormTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          findMany: {
            args: Prisma.FormTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>[]
          }
          create: {
            args: Prisma.FormTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          createMany: {
            args: Prisma.FormTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>[]
          }
          delete: {
            args: Prisma.FormTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          update: {
            args: Prisma.FormTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          deleteMany: {
            args: Prisma.FormTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>[]
          }
          upsert: {
            args: Prisma.FormTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormTemplatePayload>
          }
          aggregate: {
            args: Prisma.FormTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormTemplate>
          }
          groupBy: {
            args: Prisma.FormTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<FormTemplateCountAggregateOutputType> | number
          }
        }
      }
      FormGrouping: {
        payload: Prisma.$FormGroupingPayload<ExtArgs>
        fields: Prisma.FormGroupingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormGroupingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormGroupingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormGroupingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormGroupingPayload>
          }
          findFirst: {
            args: Prisma.FormGroupingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormGroupingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormGroupingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormGroupingPayload>
          }
          findMany: {
            args: Prisma.FormGroupingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormGroupingPayload>[]
          }
          create: {
            args: Prisma.FormGroupingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormGroupingPayload>
          }
          createMany: {
            args: Prisma.FormGroupingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormGroupingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormGroupingPayload>[]
          }
          delete: {
            args: Prisma.FormGroupingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormGroupingPayload>
          }
          update: {
            args: Prisma.FormGroupingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormGroupingPayload>
          }
          deleteMany: {
            args: Prisma.FormGroupingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormGroupingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormGroupingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormGroupingPayload>[]
          }
          upsert: {
            args: Prisma.FormGroupingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormGroupingPayload>
          }
          aggregate: {
            args: Prisma.FormGroupingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormGrouping>
          }
          groupBy: {
            args: Prisma.FormGroupingGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormGroupingGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormGroupingCountArgs<ExtArgs>
            result: $Utils.Optional<FormGroupingCountAggregateOutputType> | number
          }
        }
      }
      FormField: {
        payload: Prisma.$FormFieldPayload<ExtArgs>
        fields: Prisma.FormFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload>
          }
          findFirst: {
            args: Prisma.FormFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload>
          }
          findMany: {
            args: Prisma.FormFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload>[]
          }
          create: {
            args: Prisma.FormFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload>
          }
          createMany: {
            args: Prisma.FormFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload>[]
          }
          delete: {
            args: Prisma.FormFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload>
          }
          update: {
            args: Prisma.FormFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload>
          }
          deleteMany: {
            args: Prisma.FormFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormFieldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload>[]
          }
          upsert: {
            args: Prisma.FormFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldPayload>
          }
          aggregate: {
            args: Prisma.FormFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormField>
          }
          groupBy: {
            args: Prisma.FormFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormFieldCountArgs<ExtArgs>
            result: $Utils.Optional<FormFieldCountAggregateOutputType> | number
          }
        }
      }
      FormFieldOption: {
        payload: Prisma.$FormFieldOptionPayload<ExtArgs>
        fields: Prisma.FormFieldOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormFieldOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormFieldOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldOptionPayload>
          }
          findFirst: {
            args: Prisma.FormFieldOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormFieldOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldOptionPayload>
          }
          findMany: {
            args: Prisma.FormFieldOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldOptionPayload>[]
          }
          create: {
            args: Prisma.FormFieldOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldOptionPayload>
          }
          createMany: {
            args: Prisma.FormFieldOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormFieldOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldOptionPayload>[]
          }
          delete: {
            args: Prisma.FormFieldOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldOptionPayload>
          }
          update: {
            args: Prisma.FormFieldOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldOptionPayload>
          }
          deleteMany: {
            args: Prisma.FormFieldOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormFieldOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormFieldOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldOptionPayload>[]
          }
          upsert: {
            args: Prisma.FormFieldOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormFieldOptionPayload>
          }
          aggregate: {
            args: Prisma.FormFieldOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormFieldOption>
          }
          groupBy: {
            args: Prisma.FormFieldOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormFieldOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormFieldOptionCountArgs<ExtArgs>
            result: $Utils.Optional<FormFieldOptionCountAggregateOutputType> | number
          }
        }
      }
      FormSubmission: {
        payload: Prisma.$FormSubmissionPayload<ExtArgs>
        fields: Prisma.FormSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          findFirst: {
            args: Prisma.FormSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          findMany: {
            args: Prisma.FormSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
          }
          create: {
            args: Prisma.FormSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          createMany: {
            args: Prisma.FormSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
          }
          delete: {
            args: Prisma.FormSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          update: {
            args: Prisma.FormSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.FormSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.FormSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
          }
          aggregate: {
            args: Prisma.FormSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormSubmission>
          }
          groupBy: {
            args: Prisma.FormSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<FormSubmissionCountAggregateOutputType> | number
          }
        }
      }
      FormApproval: {
        payload: Prisma.$FormApprovalPayload<ExtArgs>
        fields: Prisma.FormApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormApprovalPayload>
          }
          findFirst: {
            args: Prisma.FormApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormApprovalPayload>
          }
          findMany: {
            args: Prisma.FormApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormApprovalPayload>[]
          }
          create: {
            args: Prisma.FormApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormApprovalPayload>
          }
          createMany: {
            args: Prisma.FormApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormApprovalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormApprovalPayload>[]
          }
          delete: {
            args: Prisma.FormApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormApprovalPayload>
          }
          update: {
            args: Prisma.FormApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormApprovalPayload>
          }
          deleteMany: {
            args: Prisma.FormApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormApprovalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormApprovalPayload>[]
          }
          upsert: {
            args: Prisma.FormApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormApprovalPayload>
          }
          aggregate: {
            args: Prisma.FormApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormApproval>
          }
          groupBy: {
            args: Prisma.FormApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<FormApprovalCountAggregateOutputType> | number
          }
        }
      }
      Jobsite: {
        payload: Prisma.$JobsitePayload<ExtArgs>
        fields: Prisma.JobsiteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobsiteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobsiteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsitePayload>
          }
          findFirst: {
            args: Prisma.JobsiteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobsiteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsitePayload>
          }
          findMany: {
            args: Prisma.JobsiteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsitePayload>[]
          }
          create: {
            args: Prisma.JobsiteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsitePayload>
          }
          createMany: {
            args: Prisma.JobsiteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobsiteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsitePayload>[]
          }
          delete: {
            args: Prisma.JobsiteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsitePayload>
          }
          update: {
            args: Prisma.JobsiteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsitePayload>
          }
          deleteMany: {
            args: Prisma.JobsiteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobsiteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JobsiteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsitePayload>[]
          }
          upsert: {
            args: Prisma.JobsiteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsitePayload>
          }
          aggregate: {
            args: Prisma.JobsiteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobsite>
          }
          groupBy: {
            args: Prisma.JobsiteGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobsiteGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobsiteCountArgs<ExtArgs>
            result: $Utils.Optional<JobsiteCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      ReportRun: {
        payload: Prisma.$ReportRunPayload<ExtArgs>
        fields: Prisma.ReportRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportRunPayload>
          }
          findFirst: {
            args: Prisma.ReportRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportRunPayload>
          }
          findMany: {
            args: Prisma.ReportRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportRunPayload>[]
          }
          create: {
            args: Prisma.ReportRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportRunPayload>
          }
          createMany: {
            args: Prisma.ReportRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportRunPayload>[]
          }
          delete: {
            args: Prisma.ReportRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportRunPayload>
          }
          update: {
            args: Prisma.ReportRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportRunPayload>
          }
          deleteMany: {
            args: Prisma.ReportRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportRunUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportRunPayload>[]
          }
          upsert: {
            args: Prisma.ReportRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportRunPayload>
          }
          aggregate: {
            args: Prisma.ReportRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportRun>
          }
          groupBy: {
            args: Prisma.ReportRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportRunCountArgs<ExtArgs>
            result: $Utils.Optional<ReportRunCountAggregateOutputType> | number
          }
        }
      }
      TimeSheet: {
        payload: Prisma.$TimeSheetPayload<ExtArgs>
        fields: Prisma.TimeSheetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeSheetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeSheetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetPayload>
          }
          findFirst: {
            args: Prisma.TimeSheetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeSheetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetPayload>
          }
          findMany: {
            args: Prisma.TimeSheetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetPayload>[]
          }
          create: {
            args: Prisma.TimeSheetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetPayload>
          }
          createMany: {
            args: Prisma.TimeSheetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeSheetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetPayload>[]
          }
          delete: {
            args: Prisma.TimeSheetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetPayload>
          }
          update: {
            args: Prisma.TimeSheetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetPayload>
          }
          deleteMany: {
            args: Prisma.TimeSheetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeSheetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimeSheetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetPayload>[]
          }
          upsert: {
            args: Prisma.TimeSheetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetPayload>
          }
          aggregate: {
            args: Prisma.TimeSheetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeSheet>
          }
          groupBy: {
            args: Prisma.TimeSheetGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeSheetGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeSheetCountArgs<ExtArgs>
            result: $Utils.Optional<TimeSheetCountAggregateOutputType> | number
          }
        }
      }
      mechanicProjects: {
        payload: Prisma.$mechanicProjectsPayload<ExtArgs>
        fields: Prisma.mechanicProjectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mechanicProjectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mechanicProjectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mechanicProjectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mechanicProjectsPayload>
          }
          findFirst: {
            args: Prisma.mechanicProjectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mechanicProjectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mechanicProjectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mechanicProjectsPayload>
          }
          findMany: {
            args: Prisma.mechanicProjectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mechanicProjectsPayload>[]
          }
          create: {
            args: Prisma.mechanicProjectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mechanicProjectsPayload>
          }
          createMany: {
            args: Prisma.mechanicProjectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mechanicProjectsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mechanicProjectsPayload>[]
          }
          delete: {
            args: Prisma.mechanicProjectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mechanicProjectsPayload>
          }
          update: {
            args: Prisma.mechanicProjectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mechanicProjectsPayload>
          }
          deleteMany: {
            args: Prisma.mechanicProjectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mechanicProjectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mechanicProjectsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mechanicProjectsPayload>[]
          }
          upsert: {
            args: Prisma.mechanicProjectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mechanicProjectsPayload>
          }
          aggregate: {
            args: Prisma.MechanicProjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMechanicProjects>
          }
          groupBy: {
            args: Prisma.mechanicProjectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MechanicProjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mechanicProjectsCountArgs<ExtArgs>
            result: $Utils.Optional<MechanicProjectsCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceLog: {
        payload: Prisma.$MaintenanceLogPayload<ExtArgs>
        fields: Prisma.MaintenanceLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          findMany: {
            args: Prisma.MaintenanceLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>[]
          }
          create: {
            args: Prisma.MaintenanceLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          createMany: {
            args: Prisma.MaintenanceLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          update: {
            args: Prisma.MaintenanceLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenanceLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>[]
          }
          upsert: {
            args: Prisma.MaintenanceLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceLogPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceLog>
          }
          groupBy: {
            args: Prisma.MaintenanceLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceLogCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceLogCountAggregateOutputType> | number
          }
        }
      }
      Maintenance: {
        payload: Prisma.$MaintenancePayload<ExtArgs>
        fields: Prisma.MaintenanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          findFirst: {
            args: Prisma.MaintenanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          findMany: {
            args: Prisma.MaintenanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>[]
          }
          create: {
            args: Prisma.MaintenanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          createMany: {
            args: Prisma.MaintenanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>[]
          }
          delete: {
            args: Prisma.MaintenanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          update: {
            args: Prisma.MaintenanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>[]
          }
          upsert: {
            args: Prisma.MaintenanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          aggregate: {
            args: Prisma.MaintenanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenance>
          }
          groupBy: {
            args: Prisma.MaintenanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceCountAggregateOutputType> | number
          }
        }
      }
      TascoLog: {
        payload: Prisma.$TascoLogPayload<ExtArgs>
        fields: Prisma.TascoLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TascoLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TascoLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoLogPayload>
          }
          findFirst: {
            args: Prisma.TascoLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TascoLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoLogPayload>
          }
          findMany: {
            args: Prisma.TascoLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoLogPayload>[]
          }
          create: {
            args: Prisma.TascoLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoLogPayload>
          }
          createMany: {
            args: Prisma.TascoLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TascoLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoLogPayload>[]
          }
          delete: {
            args: Prisma.TascoLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoLogPayload>
          }
          update: {
            args: Prisma.TascoLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoLogPayload>
          }
          deleteMany: {
            args: Prisma.TascoLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TascoLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TascoLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoLogPayload>[]
          }
          upsert: {
            args: Prisma.TascoLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoLogPayload>
          }
          aggregate: {
            args: Prisma.TascoLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTascoLog>
          }
          groupBy: {
            args: Prisma.TascoLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TascoLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TascoLogCountArgs<ExtArgs>
            result: $Utils.Optional<TascoLogCountAggregateOutputType> | number
          }
        }
      }
      TascoFLoads: {
        payload: Prisma.$TascoFLoadsPayload<ExtArgs>
        fields: Prisma.TascoFLoadsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TascoFLoadsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoFLoadsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TascoFLoadsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoFLoadsPayload>
          }
          findFirst: {
            args: Prisma.TascoFLoadsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoFLoadsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TascoFLoadsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoFLoadsPayload>
          }
          findMany: {
            args: Prisma.TascoFLoadsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoFLoadsPayload>[]
          }
          create: {
            args: Prisma.TascoFLoadsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoFLoadsPayload>
          }
          createMany: {
            args: Prisma.TascoFLoadsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TascoFLoadsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoFLoadsPayload>[]
          }
          delete: {
            args: Prisma.TascoFLoadsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoFLoadsPayload>
          }
          update: {
            args: Prisma.TascoFLoadsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoFLoadsPayload>
          }
          deleteMany: {
            args: Prisma.TascoFLoadsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TascoFLoadsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TascoFLoadsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoFLoadsPayload>[]
          }
          upsert: {
            args: Prisma.TascoFLoadsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoFLoadsPayload>
          }
          aggregate: {
            args: Prisma.TascoFLoadsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTascoFLoads>
          }
          groupBy: {
            args: Prisma.TascoFLoadsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TascoFLoadsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TascoFLoadsCountArgs<ExtArgs>
            result: $Utils.Optional<TascoFLoadsCountAggregateOutputType> | number
          }
        }
      }
      TascoMaterialTypes: {
        payload: Prisma.$TascoMaterialTypesPayload<ExtArgs>
        fields: Prisma.TascoMaterialTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TascoMaterialTypesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoMaterialTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TascoMaterialTypesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoMaterialTypesPayload>
          }
          findFirst: {
            args: Prisma.TascoMaterialTypesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoMaterialTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TascoMaterialTypesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoMaterialTypesPayload>
          }
          findMany: {
            args: Prisma.TascoMaterialTypesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoMaterialTypesPayload>[]
          }
          create: {
            args: Prisma.TascoMaterialTypesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoMaterialTypesPayload>
          }
          createMany: {
            args: Prisma.TascoMaterialTypesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TascoMaterialTypesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoMaterialTypesPayload>[]
          }
          delete: {
            args: Prisma.TascoMaterialTypesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoMaterialTypesPayload>
          }
          update: {
            args: Prisma.TascoMaterialTypesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoMaterialTypesPayload>
          }
          deleteMany: {
            args: Prisma.TascoMaterialTypesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TascoMaterialTypesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TascoMaterialTypesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoMaterialTypesPayload>[]
          }
          upsert: {
            args: Prisma.TascoMaterialTypesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TascoMaterialTypesPayload>
          }
          aggregate: {
            args: Prisma.TascoMaterialTypesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTascoMaterialTypes>
          }
          groupBy: {
            args: Prisma.TascoMaterialTypesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TascoMaterialTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.TascoMaterialTypesCountArgs<ExtArgs>
            result: $Utils.Optional<TascoMaterialTypesCountAggregateOutputType> | number
          }
        }
      }
      TruckingLog: {
        payload: Prisma.$TruckingLogPayload<ExtArgs>
        fields: Prisma.TruckingLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TruckingLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckingLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TruckingLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckingLogPayload>
          }
          findFirst: {
            args: Prisma.TruckingLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckingLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TruckingLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckingLogPayload>
          }
          findMany: {
            args: Prisma.TruckingLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckingLogPayload>[]
          }
          create: {
            args: Prisma.TruckingLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckingLogPayload>
          }
          createMany: {
            args: Prisma.TruckingLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TruckingLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckingLogPayload>[]
          }
          delete: {
            args: Prisma.TruckingLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckingLogPayload>
          }
          update: {
            args: Prisma.TruckingLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckingLogPayload>
          }
          deleteMany: {
            args: Prisma.TruckingLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TruckingLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TruckingLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckingLogPayload>[]
          }
          upsert: {
            args: Prisma.TruckingLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TruckingLogPayload>
          }
          aggregate: {
            args: Prisma.TruckingLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTruckingLog>
          }
          groupBy: {
            args: Prisma.TruckingLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TruckingLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TruckingLogCountArgs<ExtArgs>
            result: $Utils.Optional<TruckingLogCountAggregateOutputType> | number
          }
        }
      }
      StateMileage: {
        payload: Prisma.$StateMileagePayload<ExtArgs>
        fields: Prisma.StateMileageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StateMileageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateMileagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StateMileageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateMileagePayload>
          }
          findFirst: {
            args: Prisma.StateMileageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateMileagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StateMileageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateMileagePayload>
          }
          findMany: {
            args: Prisma.StateMileageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateMileagePayload>[]
          }
          create: {
            args: Prisma.StateMileageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateMileagePayload>
          }
          createMany: {
            args: Prisma.StateMileageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StateMileageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateMileagePayload>[]
          }
          delete: {
            args: Prisma.StateMileageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateMileagePayload>
          }
          update: {
            args: Prisma.StateMileageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateMileagePayload>
          }
          deleteMany: {
            args: Prisma.StateMileageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StateMileageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StateMileageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateMileagePayload>[]
          }
          upsert: {
            args: Prisma.StateMileageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StateMileagePayload>
          }
          aggregate: {
            args: Prisma.StateMileageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStateMileage>
          }
          groupBy: {
            args: Prisma.StateMileageGroupByArgs<ExtArgs>
            result: $Utils.Optional<StateMileageGroupByOutputType>[]
          }
          count: {
            args: Prisma.StateMileageCountArgs<ExtArgs>
            result: $Utils.Optional<StateMileageCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
      RefuelLog: {
        payload: Prisma.$RefuelLogPayload<ExtArgs>
        fields: Prisma.RefuelLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefuelLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefuelLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefuelLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefuelLogPayload>
          }
          findFirst: {
            args: Prisma.RefuelLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefuelLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefuelLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefuelLogPayload>
          }
          findMany: {
            args: Prisma.RefuelLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefuelLogPayload>[]
          }
          create: {
            args: Prisma.RefuelLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefuelLogPayload>
          }
          createMany: {
            args: Prisma.RefuelLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefuelLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefuelLogPayload>[]
          }
          delete: {
            args: Prisma.RefuelLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefuelLogPayload>
          }
          update: {
            args: Prisma.RefuelLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefuelLogPayload>
          }
          deleteMany: {
            args: Prisma.RefuelLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefuelLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefuelLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefuelLogPayload>[]
          }
          upsert: {
            args: Prisma.RefuelLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefuelLogPayload>
          }
          aggregate: {
            args: Prisma.RefuelLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefuelLog>
          }
          groupBy: {
            args: Prisma.RefuelLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefuelLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefuelLogCountArgs<ExtArgs>
            result: $Utils.Optional<RefuelLogCountAggregateOutputType> | number
          }
        }
      }
      EquipmentHauled: {
        payload: Prisma.$EquipmentHauledPayload<ExtArgs>
        fields: Prisma.EquipmentHauledFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentHauledFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentHauledPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentHauledFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentHauledPayload>
          }
          findFirst: {
            args: Prisma.EquipmentHauledFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentHauledPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentHauledFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentHauledPayload>
          }
          findMany: {
            args: Prisma.EquipmentHauledFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentHauledPayload>[]
          }
          create: {
            args: Prisma.EquipmentHauledCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentHauledPayload>
          }
          createMany: {
            args: Prisma.EquipmentHauledCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentHauledCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentHauledPayload>[]
          }
          delete: {
            args: Prisma.EquipmentHauledDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentHauledPayload>
          }
          update: {
            args: Prisma.EquipmentHauledUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentHauledPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentHauledDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentHauledUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipmentHauledUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentHauledPayload>[]
          }
          upsert: {
            args: Prisma.EquipmentHauledUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentHauledPayload>
          }
          aggregate: {
            args: Prisma.EquipmentHauledAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipmentHauled>
          }
          groupBy: {
            args: Prisma.EquipmentHauledGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentHauledGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentHauledCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentHauledCountAggregateOutputType> | number
          }
        }
      }
      TimeSheetChangeLog: {
        payload: Prisma.$TimeSheetChangeLogPayload<ExtArgs>
        fields: Prisma.TimeSheetChangeLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeSheetChangeLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetChangeLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeSheetChangeLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetChangeLogPayload>
          }
          findFirst: {
            args: Prisma.TimeSheetChangeLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetChangeLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeSheetChangeLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetChangeLogPayload>
          }
          findMany: {
            args: Prisma.TimeSheetChangeLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetChangeLogPayload>[]
          }
          create: {
            args: Prisma.TimeSheetChangeLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetChangeLogPayload>
          }
          createMany: {
            args: Prisma.TimeSheetChangeLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeSheetChangeLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetChangeLogPayload>[]
          }
          delete: {
            args: Prisma.TimeSheetChangeLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetChangeLogPayload>
          }
          update: {
            args: Prisma.TimeSheetChangeLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetChangeLogPayload>
          }
          deleteMany: {
            args: Prisma.TimeSheetChangeLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeSheetChangeLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TimeSheetChangeLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetChangeLogPayload>[]
          }
          upsert: {
            args: Prisma.TimeSheetChangeLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeSheetChangeLogPayload>
          }
          aggregate: {
            args: Prisma.TimeSheetChangeLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeSheetChangeLog>
          }
          groupBy: {
            args: Prisma.TimeSheetChangeLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeSheetChangeLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeSheetChangeLogCountArgs<ExtArgs>
            result: $Utils.Optional<TimeSheetChangeLogCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      Contacts: {
        payload: Prisma.$ContactsPayload<ExtArgs>
        fields: Prisma.ContactsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          findFirst: {
            args: Prisma.ContactsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          findMany: {
            args: Prisma.ContactsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>[]
          }
          create: {
            args: Prisma.ContactsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          createMany: {
            args: Prisma.ContactsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>[]
          }
          delete: {
            args: Prisma.ContactsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          update: {
            args: Prisma.ContactsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          deleteMany: {
            args: Prisma.ContactsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>[]
          }
          upsert: {
            args: Prisma.ContactsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactsPayload>
          }
          aggregate: {
            args: Prisma.ContactsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContacts>
          }
          groupBy: {
            args: Prisma.ContactsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactsCountArgs<ExtArgs>
            result: $Utils.Optional<ContactsCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      AccountSetupToken: {
        payload: Prisma.$AccountSetupTokenPayload<ExtArgs>
        fields: Prisma.AccountSetupTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountSetupTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountSetupTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountSetupTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountSetupTokenPayload>
          }
          findFirst: {
            args: Prisma.AccountSetupTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountSetupTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountSetupTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountSetupTokenPayload>
          }
          findMany: {
            args: Prisma.AccountSetupTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountSetupTokenPayload>[]
          }
          create: {
            args: Prisma.AccountSetupTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountSetupTokenPayload>
          }
          createMany: {
            args: Prisma.AccountSetupTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountSetupTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountSetupTokenPayload>[]
          }
          delete: {
            args: Prisma.AccountSetupTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountSetupTokenPayload>
          }
          update: {
            args: Prisma.AccountSetupTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountSetupTokenPayload>
          }
          deleteMany: {
            args: Prisma.AccountSetupTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountSetupTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountSetupTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountSetupTokenPayload>[]
          }
          upsert: {
            args: Prisma.AccountSetupTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountSetupTokenPayload>
          }
          aggregate: {
            args: Prisma.AccountSetupTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountSetupToken>
          }
          groupBy: {
            args: Prisma.AccountSetupTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountSetupTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountSetupTokenCountArgs<ExtArgs>
            result: $Utils.Optional<AccountSetupTokenCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      FCMToken: {
        payload: Prisma.$FCMTokenPayload<ExtArgs>
        fields: Prisma.FCMTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FCMTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FCMTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FCMTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FCMTokenPayload>
          }
          findFirst: {
            args: Prisma.FCMTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FCMTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FCMTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FCMTokenPayload>
          }
          findMany: {
            args: Prisma.FCMTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FCMTokenPayload>[]
          }
          create: {
            args: Prisma.FCMTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FCMTokenPayload>
          }
          createMany: {
            args: Prisma.FCMTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FCMTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FCMTokenPayload>[]
          }
          delete: {
            args: Prisma.FCMTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FCMTokenPayload>
          }
          update: {
            args: Prisma.FCMTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FCMTokenPayload>
          }
          deleteMany: {
            args: Prisma.FCMTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FCMTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FCMTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FCMTokenPayload>[]
          }
          upsert: {
            args: Prisma.FCMTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FCMTokenPayload>
          }
          aggregate: {
            args: Prisma.FCMTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFCMToken>
          }
          groupBy: {
            args: Prisma.FCMTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<FCMTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.FCMTokenCountArgs<ExtArgs>
            result: $Utils.Optional<FCMTokenCountAggregateOutputType> | number
          }
        }
      }
      TopicSubscription: {
        payload: Prisma.$TopicSubscriptionPayload<ExtArgs>
        fields: Prisma.TopicSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.TopicSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSubscriptionPayload>
          }
          findMany: {
            args: Prisma.TopicSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSubscriptionPayload>[]
          }
          create: {
            args: Prisma.TopicSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSubscriptionPayload>
          }
          createMany: {
            args: Prisma.TopicSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.TopicSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSubscriptionPayload>
          }
          update: {
            args: Prisma.TopicSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.TopicSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TopicSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.TopicSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.TopicSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopicSubscription>
          }
          groupBy: {
            args: Prisma.TopicSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<TopicSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationResponse: {
        payload: Prisma.$NotificationResponsePayload<ExtArgs>
        fields: Prisma.NotificationResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationResponsePayload>
          }
          findFirst: {
            args: Prisma.NotificationResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationResponsePayload>
          }
          findMany: {
            args: Prisma.NotificationResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationResponsePayload>[]
          }
          create: {
            args: Prisma.NotificationResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationResponsePayload>
          }
          createMany: {
            args: Prisma.NotificationResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationResponsePayload>[]
          }
          delete: {
            args: Prisma.NotificationResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationResponsePayload>
          }
          update: {
            args: Prisma.NotificationResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationResponsePayload>
          }
          deleteMany: {
            args: Prisma.NotificationResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationResponsePayload>[]
          }
          upsert: {
            args: Prisma.NotificationResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationResponsePayload>
          }
          aggregate: {
            args: Prisma.NotificationResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationResponse>
          }
          groupBy: {
            args: Prisma.NotificationResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationResponseCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationResponseCountAggregateOutputType> | number
          }
        }
      }
      NotificationRead: {
        payload: Prisma.$NotificationReadPayload<ExtArgs>
        fields: Prisma.NotificationReadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationReadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationReadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>
          }
          findFirst: {
            args: Prisma.NotificationReadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationReadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>
          }
          findMany: {
            args: Prisma.NotificationReadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>[]
          }
          create: {
            args: Prisma.NotificationReadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>
          }
          createMany: {
            args: Prisma.NotificationReadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationReadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>[]
          }
          delete: {
            args: Prisma.NotificationReadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>
          }
          update: {
            args: Prisma.NotificationReadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>
          }
          deleteMany: {
            args: Prisma.NotificationReadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationReadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationReadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>[]
          }
          upsert: {
            args: Prisma.NotificationReadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationReadPayload>
          }
          aggregate: {
            args: Prisma.NotificationReadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationRead>
          }
          groupBy: {
            args: Prisma.NotificationReadGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationReadGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationReadCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationReadCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    company?: CompanyOmit
    costCode?: CostCodeOmit
    cCTag?: CCTagOmit
    crew?: CrewOmit
    pdfDocument?: PdfDocumentOmit
    documentTag?: DocumentTagOmit
    equipment?: EquipmentOmit
    employeeEquipmentLog?: EmployeeEquipmentLogOmit
    formTemplate?: FormTemplateOmit
    formGrouping?: FormGroupingOmit
    formField?: FormFieldOmit
    formFieldOption?: FormFieldOptionOmit
    formSubmission?: FormSubmissionOmit
    formApproval?: FormApprovalOmit
    jobsite?: JobsiteOmit
    report?: ReportOmit
    reportRun?: ReportRunOmit
    timeSheet?: TimeSheetOmit
    mechanicProjects?: mechanicProjectsOmit
    maintenanceLog?: MaintenanceLogOmit
    maintenance?: MaintenanceOmit
    tascoLog?: TascoLogOmit
    tascoFLoads?: TascoFLoadsOmit
    tascoMaterialTypes?: TascoMaterialTypesOmit
    truckingLog?: TruckingLogOmit
    stateMileage?: StateMileageOmit
    material?: MaterialOmit
    refuelLog?: RefuelLogOmit
    equipmentHauled?: EquipmentHauledOmit
    timeSheetChangeLog?: TimeSheetChangeLogOmit
    user?: UserOmit
    userSettings?: UserSettingsOmit
    contacts?: ContactsOmit
    passwordResetToken?: PasswordResetTokenOmit
    accountSetupToken?: AccountSetupTokenOmit
    address?: AddressOmit
    fCMToken?: FCMTokenOmit
    topicSubscription?: TopicSubscriptionOmit
    notification?: NotificationOmit
    notificationResponse?: NotificationResponseOmit
    notificationRead?: NotificationReadOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    FormTemplates: number
    Reports: number
    Users: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FormTemplates?: boolean | CompanyCountOutputTypeCountFormTemplatesArgs
    Reports?: boolean | CompanyCountOutputTypeCountReportsArgs
    Users?: boolean | CompanyCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountFormTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormTemplateWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type CostCodeCountOutputType
   */

  export type CostCodeCountOutputType = {
    Timesheets: number
    CCTags: number
  }

  export type CostCodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Timesheets?: boolean | CostCodeCountOutputTypeCountTimesheetsArgs
    CCTags?: boolean | CostCodeCountOutputTypeCountCCTagsArgs
  }

  // Custom InputTypes
  /**
   * CostCodeCountOutputType without action
   */
  export type CostCodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCodeCountOutputType
     */
    select?: CostCodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CostCodeCountOutputType without action
   */
  export type CostCodeCountOutputTypeCountTimesheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSheetWhereInput
  }

  /**
   * CostCodeCountOutputType without action
   */
  export type CostCodeCountOutputTypeCountCCTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CCTagWhereInput
  }


  /**
   * Count Type CCTagCountOutputType
   */

  export type CCTagCountOutputType = {
    CostCodes: number
    Jobsites: number
  }

  export type CCTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CostCodes?: boolean | CCTagCountOutputTypeCountCostCodesArgs
    Jobsites?: boolean | CCTagCountOutputTypeCountJobsitesArgs
  }

  // Custom InputTypes
  /**
   * CCTagCountOutputType without action
   */
  export type CCTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CCTagCountOutputType
     */
    select?: CCTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CCTagCountOutputType without action
   */
  export type CCTagCountOutputTypeCountCostCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostCodeWhereInput
  }

  /**
   * CCTagCountOutputType without action
   */
  export type CCTagCountOutputTypeCountJobsitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsiteWhereInput
  }


  /**
   * Count Type CrewCountOutputType
   */

  export type CrewCountOutputType = {
    Users: number
  }

  export type CrewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | CrewCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CrewCountOutputType
     */
    select?: CrewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CrewCountOutputType without action
   */
  export type CrewCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type PdfDocumentCountOutputType
   */

  export type PdfDocumentCountOutputType = {
    DocumentTags: number
  }

  export type PdfDocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DocumentTags?: boolean | PdfDocumentCountOutputTypeCountDocumentTagsArgs
  }

  // Custom InputTypes
  /**
   * PdfDocumentCountOutputType without action
   */
  export type PdfDocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfDocumentCountOutputType
     */
    select?: PdfDocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PdfDocumentCountOutputType without action
   */
  export type PdfDocumentCountOutputTypeCountDocumentTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentTagWhereInput
  }


  /**
   * Count Type DocumentTagCountOutputType
   */

  export type DocumentTagCountOutputType = {
    Equipment: number
    Documents: number
  }

  export type DocumentTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | DocumentTagCountOutputTypeCountEquipmentArgs
    Documents?: boolean | DocumentTagCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * DocumentTagCountOutputType without action
   */
  export type DocumentTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTagCountOutputType
     */
    select?: DocumentTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentTagCountOutputType without action
   */
  export type DocumentTagCountOutputTypeCountEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * DocumentTagCountOutputType without action
   */
  export type DocumentTagCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PdfDocumentWhereInput
  }


  /**
   * Count Type EquipmentCountOutputType
   */

  export type EquipmentCountOutputType = {
    EmployeeEquipmentLogs: number
    EquipmentHauled: number
    Maintenances: number
    TascoLogs: number
    HauledInLogs: number
    UsedAsTrailer: number
    UsedAsTruck: number
    Maintenance: number
    DocumentTags: number
  }

  export type EquipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeEquipmentLogs?: boolean | EquipmentCountOutputTypeCountEmployeeEquipmentLogsArgs
    EquipmentHauled?: boolean | EquipmentCountOutputTypeCountEquipmentHauledArgs
    Maintenances?: boolean | EquipmentCountOutputTypeCountMaintenancesArgs
    TascoLogs?: boolean | EquipmentCountOutputTypeCountTascoLogsArgs
    HauledInLogs?: boolean | EquipmentCountOutputTypeCountHauledInLogsArgs
    UsedAsTrailer?: boolean | EquipmentCountOutputTypeCountUsedAsTrailerArgs
    UsedAsTruck?: boolean | EquipmentCountOutputTypeCountUsedAsTruckArgs
    Maintenance?: boolean | EquipmentCountOutputTypeCountMaintenanceArgs
    DocumentTags?: boolean | EquipmentCountOutputTypeCountDocumentTagsArgs
  }

  // Custom InputTypes
  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCountOutputType
     */
    select?: EquipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountEmployeeEquipmentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeEquipmentLogWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountEquipmentHauledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentHauledWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountMaintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountTascoLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TascoLogWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountHauledInLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TruckingLogWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountUsedAsTrailerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TruckingLogWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountUsedAsTruckArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TruckingLogWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountMaintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mechanicProjectsWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountDocumentTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentTagWhereInput
  }


  /**
   * Count Type FormTemplateCountOutputType
   */

  export type FormTemplateCountOutputType = {
    Submissions: number
    FormGrouping: number
  }

  export type FormTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Submissions?: boolean | FormTemplateCountOutputTypeCountSubmissionsArgs
    FormGrouping?: boolean | FormTemplateCountOutputTypeCountFormGroupingArgs
  }

  // Custom InputTypes
  /**
   * FormTemplateCountOutputType without action
   */
  export type FormTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplateCountOutputType
     */
    select?: FormTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormTemplateCountOutputType without action
   */
  export type FormTemplateCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
  }

  /**
   * FormTemplateCountOutputType without action
   */
  export type FormTemplateCountOutputTypeCountFormGroupingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormGroupingWhereInput
  }


  /**
   * Count Type FormGroupingCountOutputType
   */

  export type FormGroupingCountOutputType = {
    Fields: number
    FormTemplate: number
  }

  export type FormGroupingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Fields?: boolean | FormGroupingCountOutputTypeCountFieldsArgs
    FormTemplate?: boolean | FormGroupingCountOutputTypeCountFormTemplateArgs
  }

  // Custom InputTypes
  /**
   * FormGroupingCountOutputType without action
   */
  export type FormGroupingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormGroupingCountOutputType
     */
    select?: FormGroupingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormGroupingCountOutputType without action
   */
  export type FormGroupingCountOutputTypeCountFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormFieldWhereInput
  }

  /**
   * FormGroupingCountOutputType without action
   */
  export type FormGroupingCountOutputTypeCountFormTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormTemplateWhereInput
  }


  /**
   * Count Type FormFieldCountOutputType
   */

  export type FormFieldCountOutputType = {
    Options: number
  }

  export type FormFieldCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Options?: boolean | FormFieldCountOutputTypeCountOptionsArgs
  }

  // Custom InputTypes
  /**
   * FormFieldCountOutputType without action
   */
  export type FormFieldCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFieldCountOutputType
     */
    select?: FormFieldCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormFieldCountOutputType without action
   */
  export type FormFieldCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormFieldOptionWhereInput
  }


  /**
   * Count Type FormSubmissionCountOutputType
   */

  export type FormSubmissionCountOutputType = {
    Approvals: number
  }

  export type FormSubmissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Approvals?: boolean | FormSubmissionCountOutputTypeCountApprovalsArgs
  }

  // Custom InputTypes
  /**
   * FormSubmissionCountOutputType without action
   */
  export type FormSubmissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmissionCountOutputType
     */
    select?: FormSubmissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormSubmissionCountOutputType without action
   */
  export type FormSubmissionCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormApprovalWhereInput
  }


  /**
   * Count Type JobsiteCountOutputType
   */

  export type JobsiteCountOutputType = {
    TimeSheets: number
    CCTags: number
  }

  export type JobsiteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TimeSheets?: boolean | JobsiteCountOutputTypeCountTimeSheetsArgs
    CCTags?: boolean | JobsiteCountOutputTypeCountCCTagsArgs
  }

  // Custom InputTypes
  /**
   * JobsiteCountOutputType without action
   */
  export type JobsiteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobsiteCountOutputType
     */
    select?: JobsiteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobsiteCountOutputType without action
   */
  export type JobsiteCountOutputTypeCountTimeSheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSheetWhereInput
  }

  /**
   * JobsiteCountOutputType without action
   */
  export type JobsiteCountOutputTypeCountCCTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CCTagWhereInput
  }


  /**
   * Count Type ReportCountOutputType
   */

  export type ReportCountOutputType = {
    ReportRuns: number
  }

  export type ReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ReportRuns?: boolean | ReportCountOutputTypeCountReportRunsArgs
  }

  // Custom InputTypes
  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCountOutputType
     */
    select?: ReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeCountReportRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportRunWhereInput
  }


  /**
   * Count Type TimeSheetCountOutputType
   */

  export type TimeSheetCountOutputType = {
    EmployeeEquipmentLogs: number
    MaintenanceLogs: number
    TascoLogs: number
    ChangeLogs: number
    TruckingLogs: number
    Maintenance: number
  }

  export type TimeSheetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeEquipmentLogs?: boolean | TimeSheetCountOutputTypeCountEmployeeEquipmentLogsArgs
    MaintenanceLogs?: boolean | TimeSheetCountOutputTypeCountMaintenanceLogsArgs
    TascoLogs?: boolean | TimeSheetCountOutputTypeCountTascoLogsArgs
    ChangeLogs?: boolean | TimeSheetCountOutputTypeCountChangeLogsArgs
    TruckingLogs?: boolean | TimeSheetCountOutputTypeCountTruckingLogsArgs
    Maintenance?: boolean | TimeSheetCountOutputTypeCountMaintenanceArgs
  }

  // Custom InputTypes
  /**
   * TimeSheetCountOutputType without action
   */
  export type TimeSheetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheetCountOutputType
     */
    select?: TimeSheetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TimeSheetCountOutputType without action
   */
  export type TimeSheetCountOutputTypeCountEmployeeEquipmentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeEquipmentLogWhereInput
  }

  /**
   * TimeSheetCountOutputType without action
   */
  export type TimeSheetCountOutputTypeCountMaintenanceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceLogWhereInput
  }

  /**
   * TimeSheetCountOutputType without action
   */
  export type TimeSheetCountOutputTypeCountTascoLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TascoLogWhereInput
  }

  /**
   * TimeSheetCountOutputType without action
   */
  export type TimeSheetCountOutputTypeCountChangeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSheetChangeLogWhereInput
  }

  /**
   * TimeSheetCountOutputType without action
   */
  export type TimeSheetCountOutputTypeCountTruckingLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TruckingLogWhereInput
  }

  /**
   * TimeSheetCountOutputType without action
   */
  export type TimeSheetCountOutputTypeCountMaintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mechanicProjectsWhereInput
  }


  /**
   * Count Type MaintenanceCountOutputType
   */

  export type MaintenanceCountOutputType = {
    EmployeeEquipmentLog: number
    MaintenanceLogs: number
  }

  export type MaintenanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeEquipmentLog?: boolean | MaintenanceCountOutputTypeCountEmployeeEquipmentLogArgs
    MaintenanceLogs?: boolean | MaintenanceCountOutputTypeCountMaintenanceLogsArgs
  }

  // Custom InputTypes
  /**
   * MaintenanceCountOutputType without action
   */
  export type MaintenanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceCountOutputType
     */
    select?: MaintenanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MaintenanceCountOutputType without action
   */
  export type MaintenanceCountOutputTypeCountEmployeeEquipmentLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeEquipmentLogWhereInput
  }

  /**
   * MaintenanceCountOutputType without action
   */
  export type MaintenanceCountOutputTypeCountMaintenanceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceLogWhereInput
  }


  /**
   * Count Type TascoLogCountOutputType
   */

  export type TascoLogCountOutputType = {
    RefuelLogs: number
    TascoFLoads: number
  }

  export type TascoLogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RefuelLogs?: boolean | TascoLogCountOutputTypeCountRefuelLogsArgs
    TascoFLoads?: boolean | TascoLogCountOutputTypeCountTascoFLoadsArgs
  }

  // Custom InputTypes
  /**
   * TascoLogCountOutputType without action
   */
  export type TascoLogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLogCountOutputType
     */
    select?: TascoLogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TascoLogCountOutputType without action
   */
  export type TascoLogCountOutputTypeCountRefuelLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefuelLogWhereInput
  }

  /**
   * TascoLogCountOutputType without action
   */
  export type TascoLogCountOutputTypeCountTascoFLoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TascoFLoadsWhereInput
  }


  /**
   * Count Type TascoMaterialTypesCountOutputType
   */

  export type TascoMaterialTypesCountOutputType = {
    TascoLog: number
  }

  export type TascoMaterialTypesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TascoLog?: boolean | TascoMaterialTypesCountOutputTypeCountTascoLogArgs
  }

  // Custom InputTypes
  /**
   * TascoMaterialTypesCountOutputType without action
   */
  export type TascoMaterialTypesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoMaterialTypesCountOutputType
     */
    select?: TascoMaterialTypesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TascoMaterialTypesCountOutputType without action
   */
  export type TascoMaterialTypesCountOutputTypeCountTascoLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TascoLogWhereInput
  }


  /**
   * Count Type TruckingLogCountOutputType
   */

  export type TruckingLogCountOutputType = {
    EquipmentHauled: number
    Materials: number
    RefuelLogs: number
    StateMileages: number
  }

  export type TruckingLogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EquipmentHauled?: boolean | TruckingLogCountOutputTypeCountEquipmentHauledArgs
    Materials?: boolean | TruckingLogCountOutputTypeCountMaterialsArgs
    RefuelLogs?: boolean | TruckingLogCountOutputTypeCountRefuelLogsArgs
    StateMileages?: boolean | TruckingLogCountOutputTypeCountStateMileagesArgs
  }

  // Custom InputTypes
  /**
   * TruckingLogCountOutputType without action
   */
  export type TruckingLogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLogCountOutputType
     */
    select?: TruckingLogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TruckingLogCountOutputType without action
   */
  export type TruckingLogCountOutputTypeCountEquipmentHauledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentHauledWhereInput
  }

  /**
   * TruckingLogCountOutputType without action
   */
  export type TruckingLogCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }

  /**
   * TruckingLogCountOutputType without action
   */
  export type TruckingLogCountOutputTypeCountRefuelLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefuelLogWhereInput
  }

  /**
   * TruckingLogCountOutputType without action
   */
  export type TruckingLogCountOutputTypeCountStateMileagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StateMileageWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Equipment: number
    FCMToken: number
    FormApprovals: number
    FormSubmissions: number
    Jobsite: number
    MaintenanceLogs: number
    NotificationRead: number
    NotificationResponse: number
    PasswordResetTokens: number
    TimeSheets: number
    TimeSheetChanges: number
    topicSubscriptions: number
    Crews: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | UserCountOutputTypeCountEquipmentArgs
    FCMToken?: boolean | UserCountOutputTypeCountFCMTokenArgs
    FormApprovals?: boolean | UserCountOutputTypeCountFormApprovalsArgs
    FormSubmissions?: boolean | UserCountOutputTypeCountFormSubmissionsArgs
    Jobsite?: boolean | UserCountOutputTypeCountJobsiteArgs
    MaintenanceLogs?: boolean | UserCountOutputTypeCountMaintenanceLogsArgs
    NotificationRead?: boolean | UserCountOutputTypeCountNotificationReadArgs
    NotificationResponse?: boolean | UserCountOutputTypeCountNotificationResponseArgs
    PasswordResetTokens?: boolean | UserCountOutputTypeCountPasswordResetTokensArgs
    TimeSheets?: boolean | UserCountOutputTypeCountTimeSheetsArgs
    TimeSheetChanges?: boolean | UserCountOutputTypeCountTimeSheetChangesArgs
    topicSubscriptions?: boolean | UserCountOutputTypeCountTopicSubscriptionsArgs
    Crews?: boolean | UserCountOutputTypeCountCrewsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFCMTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FCMTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFormApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormApprovalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFormSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountJobsiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsiteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMaintenanceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationReadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationReadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationResponseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTimeSheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSheetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTimeSheetChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSheetChangeLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTopicSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicSubscriptionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCrewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWhereInput
  }


  /**
   * Count Type AddressCountOutputType
   */

  export type AddressCountOutputType = {
    Company: number
    Jobsite: number
  }

  export type AddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Company?: boolean | AddressCountOutputTypeCountCompanyArgs
    Jobsite?: boolean | AddressCountOutputTypeCountJobsiteArgs
  }

  // Custom InputTypes
  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
  }

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountJobsiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsiteWhereInput
  }


  /**
   * Count Type NotificationCountOutputType
   */

  export type NotificationCountOutputType = {
    Reads: number
  }

  export type NotificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Reads?: boolean | NotificationCountOutputTypeCountReadsArgs
  }

  // Custom InputTypes
  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCountOutputType
     */
    select?: NotificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationReadWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    addressId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    SubscriptionDate: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    addressId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    SubscriptionDate: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    addressId: number
    createdAt: number
    updatedAt: number
    SubscriptionDate: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    addressId?: true
    createdAt?: true
    updatedAt?: true
    SubscriptionDate?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    addressId?: true
    createdAt?: true
    updatedAt?: true
    SubscriptionDate?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    addressId?: true
    createdAt?: true
    updatedAt?: true
    SubscriptionDate?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    addressId: string | null
    createdAt: Date
    updatedAt: Date
    SubscriptionDate: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    addressId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    SubscriptionDate?: boolean
    Address?: boolean | Company$AddressArgs<ExtArgs>
    FormTemplates?: boolean | Company$FormTemplatesArgs<ExtArgs>
    Reports?: boolean | Company$ReportsArgs<ExtArgs>
    Users?: boolean | Company$UsersArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    addressId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    SubscriptionDate?: boolean
    Address?: boolean | Company$AddressArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    addressId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    SubscriptionDate?: boolean
    Address?: boolean | Company$AddressArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    addressId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    SubscriptionDate?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "addressId" | "createdAt" | "updatedAt" | "SubscriptionDate", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Address?: boolean | Company$AddressArgs<ExtArgs>
    FormTemplates?: boolean | Company$FormTemplatesArgs<ExtArgs>
    Reports?: boolean | Company$ReportsArgs<ExtArgs>
    Users?: boolean | Company$UsersArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Address?: boolean | Company$AddressArgs<ExtArgs>
  }
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Address?: boolean | Company$AddressArgs<ExtArgs>
  }

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      Address: Prisma.$AddressPayload<ExtArgs> | null
      FormTemplates: Prisma.$FormTemplatePayload<ExtArgs>[]
      Reports: Prisma.$ReportPayload<ExtArgs>[]
      Users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      addressId: string | null
      createdAt: Date
      updatedAt: Date
      SubscriptionDate: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Address<T extends Company$AddressArgs<ExtArgs> = {}>(args?: Subset<T, Company$AddressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    FormTemplates<T extends Company$FormTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Company$FormTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Reports<T extends Company$ReportsArgs<ExtArgs> = {}>(args?: Subset<T, Company$ReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Users<T extends Company$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Company$UsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly addressId: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
    readonly SubscriptionDate: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.Address
   */
  export type Company$AddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Company.FormTemplates
   */
  export type Company$FormTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormTemplate
     */
    omit?: FormTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    where?: FormTemplateWhereInput
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    cursor?: FormTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormTemplateScalarFieldEnum | FormTemplateScalarFieldEnum[]
  }

  /**
   * Company.Reports
   */
  export type Company$ReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Company.Users
   */
  export type Company$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model CostCode
   */

  export type AggregateCostCode = {
    _count: CostCodeCountAggregateOutputType | null
    _min: CostCodeMinAggregateOutputType | null
    _max: CostCodeMaxAggregateOutputType | null
  }

  export type CostCodeMinAggregateOutputType = {
    id: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    code: string | null
  }

  export type CostCodeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    code: string | null
  }

  export type CostCodeCountAggregateOutputType = {
    id: number
    name: number
    isActive: number
    createdAt: number
    updatedAt: number
    code: number
    _all: number
  }


  export type CostCodeMinAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    code?: true
  }

  export type CostCodeMaxAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    code?: true
  }

  export type CostCodeCountAggregateInputType = {
    id?: true
    name?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    code?: true
    _all?: true
  }

  export type CostCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostCode to aggregate.
     */
    where?: CostCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCodes to fetch.
     */
    orderBy?: CostCodeOrderByWithRelationInput | CostCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostCodes
    **/
    _count?: true | CostCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostCodeMaxAggregateInputType
  }

  export type GetCostCodeAggregateType<T extends CostCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateCostCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostCode[P]>
      : GetScalarType<T[P], AggregateCostCode[P]>
  }




  export type CostCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostCodeWhereInput
    orderBy?: CostCodeOrderByWithAggregationInput | CostCodeOrderByWithAggregationInput[]
    by: CostCodeScalarFieldEnum[] | CostCodeScalarFieldEnum
    having?: CostCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostCodeCountAggregateInputType | true
    _min?: CostCodeMinAggregateInputType
    _max?: CostCodeMaxAggregateInputType
  }

  export type CostCodeGroupByOutputType = {
    id: string
    name: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    code: string | null
    _count: CostCodeCountAggregateOutputType | null
    _min: CostCodeMinAggregateOutputType | null
    _max: CostCodeMaxAggregateOutputType | null
  }

  type GetCostCodeGroupByPayload<T extends CostCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostCodeGroupByOutputType[P]>
            : GetScalarType<T[P], CostCodeGroupByOutputType[P]>
        }
      >
    >


  export type CostCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean
    Timesheets?: boolean | CostCode$TimesheetsArgs<ExtArgs>
    CCTags?: boolean | CostCode$CCTagsArgs<ExtArgs>
    _count?: boolean | CostCodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costCode"]>

  export type CostCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean
  }, ExtArgs["result"]["costCode"]>

  export type CostCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean
  }, ExtArgs["result"]["costCode"]>

  export type CostCodeSelectScalar = {
    id?: boolean
    name?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    code?: boolean
  }

  export type CostCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "isActive" | "createdAt" | "updatedAt" | "code", ExtArgs["result"]["costCode"]>
  export type CostCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Timesheets?: boolean | CostCode$TimesheetsArgs<ExtArgs>
    CCTags?: boolean | CostCode$CCTagsArgs<ExtArgs>
    _count?: boolean | CostCodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CostCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CostCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CostCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostCode"
    objects: {
      Timesheets: Prisma.$TimeSheetPayload<ExtArgs>[]
      CCTags: Prisma.$CCTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      code: string | null
    }, ExtArgs["result"]["costCode"]>
    composites: {}
  }

  type CostCodeGetPayload<S extends boolean | null | undefined | CostCodeDefaultArgs> = $Result.GetResult<Prisma.$CostCodePayload, S>

  type CostCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CostCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CostCodeCountAggregateInputType | true
    }

  export interface CostCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostCode'], meta: { name: 'CostCode' } }
    /**
     * Find zero or one CostCode that matches the filter.
     * @param {CostCodeFindUniqueArgs} args - Arguments to find a CostCode
     * @example
     * // Get one CostCode
     * const costCode = await prisma.costCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostCodeFindUniqueArgs>(args: SelectSubset<T, CostCodeFindUniqueArgs<ExtArgs>>): Prisma__CostCodeClient<$Result.GetResult<Prisma.$CostCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CostCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CostCodeFindUniqueOrThrowArgs} args - Arguments to find a CostCode
     * @example
     * // Get one CostCode
     * const costCode = await prisma.costCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, CostCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostCodeClient<$Result.GetResult<Prisma.$CostCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCodeFindFirstArgs} args - Arguments to find a CostCode
     * @example
     * // Get one CostCode
     * const costCode = await prisma.costCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostCodeFindFirstArgs>(args?: SelectSubset<T, CostCodeFindFirstArgs<ExtArgs>>): Prisma__CostCodeClient<$Result.GetResult<Prisma.$CostCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCodeFindFirstOrThrowArgs} args - Arguments to find a CostCode
     * @example
     * // Get one CostCode
     * const costCode = await prisma.costCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, CostCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostCodeClient<$Result.GetResult<Prisma.$CostCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CostCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostCodes
     * const costCodes = await prisma.costCode.findMany()
     * 
     * // Get first 10 CostCodes
     * const costCodes = await prisma.costCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costCodeWithIdOnly = await prisma.costCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostCodeFindManyArgs>(args?: SelectSubset<T, CostCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CostCode.
     * @param {CostCodeCreateArgs} args - Arguments to create a CostCode.
     * @example
     * // Create one CostCode
     * const CostCode = await prisma.costCode.create({
     *   data: {
     *     // ... data to create a CostCode
     *   }
     * })
     * 
     */
    create<T extends CostCodeCreateArgs>(args: SelectSubset<T, CostCodeCreateArgs<ExtArgs>>): Prisma__CostCodeClient<$Result.GetResult<Prisma.$CostCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CostCodes.
     * @param {CostCodeCreateManyArgs} args - Arguments to create many CostCodes.
     * @example
     * // Create many CostCodes
     * const costCode = await prisma.costCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostCodeCreateManyArgs>(args?: SelectSubset<T, CostCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostCodes and returns the data saved in the database.
     * @param {CostCodeCreateManyAndReturnArgs} args - Arguments to create many CostCodes.
     * @example
     * // Create many CostCodes
     * const costCode = await prisma.costCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostCodes and only return the `id`
     * const costCodeWithIdOnly = await prisma.costCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, CostCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CostCode.
     * @param {CostCodeDeleteArgs} args - Arguments to delete one CostCode.
     * @example
     * // Delete one CostCode
     * const CostCode = await prisma.costCode.delete({
     *   where: {
     *     // ... filter to delete one CostCode
     *   }
     * })
     * 
     */
    delete<T extends CostCodeDeleteArgs>(args: SelectSubset<T, CostCodeDeleteArgs<ExtArgs>>): Prisma__CostCodeClient<$Result.GetResult<Prisma.$CostCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CostCode.
     * @param {CostCodeUpdateArgs} args - Arguments to update one CostCode.
     * @example
     * // Update one CostCode
     * const costCode = await prisma.costCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostCodeUpdateArgs>(args: SelectSubset<T, CostCodeUpdateArgs<ExtArgs>>): Prisma__CostCodeClient<$Result.GetResult<Prisma.$CostCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CostCodes.
     * @param {CostCodeDeleteManyArgs} args - Arguments to filter CostCodes to delete.
     * @example
     * // Delete a few CostCodes
     * const { count } = await prisma.costCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostCodeDeleteManyArgs>(args?: SelectSubset<T, CostCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostCodes
     * const costCode = await prisma.costCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostCodeUpdateManyArgs>(args: SelectSubset<T, CostCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostCodes and returns the data updated in the database.
     * @param {CostCodeUpdateManyAndReturnArgs} args - Arguments to update many CostCodes.
     * @example
     * // Update many CostCodes
     * const costCode = await prisma.costCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CostCodes and only return the `id`
     * const costCodeWithIdOnly = await prisma.costCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CostCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, CostCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CostCode.
     * @param {CostCodeUpsertArgs} args - Arguments to update or create a CostCode.
     * @example
     * // Update or create a CostCode
     * const costCode = await prisma.costCode.upsert({
     *   create: {
     *     // ... data to create a CostCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostCode we want to update
     *   }
     * })
     */
    upsert<T extends CostCodeUpsertArgs>(args: SelectSubset<T, CostCodeUpsertArgs<ExtArgs>>): Prisma__CostCodeClient<$Result.GetResult<Prisma.$CostCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CostCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCodeCountArgs} args - Arguments to filter CostCodes to count.
     * @example
     * // Count the number of CostCodes
     * const count = await prisma.costCode.count({
     *   where: {
     *     // ... the filter for the CostCodes we want to count
     *   }
     * })
    **/
    count<T extends CostCodeCountArgs>(
      args?: Subset<T, CostCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostCodeAggregateArgs>(args: Subset<T, CostCodeAggregateArgs>): Prisma.PrismaPromise<GetCostCodeAggregateType<T>>

    /**
     * Group by CostCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostCodeGroupByArgs['orderBy'] }
        : { orderBy?: CostCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostCode model
   */
  readonly fields: CostCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Timesheets<T extends CostCode$TimesheetsArgs<ExtArgs> = {}>(args?: Subset<T, CostCode$TimesheetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CCTags<T extends CostCode$CCTagsArgs<ExtArgs> = {}>(args?: Subset<T, CostCode$CCTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CCTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostCode model
   */
  interface CostCodeFieldRefs {
    readonly id: FieldRef<"CostCode", 'String'>
    readonly name: FieldRef<"CostCode", 'String'>
    readonly isActive: FieldRef<"CostCode", 'Boolean'>
    readonly createdAt: FieldRef<"CostCode", 'DateTime'>
    readonly updatedAt: FieldRef<"CostCode", 'DateTime'>
    readonly code: FieldRef<"CostCode", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CostCode findUnique
   */
  export type CostCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCode
     */
    select?: CostCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCode
     */
    omit?: CostCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCodeInclude<ExtArgs> | null
    /**
     * Filter, which CostCode to fetch.
     */
    where: CostCodeWhereUniqueInput
  }

  /**
   * CostCode findUniqueOrThrow
   */
  export type CostCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCode
     */
    select?: CostCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCode
     */
    omit?: CostCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCodeInclude<ExtArgs> | null
    /**
     * Filter, which CostCode to fetch.
     */
    where: CostCodeWhereUniqueInput
  }

  /**
   * CostCode findFirst
   */
  export type CostCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCode
     */
    select?: CostCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCode
     */
    omit?: CostCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCodeInclude<ExtArgs> | null
    /**
     * Filter, which CostCode to fetch.
     */
    where?: CostCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCodes to fetch.
     */
    orderBy?: CostCodeOrderByWithRelationInput | CostCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostCodes.
     */
    cursor?: CostCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostCodes.
     */
    distinct?: CostCodeScalarFieldEnum | CostCodeScalarFieldEnum[]
  }

  /**
   * CostCode findFirstOrThrow
   */
  export type CostCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCode
     */
    select?: CostCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCode
     */
    omit?: CostCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCodeInclude<ExtArgs> | null
    /**
     * Filter, which CostCode to fetch.
     */
    where?: CostCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCodes to fetch.
     */
    orderBy?: CostCodeOrderByWithRelationInput | CostCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostCodes.
     */
    cursor?: CostCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostCodes.
     */
    distinct?: CostCodeScalarFieldEnum | CostCodeScalarFieldEnum[]
  }

  /**
   * CostCode findMany
   */
  export type CostCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCode
     */
    select?: CostCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCode
     */
    omit?: CostCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCodeInclude<ExtArgs> | null
    /**
     * Filter, which CostCodes to fetch.
     */
    where?: CostCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostCodes to fetch.
     */
    orderBy?: CostCodeOrderByWithRelationInput | CostCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostCodes.
     */
    cursor?: CostCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostCodes.
     */
    skip?: number
    distinct?: CostCodeScalarFieldEnum | CostCodeScalarFieldEnum[]
  }

  /**
   * CostCode create
   */
  export type CostCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCode
     */
    select?: CostCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCode
     */
    omit?: CostCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a CostCode.
     */
    data: XOR<CostCodeCreateInput, CostCodeUncheckedCreateInput>
  }

  /**
   * CostCode createMany
   */
  export type CostCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostCodes.
     */
    data: CostCodeCreateManyInput | CostCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostCode createManyAndReturn
   */
  export type CostCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCode
     */
    select?: CostCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostCode
     */
    omit?: CostCodeOmit<ExtArgs> | null
    /**
     * The data used to create many CostCodes.
     */
    data: CostCodeCreateManyInput | CostCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostCode update
   */
  export type CostCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCode
     */
    select?: CostCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCode
     */
    omit?: CostCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a CostCode.
     */
    data: XOR<CostCodeUpdateInput, CostCodeUncheckedUpdateInput>
    /**
     * Choose, which CostCode to update.
     */
    where: CostCodeWhereUniqueInput
  }

  /**
   * CostCode updateMany
   */
  export type CostCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostCodes.
     */
    data: XOR<CostCodeUpdateManyMutationInput, CostCodeUncheckedUpdateManyInput>
    /**
     * Filter which CostCodes to update
     */
    where?: CostCodeWhereInput
    /**
     * Limit how many CostCodes to update.
     */
    limit?: number
  }

  /**
   * CostCode updateManyAndReturn
   */
  export type CostCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCode
     */
    select?: CostCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostCode
     */
    omit?: CostCodeOmit<ExtArgs> | null
    /**
     * The data used to update CostCodes.
     */
    data: XOR<CostCodeUpdateManyMutationInput, CostCodeUncheckedUpdateManyInput>
    /**
     * Filter which CostCodes to update
     */
    where?: CostCodeWhereInput
    /**
     * Limit how many CostCodes to update.
     */
    limit?: number
  }

  /**
   * CostCode upsert
   */
  export type CostCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCode
     */
    select?: CostCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCode
     */
    omit?: CostCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the CostCode to update in case it exists.
     */
    where: CostCodeWhereUniqueInput
    /**
     * In case the CostCode found by the `where` argument doesn't exist, create a new CostCode with this data.
     */
    create: XOR<CostCodeCreateInput, CostCodeUncheckedCreateInput>
    /**
     * In case the CostCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostCodeUpdateInput, CostCodeUncheckedUpdateInput>
  }

  /**
   * CostCode delete
   */
  export type CostCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCode
     */
    select?: CostCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCode
     */
    omit?: CostCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCodeInclude<ExtArgs> | null
    /**
     * Filter which CostCode to delete.
     */
    where: CostCodeWhereUniqueInput
  }

  /**
   * CostCode deleteMany
   */
  export type CostCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostCodes to delete
     */
    where?: CostCodeWhereInput
    /**
     * Limit how many CostCodes to delete.
     */
    limit?: number
  }

  /**
   * CostCode.Timesheets
   */
  export type CostCode$TimesheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheet
     */
    select?: TimeSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheet
     */
    omit?: TimeSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetInclude<ExtArgs> | null
    where?: TimeSheetWhereInput
    orderBy?: TimeSheetOrderByWithRelationInput | TimeSheetOrderByWithRelationInput[]
    cursor?: TimeSheetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeSheetScalarFieldEnum | TimeSheetScalarFieldEnum[]
  }

  /**
   * CostCode.CCTags
   */
  export type CostCode$CCTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CCTag
     */
    select?: CCTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CCTag
     */
    omit?: CCTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CCTagInclude<ExtArgs> | null
    where?: CCTagWhereInput
    orderBy?: CCTagOrderByWithRelationInput | CCTagOrderByWithRelationInput[]
    cursor?: CCTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CCTagScalarFieldEnum | CCTagScalarFieldEnum[]
  }

  /**
   * CostCode without action
   */
  export type CostCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCode
     */
    select?: CostCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCode
     */
    omit?: CostCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCodeInclude<ExtArgs> | null
  }


  /**
   * Model CCTag
   */

  export type AggregateCCTag = {
    _count: CCTagCountAggregateOutputType | null
    _min: CCTagMinAggregateOutputType | null
    _max: CCTagMaxAggregateOutputType | null
  }

  export type CCTagMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type CCTagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type CCTagCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type CCTagMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type CCTagMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type CCTagCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type CCTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CCTag to aggregate.
     */
    where?: CCTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CCTags to fetch.
     */
    orderBy?: CCTagOrderByWithRelationInput | CCTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CCTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CCTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CCTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CCTags
    **/
    _count?: true | CCTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CCTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CCTagMaxAggregateInputType
  }

  export type GetCCTagAggregateType<T extends CCTagAggregateArgs> = {
        [P in keyof T & keyof AggregateCCTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCCTag[P]>
      : GetScalarType<T[P], AggregateCCTag[P]>
  }




  export type CCTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CCTagWhereInput
    orderBy?: CCTagOrderByWithAggregationInput | CCTagOrderByWithAggregationInput[]
    by: CCTagScalarFieldEnum[] | CCTagScalarFieldEnum
    having?: CCTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CCTagCountAggregateInputType | true
    _min?: CCTagMinAggregateInputType
    _max?: CCTagMaxAggregateInputType
  }

  export type CCTagGroupByOutputType = {
    id: string
    name: string
    description: string | null
    _count: CCTagCountAggregateOutputType | null
    _min: CCTagMinAggregateOutputType | null
    _max: CCTagMaxAggregateOutputType | null
  }

  type GetCCTagGroupByPayload<T extends CCTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CCTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CCTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CCTagGroupByOutputType[P]>
            : GetScalarType<T[P], CCTagGroupByOutputType[P]>
        }
      >
    >


  export type CCTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    CostCodes?: boolean | CCTag$CostCodesArgs<ExtArgs>
    Jobsites?: boolean | CCTag$JobsitesArgs<ExtArgs>
    _count?: boolean | CCTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cCTag"]>

  export type CCTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["cCTag"]>

  export type CCTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["cCTag"]>

  export type CCTagSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type CCTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["cCTag"]>
  export type CCTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CostCodes?: boolean | CCTag$CostCodesArgs<ExtArgs>
    Jobsites?: boolean | CCTag$JobsitesArgs<ExtArgs>
    _count?: boolean | CCTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CCTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CCTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CCTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CCTag"
    objects: {
      CostCodes: Prisma.$CostCodePayload<ExtArgs>[]
      Jobsites: Prisma.$JobsitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
    }, ExtArgs["result"]["cCTag"]>
    composites: {}
  }

  type CCTagGetPayload<S extends boolean | null | undefined | CCTagDefaultArgs> = $Result.GetResult<Prisma.$CCTagPayload, S>

  type CCTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CCTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CCTagCountAggregateInputType | true
    }

  export interface CCTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CCTag'], meta: { name: 'CCTag' } }
    /**
     * Find zero or one CCTag that matches the filter.
     * @param {CCTagFindUniqueArgs} args - Arguments to find a CCTag
     * @example
     * // Get one CCTag
     * const cCTag = await prisma.cCTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CCTagFindUniqueArgs>(args: SelectSubset<T, CCTagFindUniqueArgs<ExtArgs>>): Prisma__CCTagClient<$Result.GetResult<Prisma.$CCTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CCTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CCTagFindUniqueOrThrowArgs} args - Arguments to find a CCTag
     * @example
     * // Get one CCTag
     * const cCTag = await prisma.cCTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CCTagFindUniqueOrThrowArgs>(args: SelectSubset<T, CCTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CCTagClient<$Result.GetResult<Prisma.$CCTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CCTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CCTagFindFirstArgs} args - Arguments to find a CCTag
     * @example
     * // Get one CCTag
     * const cCTag = await prisma.cCTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CCTagFindFirstArgs>(args?: SelectSubset<T, CCTagFindFirstArgs<ExtArgs>>): Prisma__CCTagClient<$Result.GetResult<Prisma.$CCTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CCTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CCTagFindFirstOrThrowArgs} args - Arguments to find a CCTag
     * @example
     * // Get one CCTag
     * const cCTag = await prisma.cCTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CCTagFindFirstOrThrowArgs>(args?: SelectSubset<T, CCTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__CCTagClient<$Result.GetResult<Prisma.$CCTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CCTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CCTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CCTags
     * const cCTags = await prisma.cCTag.findMany()
     * 
     * // Get first 10 CCTags
     * const cCTags = await prisma.cCTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cCTagWithIdOnly = await prisma.cCTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CCTagFindManyArgs>(args?: SelectSubset<T, CCTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CCTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CCTag.
     * @param {CCTagCreateArgs} args - Arguments to create a CCTag.
     * @example
     * // Create one CCTag
     * const CCTag = await prisma.cCTag.create({
     *   data: {
     *     // ... data to create a CCTag
     *   }
     * })
     * 
     */
    create<T extends CCTagCreateArgs>(args: SelectSubset<T, CCTagCreateArgs<ExtArgs>>): Prisma__CCTagClient<$Result.GetResult<Prisma.$CCTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CCTags.
     * @param {CCTagCreateManyArgs} args - Arguments to create many CCTags.
     * @example
     * // Create many CCTags
     * const cCTag = await prisma.cCTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CCTagCreateManyArgs>(args?: SelectSubset<T, CCTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CCTags and returns the data saved in the database.
     * @param {CCTagCreateManyAndReturnArgs} args - Arguments to create many CCTags.
     * @example
     * // Create many CCTags
     * const cCTag = await prisma.cCTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CCTags and only return the `id`
     * const cCTagWithIdOnly = await prisma.cCTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CCTagCreateManyAndReturnArgs>(args?: SelectSubset<T, CCTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CCTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CCTag.
     * @param {CCTagDeleteArgs} args - Arguments to delete one CCTag.
     * @example
     * // Delete one CCTag
     * const CCTag = await prisma.cCTag.delete({
     *   where: {
     *     // ... filter to delete one CCTag
     *   }
     * })
     * 
     */
    delete<T extends CCTagDeleteArgs>(args: SelectSubset<T, CCTagDeleteArgs<ExtArgs>>): Prisma__CCTagClient<$Result.GetResult<Prisma.$CCTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CCTag.
     * @param {CCTagUpdateArgs} args - Arguments to update one CCTag.
     * @example
     * // Update one CCTag
     * const cCTag = await prisma.cCTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CCTagUpdateArgs>(args: SelectSubset<T, CCTagUpdateArgs<ExtArgs>>): Prisma__CCTagClient<$Result.GetResult<Prisma.$CCTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CCTags.
     * @param {CCTagDeleteManyArgs} args - Arguments to filter CCTags to delete.
     * @example
     * // Delete a few CCTags
     * const { count } = await prisma.cCTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CCTagDeleteManyArgs>(args?: SelectSubset<T, CCTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CCTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CCTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CCTags
     * const cCTag = await prisma.cCTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CCTagUpdateManyArgs>(args: SelectSubset<T, CCTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CCTags and returns the data updated in the database.
     * @param {CCTagUpdateManyAndReturnArgs} args - Arguments to update many CCTags.
     * @example
     * // Update many CCTags
     * const cCTag = await prisma.cCTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CCTags and only return the `id`
     * const cCTagWithIdOnly = await prisma.cCTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CCTagUpdateManyAndReturnArgs>(args: SelectSubset<T, CCTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CCTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CCTag.
     * @param {CCTagUpsertArgs} args - Arguments to update or create a CCTag.
     * @example
     * // Update or create a CCTag
     * const cCTag = await prisma.cCTag.upsert({
     *   create: {
     *     // ... data to create a CCTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CCTag we want to update
     *   }
     * })
     */
    upsert<T extends CCTagUpsertArgs>(args: SelectSubset<T, CCTagUpsertArgs<ExtArgs>>): Prisma__CCTagClient<$Result.GetResult<Prisma.$CCTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CCTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CCTagCountArgs} args - Arguments to filter CCTags to count.
     * @example
     * // Count the number of CCTags
     * const count = await prisma.cCTag.count({
     *   where: {
     *     // ... the filter for the CCTags we want to count
     *   }
     * })
    **/
    count<T extends CCTagCountArgs>(
      args?: Subset<T, CCTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CCTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CCTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CCTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CCTagAggregateArgs>(args: Subset<T, CCTagAggregateArgs>): Prisma.PrismaPromise<GetCCTagAggregateType<T>>

    /**
     * Group by CCTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CCTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CCTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CCTagGroupByArgs['orderBy'] }
        : { orderBy?: CCTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CCTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCCTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CCTag model
   */
  readonly fields: CCTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CCTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CCTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CostCodes<T extends CCTag$CostCodesArgs<ExtArgs> = {}>(args?: Subset<T, CCTag$CostCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Jobsites<T extends CCTag$JobsitesArgs<ExtArgs> = {}>(args?: Subset<T, CCTag$JobsitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CCTag model
   */
  interface CCTagFieldRefs {
    readonly id: FieldRef<"CCTag", 'String'>
    readonly name: FieldRef<"CCTag", 'String'>
    readonly description: FieldRef<"CCTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CCTag findUnique
   */
  export type CCTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CCTag
     */
    select?: CCTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CCTag
     */
    omit?: CCTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CCTagInclude<ExtArgs> | null
    /**
     * Filter, which CCTag to fetch.
     */
    where: CCTagWhereUniqueInput
  }

  /**
   * CCTag findUniqueOrThrow
   */
  export type CCTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CCTag
     */
    select?: CCTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CCTag
     */
    omit?: CCTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CCTagInclude<ExtArgs> | null
    /**
     * Filter, which CCTag to fetch.
     */
    where: CCTagWhereUniqueInput
  }

  /**
   * CCTag findFirst
   */
  export type CCTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CCTag
     */
    select?: CCTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CCTag
     */
    omit?: CCTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CCTagInclude<ExtArgs> | null
    /**
     * Filter, which CCTag to fetch.
     */
    where?: CCTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CCTags to fetch.
     */
    orderBy?: CCTagOrderByWithRelationInput | CCTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CCTags.
     */
    cursor?: CCTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CCTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CCTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CCTags.
     */
    distinct?: CCTagScalarFieldEnum | CCTagScalarFieldEnum[]
  }

  /**
   * CCTag findFirstOrThrow
   */
  export type CCTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CCTag
     */
    select?: CCTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CCTag
     */
    omit?: CCTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CCTagInclude<ExtArgs> | null
    /**
     * Filter, which CCTag to fetch.
     */
    where?: CCTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CCTags to fetch.
     */
    orderBy?: CCTagOrderByWithRelationInput | CCTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CCTags.
     */
    cursor?: CCTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CCTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CCTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CCTags.
     */
    distinct?: CCTagScalarFieldEnum | CCTagScalarFieldEnum[]
  }

  /**
   * CCTag findMany
   */
  export type CCTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CCTag
     */
    select?: CCTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CCTag
     */
    omit?: CCTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CCTagInclude<ExtArgs> | null
    /**
     * Filter, which CCTags to fetch.
     */
    where?: CCTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CCTags to fetch.
     */
    orderBy?: CCTagOrderByWithRelationInput | CCTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CCTags.
     */
    cursor?: CCTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CCTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CCTags.
     */
    skip?: number
    distinct?: CCTagScalarFieldEnum | CCTagScalarFieldEnum[]
  }

  /**
   * CCTag create
   */
  export type CCTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CCTag
     */
    select?: CCTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CCTag
     */
    omit?: CCTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CCTagInclude<ExtArgs> | null
    /**
     * The data needed to create a CCTag.
     */
    data: XOR<CCTagCreateInput, CCTagUncheckedCreateInput>
  }

  /**
   * CCTag createMany
   */
  export type CCTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CCTags.
     */
    data: CCTagCreateManyInput | CCTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CCTag createManyAndReturn
   */
  export type CCTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CCTag
     */
    select?: CCTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CCTag
     */
    omit?: CCTagOmit<ExtArgs> | null
    /**
     * The data used to create many CCTags.
     */
    data: CCTagCreateManyInput | CCTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CCTag update
   */
  export type CCTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CCTag
     */
    select?: CCTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CCTag
     */
    omit?: CCTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CCTagInclude<ExtArgs> | null
    /**
     * The data needed to update a CCTag.
     */
    data: XOR<CCTagUpdateInput, CCTagUncheckedUpdateInput>
    /**
     * Choose, which CCTag to update.
     */
    where: CCTagWhereUniqueInput
  }

  /**
   * CCTag updateMany
   */
  export type CCTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CCTags.
     */
    data: XOR<CCTagUpdateManyMutationInput, CCTagUncheckedUpdateManyInput>
    /**
     * Filter which CCTags to update
     */
    where?: CCTagWhereInput
    /**
     * Limit how many CCTags to update.
     */
    limit?: number
  }

  /**
   * CCTag updateManyAndReturn
   */
  export type CCTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CCTag
     */
    select?: CCTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CCTag
     */
    omit?: CCTagOmit<ExtArgs> | null
    /**
     * The data used to update CCTags.
     */
    data: XOR<CCTagUpdateManyMutationInput, CCTagUncheckedUpdateManyInput>
    /**
     * Filter which CCTags to update
     */
    where?: CCTagWhereInput
    /**
     * Limit how many CCTags to update.
     */
    limit?: number
  }

  /**
   * CCTag upsert
   */
  export type CCTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CCTag
     */
    select?: CCTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CCTag
     */
    omit?: CCTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CCTagInclude<ExtArgs> | null
    /**
     * The filter to search for the CCTag to update in case it exists.
     */
    where: CCTagWhereUniqueInput
    /**
     * In case the CCTag found by the `where` argument doesn't exist, create a new CCTag with this data.
     */
    create: XOR<CCTagCreateInput, CCTagUncheckedCreateInput>
    /**
     * In case the CCTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CCTagUpdateInput, CCTagUncheckedUpdateInput>
  }

  /**
   * CCTag delete
   */
  export type CCTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CCTag
     */
    select?: CCTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CCTag
     */
    omit?: CCTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CCTagInclude<ExtArgs> | null
    /**
     * Filter which CCTag to delete.
     */
    where: CCTagWhereUniqueInput
  }

  /**
   * CCTag deleteMany
   */
  export type CCTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CCTags to delete
     */
    where?: CCTagWhereInput
    /**
     * Limit how many CCTags to delete.
     */
    limit?: number
  }

  /**
   * CCTag.CostCodes
   */
  export type CCTag$CostCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostCode
     */
    select?: CostCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostCode
     */
    omit?: CostCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostCodeInclude<ExtArgs> | null
    where?: CostCodeWhereInput
    orderBy?: CostCodeOrderByWithRelationInput | CostCodeOrderByWithRelationInput[]
    cursor?: CostCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CostCodeScalarFieldEnum | CostCodeScalarFieldEnum[]
  }

  /**
   * CCTag.Jobsites
   */
  export type CCTag$JobsitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobsite
     */
    select?: JobsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobsite
     */
    omit?: JobsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsiteInclude<ExtArgs> | null
    where?: JobsiteWhereInput
    orderBy?: JobsiteOrderByWithRelationInput | JobsiteOrderByWithRelationInput[]
    cursor?: JobsiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsiteScalarFieldEnum | JobsiteScalarFieldEnum[]
  }

  /**
   * CCTag without action
   */
  export type CCTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CCTag
     */
    select?: CCTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CCTag
     */
    omit?: CCTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CCTagInclude<ExtArgs> | null
  }


  /**
   * Model Crew
   */

  export type AggregateCrew = {
    _count: CrewCountAggregateOutputType | null
    _min: CrewMinAggregateOutputType | null
    _max: CrewMaxAggregateOutputType | null
  }

  export type CrewMinAggregateOutputType = {
    id: string | null
    name: string | null
    leadId: string | null
    crewType: $Enums.WorkType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrewMaxAggregateOutputType = {
    id: string | null
    name: string | null
    leadId: string | null
    crewType: $Enums.WorkType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CrewCountAggregateOutputType = {
    id: number
    name: number
    leadId: number
    crewType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CrewMinAggregateInputType = {
    id?: true
    name?: true
    leadId?: true
    crewType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrewMaxAggregateInputType = {
    id?: true
    name?: true
    leadId?: true
    crewType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CrewCountAggregateInputType = {
    id?: true
    name?: true
    leadId?: true
    crewType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CrewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crew to aggregate.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Crews
    **/
    _count?: true | CrewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CrewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CrewMaxAggregateInputType
  }

  export type GetCrewAggregateType<T extends CrewAggregateArgs> = {
        [P in keyof T & keyof AggregateCrew]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCrew[P]>
      : GetScalarType<T[P], AggregateCrew[P]>
  }




  export type CrewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CrewWhereInput
    orderBy?: CrewOrderByWithAggregationInput | CrewOrderByWithAggregationInput[]
    by: CrewScalarFieldEnum[] | CrewScalarFieldEnum
    having?: CrewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CrewCountAggregateInputType | true
    _min?: CrewMinAggregateInputType
    _max?: CrewMaxAggregateInputType
  }

  export type CrewGroupByOutputType = {
    id: string
    name: string
    leadId: string
    crewType: $Enums.WorkType
    createdAt: Date
    updatedAt: Date
    _count: CrewCountAggregateOutputType | null
    _min: CrewMinAggregateOutputType | null
    _max: CrewMaxAggregateOutputType | null
  }

  type GetCrewGroupByPayload<T extends CrewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CrewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CrewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CrewGroupByOutputType[P]>
            : GetScalarType<T[P], CrewGroupByOutputType[P]>
        }
      >
    >


  export type CrewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    leadId?: boolean
    crewType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Users?: boolean | Crew$UsersArgs<ExtArgs>
    _count?: boolean | CrewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["crew"]>

  export type CrewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    leadId?: boolean
    crewType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["crew"]>

  export type CrewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    leadId?: boolean
    crewType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["crew"]>

  export type CrewSelectScalar = {
    id?: boolean
    name?: boolean
    leadId?: boolean
    crewType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CrewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "leadId" | "crewType" | "createdAt" | "updatedAt", ExtArgs["result"]["crew"]>
  export type CrewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Users?: boolean | Crew$UsersArgs<ExtArgs>
    _count?: boolean | CrewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CrewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CrewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CrewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Crew"
    objects: {
      Users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      leadId: string
      crewType: $Enums.WorkType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["crew"]>
    composites: {}
  }

  type CrewGetPayload<S extends boolean | null | undefined | CrewDefaultArgs> = $Result.GetResult<Prisma.$CrewPayload, S>

  type CrewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CrewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CrewCountAggregateInputType | true
    }

  export interface CrewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Crew'], meta: { name: 'Crew' } }
    /**
     * Find zero or one Crew that matches the filter.
     * @param {CrewFindUniqueArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CrewFindUniqueArgs>(args: SelectSubset<T, CrewFindUniqueArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Crew that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CrewFindUniqueOrThrowArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CrewFindUniqueOrThrowArgs>(args: SelectSubset<T, CrewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crew that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindFirstArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CrewFindFirstArgs>(args?: SelectSubset<T, CrewFindFirstArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Crew that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindFirstOrThrowArgs} args - Arguments to find a Crew
     * @example
     * // Get one Crew
     * const crew = await prisma.crew.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CrewFindFirstOrThrowArgs>(args?: SelectSubset<T, CrewFindFirstOrThrowArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Crews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Crews
     * const crews = await prisma.crew.findMany()
     * 
     * // Get first 10 Crews
     * const crews = await prisma.crew.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const crewWithIdOnly = await prisma.crew.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CrewFindManyArgs>(args?: SelectSubset<T, CrewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Crew.
     * @param {CrewCreateArgs} args - Arguments to create a Crew.
     * @example
     * // Create one Crew
     * const Crew = await prisma.crew.create({
     *   data: {
     *     // ... data to create a Crew
     *   }
     * })
     * 
     */
    create<T extends CrewCreateArgs>(args: SelectSubset<T, CrewCreateArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Crews.
     * @param {CrewCreateManyArgs} args - Arguments to create many Crews.
     * @example
     * // Create many Crews
     * const crew = await prisma.crew.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CrewCreateManyArgs>(args?: SelectSubset<T, CrewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Crews and returns the data saved in the database.
     * @param {CrewCreateManyAndReturnArgs} args - Arguments to create many Crews.
     * @example
     * // Create many Crews
     * const crew = await prisma.crew.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Crews and only return the `id`
     * const crewWithIdOnly = await prisma.crew.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CrewCreateManyAndReturnArgs>(args?: SelectSubset<T, CrewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Crew.
     * @param {CrewDeleteArgs} args - Arguments to delete one Crew.
     * @example
     * // Delete one Crew
     * const Crew = await prisma.crew.delete({
     *   where: {
     *     // ... filter to delete one Crew
     *   }
     * })
     * 
     */
    delete<T extends CrewDeleteArgs>(args: SelectSubset<T, CrewDeleteArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Crew.
     * @param {CrewUpdateArgs} args - Arguments to update one Crew.
     * @example
     * // Update one Crew
     * const crew = await prisma.crew.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CrewUpdateArgs>(args: SelectSubset<T, CrewUpdateArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Crews.
     * @param {CrewDeleteManyArgs} args - Arguments to filter Crews to delete.
     * @example
     * // Delete a few Crews
     * const { count } = await prisma.crew.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CrewDeleteManyArgs>(args?: SelectSubset<T, CrewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Crews
     * const crew = await prisma.crew.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CrewUpdateManyArgs>(args: SelectSubset<T, CrewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Crews and returns the data updated in the database.
     * @param {CrewUpdateManyAndReturnArgs} args - Arguments to update many Crews.
     * @example
     * // Update many Crews
     * const crew = await prisma.crew.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Crews and only return the `id`
     * const crewWithIdOnly = await prisma.crew.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CrewUpdateManyAndReturnArgs>(args: SelectSubset<T, CrewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Crew.
     * @param {CrewUpsertArgs} args - Arguments to update or create a Crew.
     * @example
     * // Update or create a Crew
     * const crew = await prisma.crew.upsert({
     *   create: {
     *     // ... data to create a Crew
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Crew we want to update
     *   }
     * })
     */
    upsert<T extends CrewUpsertArgs>(args: SelectSubset<T, CrewUpsertArgs<ExtArgs>>): Prisma__CrewClient<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Crews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewCountArgs} args - Arguments to filter Crews to count.
     * @example
     * // Count the number of Crews
     * const count = await prisma.crew.count({
     *   where: {
     *     // ... the filter for the Crews we want to count
     *   }
     * })
    **/
    count<T extends CrewCountArgs>(
      args?: Subset<T, CrewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CrewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Crew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CrewAggregateArgs>(args: Subset<T, CrewAggregateArgs>): Prisma.PrismaPromise<GetCrewAggregateType<T>>

    /**
     * Group by Crew.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CrewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CrewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CrewGroupByArgs['orderBy'] }
        : { orderBy?: CrewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CrewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCrewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Crew model
   */
  readonly fields: CrewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Crew.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CrewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Users<T extends Crew$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Crew$UsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Crew model
   */
  interface CrewFieldRefs {
    readonly id: FieldRef<"Crew", 'String'>
    readonly name: FieldRef<"Crew", 'String'>
    readonly leadId: FieldRef<"Crew", 'String'>
    readonly crewType: FieldRef<"Crew", 'WorkType'>
    readonly createdAt: FieldRef<"Crew", 'DateTime'>
    readonly updatedAt: FieldRef<"Crew", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Crew findUnique
   */
  export type CrewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crew
     */
    omit?: CrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where: CrewWhereUniqueInput
  }

  /**
   * Crew findUniqueOrThrow
   */
  export type CrewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crew
     */
    omit?: CrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where: CrewWhereUniqueInput
  }

  /**
   * Crew findFirst
   */
  export type CrewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crew
     */
    omit?: CrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crews.
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crews.
     */
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }

  /**
   * Crew findFirstOrThrow
   */
  export type CrewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crew
     */
    omit?: CrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crew to fetch.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Crews.
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Crews.
     */
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }

  /**
   * Crew findMany
   */
  export type CrewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crew
     */
    omit?: CrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter, which Crews to fetch.
     */
    where?: CrewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Crews to fetch.
     */
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Crews.
     */
    cursor?: CrewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Crews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Crews.
     */
    skip?: number
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }

  /**
   * Crew create
   */
  export type CrewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crew
     */
    omit?: CrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * The data needed to create a Crew.
     */
    data: XOR<CrewCreateInput, CrewUncheckedCreateInput>
  }

  /**
   * Crew createMany
   */
  export type CrewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Crews.
     */
    data: CrewCreateManyInput | CrewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Crew createManyAndReturn
   */
  export type CrewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Crew
     */
    omit?: CrewOmit<ExtArgs> | null
    /**
     * The data used to create many Crews.
     */
    data: CrewCreateManyInput | CrewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Crew update
   */
  export type CrewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crew
     */
    omit?: CrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * The data needed to update a Crew.
     */
    data: XOR<CrewUpdateInput, CrewUncheckedUpdateInput>
    /**
     * Choose, which Crew to update.
     */
    where: CrewWhereUniqueInput
  }

  /**
   * Crew updateMany
   */
  export type CrewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Crews.
     */
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyInput>
    /**
     * Filter which Crews to update
     */
    where?: CrewWhereInput
    /**
     * Limit how many Crews to update.
     */
    limit?: number
  }

  /**
   * Crew updateManyAndReturn
   */
  export type CrewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Crew
     */
    omit?: CrewOmit<ExtArgs> | null
    /**
     * The data used to update Crews.
     */
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyInput>
    /**
     * Filter which Crews to update
     */
    where?: CrewWhereInput
    /**
     * Limit how many Crews to update.
     */
    limit?: number
  }

  /**
   * Crew upsert
   */
  export type CrewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crew
     */
    omit?: CrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * The filter to search for the Crew to update in case it exists.
     */
    where: CrewWhereUniqueInput
    /**
     * In case the Crew found by the `where` argument doesn't exist, create a new Crew with this data.
     */
    create: XOR<CrewCreateInput, CrewUncheckedCreateInput>
    /**
     * In case the Crew was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CrewUpdateInput, CrewUncheckedUpdateInput>
  }

  /**
   * Crew delete
   */
  export type CrewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crew
     */
    omit?: CrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    /**
     * Filter which Crew to delete.
     */
    where: CrewWhereUniqueInput
  }

  /**
   * Crew deleteMany
   */
  export type CrewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Crews to delete
     */
    where?: CrewWhereInput
    /**
     * Limit how many Crews to delete.
     */
    limit?: number
  }

  /**
   * Crew.Users
   */
  export type Crew$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Crew without action
   */
  export type CrewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crew
     */
    omit?: CrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
  }


  /**
   * Model PdfDocument
   */

  export type AggregatePdfDocument = {
    _count: PdfDocumentCountAggregateOutputType | null
    _avg: PdfDocumentAvgAggregateOutputType | null
    _sum: PdfDocumentSumAggregateOutputType | null
    _min: PdfDocumentMinAggregateOutputType | null
    _max: PdfDocumentMaxAggregateOutputType | null
  }

  export type PdfDocumentAvgAggregateOutputType = {
    size: number | null
  }

  export type PdfDocumentSumAggregateOutputType = {
    size: number | null
  }

  export type PdfDocumentMinAggregateOutputType = {
    id: string | null
    qrId: string | null
    fileName: string | null
    description: string | null
    fileData: Bytes | null
    contentType: string | null
    size: number | null
    isActive: boolean | null
    createdAt: Date | null
    uploadDate: Date | null
  }

  export type PdfDocumentMaxAggregateOutputType = {
    id: string | null
    qrId: string | null
    fileName: string | null
    description: string | null
    fileData: Bytes | null
    contentType: string | null
    size: number | null
    isActive: boolean | null
    createdAt: Date | null
    uploadDate: Date | null
  }

  export type PdfDocumentCountAggregateOutputType = {
    id: number
    qrId: number
    fileName: number
    description: number
    fileData: number
    contentType: number
    size: number
    isActive: number
    createdAt: number
    uploadDate: number
    _all: number
  }


  export type PdfDocumentAvgAggregateInputType = {
    size?: true
  }

  export type PdfDocumentSumAggregateInputType = {
    size?: true
  }

  export type PdfDocumentMinAggregateInputType = {
    id?: true
    qrId?: true
    fileName?: true
    description?: true
    fileData?: true
    contentType?: true
    size?: true
    isActive?: true
    createdAt?: true
    uploadDate?: true
  }

  export type PdfDocumentMaxAggregateInputType = {
    id?: true
    qrId?: true
    fileName?: true
    description?: true
    fileData?: true
    contentType?: true
    size?: true
    isActive?: true
    createdAt?: true
    uploadDate?: true
  }

  export type PdfDocumentCountAggregateInputType = {
    id?: true
    qrId?: true
    fileName?: true
    description?: true
    fileData?: true
    contentType?: true
    size?: true
    isActive?: true
    createdAt?: true
    uploadDate?: true
    _all?: true
  }

  export type PdfDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PdfDocument to aggregate.
     */
    where?: PdfDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PdfDocuments to fetch.
     */
    orderBy?: PdfDocumentOrderByWithRelationInput | PdfDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PdfDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PdfDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PdfDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PdfDocuments
    **/
    _count?: true | PdfDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PdfDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PdfDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PdfDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PdfDocumentMaxAggregateInputType
  }

  export type GetPdfDocumentAggregateType<T extends PdfDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregatePdfDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePdfDocument[P]>
      : GetScalarType<T[P], AggregatePdfDocument[P]>
  }




  export type PdfDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PdfDocumentWhereInput
    orderBy?: PdfDocumentOrderByWithAggregationInput | PdfDocumentOrderByWithAggregationInput[]
    by: PdfDocumentScalarFieldEnum[] | PdfDocumentScalarFieldEnum
    having?: PdfDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PdfDocumentCountAggregateInputType | true
    _avg?: PdfDocumentAvgAggregateInputType
    _sum?: PdfDocumentSumAggregateInputType
    _min?: PdfDocumentMinAggregateInputType
    _max?: PdfDocumentMaxAggregateInputType
  }

  export type PdfDocumentGroupByOutputType = {
    id: string
    qrId: string
    fileName: string
    description: string | null
    fileData: Bytes
    contentType: string
    size: number
    isActive: boolean
    createdAt: Date
    uploadDate: Date
    _count: PdfDocumentCountAggregateOutputType | null
    _avg: PdfDocumentAvgAggregateOutputType | null
    _sum: PdfDocumentSumAggregateOutputType | null
    _min: PdfDocumentMinAggregateOutputType | null
    _max: PdfDocumentMaxAggregateOutputType | null
  }

  type GetPdfDocumentGroupByPayload<T extends PdfDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PdfDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PdfDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PdfDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], PdfDocumentGroupByOutputType[P]>
        }
      >
    >


  export type PdfDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qrId?: boolean
    fileName?: boolean
    description?: boolean
    fileData?: boolean
    contentType?: boolean
    size?: boolean
    isActive?: boolean
    createdAt?: boolean
    uploadDate?: boolean
    DocumentTags?: boolean | PdfDocument$DocumentTagsArgs<ExtArgs>
    _count?: boolean | PdfDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pdfDocument"]>

  export type PdfDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qrId?: boolean
    fileName?: boolean
    description?: boolean
    fileData?: boolean
    contentType?: boolean
    size?: boolean
    isActive?: boolean
    createdAt?: boolean
    uploadDate?: boolean
  }, ExtArgs["result"]["pdfDocument"]>

  export type PdfDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qrId?: boolean
    fileName?: boolean
    description?: boolean
    fileData?: boolean
    contentType?: boolean
    size?: boolean
    isActive?: boolean
    createdAt?: boolean
    uploadDate?: boolean
  }, ExtArgs["result"]["pdfDocument"]>

  export type PdfDocumentSelectScalar = {
    id?: boolean
    qrId?: boolean
    fileName?: boolean
    description?: boolean
    fileData?: boolean
    contentType?: boolean
    size?: boolean
    isActive?: boolean
    createdAt?: boolean
    uploadDate?: boolean
  }

  export type PdfDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "qrId" | "fileName" | "description" | "fileData" | "contentType" | "size" | "isActive" | "createdAt" | "uploadDate", ExtArgs["result"]["pdfDocument"]>
  export type PdfDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DocumentTags?: boolean | PdfDocument$DocumentTagsArgs<ExtArgs>
    _count?: boolean | PdfDocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PdfDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PdfDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PdfDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PdfDocument"
    objects: {
      DocumentTags: Prisma.$DocumentTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      qrId: string
      fileName: string
      description: string | null
      fileData: Prisma.Bytes
      contentType: string
      size: number
      isActive: boolean
      createdAt: Date
      uploadDate: Date
    }, ExtArgs["result"]["pdfDocument"]>
    composites: {}
  }

  type PdfDocumentGetPayload<S extends boolean | null | undefined | PdfDocumentDefaultArgs> = $Result.GetResult<Prisma.$PdfDocumentPayload, S>

  type PdfDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PdfDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PdfDocumentCountAggregateInputType | true
    }

  export interface PdfDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PdfDocument'], meta: { name: 'PdfDocument' } }
    /**
     * Find zero or one PdfDocument that matches the filter.
     * @param {PdfDocumentFindUniqueArgs} args - Arguments to find a PdfDocument
     * @example
     * // Get one PdfDocument
     * const pdfDocument = await prisma.pdfDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PdfDocumentFindUniqueArgs>(args: SelectSubset<T, PdfDocumentFindUniqueArgs<ExtArgs>>): Prisma__PdfDocumentClient<$Result.GetResult<Prisma.$PdfDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PdfDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PdfDocumentFindUniqueOrThrowArgs} args - Arguments to find a PdfDocument
     * @example
     * // Get one PdfDocument
     * const pdfDocument = await prisma.pdfDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PdfDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, PdfDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PdfDocumentClient<$Result.GetResult<Prisma.$PdfDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PdfDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfDocumentFindFirstArgs} args - Arguments to find a PdfDocument
     * @example
     * // Get one PdfDocument
     * const pdfDocument = await prisma.pdfDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PdfDocumentFindFirstArgs>(args?: SelectSubset<T, PdfDocumentFindFirstArgs<ExtArgs>>): Prisma__PdfDocumentClient<$Result.GetResult<Prisma.$PdfDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PdfDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfDocumentFindFirstOrThrowArgs} args - Arguments to find a PdfDocument
     * @example
     * // Get one PdfDocument
     * const pdfDocument = await prisma.pdfDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PdfDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, PdfDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PdfDocumentClient<$Result.GetResult<Prisma.$PdfDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PdfDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PdfDocuments
     * const pdfDocuments = await prisma.pdfDocument.findMany()
     * 
     * // Get first 10 PdfDocuments
     * const pdfDocuments = await prisma.pdfDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pdfDocumentWithIdOnly = await prisma.pdfDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PdfDocumentFindManyArgs>(args?: SelectSubset<T, PdfDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PdfDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PdfDocument.
     * @param {PdfDocumentCreateArgs} args - Arguments to create a PdfDocument.
     * @example
     * // Create one PdfDocument
     * const PdfDocument = await prisma.pdfDocument.create({
     *   data: {
     *     // ... data to create a PdfDocument
     *   }
     * })
     * 
     */
    create<T extends PdfDocumentCreateArgs>(args: SelectSubset<T, PdfDocumentCreateArgs<ExtArgs>>): Prisma__PdfDocumentClient<$Result.GetResult<Prisma.$PdfDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PdfDocuments.
     * @param {PdfDocumentCreateManyArgs} args - Arguments to create many PdfDocuments.
     * @example
     * // Create many PdfDocuments
     * const pdfDocument = await prisma.pdfDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PdfDocumentCreateManyArgs>(args?: SelectSubset<T, PdfDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PdfDocuments and returns the data saved in the database.
     * @param {PdfDocumentCreateManyAndReturnArgs} args - Arguments to create many PdfDocuments.
     * @example
     * // Create many PdfDocuments
     * const pdfDocument = await prisma.pdfDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PdfDocuments and only return the `id`
     * const pdfDocumentWithIdOnly = await prisma.pdfDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PdfDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, PdfDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PdfDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PdfDocument.
     * @param {PdfDocumentDeleteArgs} args - Arguments to delete one PdfDocument.
     * @example
     * // Delete one PdfDocument
     * const PdfDocument = await prisma.pdfDocument.delete({
     *   where: {
     *     // ... filter to delete one PdfDocument
     *   }
     * })
     * 
     */
    delete<T extends PdfDocumentDeleteArgs>(args: SelectSubset<T, PdfDocumentDeleteArgs<ExtArgs>>): Prisma__PdfDocumentClient<$Result.GetResult<Prisma.$PdfDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PdfDocument.
     * @param {PdfDocumentUpdateArgs} args - Arguments to update one PdfDocument.
     * @example
     * // Update one PdfDocument
     * const pdfDocument = await prisma.pdfDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PdfDocumentUpdateArgs>(args: SelectSubset<T, PdfDocumentUpdateArgs<ExtArgs>>): Prisma__PdfDocumentClient<$Result.GetResult<Prisma.$PdfDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PdfDocuments.
     * @param {PdfDocumentDeleteManyArgs} args - Arguments to filter PdfDocuments to delete.
     * @example
     * // Delete a few PdfDocuments
     * const { count } = await prisma.pdfDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PdfDocumentDeleteManyArgs>(args?: SelectSubset<T, PdfDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PdfDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PdfDocuments
     * const pdfDocument = await prisma.pdfDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PdfDocumentUpdateManyArgs>(args: SelectSubset<T, PdfDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PdfDocuments and returns the data updated in the database.
     * @param {PdfDocumentUpdateManyAndReturnArgs} args - Arguments to update many PdfDocuments.
     * @example
     * // Update many PdfDocuments
     * const pdfDocument = await prisma.pdfDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PdfDocuments and only return the `id`
     * const pdfDocumentWithIdOnly = await prisma.pdfDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PdfDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, PdfDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PdfDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PdfDocument.
     * @param {PdfDocumentUpsertArgs} args - Arguments to update or create a PdfDocument.
     * @example
     * // Update or create a PdfDocument
     * const pdfDocument = await prisma.pdfDocument.upsert({
     *   create: {
     *     // ... data to create a PdfDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PdfDocument we want to update
     *   }
     * })
     */
    upsert<T extends PdfDocumentUpsertArgs>(args: SelectSubset<T, PdfDocumentUpsertArgs<ExtArgs>>): Prisma__PdfDocumentClient<$Result.GetResult<Prisma.$PdfDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PdfDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfDocumentCountArgs} args - Arguments to filter PdfDocuments to count.
     * @example
     * // Count the number of PdfDocuments
     * const count = await prisma.pdfDocument.count({
     *   where: {
     *     // ... the filter for the PdfDocuments we want to count
     *   }
     * })
    **/
    count<T extends PdfDocumentCountArgs>(
      args?: Subset<T, PdfDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PdfDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PdfDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PdfDocumentAggregateArgs>(args: Subset<T, PdfDocumentAggregateArgs>): Prisma.PrismaPromise<GetPdfDocumentAggregateType<T>>

    /**
     * Group by PdfDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PdfDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PdfDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PdfDocumentGroupByArgs['orderBy'] }
        : { orderBy?: PdfDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PdfDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPdfDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PdfDocument model
   */
  readonly fields: PdfDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PdfDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PdfDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DocumentTags<T extends PdfDocument$DocumentTagsArgs<ExtArgs> = {}>(args?: Subset<T, PdfDocument$DocumentTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PdfDocument model
   */
  interface PdfDocumentFieldRefs {
    readonly id: FieldRef<"PdfDocument", 'String'>
    readonly qrId: FieldRef<"PdfDocument", 'String'>
    readonly fileName: FieldRef<"PdfDocument", 'String'>
    readonly description: FieldRef<"PdfDocument", 'String'>
    readonly fileData: FieldRef<"PdfDocument", 'Bytes'>
    readonly contentType: FieldRef<"PdfDocument", 'String'>
    readonly size: FieldRef<"PdfDocument", 'Int'>
    readonly isActive: FieldRef<"PdfDocument", 'Boolean'>
    readonly createdAt: FieldRef<"PdfDocument", 'DateTime'>
    readonly uploadDate: FieldRef<"PdfDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PdfDocument findUnique
   */
  export type PdfDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfDocument
     */
    select?: PdfDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfDocument
     */
    omit?: PdfDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PdfDocument to fetch.
     */
    where: PdfDocumentWhereUniqueInput
  }

  /**
   * PdfDocument findUniqueOrThrow
   */
  export type PdfDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfDocument
     */
    select?: PdfDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfDocument
     */
    omit?: PdfDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PdfDocument to fetch.
     */
    where: PdfDocumentWhereUniqueInput
  }

  /**
   * PdfDocument findFirst
   */
  export type PdfDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfDocument
     */
    select?: PdfDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfDocument
     */
    omit?: PdfDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PdfDocument to fetch.
     */
    where?: PdfDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PdfDocuments to fetch.
     */
    orderBy?: PdfDocumentOrderByWithRelationInput | PdfDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PdfDocuments.
     */
    cursor?: PdfDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PdfDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PdfDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PdfDocuments.
     */
    distinct?: PdfDocumentScalarFieldEnum | PdfDocumentScalarFieldEnum[]
  }

  /**
   * PdfDocument findFirstOrThrow
   */
  export type PdfDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfDocument
     */
    select?: PdfDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfDocument
     */
    omit?: PdfDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PdfDocument to fetch.
     */
    where?: PdfDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PdfDocuments to fetch.
     */
    orderBy?: PdfDocumentOrderByWithRelationInput | PdfDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PdfDocuments.
     */
    cursor?: PdfDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PdfDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PdfDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PdfDocuments.
     */
    distinct?: PdfDocumentScalarFieldEnum | PdfDocumentScalarFieldEnum[]
  }

  /**
   * PdfDocument findMany
   */
  export type PdfDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfDocument
     */
    select?: PdfDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfDocument
     */
    omit?: PdfDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PdfDocuments to fetch.
     */
    where?: PdfDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PdfDocuments to fetch.
     */
    orderBy?: PdfDocumentOrderByWithRelationInput | PdfDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PdfDocuments.
     */
    cursor?: PdfDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PdfDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PdfDocuments.
     */
    skip?: number
    distinct?: PdfDocumentScalarFieldEnum | PdfDocumentScalarFieldEnum[]
  }

  /**
   * PdfDocument create
   */
  export type PdfDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfDocument
     */
    select?: PdfDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfDocument
     */
    omit?: PdfDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a PdfDocument.
     */
    data: XOR<PdfDocumentCreateInput, PdfDocumentUncheckedCreateInput>
  }

  /**
   * PdfDocument createMany
   */
  export type PdfDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PdfDocuments.
     */
    data: PdfDocumentCreateManyInput | PdfDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PdfDocument createManyAndReturn
   */
  export type PdfDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfDocument
     */
    select?: PdfDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PdfDocument
     */
    omit?: PdfDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many PdfDocuments.
     */
    data: PdfDocumentCreateManyInput | PdfDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PdfDocument update
   */
  export type PdfDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfDocument
     */
    select?: PdfDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfDocument
     */
    omit?: PdfDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a PdfDocument.
     */
    data: XOR<PdfDocumentUpdateInput, PdfDocumentUncheckedUpdateInput>
    /**
     * Choose, which PdfDocument to update.
     */
    where: PdfDocumentWhereUniqueInput
  }

  /**
   * PdfDocument updateMany
   */
  export type PdfDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PdfDocuments.
     */
    data: XOR<PdfDocumentUpdateManyMutationInput, PdfDocumentUncheckedUpdateManyInput>
    /**
     * Filter which PdfDocuments to update
     */
    where?: PdfDocumentWhereInput
    /**
     * Limit how many PdfDocuments to update.
     */
    limit?: number
  }

  /**
   * PdfDocument updateManyAndReturn
   */
  export type PdfDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfDocument
     */
    select?: PdfDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PdfDocument
     */
    omit?: PdfDocumentOmit<ExtArgs> | null
    /**
     * The data used to update PdfDocuments.
     */
    data: XOR<PdfDocumentUpdateManyMutationInput, PdfDocumentUncheckedUpdateManyInput>
    /**
     * Filter which PdfDocuments to update
     */
    where?: PdfDocumentWhereInput
    /**
     * Limit how many PdfDocuments to update.
     */
    limit?: number
  }

  /**
   * PdfDocument upsert
   */
  export type PdfDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfDocument
     */
    select?: PdfDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfDocument
     */
    omit?: PdfDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the PdfDocument to update in case it exists.
     */
    where: PdfDocumentWhereUniqueInput
    /**
     * In case the PdfDocument found by the `where` argument doesn't exist, create a new PdfDocument with this data.
     */
    create: XOR<PdfDocumentCreateInput, PdfDocumentUncheckedCreateInput>
    /**
     * In case the PdfDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PdfDocumentUpdateInput, PdfDocumentUncheckedUpdateInput>
  }

  /**
   * PdfDocument delete
   */
  export type PdfDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfDocument
     */
    select?: PdfDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfDocument
     */
    omit?: PdfDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfDocumentInclude<ExtArgs> | null
    /**
     * Filter which PdfDocument to delete.
     */
    where: PdfDocumentWhereUniqueInput
  }

  /**
   * PdfDocument deleteMany
   */
  export type PdfDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PdfDocuments to delete
     */
    where?: PdfDocumentWhereInput
    /**
     * Limit how many PdfDocuments to delete.
     */
    limit?: number
  }

  /**
   * PdfDocument.DocumentTags
   */
  export type PdfDocument$DocumentTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    where?: DocumentTagWhereInput
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    cursor?: DocumentTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentTagScalarFieldEnum | DocumentTagScalarFieldEnum[]
  }

  /**
   * PdfDocument without action
   */
  export type PdfDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfDocument
     */
    select?: PdfDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfDocument
     */
    omit?: PdfDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfDocumentInclude<ExtArgs> | null
  }


  /**
   * Model DocumentTag
   */

  export type AggregateDocumentTag = {
    _count: DocumentTagCountAggregateOutputType | null
    _min: DocumentTagMinAggregateOutputType | null
    _max: DocumentTagMaxAggregateOutputType | null
  }

  export type DocumentTagMinAggregateOutputType = {
    id: string | null
    tagName: string | null
  }

  export type DocumentTagMaxAggregateOutputType = {
    id: string | null
    tagName: string | null
  }

  export type DocumentTagCountAggregateOutputType = {
    id: number
    tagName: number
    _all: number
  }


  export type DocumentTagMinAggregateInputType = {
    id?: true
    tagName?: true
  }

  export type DocumentTagMaxAggregateInputType = {
    id?: true
    tagName?: true
  }

  export type DocumentTagCountAggregateInputType = {
    id?: true
    tagName?: true
    _all?: true
  }

  export type DocumentTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentTag to aggregate.
     */
    where?: DocumentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTags to fetch.
     */
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentTags
    **/
    _count?: true | DocumentTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentTagMaxAggregateInputType
  }

  export type GetDocumentTagAggregateType<T extends DocumentTagAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentTag[P]>
      : GetScalarType<T[P], AggregateDocumentTag[P]>
  }




  export type DocumentTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentTagWhereInput
    orderBy?: DocumentTagOrderByWithAggregationInput | DocumentTagOrderByWithAggregationInput[]
    by: DocumentTagScalarFieldEnum[] | DocumentTagScalarFieldEnum
    having?: DocumentTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentTagCountAggregateInputType | true
    _min?: DocumentTagMinAggregateInputType
    _max?: DocumentTagMaxAggregateInputType
  }

  export type DocumentTagGroupByOutputType = {
    id: string
    tagName: string
    _count: DocumentTagCountAggregateOutputType | null
    _min: DocumentTagMinAggregateOutputType | null
    _max: DocumentTagMaxAggregateOutputType | null
  }

  type GetDocumentTagGroupByPayload<T extends DocumentTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentTagGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentTagGroupByOutputType[P]>
        }
      >
    >


  export type DocumentTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagName?: boolean
    Equipment?: boolean | DocumentTag$EquipmentArgs<ExtArgs>
    Documents?: boolean | DocumentTag$DocumentsArgs<ExtArgs>
    _count?: boolean | DocumentTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentTag"]>

  export type DocumentTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagName?: boolean
  }, ExtArgs["result"]["documentTag"]>

  export type DocumentTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagName?: boolean
  }, ExtArgs["result"]["documentTag"]>

  export type DocumentTagSelectScalar = {
    id?: boolean
    tagName?: boolean
  }

  export type DocumentTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tagName", ExtArgs["result"]["documentTag"]>
  export type DocumentTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | DocumentTag$EquipmentArgs<ExtArgs>
    Documents?: boolean | DocumentTag$DocumentsArgs<ExtArgs>
    _count?: boolean | DocumentTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DocumentTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DocumentTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentTag"
    objects: {
      Equipment: Prisma.$EquipmentPayload<ExtArgs>[]
      Documents: Prisma.$PdfDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tagName: string
    }, ExtArgs["result"]["documentTag"]>
    composites: {}
  }

  type DocumentTagGetPayload<S extends boolean | null | undefined | DocumentTagDefaultArgs> = $Result.GetResult<Prisma.$DocumentTagPayload, S>

  type DocumentTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentTagCountAggregateInputType | true
    }

  export interface DocumentTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentTag'], meta: { name: 'DocumentTag' } }
    /**
     * Find zero or one DocumentTag that matches the filter.
     * @param {DocumentTagFindUniqueArgs} args - Arguments to find a DocumentTag
     * @example
     * // Get one DocumentTag
     * const documentTag = await prisma.documentTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentTagFindUniqueArgs>(args: SelectSubset<T, DocumentTagFindUniqueArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentTagFindUniqueOrThrowArgs} args - Arguments to find a DocumentTag
     * @example
     * // Get one DocumentTag
     * const documentTag = await prisma.documentTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentTagFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagFindFirstArgs} args - Arguments to find a DocumentTag
     * @example
     * // Get one DocumentTag
     * const documentTag = await prisma.documentTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentTagFindFirstArgs>(args?: SelectSubset<T, DocumentTagFindFirstArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagFindFirstOrThrowArgs} args - Arguments to find a DocumentTag
     * @example
     * // Get one DocumentTag
     * const documentTag = await prisma.documentTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentTagFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentTags
     * const documentTags = await prisma.documentTag.findMany()
     * 
     * // Get first 10 DocumentTags
     * const documentTags = await prisma.documentTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentTagWithIdOnly = await prisma.documentTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentTagFindManyArgs>(args?: SelectSubset<T, DocumentTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentTag.
     * @param {DocumentTagCreateArgs} args - Arguments to create a DocumentTag.
     * @example
     * // Create one DocumentTag
     * const DocumentTag = await prisma.documentTag.create({
     *   data: {
     *     // ... data to create a DocumentTag
     *   }
     * })
     * 
     */
    create<T extends DocumentTagCreateArgs>(args: SelectSubset<T, DocumentTagCreateArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentTags.
     * @param {DocumentTagCreateManyArgs} args - Arguments to create many DocumentTags.
     * @example
     * // Create many DocumentTags
     * const documentTag = await prisma.documentTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentTagCreateManyArgs>(args?: SelectSubset<T, DocumentTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentTags and returns the data saved in the database.
     * @param {DocumentTagCreateManyAndReturnArgs} args - Arguments to create many DocumentTags.
     * @example
     * // Create many DocumentTags
     * const documentTag = await prisma.documentTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentTags and only return the `id`
     * const documentTagWithIdOnly = await prisma.documentTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentTagCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentTag.
     * @param {DocumentTagDeleteArgs} args - Arguments to delete one DocumentTag.
     * @example
     * // Delete one DocumentTag
     * const DocumentTag = await prisma.documentTag.delete({
     *   where: {
     *     // ... filter to delete one DocumentTag
     *   }
     * })
     * 
     */
    delete<T extends DocumentTagDeleteArgs>(args: SelectSubset<T, DocumentTagDeleteArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentTag.
     * @param {DocumentTagUpdateArgs} args - Arguments to update one DocumentTag.
     * @example
     * // Update one DocumentTag
     * const documentTag = await prisma.documentTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentTagUpdateArgs>(args: SelectSubset<T, DocumentTagUpdateArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentTags.
     * @param {DocumentTagDeleteManyArgs} args - Arguments to filter DocumentTags to delete.
     * @example
     * // Delete a few DocumentTags
     * const { count } = await prisma.documentTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentTagDeleteManyArgs>(args?: SelectSubset<T, DocumentTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentTags
     * const documentTag = await prisma.documentTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentTagUpdateManyArgs>(args: SelectSubset<T, DocumentTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentTags and returns the data updated in the database.
     * @param {DocumentTagUpdateManyAndReturnArgs} args - Arguments to update many DocumentTags.
     * @example
     * // Update many DocumentTags
     * const documentTag = await prisma.documentTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentTags and only return the `id`
     * const documentTagWithIdOnly = await prisma.documentTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentTagUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentTag.
     * @param {DocumentTagUpsertArgs} args - Arguments to update or create a DocumentTag.
     * @example
     * // Update or create a DocumentTag
     * const documentTag = await prisma.documentTag.upsert({
     *   create: {
     *     // ... data to create a DocumentTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentTag we want to update
     *   }
     * })
     */
    upsert<T extends DocumentTagUpsertArgs>(args: SelectSubset<T, DocumentTagUpsertArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagCountArgs} args - Arguments to filter DocumentTags to count.
     * @example
     * // Count the number of DocumentTags
     * const count = await prisma.documentTag.count({
     *   where: {
     *     // ... the filter for the DocumentTags we want to count
     *   }
     * })
    **/
    count<T extends DocumentTagCountArgs>(
      args?: Subset<T, DocumentTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentTagAggregateArgs>(args: Subset<T, DocumentTagAggregateArgs>): Prisma.PrismaPromise<GetDocumentTagAggregateType<T>>

    /**
     * Group by DocumentTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentTagGroupByArgs['orderBy'] }
        : { orderBy?: DocumentTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentTag model
   */
  readonly fields: DocumentTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Equipment<T extends DocumentTag$EquipmentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentTag$EquipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Documents<T extends DocumentTag$DocumentsArgs<ExtArgs> = {}>(args?: Subset<T, DocumentTag$DocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PdfDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentTag model
   */
  interface DocumentTagFieldRefs {
    readonly id: FieldRef<"DocumentTag", 'String'>
    readonly tagName: FieldRef<"DocumentTag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DocumentTag findUnique
   */
  export type DocumentTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTag to fetch.
     */
    where: DocumentTagWhereUniqueInput
  }

  /**
   * DocumentTag findUniqueOrThrow
   */
  export type DocumentTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTag to fetch.
     */
    where: DocumentTagWhereUniqueInput
  }

  /**
   * DocumentTag findFirst
   */
  export type DocumentTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTag to fetch.
     */
    where?: DocumentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTags to fetch.
     */
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentTags.
     */
    cursor?: DocumentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentTags.
     */
    distinct?: DocumentTagScalarFieldEnum | DocumentTagScalarFieldEnum[]
  }

  /**
   * DocumentTag findFirstOrThrow
   */
  export type DocumentTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTag to fetch.
     */
    where?: DocumentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTags to fetch.
     */
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentTags.
     */
    cursor?: DocumentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentTags.
     */
    distinct?: DocumentTagScalarFieldEnum | DocumentTagScalarFieldEnum[]
  }

  /**
   * DocumentTag findMany
   */
  export type DocumentTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTags to fetch.
     */
    where?: DocumentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTags to fetch.
     */
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentTags.
     */
    cursor?: DocumentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTags.
     */
    skip?: number
    distinct?: DocumentTagScalarFieldEnum | DocumentTagScalarFieldEnum[]
  }

  /**
   * DocumentTag create
   */
  export type DocumentTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentTag.
     */
    data: XOR<DocumentTagCreateInput, DocumentTagUncheckedCreateInput>
  }

  /**
   * DocumentTag createMany
   */
  export type DocumentTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentTags.
     */
    data: DocumentTagCreateManyInput | DocumentTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentTag createManyAndReturn
   */
  export type DocumentTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentTags.
     */
    data: DocumentTagCreateManyInput | DocumentTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentTag update
   */
  export type DocumentTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentTag.
     */
    data: XOR<DocumentTagUpdateInput, DocumentTagUncheckedUpdateInput>
    /**
     * Choose, which DocumentTag to update.
     */
    where: DocumentTagWhereUniqueInput
  }

  /**
   * DocumentTag updateMany
   */
  export type DocumentTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentTags.
     */
    data: XOR<DocumentTagUpdateManyMutationInput, DocumentTagUncheckedUpdateManyInput>
    /**
     * Filter which DocumentTags to update
     */
    where?: DocumentTagWhereInput
    /**
     * Limit how many DocumentTags to update.
     */
    limit?: number
  }

  /**
   * DocumentTag updateManyAndReturn
   */
  export type DocumentTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * The data used to update DocumentTags.
     */
    data: XOR<DocumentTagUpdateManyMutationInput, DocumentTagUncheckedUpdateManyInput>
    /**
     * Filter which DocumentTags to update
     */
    where?: DocumentTagWhereInput
    /**
     * Limit how many DocumentTags to update.
     */
    limit?: number
  }

  /**
   * DocumentTag upsert
   */
  export type DocumentTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentTag to update in case it exists.
     */
    where: DocumentTagWhereUniqueInput
    /**
     * In case the DocumentTag found by the `where` argument doesn't exist, create a new DocumentTag with this data.
     */
    create: XOR<DocumentTagCreateInput, DocumentTagUncheckedCreateInput>
    /**
     * In case the DocumentTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentTagUpdateInput, DocumentTagUncheckedUpdateInput>
  }

  /**
   * DocumentTag delete
   */
  export type DocumentTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter which DocumentTag to delete.
     */
    where: DocumentTagWhereUniqueInput
  }

  /**
   * DocumentTag deleteMany
   */
  export type DocumentTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentTags to delete
     */
    where?: DocumentTagWhereInput
    /**
     * Limit how many DocumentTags to delete.
     */
    limit?: number
  }

  /**
   * DocumentTag.Equipment
   */
  export type DocumentTag$EquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * DocumentTag.Documents
   */
  export type DocumentTag$DocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PdfDocument
     */
    select?: PdfDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PdfDocument
     */
    omit?: PdfDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PdfDocumentInclude<ExtArgs> | null
    where?: PdfDocumentWhereInput
    orderBy?: PdfDocumentOrderByWithRelationInput | PdfDocumentOrderByWithRelationInput[]
    cursor?: PdfDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PdfDocumentScalarFieldEnum | PdfDocumentScalarFieldEnum[]
  }

  /**
   * DocumentTag without action
   */
  export type DocumentTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
  }


  /**
   * Model Equipment
   */

  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentAvgAggregateOutputType = {
    currentWeight: number | null
  }

  export type EquipmentSumAggregateOutputType = {
    currentWeight: number | null
  }

  export type EquipmentMinAggregateOutputType = {
    id: string | null
    qrId: string | null
    name: string | null
    description: string | null
    creationReason: string | null
    equipmentTag: $Enums.EquipmentTags | null
    state: $Enums.EquipmentState | null
    approvalStatus: $Enums.ApprovalStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    overWeight: boolean | null
    currentWeight: number | null
    createdById: string | null
    createdVia: $Enums.CreatedVia | null
    acquiredDate: Date | null
    code: string | null
    color: string | null
    licensePlate: string | null
    licenseState: string | null
    make: string | null
    memo: string | null
    model: string | null
    ownershipType: $Enums.OwnershipType | null
    registrationExpiration: Date | null
    serialNumber: string | null
    year: string | null
    acquiredCondition: $Enums.Condition | null
    status: $Enums.FormTemplateStatus | null
  }

  export type EquipmentMaxAggregateOutputType = {
    id: string | null
    qrId: string | null
    name: string | null
    description: string | null
    creationReason: string | null
    equipmentTag: $Enums.EquipmentTags | null
    state: $Enums.EquipmentState | null
    approvalStatus: $Enums.ApprovalStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    overWeight: boolean | null
    currentWeight: number | null
    createdById: string | null
    createdVia: $Enums.CreatedVia | null
    acquiredDate: Date | null
    code: string | null
    color: string | null
    licensePlate: string | null
    licenseState: string | null
    make: string | null
    memo: string | null
    model: string | null
    ownershipType: $Enums.OwnershipType | null
    registrationExpiration: Date | null
    serialNumber: string | null
    year: string | null
    acquiredCondition: $Enums.Condition | null
    status: $Enums.FormTemplateStatus | null
  }

  export type EquipmentCountAggregateOutputType = {
    id: number
    qrId: number
    name: number
    description: number
    creationReason: number
    equipmentTag: number
    state: number
    approvalStatus: number
    createdAt: number
    updatedAt: number
    overWeight: number
    currentWeight: number
    createdById: number
    createdVia: number
    acquiredDate: number
    code: number
    color: number
    licensePlate: number
    licenseState: number
    make: number
    memo: number
    model: number
    ownershipType: number
    registrationExpiration: number
    serialNumber: number
    year: number
    acquiredCondition: number
    status: number
    _all: number
  }


  export type EquipmentAvgAggregateInputType = {
    currentWeight?: true
  }

  export type EquipmentSumAggregateInputType = {
    currentWeight?: true
  }

  export type EquipmentMinAggregateInputType = {
    id?: true
    qrId?: true
    name?: true
    description?: true
    creationReason?: true
    equipmentTag?: true
    state?: true
    approvalStatus?: true
    createdAt?: true
    updatedAt?: true
    overWeight?: true
    currentWeight?: true
    createdById?: true
    createdVia?: true
    acquiredDate?: true
    code?: true
    color?: true
    licensePlate?: true
    licenseState?: true
    make?: true
    memo?: true
    model?: true
    ownershipType?: true
    registrationExpiration?: true
    serialNumber?: true
    year?: true
    acquiredCondition?: true
    status?: true
  }

  export type EquipmentMaxAggregateInputType = {
    id?: true
    qrId?: true
    name?: true
    description?: true
    creationReason?: true
    equipmentTag?: true
    state?: true
    approvalStatus?: true
    createdAt?: true
    updatedAt?: true
    overWeight?: true
    currentWeight?: true
    createdById?: true
    createdVia?: true
    acquiredDate?: true
    code?: true
    color?: true
    licensePlate?: true
    licenseState?: true
    make?: true
    memo?: true
    model?: true
    ownershipType?: true
    registrationExpiration?: true
    serialNumber?: true
    year?: true
    acquiredCondition?: true
    status?: true
  }

  export type EquipmentCountAggregateInputType = {
    id?: true
    qrId?: true
    name?: true
    description?: true
    creationReason?: true
    equipmentTag?: true
    state?: true
    approvalStatus?: true
    createdAt?: true
    updatedAt?: true
    overWeight?: true
    currentWeight?: true
    createdById?: true
    createdVia?: true
    acquiredDate?: true
    code?: true
    color?: true
    licensePlate?: true
    licenseState?: true
    make?: true
    memo?: true
    model?: true
    ownershipType?: true
    registrationExpiration?: true
    serialNumber?: true
    year?: true
    acquiredCondition?: true
    status?: true
    _all?: true
  }

  export type EquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to aggregate.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type EquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithAggregationInput | EquipmentOrderByWithAggregationInput[]
    by: EquipmentScalarFieldEnum[] | EquipmentScalarFieldEnum
    having?: EquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _avg?: EquipmentAvgAggregateInputType
    _sum?: EquipmentSumAggregateInputType
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }

  export type EquipmentGroupByOutputType = {
    id: string
    qrId: string
    name: string
    description: string | null
    creationReason: string | null
    equipmentTag: $Enums.EquipmentTags
    state: $Enums.EquipmentState
    approvalStatus: $Enums.ApprovalStatus
    createdAt: Date
    updatedAt: Date
    overWeight: boolean | null
    currentWeight: number | null
    createdById: string | null
    createdVia: $Enums.CreatedVia
    acquiredDate: Date | null
    code: string | null
    color: string | null
    licensePlate: string | null
    licenseState: string | null
    make: string | null
    memo: string | null
    model: string | null
    ownershipType: $Enums.OwnershipType | null
    registrationExpiration: Date | null
    serialNumber: string | null
    year: string | null
    acquiredCondition: $Enums.Condition | null
    status: $Enums.FormTemplateStatus
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends EquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qrId?: boolean
    name?: boolean
    description?: boolean
    creationReason?: boolean
    equipmentTag?: boolean
    state?: boolean
    approvalStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    overWeight?: boolean
    currentWeight?: boolean
    createdById?: boolean
    createdVia?: boolean
    acquiredDate?: boolean
    code?: boolean
    color?: boolean
    licensePlate?: boolean
    licenseState?: boolean
    make?: boolean
    memo?: boolean
    model?: boolean
    ownershipType?: boolean
    registrationExpiration?: boolean
    serialNumber?: boolean
    year?: boolean
    acquiredCondition?: boolean
    status?: boolean
    EmployeeEquipmentLogs?: boolean | Equipment$EmployeeEquipmentLogsArgs<ExtArgs>
    createdBy?: boolean | Equipment$createdByArgs<ExtArgs>
    EquipmentHauled?: boolean | Equipment$EquipmentHauledArgs<ExtArgs>
    Maintenances?: boolean | Equipment$MaintenancesArgs<ExtArgs>
    TascoLogs?: boolean | Equipment$TascoLogsArgs<ExtArgs>
    HauledInLogs?: boolean | Equipment$HauledInLogsArgs<ExtArgs>
    UsedAsTrailer?: boolean | Equipment$UsedAsTrailerArgs<ExtArgs>
    UsedAsTruck?: boolean | Equipment$UsedAsTruckArgs<ExtArgs>
    Maintenance?: boolean | Equipment$MaintenanceArgs<ExtArgs>
    DocumentTags?: boolean | Equipment$DocumentTagsArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qrId?: boolean
    name?: boolean
    description?: boolean
    creationReason?: boolean
    equipmentTag?: boolean
    state?: boolean
    approvalStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    overWeight?: boolean
    currentWeight?: boolean
    createdById?: boolean
    createdVia?: boolean
    acquiredDate?: boolean
    code?: boolean
    color?: boolean
    licensePlate?: boolean
    licenseState?: boolean
    make?: boolean
    memo?: boolean
    model?: boolean
    ownershipType?: boolean
    registrationExpiration?: boolean
    serialNumber?: boolean
    year?: boolean
    acquiredCondition?: boolean
    status?: boolean
    createdBy?: boolean | Equipment$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qrId?: boolean
    name?: boolean
    description?: boolean
    creationReason?: boolean
    equipmentTag?: boolean
    state?: boolean
    approvalStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    overWeight?: boolean
    currentWeight?: boolean
    createdById?: boolean
    createdVia?: boolean
    acquiredDate?: boolean
    code?: boolean
    color?: boolean
    licensePlate?: boolean
    licenseState?: boolean
    make?: boolean
    memo?: boolean
    model?: boolean
    ownershipType?: boolean
    registrationExpiration?: boolean
    serialNumber?: boolean
    year?: boolean
    acquiredCondition?: boolean
    status?: boolean
    createdBy?: boolean | Equipment$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectScalar = {
    id?: boolean
    qrId?: boolean
    name?: boolean
    description?: boolean
    creationReason?: boolean
    equipmentTag?: boolean
    state?: boolean
    approvalStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    overWeight?: boolean
    currentWeight?: boolean
    createdById?: boolean
    createdVia?: boolean
    acquiredDate?: boolean
    code?: boolean
    color?: boolean
    licensePlate?: boolean
    licenseState?: boolean
    make?: boolean
    memo?: boolean
    model?: boolean
    ownershipType?: boolean
    registrationExpiration?: boolean
    serialNumber?: boolean
    year?: boolean
    acquiredCondition?: boolean
    status?: boolean
  }

  export type EquipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "qrId" | "name" | "description" | "creationReason" | "equipmentTag" | "state" | "approvalStatus" | "createdAt" | "updatedAt" | "overWeight" | "currentWeight" | "createdById" | "createdVia" | "acquiredDate" | "code" | "color" | "licensePlate" | "licenseState" | "make" | "memo" | "model" | "ownershipType" | "registrationExpiration" | "serialNumber" | "year" | "acquiredCondition" | "status", ExtArgs["result"]["equipment"]>
  export type EquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeEquipmentLogs?: boolean | Equipment$EmployeeEquipmentLogsArgs<ExtArgs>
    createdBy?: boolean | Equipment$createdByArgs<ExtArgs>
    EquipmentHauled?: boolean | Equipment$EquipmentHauledArgs<ExtArgs>
    Maintenances?: boolean | Equipment$MaintenancesArgs<ExtArgs>
    TascoLogs?: boolean | Equipment$TascoLogsArgs<ExtArgs>
    HauledInLogs?: boolean | Equipment$HauledInLogsArgs<ExtArgs>
    UsedAsTrailer?: boolean | Equipment$UsedAsTrailerArgs<ExtArgs>
    UsedAsTruck?: boolean | Equipment$UsedAsTruckArgs<ExtArgs>
    Maintenance?: boolean | Equipment$MaintenanceArgs<ExtArgs>
    DocumentTags?: boolean | Equipment$DocumentTagsArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Equipment$createdByArgs<ExtArgs>
  }
  export type EquipmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Equipment$createdByArgs<ExtArgs>
  }

  export type $EquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equipment"
    objects: {
      EmployeeEquipmentLogs: Prisma.$EmployeeEquipmentLogPayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      EquipmentHauled: Prisma.$EquipmentHauledPayload<ExtArgs>[]
      Maintenances: Prisma.$MaintenancePayload<ExtArgs>[]
      TascoLogs: Prisma.$TascoLogPayload<ExtArgs>[]
      HauledInLogs: Prisma.$TruckingLogPayload<ExtArgs>[]
      UsedAsTrailer: Prisma.$TruckingLogPayload<ExtArgs>[]
      UsedAsTruck: Prisma.$TruckingLogPayload<ExtArgs>[]
      Maintenance: Prisma.$mechanicProjectsPayload<ExtArgs>[]
      DocumentTags: Prisma.$DocumentTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      qrId: string
      name: string
      description: string | null
      creationReason: string | null
      equipmentTag: $Enums.EquipmentTags
      state: $Enums.EquipmentState
      approvalStatus: $Enums.ApprovalStatus
      createdAt: Date
      updatedAt: Date
      overWeight: boolean | null
      currentWeight: number | null
      createdById: string | null
      createdVia: $Enums.CreatedVia
      acquiredDate: Date | null
      code: string | null
      color: string | null
      licensePlate: string | null
      licenseState: string | null
      make: string | null
      memo: string | null
      model: string | null
      ownershipType: $Enums.OwnershipType | null
      registrationExpiration: Date | null
      serialNumber: string | null
      year: string | null
      acquiredCondition: $Enums.Condition | null
      status: $Enums.FormTemplateStatus
    }, ExtArgs["result"]["equipment"]>
    composites: {}
  }

  type EquipmentGetPayload<S extends boolean | null | undefined | EquipmentDefaultArgs> = $Result.GetResult<Prisma.$EquipmentPayload, S>

  type EquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface EquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equipment'], meta: { name: 'Equipment' } }
    /**
     * Find zero or one Equipment that matches the filter.
     * @param {EquipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentFindUniqueArgs>(args: SelectSubset<T, EquipmentFindUniqueArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Equipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentFindFirstArgs>(args?: SelectSubset<T, EquipmentFindFirstArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentWithIdOnly = await prisma.equipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentFindManyArgs>(args?: SelectSubset<T, EquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Equipment.
     * @param {EquipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
     */
    create<T extends EquipmentCreateArgs>(args: SelectSubset<T, EquipmentCreateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Equipment.
     * @param {EquipmentCreateManyArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentCreateManyArgs>(args?: SelectSubset<T, EquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equipment and returns the data saved in the database.
     * @param {EquipmentCreateManyAndReturnArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Equipment.
     * @param {EquipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
     */
    delete<T extends EquipmentDeleteArgs>(args: SelectSubset<T, EquipmentDeleteArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Equipment.
     * @param {EquipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentUpdateArgs>(args: SelectSubset<T, EquipmentUpdateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Equipment.
     * @param {EquipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentDeleteManyArgs>(args?: SelectSubset<T, EquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentUpdateManyArgs>(args: SelectSubset<T, EquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment and returns the data updated in the database.
     * @param {EquipmentUpdateManyAndReturnArgs} args - Arguments to update many Equipment.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Equipment.
     * @param {EquipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentUpsertArgs>(args: SelectSubset<T, EquipmentUpsertArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCountArgs>(
      args?: Subset<T, EquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equipment model
   */
  readonly fields: EquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EmployeeEquipmentLogs<T extends Equipment$EmployeeEquipmentLogsArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$EmployeeEquipmentLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeEquipmentLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBy<T extends Equipment$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    EquipmentHauled<T extends Equipment$EquipmentHauledArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$EquipmentHauledArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentHauledPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Maintenances<T extends Equipment$MaintenancesArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$MaintenancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TascoLogs<T extends Equipment$TascoLogsArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$TascoLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TascoLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    HauledInLogs<T extends Equipment$HauledInLogsArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$HauledInLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UsedAsTrailer<T extends Equipment$UsedAsTrailerArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$UsedAsTrailerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    UsedAsTruck<T extends Equipment$UsedAsTruckArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$UsedAsTruckArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Maintenance<T extends Equipment$MaintenanceArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$MaintenanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mechanicProjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DocumentTags<T extends Equipment$DocumentTagsArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$DocumentTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equipment model
   */
  interface EquipmentFieldRefs {
    readonly id: FieldRef<"Equipment", 'String'>
    readonly qrId: FieldRef<"Equipment", 'String'>
    readonly name: FieldRef<"Equipment", 'String'>
    readonly description: FieldRef<"Equipment", 'String'>
    readonly creationReason: FieldRef<"Equipment", 'String'>
    readonly equipmentTag: FieldRef<"Equipment", 'EquipmentTags'>
    readonly state: FieldRef<"Equipment", 'EquipmentState'>
    readonly approvalStatus: FieldRef<"Equipment", 'ApprovalStatus'>
    readonly createdAt: FieldRef<"Equipment", 'DateTime'>
    readonly updatedAt: FieldRef<"Equipment", 'DateTime'>
    readonly overWeight: FieldRef<"Equipment", 'Boolean'>
    readonly currentWeight: FieldRef<"Equipment", 'Float'>
    readonly createdById: FieldRef<"Equipment", 'String'>
    readonly createdVia: FieldRef<"Equipment", 'CreatedVia'>
    readonly acquiredDate: FieldRef<"Equipment", 'DateTime'>
    readonly code: FieldRef<"Equipment", 'String'>
    readonly color: FieldRef<"Equipment", 'String'>
    readonly licensePlate: FieldRef<"Equipment", 'String'>
    readonly licenseState: FieldRef<"Equipment", 'String'>
    readonly make: FieldRef<"Equipment", 'String'>
    readonly memo: FieldRef<"Equipment", 'String'>
    readonly model: FieldRef<"Equipment", 'String'>
    readonly ownershipType: FieldRef<"Equipment", 'OwnershipType'>
    readonly registrationExpiration: FieldRef<"Equipment", 'DateTime'>
    readonly serialNumber: FieldRef<"Equipment", 'String'>
    readonly year: FieldRef<"Equipment", 'String'>
    readonly acquiredCondition: FieldRef<"Equipment", 'Condition'>
    readonly status: FieldRef<"Equipment", 'FormTemplateStatus'>
  }
    

  // Custom InputTypes
  /**
   * Equipment findUnique
   */
  export type EquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findUniqueOrThrow
   */
  export type EquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findFirst
   */
  export type EquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findFirstOrThrow
   */
  export type EquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findMany
   */
  export type EquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment create
   */
  export type EquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Equipment.
     */
    data: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
  }

  /**
   * Equipment createMany
   */
  export type EquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipment createManyAndReturn
   */
  export type EquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Equipment update
   */
  export type EquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Equipment.
     */
    data: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
    /**
     * Choose, which Equipment to update.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment updateMany
   */
  export type EquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to update.
     */
    limit?: number
  }

  /**
   * Equipment updateManyAndReturn
   */
  export type EquipmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Equipment upsert
   */
  export type EquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Equipment to update in case it exists.
     */
    where: EquipmentWhereUniqueInput
    /**
     * In case the Equipment found by the `where` argument doesn't exist, create a new Equipment with this data.
     */
    create: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
    /**
     * In case the Equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
  }

  /**
   * Equipment delete
   */
  export type EquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter which Equipment to delete.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment deleteMany
   */
  export type EquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to delete
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to delete.
     */
    limit?: number
  }

  /**
   * Equipment.EmployeeEquipmentLogs
   */
  export type Equipment$EmployeeEquipmentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeEquipmentLog
     */
    select?: EmployeeEquipmentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeEquipmentLog
     */
    omit?: EmployeeEquipmentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeEquipmentLogInclude<ExtArgs> | null
    where?: EmployeeEquipmentLogWhereInput
    orderBy?: EmployeeEquipmentLogOrderByWithRelationInput | EmployeeEquipmentLogOrderByWithRelationInput[]
    cursor?: EmployeeEquipmentLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeEquipmentLogScalarFieldEnum | EmployeeEquipmentLogScalarFieldEnum[]
  }

  /**
   * Equipment.createdBy
   */
  export type Equipment$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Equipment.EquipmentHauled
   */
  export type Equipment$EquipmentHauledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentHauled
     */
    select?: EquipmentHauledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentHauled
     */
    omit?: EquipmentHauledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentHauledInclude<ExtArgs> | null
    where?: EquipmentHauledWhereInput
    orderBy?: EquipmentHauledOrderByWithRelationInput | EquipmentHauledOrderByWithRelationInput[]
    cursor?: EquipmentHauledWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentHauledScalarFieldEnum | EquipmentHauledScalarFieldEnum[]
  }

  /**
   * Equipment.Maintenances
   */
  export type Equipment$MaintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    cursor?: MaintenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Equipment.TascoLogs
   */
  export type Equipment$TascoLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLog
     */
    select?: TascoLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoLog
     */
    omit?: TascoLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoLogInclude<ExtArgs> | null
    where?: TascoLogWhereInput
    orderBy?: TascoLogOrderByWithRelationInput | TascoLogOrderByWithRelationInput[]
    cursor?: TascoLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TascoLogScalarFieldEnum | TascoLogScalarFieldEnum[]
  }

  /**
   * Equipment.HauledInLogs
   */
  export type Equipment$HauledInLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogInclude<ExtArgs> | null
    where?: TruckingLogWhereInput
    orderBy?: TruckingLogOrderByWithRelationInput | TruckingLogOrderByWithRelationInput[]
    cursor?: TruckingLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TruckingLogScalarFieldEnum | TruckingLogScalarFieldEnum[]
  }

  /**
   * Equipment.UsedAsTrailer
   */
  export type Equipment$UsedAsTrailerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogInclude<ExtArgs> | null
    where?: TruckingLogWhereInput
    orderBy?: TruckingLogOrderByWithRelationInput | TruckingLogOrderByWithRelationInput[]
    cursor?: TruckingLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TruckingLogScalarFieldEnum | TruckingLogScalarFieldEnum[]
  }

  /**
   * Equipment.UsedAsTruck
   */
  export type Equipment$UsedAsTruckArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogInclude<ExtArgs> | null
    where?: TruckingLogWhereInput
    orderBy?: TruckingLogOrderByWithRelationInput | TruckingLogOrderByWithRelationInput[]
    cursor?: TruckingLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TruckingLogScalarFieldEnum | TruckingLogScalarFieldEnum[]
  }

  /**
   * Equipment.Maintenance
   */
  export type Equipment$MaintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mechanicProjects
     */
    select?: mechanicProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mechanicProjects
     */
    omit?: mechanicProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mechanicProjectsInclude<ExtArgs> | null
    where?: mechanicProjectsWhereInput
    orderBy?: mechanicProjectsOrderByWithRelationInput | mechanicProjectsOrderByWithRelationInput[]
    cursor?: mechanicProjectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MechanicProjectsScalarFieldEnum | MechanicProjectsScalarFieldEnum[]
  }

  /**
   * Equipment.DocumentTags
   */
  export type Equipment$DocumentTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    where?: DocumentTagWhereInput
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    cursor?: DocumentTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentTagScalarFieldEnum | DocumentTagScalarFieldEnum[]
  }

  /**
   * Equipment without action
   */
  export type EquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeEquipmentLog
   */

  export type AggregateEmployeeEquipmentLog = {
    _count: EmployeeEquipmentLogCountAggregateOutputType | null
    _avg: EmployeeEquipmentLogAvgAggregateOutputType | null
    _sum: EmployeeEquipmentLogSumAggregateOutputType | null
    _min: EmployeeEquipmentLogMinAggregateOutputType | null
    _max: EmployeeEquipmentLogMaxAggregateOutputType | null
  }

  export type EmployeeEquipmentLogAvgAggregateOutputType = {
    timeSheetId: number | null
  }

  export type EmployeeEquipmentLogSumAggregateOutputType = {
    timeSheetId: number | null
  }

  export type EmployeeEquipmentLogMinAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    maintenanceId: string | null
    startTime: Date | null
    endTime: Date | null
    comment: string | null
    timeSheetId: number | null
    rental: boolean | null
  }

  export type EmployeeEquipmentLogMaxAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    maintenanceId: string | null
    startTime: Date | null
    endTime: Date | null
    comment: string | null
    timeSheetId: number | null
    rental: boolean | null
  }

  export type EmployeeEquipmentLogCountAggregateOutputType = {
    id: number
    equipmentId: number
    maintenanceId: number
    startTime: number
    endTime: number
    comment: number
    timeSheetId: number
    rental: number
    _all: number
  }


  export type EmployeeEquipmentLogAvgAggregateInputType = {
    timeSheetId?: true
  }

  export type EmployeeEquipmentLogSumAggregateInputType = {
    timeSheetId?: true
  }

  export type EmployeeEquipmentLogMinAggregateInputType = {
    id?: true
    equipmentId?: true
    maintenanceId?: true
    startTime?: true
    endTime?: true
    comment?: true
    timeSheetId?: true
    rental?: true
  }

  export type EmployeeEquipmentLogMaxAggregateInputType = {
    id?: true
    equipmentId?: true
    maintenanceId?: true
    startTime?: true
    endTime?: true
    comment?: true
    timeSheetId?: true
    rental?: true
  }

  export type EmployeeEquipmentLogCountAggregateInputType = {
    id?: true
    equipmentId?: true
    maintenanceId?: true
    startTime?: true
    endTime?: true
    comment?: true
    timeSheetId?: true
    rental?: true
    _all?: true
  }

  export type EmployeeEquipmentLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeEquipmentLog to aggregate.
     */
    where?: EmployeeEquipmentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeEquipmentLogs to fetch.
     */
    orderBy?: EmployeeEquipmentLogOrderByWithRelationInput | EmployeeEquipmentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeEquipmentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeEquipmentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeEquipmentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeEquipmentLogs
    **/
    _count?: true | EmployeeEquipmentLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeEquipmentLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeEquipmentLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeEquipmentLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeEquipmentLogMaxAggregateInputType
  }

  export type GetEmployeeEquipmentLogAggregateType<T extends EmployeeEquipmentLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeEquipmentLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeEquipmentLog[P]>
      : GetScalarType<T[P], AggregateEmployeeEquipmentLog[P]>
  }




  export type EmployeeEquipmentLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeEquipmentLogWhereInput
    orderBy?: EmployeeEquipmentLogOrderByWithAggregationInput | EmployeeEquipmentLogOrderByWithAggregationInput[]
    by: EmployeeEquipmentLogScalarFieldEnum[] | EmployeeEquipmentLogScalarFieldEnum
    having?: EmployeeEquipmentLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeEquipmentLogCountAggregateInputType | true
    _avg?: EmployeeEquipmentLogAvgAggregateInputType
    _sum?: EmployeeEquipmentLogSumAggregateInputType
    _min?: EmployeeEquipmentLogMinAggregateInputType
    _max?: EmployeeEquipmentLogMaxAggregateInputType
  }

  export type EmployeeEquipmentLogGroupByOutputType = {
    id: string
    equipmentId: string | null
    maintenanceId: string | null
    startTime: Date
    endTime: Date | null
    comment: string | null
    timeSheetId: number
    rental: boolean
    _count: EmployeeEquipmentLogCountAggregateOutputType | null
    _avg: EmployeeEquipmentLogAvgAggregateOutputType | null
    _sum: EmployeeEquipmentLogSumAggregateOutputType | null
    _min: EmployeeEquipmentLogMinAggregateOutputType | null
    _max: EmployeeEquipmentLogMaxAggregateOutputType | null
  }

  type GetEmployeeEquipmentLogGroupByPayload<T extends EmployeeEquipmentLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeEquipmentLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeEquipmentLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeEquipmentLogGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeEquipmentLogGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeEquipmentLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    maintenanceId?: boolean
    startTime?: boolean
    endTime?: boolean
    comment?: boolean
    timeSheetId?: boolean
    rental?: boolean
    Equipment?: boolean | EmployeeEquipmentLog$EquipmentArgs<ExtArgs>
    Maintenance?: boolean | EmployeeEquipmentLog$MaintenanceArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
    RefuelLog?: boolean | EmployeeEquipmentLog$RefuelLogArgs<ExtArgs>
  }, ExtArgs["result"]["employeeEquipmentLog"]>

  export type EmployeeEquipmentLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    maintenanceId?: boolean
    startTime?: boolean
    endTime?: boolean
    comment?: boolean
    timeSheetId?: boolean
    rental?: boolean
    Equipment?: boolean | EmployeeEquipmentLog$EquipmentArgs<ExtArgs>
    Maintenance?: boolean | EmployeeEquipmentLog$MaintenanceArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeEquipmentLog"]>

  export type EmployeeEquipmentLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    maintenanceId?: boolean
    startTime?: boolean
    endTime?: boolean
    comment?: boolean
    timeSheetId?: boolean
    rental?: boolean
    Equipment?: boolean | EmployeeEquipmentLog$EquipmentArgs<ExtArgs>
    Maintenance?: boolean | EmployeeEquipmentLog$MaintenanceArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeEquipmentLog"]>

  export type EmployeeEquipmentLogSelectScalar = {
    id?: boolean
    equipmentId?: boolean
    maintenanceId?: boolean
    startTime?: boolean
    endTime?: boolean
    comment?: boolean
    timeSheetId?: boolean
    rental?: boolean
  }

  export type EmployeeEquipmentLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "equipmentId" | "maintenanceId" | "startTime" | "endTime" | "comment" | "timeSheetId" | "rental", ExtArgs["result"]["employeeEquipmentLog"]>
  export type EmployeeEquipmentLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EmployeeEquipmentLog$EquipmentArgs<ExtArgs>
    Maintenance?: boolean | EmployeeEquipmentLog$MaintenanceArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
    RefuelLog?: boolean | EmployeeEquipmentLog$RefuelLogArgs<ExtArgs>
  }
  export type EmployeeEquipmentLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EmployeeEquipmentLog$EquipmentArgs<ExtArgs>
    Maintenance?: boolean | EmployeeEquipmentLog$MaintenanceArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }
  export type EmployeeEquipmentLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EmployeeEquipmentLog$EquipmentArgs<ExtArgs>
    Maintenance?: boolean | EmployeeEquipmentLog$MaintenanceArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }

  export type $EmployeeEquipmentLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeEquipmentLog"
    objects: {
      Equipment: Prisma.$EquipmentPayload<ExtArgs> | null
      Maintenance: Prisma.$MaintenancePayload<ExtArgs> | null
      TimeSheet: Prisma.$TimeSheetPayload<ExtArgs>
      RefuelLog: Prisma.$RefuelLogPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      equipmentId: string | null
      maintenanceId: string | null
      startTime: Date
      endTime: Date | null
      comment: string | null
      timeSheetId: number
      rental: boolean
    }, ExtArgs["result"]["employeeEquipmentLog"]>
    composites: {}
  }

  type EmployeeEquipmentLogGetPayload<S extends boolean | null | undefined | EmployeeEquipmentLogDefaultArgs> = $Result.GetResult<Prisma.$EmployeeEquipmentLogPayload, S>

  type EmployeeEquipmentLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeEquipmentLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeEquipmentLogCountAggregateInputType | true
    }

  export interface EmployeeEquipmentLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeEquipmentLog'], meta: { name: 'EmployeeEquipmentLog' } }
    /**
     * Find zero or one EmployeeEquipmentLog that matches the filter.
     * @param {EmployeeEquipmentLogFindUniqueArgs} args - Arguments to find a EmployeeEquipmentLog
     * @example
     * // Get one EmployeeEquipmentLog
     * const employeeEquipmentLog = await prisma.employeeEquipmentLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeEquipmentLogFindUniqueArgs>(args: SelectSubset<T, EmployeeEquipmentLogFindUniqueArgs<ExtArgs>>): Prisma__EmployeeEquipmentLogClient<$Result.GetResult<Prisma.$EmployeeEquipmentLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeEquipmentLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeEquipmentLogFindUniqueOrThrowArgs} args - Arguments to find a EmployeeEquipmentLog
     * @example
     * // Get one EmployeeEquipmentLog
     * const employeeEquipmentLog = await prisma.employeeEquipmentLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeEquipmentLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeEquipmentLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeEquipmentLogClient<$Result.GetResult<Prisma.$EmployeeEquipmentLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeEquipmentLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeEquipmentLogFindFirstArgs} args - Arguments to find a EmployeeEquipmentLog
     * @example
     * // Get one EmployeeEquipmentLog
     * const employeeEquipmentLog = await prisma.employeeEquipmentLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeEquipmentLogFindFirstArgs>(args?: SelectSubset<T, EmployeeEquipmentLogFindFirstArgs<ExtArgs>>): Prisma__EmployeeEquipmentLogClient<$Result.GetResult<Prisma.$EmployeeEquipmentLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeEquipmentLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeEquipmentLogFindFirstOrThrowArgs} args - Arguments to find a EmployeeEquipmentLog
     * @example
     * // Get one EmployeeEquipmentLog
     * const employeeEquipmentLog = await prisma.employeeEquipmentLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeEquipmentLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeEquipmentLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeEquipmentLogClient<$Result.GetResult<Prisma.$EmployeeEquipmentLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeEquipmentLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeEquipmentLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeEquipmentLogs
     * const employeeEquipmentLogs = await prisma.employeeEquipmentLog.findMany()
     * 
     * // Get first 10 EmployeeEquipmentLogs
     * const employeeEquipmentLogs = await prisma.employeeEquipmentLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeEquipmentLogWithIdOnly = await prisma.employeeEquipmentLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeEquipmentLogFindManyArgs>(args?: SelectSubset<T, EmployeeEquipmentLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeEquipmentLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeEquipmentLog.
     * @param {EmployeeEquipmentLogCreateArgs} args - Arguments to create a EmployeeEquipmentLog.
     * @example
     * // Create one EmployeeEquipmentLog
     * const EmployeeEquipmentLog = await prisma.employeeEquipmentLog.create({
     *   data: {
     *     // ... data to create a EmployeeEquipmentLog
     *   }
     * })
     * 
     */
    create<T extends EmployeeEquipmentLogCreateArgs>(args: SelectSubset<T, EmployeeEquipmentLogCreateArgs<ExtArgs>>): Prisma__EmployeeEquipmentLogClient<$Result.GetResult<Prisma.$EmployeeEquipmentLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeEquipmentLogs.
     * @param {EmployeeEquipmentLogCreateManyArgs} args - Arguments to create many EmployeeEquipmentLogs.
     * @example
     * // Create many EmployeeEquipmentLogs
     * const employeeEquipmentLog = await prisma.employeeEquipmentLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeEquipmentLogCreateManyArgs>(args?: SelectSubset<T, EmployeeEquipmentLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeEquipmentLogs and returns the data saved in the database.
     * @param {EmployeeEquipmentLogCreateManyAndReturnArgs} args - Arguments to create many EmployeeEquipmentLogs.
     * @example
     * // Create many EmployeeEquipmentLogs
     * const employeeEquipmentLog = await prisma.employeeEquipmentLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeEquipmentLogs and only return the `id`
     * const employeeEquipmentLogWithIdOnly = await prisma.employeeEquipmentLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeEquipmentLogCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeEquipmentLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeEquipmentLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeEquipmentLog.
     * @param {EmployeeEquipmentLogDeleteArgs} args - Arguments to delete one EmployeeEquipmentLog.
     * @example
     * // Delete one EmployeeEquipmentLog
     * const EmployeeEquipmentLog = await prisma.employeeEquipmentLog.delete({
     *   where: {
     *     // ... filter to delete one EmployeeEquipmentLog
     *   }
     * })
     * 
     */
    delete<T extends EmployeeEquipmentLogDeleteArgs>(args: SelectSubset<T, EmployeeEquipmentLogDeleteArgs<ExtArgs>>): Prisma__EmployeeEquipmentLogClient<$Result.GetResult<Prisma.$EmployeeEquipmentLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeEquipmentLog.
     * @param {EmployeeEquipmentLogUpdateArgs} args - Arguments to update one EmployeeEquipmentLog.
     * @example
     * // Update one EmployeeEquipmentLog
     * const employeeEquipmentLog = await prisma.employeeEquipmentLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeEquipmentLogUpdateArgs>(args: SelectSubset<T, EmployeeEquipmentLogUpdateArgs<ExtArgs>>): Prisma__EmployeeEquipmentLogClient<$Result.GetResult<Prisma.$EmployeeEquipmentLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeEquipmentLogs.
     * @param {EmployeeEquipmentLogDeleteManyArgs} args - Arguments to filter EmployeeEquipmentLogs to delete.
     * @example
     * // Delete a few EmployeeEquipmentLogs
     * const { count } = await prisma.employeeEquipmentLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeEquipmentLogDeleteManyArgs>(args?: SelectSubset<T, EmployeeEquipmentLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeEquipmentLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeEquipmentLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeEquipmentLogs
     * const employeeEquipmentLog = await prisma.employeeEquipmentLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeEquipmentLogUpdateManyArgs>(args: SelectSubset<T, EmployeeEquipmentLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeEquipmentLogs and returns the data updated in the database.
     * @param {EmployeeEquipmentLogUpdateManyAndReturnArgs} args - Arguments to update many EmployeeEquipmentLogs.
     * @example
     * // Update many EmployeeEquipmentLogs
     * const employeeEquipmentLog = await prisma.employeeEquipmentLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeEquipmentLogs and only return the `id`
     * const employeeEquipmentLogWithIdOnly = await prisma.employeeEquipmentLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeEquipmentLogUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeEquipmentLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeEquipmentLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeEquipmentLog.
     * @param {EmployeeEquipmentLogUpsertArgs} args - Arguments to update or create a EmployeeEquipmentLog.
     * @example
     * // Update or create a EmployeeEquipmentLog
     * const employeeEquipmentLog = await prisma.employeeEquipmentLog.upsert({
     *   create: {
     *     // ... data to create a EmployeeEquipmentLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeEquipmentLog we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeEquipmentLogUpsertArgs>(args: SelectSubset<T, EmployeeEquipmentLogUpsertArgs<ExtArgs>>): Prisma__EmployeeEquipmentLogClient<$Result.GetResult<Prisma.$EmployeeEquipmentLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeEquipmentLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeEquipmentLogCountArgs} args - Arguments to filter EmployeeEquipmentLogs to count.
     * @example
     * // Count the number of EmployeeEquipmentLogs
     * const count = await prisma.employeeEquipmentLog.count({
     *   where: {
     *     // ... the filter for the EmployeeEquipmentLogs we want to count
     *   }
     * })
    **/
    count<T extends EmployeeEquipmentLogCountArgs>(
      args?: Subset<T, EmployeeEquipmentLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeEquipmentLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeEquipmentLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeEquipmentLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeEquipmentLogAggregateArgs>(args: Subset<T, EmployeeEquipmentLogAggregateArgs>): Prisma.PrismaPromise<GetEmployeeEquipmentLogAggregateType<T>>

    /**
     * Group by EmployeeEquipmentLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeEquipmentLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeEquipmentLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeEquipmentLogGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeEquipmentLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeEquipmentLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeEquipmentLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeEquipmentLog model
   */
  readonly fields: EmployeeEquipmentLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeEquipmentLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeEquipmentLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Equipment<T extends EmployeeEquipmentLog$EquipmentArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeEquipmentLog$EquipmentArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Maintenance<T extends EmployeeEquipmentLog$MaintenanceArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeEquipmentLog$MaintenanceArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    TimeSheet<T extends TimeSheetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TimeSheetDefaultArgs<ExtArgs>>): Prisma__TimeSheetClient<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    RefuelLog<T extends EmployeeEquipmentLog$RefuelLogArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeEquipmentLog$RefuelLogArgs<ExtArgs>>): Prisma__RefuelLogClient<$Result.GetResult<Prisma.$RefuelLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeEquipmentLog model
   */
  interface EmployeeEquipmentLogFieldRefs {
    readonly id: FieldRef<"EmployeeEquipmentLog", 'String'>
    readonly equipmentId: FieldRef<"EmployeeEquipmentLog", 'String'>
    readonly maintenanceId: FieldRef<"EmployeeEquipmentLog", 'String'>
    readonly startTime: FieldRef<"EmployeeEquipmentLog", 'DateTime'>
    readonly endTime: FieldRef<"EmployeeEquipmentLog", 'DateTime'>
    readonly comment: FieldRef<"EmployeeEquipmentLog", 'String'>
    readonly timeSheetId: FieldRef<"EmployeeEquipmentLog", 'Int'>
    readonly rental: FieldRef<"EmployeeEquipmentLog", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeEquipmentLog findUnique
   */
  export type EmployeeEquipmentLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeEquipmentLog
     */
    select?: EmployeeEquipmentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeEquipmentLog
     */
    omit?: EmployeeEquipmentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeEquipmentLogInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeEquipmentLog to fetch.
     */
    where: EmployeeEquipmentLogWhereUniqueInput
  }

  /**
   * EmployeeEquipmentLog findUniqueOrThrow
   */
  export type EmployeeEquipmentLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeEquipmentLog
     */
    select?: EmployeeEquipmentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeEquipmentLog
     */
    omit?: EmployeeEquipmentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeEquipmentLogInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeEquipmentLog to fetch.
     */
    where: EmployeeEquipmentLogWhereUniqueInput
  }

  /**
   * EmployeeEquipmentLog findFirst
   */
  export type EmployeeEquipmentLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeEquipmentLog
     */
    select?: EmployeeEquipmentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeEquipmentLog
     */
    omit?: EmployeeEquipmentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeEquipmentLogInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeEquipmentLog to fetch.
     */
    where?: EmployeeEquipmentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeEquipmentLogs to fetch.
     */
    orderBy?: EmployeeEquipmentLogOrderByWithRelationInput | EmployeeEquipmentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeEquipmentLogs.
     */
    cursor?: EmployeeEquipmentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeEquipmentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeEquipmentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeEquipmentLogs.
     */
    distinct?: EmployeeEquipmentLogScalarFieldEnum | EmployeeEquipmentLogScalarFieldEnum[]
  }

  /**
   * EmployeeEquipmentLog findFirstOrThrow
   */
  export type EmployeeEquipmentLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeEquipmentLog
     */
    select?: EmployeeEquipmentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeEquipmentLog
     */
    omit?: EmployeeEquipmentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeEquipmentLogInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeEquipmentLog to fetch.
     */
    where?: EmployeeEquipmentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeEquipmentLogs to fetch.
     */
    orderBy?: EmployeeEquipmentLogOrderByWithRelationInput | EmployeeEquipmentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeEquipmentLogs.
     */
    cursor?: EmployeeEquipmentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeEquipmentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeEquipmentLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeEquipmentLogs.
     */
    distinct?: EmployeeEquipmentLogScalarFieldEnum | EmployeeEquipmentLogScalarFieldEnum[]
  }

  /**
   * EmployeeEquipmentLog findMany
   */
  export type EmployeeEquipmentLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeEquipmentLog
     */
    select?: EmployeeEquipmentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeEquipmentLog
     */
    omit?: EmployeeEquipmentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeEquipmentLogInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeEquipmentLogs to fetch.
     */
    where?: EmployeeEquipmentLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeEquipmentLogs to fetch.
     */
    orderBy?: EmployeeEquipmentLogOrderByWithRelationInput | EmployeeEquipmentLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeEquipmentLogs.
     */
    cursor?: EmployeeEquipmentLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeEquipmentLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeEquipmentLogs.
     */
    skip?: number
    distinct?: EmployeeEquipmentLogScalarFieldEnum | EmployeeEquipmentLogScalarFieldEnum[]
  }

  /**
   * EmployeeEquipmentLog create
   */
  export type EmployeeEquipmentLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeEquipmentLog
     */
    select?: EmployeeEquipmentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeEquipmentLog
     */
    omit?: EmployeeEquipmentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeEquipmentLogInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeEquipmentLog.
     */
    data: XOR<EmployeeEquipmentLogCreateInput, EmployeeEquipmentLogUncheckedCreateInput>
  }

  /**
   * EmployeeEquipmentLog createMany
   */
  export type EmployeeEquipmentLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeEquipmentLogs.
     */
    data: EmployeeEquipmentLogCreateManyInput | EmployeeEquipmentLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeEquipmentLog createManyAndReturn
   */
  export type EmployeeEquipmentLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeEquipmentLog
     */
    select?: EmployeeEquipmentLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeEquipmentLog
     */
    omit?: EmployeeEquipmentLogOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeEquipmentLogs.
     */
    data: EmployeeEquipmentLogCreateManyInput | EmployeeEquipmentLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeEquipmentLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeEquipmentLog update
   */
  export type EmployeeEquipmentLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeEquipmentLog
     */
    select?: EmployeeEquipmentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeEquipmentLog
     */
    omit?: EmployeeEquipmentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeEquipmentLogInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeEquipmentLog.
     */
    data: XOR<EmployeeEquipmentLogUpdateInput, EmployeeEquipmentLogUncheckedUpdateInput>
    /**
     * Choose, which EmployeeEquipmentLog to update.
     */
    where: EmployeeEquipmentLogWhereUniqueInput
  }

  /**
   * EmployeeEquipmentLog updateMany
   */
  export type EmployeeEquipmentLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeEquipmentLogs.
     */
    data: XOR<EmployeeEquipmentLogUpdateManyMutationInput, EmployeeEquipmentLogUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeEquipmentLogs to update
     */
    where?: EmployeeEquipmentLogWhereInput
    /**
     * Limit how many EmployeeEquipmentLogs to update.
     */
    limit?: number
  }

  /**
   * EmployeeEquipmentLog updateManyAndReturn
   */
  export type EmployeeEquipmentLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeEquipmentLog
     */
    select?: EmployeeEquipmentLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeEquipmentLog
     */
    omit?: EmployeeEquipmentLogOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeEquipmentLogs.
     */
    data: XOR<EmployeeEquipmentLogUpdateManyMutationInput, EmployeeEquipmentLogUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeEquipmentLogs to update
     */
    where?: EmployeeEquipmentLogWhereInput
    /**
     * Limit how many EmployeeEquipmentLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeEquipmentLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeEquipmentLog upsert
   */
  export type EmployeeEquipmentLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeEquipmentLog
     */
    select?: EmployeeEquipmentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeEquipmentLog
     */
    omit?: EmployeeEquipmentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeEquipmentLogInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeEquipmentLog to update in case it exists.
     */
    where: EmployeeEquipmentLogWhereUniqueInput
    /**
     * In case the EmployeeEquipmentLog found by the `where` argument doesn't exist, create a new EmployeeEquipmentLog with this data.
     */
    create: XOR<EmployeeEquipmentLogCreateInput, EmployeeEquipmentLogUncheckedCreateInput>
    /**
     * In case the EmployeeEquipmentLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeEquipmentLogUpdateInput, EmployeeEquipmentLogUncheckedUpdateInput>
  }

  /**
   * EmployeeEquipmentLog delete
   */
  export type EmployeeEquipmentLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeEquipmentLog
     */
    select?: EmployeeEquipmentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeEquipmentLog
     */
    omit?: EmployeeEquipmentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeEquipmentLogInclude<ExtArgs> | null
    /**
     * Filter which EmployeeEquipmentLog to delete.
     */
    where: EmployeeEquipmentLogWhereUniqueInput
  }

  /**
   * EmployeeEquipmentLog deleteMany
   */
  export type EmployeeEquipmentLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeEquipmentLogs to delete
     */
    where?: EmployeeEquipmentLogWhereInput
    /**
     * Limit how many EmployeeEquipmentLogs to delete.
     */
    limit?: number
  }

  /**
   * EmployeeEquipmentLog.Equipment
   */
  export type EmployeeEquipmentLog$EquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
  }

  /**
   * EmployeeEquipmentLog.Maintenance
   */
  export type EmployeeEquipmentLog$MaintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    where?: MaintenanceWhereInput
  }

  /**
   * EmployeeEquipmentLog.RefuelLog
   */
  export type EmployeeEquipmentLog$RefuelLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefuelLog
     */
    select?: RefuelLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefuelLog
     */
    omit?: RefuelLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefuelLogInclude<ExtArgs> | null
    where?: RefuelLogWhereInput
  }

  /**
   * EmployeeEquipmentLog without action
   */
  export type EmployeeEquipmentLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeEquipmentLog
     */
    select?: EmployeeEquipmentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeEquipmentLog
     */
    omit?: EmployeeEquipmentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeEquipmentLogInclude<ExtArgs> | null
  }


  /**
   * Model FormTemplate
   */

  export type AggregateFormTemplate = {
    _count: FormTemplateCountAggregateOutputType | null
    _min: FormTemplateMinAggregateOutputType | null
    _max: FormTemplateMaxAggregateOutputType | null
  }

  export type FormTemplateMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isSignatureRequired: boolean | null
    description: string | null
    isActive: $Enums.FormTemplateStatus | null
    formType: $Enums.FormTemplateCategory | null
    isApprovalRequired: boolean | null
  }

  export type FormTemplateMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isSignatureRequired: boolean | null
    description: string | null
    isActive: $Enums.FormTemplateStatus | null
    formType: $Enums.FormTemplateCategory | null
    isApprovalRequired: boolean | null
  }

  export type FormTemplateCountAggregateOutputType = {
    id: number
    companyId: number
    name: number
    createdAt: number
    updatedAt: number
    isSignatureRequired: number
    description: number
    isActive: number
    formType: number
    isApprovalRequired: number
    _all: number
  }


  export type FormTemplateMinAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    isSignatureRequired?: true
    description?: true
    isActive?: true
    formType?: true
    isApprovalRequired?: true
  }

  export type FormTemplateMaxAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    isSignatureRequired?: true
    description?: true
    isActive?: true
    formType?: true
    isApprovalRequired?: true
  }

  export type FormTemplateCountAggregateInputType = {
    id?: true
    companyId?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    isSignatureRequired?: true
    description?: true
    isActive?: true
    formType?: true
    isApprovalRequired?: true
    _all?: true
  }

  export type FormTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormTemplate to aggregate.
     */
    where?: FormTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormTemplates to fetch.
     */
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormTemplates
    **/
    _count?: true | FormTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormTemplateMaxAggregateInputType
  }

  export type GetFormTemplateAggregateType<T extends FormTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateFormTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormTemplate[P]>
      : GetScalarType<T[P], AggregateFormTemplate[P]>
  }




  export type FormTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormTemplateWhereInput
    orderBy?: FormTemplateOrderByWithAggregationInput | FormTemplateOrderByWithAggregationInput[]
    by: FormTemplateScalarFieldEnum[] | FormTemplateScalarFieldEnum
    having?: FormTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormTemplateCountAggregateInputType | true
    _min?: FormTemplateMinAggregateInputType
    _max?: FormTemplateMaxAggregateInputType
  }

  export type FormTemplateGroupByOutputType = {
    id: string
    companyId: string
    name: string
    createdAt: Date
    updatedAt: Date
    isSignatureRequired: boolean
    description: string | null
    isActive: $Enums.FormTemplateStatus
    formType: $Enums.FormTemplateCategory
    isApprovalRequired: boolean
    _count: FormTemplateCountAggregateOutputType | null
    _min: FormTemplateMinAggregateOutputType | null
    _max: FormTemplateMaxAggregateOutputType | null
  }

  type GetFormTemplateGroupByPayload<T extends FormTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], FormTemplateGroupByOutputType[P]>
        }
      >
    >


  export type FormTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isSignatureRequired?: boolean
    description?: boolean
    isActive?: boolean
    formType?: boolean
    isApprovalRequired?: boolean
    Submissions?: boolean | FormTemplate$SubmissionsArgs<ExtArgs>
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
    FormGrouping?: boolean | FormTemplate$FormGroupingArgs<ExtArgs>
    _count?: boolean | FormTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formTemplate"]>

  export type FormTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isSignatureRequired?: boolean
    description?: boolean
    isActive?: boolean
    formType?: boolean
    isApprovalRequired?: boolean
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formTemplate"]>

  export type FormTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isSignatureRequired?: boolean
    description?: boolean
    isActive?: boolean
    formType?: boolean
    isApprovalRequired?: boolean
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formTemplate"]>

  export type FormTemplateSelectScalar = {
    id?: boolean
    companyId?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isSignatureRequired?: boolean
    description?: boolean
    isActive?: boolean
    formType?: boolean
    isApprovalRequired?: boolean
  }

  export type FormTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "name" | "createdAt" | "updatedAt" | "isSignatureRequired" | "description" | "isActive" | "formType" | "isApprovalRequired", ExtArgs["result"]["formTemplate"]>
  export type FormTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Submissions?: boolean | FormTemplate$SubmissionsArgs<ExtArgs>
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
    FormGrouping?: boolean | FormTemplate$FormGroupingArgs<ExtArgs>
    _count?: boolean | FormTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FormTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type FormTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $FormTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormTemplate"
    objects: {
      Submissions: Prisma.$FormSubmissionPayload<ExtArgs>[]
      Company: Prisma.$CompanyPayload<ExtArgs>
      FormGrouping: Prisma.$FormGroupingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      name: string
      createdAt: Date
      updatedAt: Date
      isSignatureRequired: boolean
      description: string | null
      isActive: $Enums.FormTemplateStatus
      formType: $Enums.FormTemplateCategory
      isApprovalRequired: boolean
    }, ExtArgs["result"]["formTemplate"]>
    composites: {}
  }

  type FormTemplateGetPayload<S extends boolean | null | undefined | FormTemplateDefaultArgs> = $Result.GetResult<Prisma.$FormTemplatePayload, S>

  type FormTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormTemplateCountAggregateInputType | true
    }

  export interface FormTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormTemplate'], meta: { name: 'FormTemplate' } }
    /**
     * Find zero or one FormTemplate that matches the filter.
     * @param {FormTemplateFindUniqueArgs} args - Arguments to find a FormTemplate
     * @example
     * // Get one FormTemplate
     * const formTemplate = await prisma.formTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormTemplateFindUniqueArgs>(args: SelectSubset<T, FormTemplateFindUniqueArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormTemplateFindUniqueOrThrowArgs} args - Arguments to find a FormTemplate
     * @example
     * // Get one FormTemplate
     * const formTemplate = await prisma.formTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, FormTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateFindFirstArgs} args - Arguments to find a FormTemplate
     * @example
     * // Get one FormTemplate
     * const formTemplate = await prisma.formTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormTemplateFindFirstArgs>(args?: SelectSubset<T, FormTemplateFindFirstArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateFindFirstOrThrowArgs} args - Arguments to find a FormTemplate
     * @example
     * // Get one FormTemplate
     * const formTemplate = await prisma.formTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, FormTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormTemplates
     * const formTemplates = await prisma.formTemplate.findMany()
     * 
     * // Get first 10 FormTemplates
     * const formTemplates = await prisma.formTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formTemplateWithIdOnly = await prisma.formTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormTemplateFindManyArgs>(args?: SelectSubset<T, FormTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormTemplate.
     * @param {FormTemplateCreateArgs} args - Arguments to create a FormTemplate.
     * @example
     * // Create one FormTemplate
     * const FormTemplate = await prisma.formTemplate.create({
     *   data: {
     *     // ... data to create a FormTemplate
     *   }
     * })
     * 
     */
    create<T extends FormTemplateCreateArgs>(args: SelectSubset<T, FormTemplateCreateArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormTemplates.
     * @param {FormTemplateCreateManyArgs} args - Arguments to create many FormTemplates.
     * @example
     * // Create many FormTemplates
     * const formTemplate = await prisma.formTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormTemplateCreateManyArgs>(args?: SelectSubset<T, FormTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormTemplates and returns the data saved in the database.
     * @param {FormTemplateCreateManyAndReturnArgs} args - Arguments to create many FormTemplates.
     * @example
     * // Create many FormTemplates
     * const formTemplate = await prisma.formTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormTemplates and only return the `id`
     * const formTemplateWithIdOnly = await prisma.formTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, FormTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormTemplate.
     * @param {FormTemplateDeleteArgs} args - Arguments to delete one FormTemplate.
     * @example
     * // Delete one FormTemplate
     * const FormTemplate = await prisma.formTemplate.delete({
     *   where: {
     *     // ... filter to delete one FormTemplate
     *   }
     * })
     * 
     */
    delete<T extends FormTemplateDeleteArgs>(args: SelectSubset<T, FormTemplateDeleteArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormTemplate.
     * @param {FormTemplateUpdateArgs} args - Arguments to update one FormTemplate.
     * @example
     * // Update one FormTemplate
     * const formTemplate = await prisma.formTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormTemplateUpdateArgs>(args: SelectSubset<T, FormTemplateUpdateArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormTemplates.
     * @param {FormTemplateDeleteManyArgs} args - Arguments to filter FormTemplates to delete.
     * @example
     * // Delete a few FormTemplates
     * const { count } = await prisma.formTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormTemplateDeleteManyArgs>(args?: SelectSubset<T, FormTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormTemplates
     * const formTemplate = await prisma.formTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormTemplateUpdateManyArgs>(args: SelectSubset<T, FormTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormTemplates and returns the data updated in the database.
     * @param {FormTemplateUpdateManyAndReturnArgs} args - Arguments to update many FormTemplates.
     * @example
     * // Update many FormTemplates
     * const formTemplate = await prisma.formTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormTemplates and only return the `id`
     * const formTemplateWithIdOnly = await prisma.formTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, FormTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormTemplate.
     * @param {FormTemplateUpsertArgs} args - Arguments to update or create a FormTemplate.
     * @example
     * // Update or create a FormTemplate
     * const formTemplate = await prisma.formTemplate.upsert({
     *   create: {
     *     // ... data to create a FormTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormTemplate we want to update
     *   }
     * })
     */
    upsert<T extends FormTemplateUpsertArgs>(args: SelectSubset<T, FormTemplateUpsertArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateCountArgs} args - Arguments to filter FormTemplates to count.
     * @example
     * // Count the number of FormTemplates
     * const count = await prisma.formTemplate.count({
     *   where: {
     *     // ... the filter for the FormTemplates we want to count
     *   }
     * })
    **/
    count<T extends FormTemplateCountArgs>(
      args?: Subset<T, FormTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormTemplateAggregateArgs>(args: Subset<T, FormTemplateAggregateArgs>): Prisma.PrismaPromise<GetFormTemplateAggregateType<T>>

    /**
     * Group by FormTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormTemplateGroupByArgs['orderBy'] }
        : { orderBy?: FormTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormTemplate model
   */
  readonly fields: FormTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Submissions<T extends FormTemplate$SubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, FormTemplate$SubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    FormGrouping<T extends FormTemplate$FormGroupingArgs<ExtArgs> = {}>(args?: Subset<T, FormTemplate$FormGroupingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormGroupingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormTemplate model
   */
  interface FormTemplateFieldRefs {
    readonly id: FieldRef<"FormTemplate", 'String'>
    readonly companyId: FieldRef<"FormTemplate", 'String'>
    readonly name: FieldRef<"FormTemplate", 'String'>
    readonly createdAt: FieldRef<"FormTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"FormTemplate", 'DateTime'>
    readonly isSignatureRequired: FieldRef<"FormTemplate", 'Boolean'>
    readonly description: FieldRef<"FormTemplate", 'String'>
    readonly isActive: FieldRef<"FormTemplate", 'FormTemplateStatus'>
    readonly formType: FieldRef<"FormTemplate", 'FormTemplateCategory'>
    readonly isApprovalRequired: FieldRef<"FormTemplate", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * FormTemplate findUnique
   */
  export type FormTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormTemplate
     */
    omit?: FormTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FormTemplate to fetch.
     */
    where: FormTemplateWhereUniqueInput
  }

  /**
   * FormTemplate findUniqueOrThrow
   */
  export type FormTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormTemplate
     */
    omit?: FormTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FormTemplate to fetch.
     */
    where: FormTemplateWhereUniqueInput
  }

  /**
   * FormTemplate findFirst
   */
  export type FormTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormTemplate
     */
    omit?: FormTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FormTemplate to fetch.
     */
    where?: FormTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormTemplates to fetch.
     */
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormTemplates.
     */
    cursor?: FormTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormTemplates.
     */
    distinct?: FormTemplateScalarFieldEnum | FormTemplateScalarFieldEnum[]
  }

  /**
   * FormTemplate findFirstOrThrow
   */
  export type FormTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormTemplate
     */
    omit?: FormTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FormTemplate to fetch.
     */
    where?: FormTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormTemplates to fetch.
     */
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormTemplates.
     */
    cursor?: FormTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormTemplates.
     */
    distinct?: FormTemplateScalarFieldEnum | FormTemplateScalarFieldEnum[]
  }

  /**
   * FormTemplate findMany
   */
  export type FormTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormTemplate
     */
    omit?: FormTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * Filter, which FormTemplates to fetch.
     */
    where?: FormTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormTemplates to fetch.
     */
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormTemplates.
     */
    cursor?: FormTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormTemplates.
     */
    skip?: number
    distinct?: FormTemplateScalarFieldEnum | FormTemplateScalarFieldEnum[]
  }

  /**
   * FormTemplate create
   */
  export type FormTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormTemplate
     */
    omit?: FormTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a FormTemplate.
     */
    data: XOR<FormTemplateCreateInput, FormTemplateUncheckedCreateInput>
  }

  /**
   * FormTemplate createMany
   */
  export type FormTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormTemplates.
     */
    data: FormTemplateCreateManyInput | FormTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormTemplate createManyAndReturn
   */
  export type FormTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormTemplate
     */
    omit?: FormTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many FormTemplates.
     */
    data: FormTemplateCreateManyInput | FormTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormTemplate update
   */
  export type FormTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormTemplate
     */
    omit?: FormTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a FormTemplate.
     */
    data: XOR<FormTemplateUpdateInput, FormTemplateUncheckedUpdateInput>
    /**
     * Choose, which FormTemplate to update.
     */
    where: FormTemplateWhereUniqueInput
  }

  /**
   * FormTemplate updateMany
   */
  export type FormTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormTemplates.
     */
    data: XOR<FormTemplateUpdateManyMutationInput, FormTemplateUncheckedUpdateManyInput>
    /**
     * Filter which FormTemplates to update
     */
    where?: FormTemplateWhereInput
    /**
     * Limit how many FormTemplates to update.
     */
    limit?: number
  }

  /**
   * FormTemplate updateManyAndReturn
   */
  export type FormTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormTemplate
     */
    omit?: FormTemplateOmit<ExtArgs> | null
    /**
     * The data used to update FormTemplates.
     */
    data: XOR<FormTemplateUpdateManyMutationInput, FormTemplateUncheckedUpdateManyInput>
    /**
     * Filter which FormTemplates to update
     */
    where?: FormTemplateWhereInput
    /**
     * Limit how many FormTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormTemplate upsert
   */
  export type FormTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormTemplate
     */
    omit?: FormTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the FormTemplate to update in case it exists.
     */
    where: FormTemplateWhereUniqueInput
    /**
     * In case the FormTemplate found by the `where` argument doesn't exist, create a new FormTemplate with this data.
     */
    create: XOR<FormTemplateCreateInput, FormTemplateUncheckedCreateInput>
    /**
     * In case the FormTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormTemplateUpdateInput, FormTemplateUncheckedUpdateInput>
  }

  /**
   * FormTemplate delete
   */
  export type FormTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormTemplate
     */
    omit?: FormTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    /**
     * Filter which FormTemplate to delete.
     */
    where: FormTemplateWhereUniqueInput
  }

  /**
   * FormTemplate deleteMany
   */
  export type FormTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormTemplates to delete
     */
    where?: FormTemplateWhereInput
    /**
     * Limit how many FormTemplates to delete.
     */
    limit?: number
  }

  /**
   * FormTemplate.Submissions
   */
  export type FormTemplate$SubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    cursor?: FormSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormTemplate.FormGrouping
   */
  export type FormTemplate$FormGroupingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormGrouping
     */
    select?: FormGroupingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormGrouping
     */
    omit?: FormGroupingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormGroupingInclude<ExtArgs> | null
    where?: FormGroupingWhereInput
    orderBy?: FormGroupingOrderByWithRelationInput | FormGroupingOrderByWithRelationInput[]
    cursor?: FormGroupingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormGroupingScalarFieldEnum | FormGroupingScalarFieldEnum[]
  }

  /**
   * FormTemplate without action
   */
  export type FormTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormTemplate
     */
    omit?: FormTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
  }


  /**
   * Model FormGrouping
   */

  export type AggregateFormGrouping = {
    _count: FormGroupingCountAggregateOutputType | null
    _avg: FormGroupingAvgAggregateOutputType | null
    _sum: FormGroupingSumAggregateOutputType | null
    _min: FormGroupingMinAggregateOutputType | null
    _max: FormGroupingMaxAggregateOutputType | null
  }

  export type FormGroupingAvgAggregateOutputType = {
    order: number | null
  }

  export type FormGroupingSumAggregateOutputType = {
    order: number | null
  }

  export type FormGroupingMinAggregateOutputType = {
    id: string | null
    title: string | null
    order: number | null
  }

  export type FormGroupingMaxAggregateOutputType = {
    id: string | null
    title: string | null
    order: number | null
  }

  export type FormGroupingCountAggregateOutputType = {
    id: number
    title: number
    order: number
    _all: number
  }


  export type FormGroupingAvgAggregateInputType = {
    order?: true
  }

  export type FormGroupingSumAggregateInputType = {
    order?: true
  }

  export type FormGroupingMinAggregateInputType = {
    id?: true
    title?: true
    order?: true
  }

  export type FormGroupingMaxAggregateInputType = {
    id?: true
    title?: true
    order?: true
  }

  export type FormGroupingCountAggregateInputType = {
    id?: true
    title?: true
    order?: true
    _all?: true
  }

  export type FormGroupingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormGrouping to aggregate.
     */
    where?: FormGroupingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormGroupings to fetch.
     */
    orderBy?: FormGroupingOrderByWithRelationInput | FormGroupingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormGroupingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormGroupings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormGroupings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormGroupings
    **/
    _count?: true | FormGroupingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormGroupingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormGroupingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormGroupingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormGroupingMaxAggregateInputType
  }

  export type GetFormGroupingAggregateType<T extends FormGroupingAggregateArgs> = {
        [P in keyof T & keyof AggregateFormGrouping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormGrouping[P]>
      : GetScalarType<T[P], AggregateFormGrouping[P]>
  }




  export type FormGroupingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormGroupingWhereInput
    orderBy?: FormGroupingOrderByWithAggregationInput | FormGroupingOrderByWithAggregationInput[]
    by: FormGroupingScalarFieldEnum[] | FormGroupingScalarFieldEnum
    having?: FormGroupingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormGroupingCountAggregateInputType | true
    _avg?: FormGroupingAvgAggregateInputType
    _sum?: FormGroupingSumAggregateInputType
    _min?: FormGroupingMinAggregateInputType
    _max?: FormGroupingMaxAggregateInputType
  }

  export type FormGroupingGroupByOutputType = {
    id: string
    title: string | null
    order: number
    _count: FormGroupingCountAggregateOutputType | null
    _avg: FormGroupingAvgAggregateOutputType | null
    _sum: FormGroupingSumAggregateOutputType | null
    _min: FormGroupingMinAggregateOutputType | null
    _max: FormGroupingMaxAggregateOutputType | null
  }

  type GetFormGroupingGroupByPayload<T extends FormGroupingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormGroupingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormGroupingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormGroupingGroupByOutputType[P]>
            : GetScalarType<T[P], FormGroupingGroupByOutputType[P]>
        }
      >
    >


  export type FormGroupingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    order?: boolean
    Fields?: boolean | FormGrouping$FieldsArgs<ExtArgs>
    FormTemplate?: boolean | FormGrouping$FormTemplateArgs<ExtArgs>
    _count?: boolean | FormGroupingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formGrouping"]>

  export type FormGroupingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    order?: boolean
  }, ExtArgs["result"]["formGrouping"]>

  export type FormGroupingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    order?: boolean
  }, ExtArgs["result"]["formGrouping"]>

  export type FormGroupingSelectScalar = {
    id?: boolean
    title?: boolean
    order?: boolean
  }

  export type FormGroupingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "order", ExtArgs["result"]["formGrouping"]>
  export type FormGroupingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Fields?: boolean | FormGrouping$FieldsArgs<ExtArgs>
    FormTemplate?: boolean | FormGrouping$FormTemplateArgs<ExtArgs>
    _count?: boolean | FormGroupingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FormGroupingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FormGroupingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FormGroupingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormGrouping"
    objects: {
      Fields: Prisma.$FormFieldPayload<ExtArgs>[]
      FormTemplate: Prisma.$FormTemplatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string | null
      order: number
    }, ExtArgs["result"]["formGrouping"]>
    composites: {}
  }

  type FormGroupingGetPayload<S extends boolean | null | undefined | FormGroupingDefaultArgs> = $Result.GetResult<Prisma.$FormGroupingPayload, S>

  type FormGroupingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormGroupingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormGroupingCountAggregateInputType | true
    }

  export interface FormGroupingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormGrouping'], meta: { name: 'FormGrouping' } }
    /**
     * Find zero or one FormGrouping that matches the filter.
     * @param {FormGroupingFindUniqueArgs} args - Arguments to find a FormGrouping
     * @example
     * // Get one FormGrouping
     * const formGrouping = await prisma.formGrouping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormGroupingFindUniqueArgs>(args: SelectSubset<T, FormGroupingFindUniqueArgs<ExtArgs>>): Prisma__FormGroupingClient<$Result.GetResult<Prisma.$FormGroupingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormGrouping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormGroupingFindUniqueOrThrowArgs} args - Arguments to find a FormGrouping
     * @example
     * // Get one FormGrouping
     * const formGrouping = await prisma.formGrouping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormGroupingFindUniqueOrThrowArgs>(args: SelectSubset<T, FormGroupingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormGroupingClient<$Result.GetResult<Prisma.$FormGroupingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormGrouping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormGroupingFindFirstArgs} args - Arguments to find a FormGrouping
     * @example
     * // Get one FormGrouping
     * const formGrouping = await prisma.formGrouping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormGroupingFindFirstArgs>(args?: SelectSubset<T, FormGroupingFindFirstArgs<ExtArgs>>): Prisma__FormGroupingClient<$Result.GetResult<Prisma.$FormGroupingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormGrouping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormGroupingFindFirstOrThrowArgs} args - Arguments to find a FormGrouping
     * @example
     * // Get one FormGrouping
     * const formGrouping = await prisma.formGrouping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormGroupingFindFirstOrThrowArgs>(args?: SelectSubset<T, FormGroupingFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormGroupingClient<$Result.GetResult<Prisma.$FormGroupingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormGroupings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormGroupingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormGroupings
     * const formGroupings = await prisma.formGrouping.findMany()
     * 
     * // Get first 10 FormGroupings
     * const formGroupings = await prisma.formGrouping.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formGroupingWithIdOnly = await prisma.formGrouping.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormGroupingFindManyArgs>(args?: SelectSubset<T, FormGroupingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormGroupingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormGrouping.
     * @param {FormGroupingCreateArgs} args - Arguments to create a FormGrouping.
     * @example
     * // Create one FormGrouping
     * const FormGrouping = await prisma.formGrouping.create({
     *   data: {
     *     // ... data to create a FormGrouping
     *   }
     * })
     * 
     */
    create<T extends FormGroupingCreateArgs>(args: SelectSubset<T, FormGroupingCreateArgs<ExtArgs>>): Prisma__FormGroupingClient<$Result.GetResult<Prisma.$FormGroupingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormGroupings.
     * @param {FormGroupingCreateManyArgs} args - Arguments to create many FormGroupings.
     * @example
     * // Create many FormGroupings
     * const formGrouping = await prisma.formGrouping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormGroupingCreateManyArgs>(args?: SelectSubset<T, FormGroupingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormGroupings and returns the data saved in the database.
     * @param {FormGroupingCreateManyAndReturnArgs} args - Arguments to create many FormGroupings.
     * @example
     * // Create many FormGroupings
     * const formGrouping = await prisma.formGrouping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormGroupings and only return the `id`
     * const formGroupingWithIdOnly = await prisma.formGrouping.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormGroupingCreateManyAndReturnArgs>(args?: SelectSubset<T, FormGroupingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormGroupingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormGrouping.
     * @param {FormGroupingDeleteArgs} args - Arguments to delete one FormGrouping.
     * @example
     * // Delete one FormGrouping
     * const FormGrouping = await prisma.formGrouping.delete({
     *   where: {
     *     // ... filter to delete one FormGrouping
     *   }
     * })
     * 
     */
    delete<T extends FormGroupingDeleteArgs>(args: SelectSubset<T, FormGroupingDeleteArgs<ExtArgs>>): Prisma__FormGroupingClient<$Result.GetResult<Prisma.$FormGroupingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormGrouping.
     * @param {FormGroupingUpdateArgs} args - Arguments to update one FormGrouping.
     * @example
     * // Update one FormGrouping
     * const formGrouping = await prisma.formGrouping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormGroupingUpdateArgs>(args: SelectSubset<T, FormGroupingUpdateArgs<ExtArgs>>): Prisma__FormGroupingClient<$Result.GetResult<Prisma.$FormGroupingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormGroupings.
     * @param {FormGroupingDeleteManyArgs} args - Arguments to filter FormGroupings to delete.
     * @example
     * // Delete a few FormGroupings
     * const { count } = await prisma.formGrouping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormGroupingDeleteManyArgs>(args?: SelectSubset<T, FormGroupingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormGroupings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormGroupingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormGroupings
     * const formGrouping = await prisma.formGrouping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormGroupingUpdateManyArgs>(args: SelectSubset<T, FormGroupingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormGroupings and returns the data updated in the database.
     * @param {FormGroupingUpdateManyAndReturnArgs} args - Arguments to update many FormGroupings.
     * @example
     * // Update many FormGroupings
     * const formGrouping = await prisma.formGrouping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormGroupings and only return the `id`
     * const formGroupingWithIdOnly = await prisma.formGrouping.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormGroupingUpdateManyAndReturnArgs>(args: SelectSubset<T, FormGroupingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormGroupingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormGrouping.
     * @param {FormGroupingUpsertArgs} args - Arguments to update or create a FormGrouping.
     * @example
     * // Update or create a FormGrouping
     * const formGrouping = await prisma.formGrouping.upsert({
     *   create: {
     *     // ... data to create a FormGrouping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormGrouping we want to update
     *   }
     * })
     */
    upsert<T extends FormGroupingUpsertArgs>(args: SelectSubset<T, FormGroupingUpsertArgs<ExtArgs>>): Prisma__FormGroupingClient<$Result.GetResult<Prisma.$FormGroupingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormGroupings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormGroupingCountArgs} args - Arguments to filter FormGroupings to count.
     * @example
     * // Count the number of FormGroupings
     * const count = await prisma.formGrouping.count({
     *   where: {
     *     // ... the filter for the FormGroupings we want to count
     *   }
     * })
    **/
    count<T extends FormGroupingCountArgs>(
      args?: Subset<T, FormGroupingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormGroupingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormGrouping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormGroupingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormGroupingAggregateArgs>(args: Subset<T, FormGroupingAggregateArgs>): Prisma.PrismaPromise<GetFormGroupingAggregateType<T>>

    /**
     * Group by FormGrouping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormGroupingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormGroupingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormGroupingGroupByArgs['orderBy'] }
        : { orderBy?: FormGroupingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormGroupingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormGroupingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormGrouping model
   */
  readonly fields: FormGroupingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormGrouping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormGroupingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Fields<T extends FormGrouping$FieldsArgs<ExtArgs> = {}>(args?: Subset<T, FormGrouping$FieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FormTemplate<T extends FormGrouping$FormTemplateArgs<ExtArgs> = {}>(args?: Subset<T, FormGrouping$FormTemplateArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormGrouping model
   */
  interface FormGroupingFieldRefs {
    readonly id: FieldRef<"FormGrouping", 'String'>
    readonly title: FieldRef<"FormGrouping", 'String'>
    readonly order: FieldRef<"FormGrouping", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FormGrouping findUnique
   */
  export type FormGroupingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormGrouping
     */
    select?: FormGroupingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormGrouping
     */
    omit?: FormGroupingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormGroupingInclude<ExtArgs> | null
    /**
     * Filter, which FormGrouping to fetch.
     */
    where: FormGroupingWhereUniqueInput
  }

  /**
   * FormGrouping findUniqueOrThrow
   */
  export type FormGroupingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormGrouping
     */
    select?: FormGroupingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormGrouping
     */
    omit?: FormGroupingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormGroupingInclude<ExtArgs> | null
    /**
     * Filter, which FormGrouping to fetch.
     */
    where: FormGroupingWhereUniqueInput
  }

  /**
   * FormGrouping findFirst
   */
  export type FormGroupingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormGrouping
     */
    select?: FormGroupingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormGrouping
     */
    omit?: FormGroupingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormGroupingInclude<ExtArgs> | null
    /**
     * Filter, which FormGrouping to fetch.
     */
    where?: FormGroupingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormGroupings to fetch.
     */
    orderBy?: FormGroupingOrderByWithRelationInput | FormGroupingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormGroupings.
     */
    cursor?: FormGroupingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormGroupings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormGroupings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormGroupings.
     */
    distinct?: FormGroupingScalarFieldEnum | FormGroupingScalarFieldEnum[]
  }

  /**
   * FormGrouping findFirstOrThrow
   */
  export type FormGroupingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormGrouping
     */
    select?: FormGroupingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormGrouping
     */
    omit?: FormGroupingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormGroupingInclude<ExtArgs> | null
    /**
     * Filter, which FormGrouping to fetch.
     */
    where?: FormGroupingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormGroupings to fetch.
     */
    orderBy?: FormGroupingOrderByWithRelationInput | FormGroupingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormGroupings.
     */
    cursor?: FormGroupingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormGroupings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormGroupings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormGroupings.
     */
    distinct?: FormGroupingScalarFieldEnum | FormGroupingScalarFieldEnum[]
  }

  /**
   * FormGrouping findMany
   */
  export type FormGroupingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormGrouping
     */
    select?: FormGroupingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormGrouping
     */
    omit?: FormGroupingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormGroupingInclude<ExtArgs> | null
    /**
     * Filter, which FormGroupings to fetch.
     */
    where?: FormGroupingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormGroupings to fetch.
     */
    orderBy?: FormGroupingOrderByWithRelationInput | FormGroupingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormGroupings.
     */
    cursor?: FormGroupingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormGroupings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormGroupings.
     */
    skip?: number
    distinct?: FormGroupingScalarFieldEnum | FormGroupingScalarFieldEnum[]
  }

  /**
   * FormGrouping create
   */
  export type FormGroupingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormGrouping
     */
    select?: FormGroupingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormGrouping
     */
    omit?: FormGroupingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormGroupingInclude<ExtArgs> | null
    /**
     * The data needed to create a FormGrouping.
     */
    data: XOR<FormGroupingCreateInput, FormGroupingUncheckedCreateInput>
  }

  /**
   * FormGrouping createMany
   */
  export type FormGroupingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormGroupings.
     */
    data: FormGroupingCreateManyInput | FormGroupingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormGrouping createManyAndReturn
   */
  export type FormGroupingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormGrouping
     */
    select?: FormGroupingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormGrouping
     */
    omit?: FormGroupingOmit<ExtArgs> | null
    /**
     * The data used to create many FormGroupings.
     */
    data: FormGroupingCreateManyInput | FormGroupingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormGrouping update
   */
  export type FormGroupingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormGrouping
     */
    select?: FormGroupingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormGrouping
     */
    omit?: FormGroupingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormGroupingInclude<ExtArgs> | null
    /**
     * The data needed to update a FormGrouping.
     */
    data: XOR<FormGroupingUpdateInput, FormGroupingUncheckedUpdateInput>
    /**
     * Choose, which FormGrouping to update.
     */
    where: FormGroupingWhereUniqueInput
  }

  /**
   * FormGrouping updateMany
   */
  export type FormGroupingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormGroupings.
     */
    data: XOR<FormGroupingUpdateManyMutationInput, FormGroupingUncheckedUpdateManyInput>
    /**
     * Filter which FormGroupings to update
     */
    where?: FormGroupingWhereInput
    /**
     * Limit how many FormGroupings to update.
     */
    limit?: number
  }

  /**
   * FormGrouping updateManyAndReturn
   */
  export type FormGroupingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormGrouping
     */
    select?: FormGroupingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormGrouping
     */
    omit?: FormGroupingOmit<ExtArgs> | null
    /**
     * The data used to update FormGroupings.
     */
    data: XOR<FormGroupingUpdateManyMutationInput, FormGroupingUncheckedUpdateManyInput>
    /**
     * Filter which FormGroupings to update
     */
    where?: FormGroupingWhereInput
    /**
     * Limit how many FormGroupings to update.
     */
    limit?: number
  }

  /**
   * FormGrouping upsert
   */
  export type FormGroupingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormGrouping
     */
    select?: FormGroupingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormGrouping
     */
    omit?: FormGroupingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormGroupingInclude<ExtArgs> | null
    /**
     * The filter to search for the FormGrouping to update in case it exists.
     */
    where: FormGroupingWhereUniqueInput
    /**
     * In case the FormGrouping found by the `where` argument doesn't exist, create a new FormGrouping with this data.
     */
    create: XOR<FormGroupingCreateInput, FormGroupingUncheckedCreateInput>
    /**
     * In case the FormGrouping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormGroupingUpdateInput, FormGroupingUncheckedUpdateInput>
  }

  /**
   * FormGrouping delete
   */
  export type FormGroupingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormGrouping
     */
    select?: FormGroupingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormGrouping
     */
    omit?: FormGroupingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormGroupingInclude<ExtArgs> | null
    /**
     * Filter which FormGrouping to delete.
     */
    where: FormGroupingWhereUniqueInput
  }

  /**
   * FormGrouping deleteMany
   */
  export type FormGroupingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormGroupings to delete
     */
    where?: FormGroupingWhereInput
    /**
     * Limit how many FormGroupings to delete.
     */
    limit?: number
  }

  /**
   * FormGrouping.Fields
   */
  export type FormGrouping$FieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormField
     */
    omit?: FormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    where?: FormFieldWhereInput
    orderBy?: FormFieldOrderByWithRelationInput | FormFieldOrderByWithRelationInput[]
    cursor?: FormFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormFieldScalarFieldEnum | FormFieldScalarFieldEnum[]
  }

  /**
   * FormGrouping.FormTemplate
   */
  export type FormGrouping$FormTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormTemplate
     */
    select?: FormTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormTemplate
     */
    omit?: FormTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormTemplateInclude<ExtArgs> | null
    where?: FormTemplateWhereInput
    orderBy?: FormTemplateOrderByWithRelationInput | FormTemplateOrderByWithRelationInput[]
    cursor?: FormTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormTemplateScalarFieldEnum | FormTemplateScalarFieldEnum[]
  }

  /**
   * FormGrouping without action
   */
  export type FormGroupingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormGrouping
     */
    select?: FormGroupingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormGrouping
     */
    omit?: FormGroupingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormGroupingInclude<ExtArgs> | null
  }


  /**
   * Model FormField
   */

  export type AggregateFormField = {
    _count: FormFieldCountAggregateOutputType | null
    _avg: FormFieldAvgAggregateOutputType | null
    _sum: FormFieldSumAggregateOutputType | null
    _min: FormFieldMinAggregateOutputType | null
    _max: FormFieldMaxAggregateOutputType | null
  }

  export type FormFieldAvgAggregateOutputType = {
    order: number | null
    maxLength: number | null
    minLength: number | null
  }

  export type FormFieldSumAggregateOutputType = {
    order: number | null
    maxLength: number | null
    minLength: number | null
  }

  export type FormFieldMinAggregateOutputType = {
    id: string | null
    formGroupingId: string | null
    label: string | null
    type: $Enums.FieldType | null
    required: boolean | null
    order: number | null
    placeholder: string | null
    maxLength: number | null
    content: string | null
    filter: string | null
    minLength: number | null
    multiple: boolean | null
  }

  export type FormFieldMaxAggregateOutputType = {
    id: string | null
    formGroupingId: string | null
    label: string | null
    type: $Enums.FieldType | null
    required: boolean | null
    order: number | null
    placeholder: string | null
    maxLength: number | null
    content: string | null
    filter: string | null
    minLength: number | null
    multiple: boolean | null
  }

  export type FormFieldCountAggregateOutputType = {
    id: number
    formGroupingId: number
    label: number
    type: number
    required: number
    order: number
    placeholder: number
    maxLength: number
    content: number
    filter: number
    minLength: number
    multiple: number
    _all: number
  }


  export type FormFieldAvgAggregateInputType = {
    order?: true
    maxLength?: true
    minLength?: true
  }

  export type FormFieldSumAggregateInputType = {
    order?: true
    maxLength?: true
    minLength?: true
  }

  export type FormFieldMinAggregateInputType = {
    id?: true
    formGroupingId?: true
    label?: true
    type?: true
    required?: true
    order?: true
    placeholder?: true
    maxLength?: true
    content?: true
    filter?: true
    minLength?: true
    multiple?: true
  }

  export type FormFieldMaxAggregateInputType = {
    id?: true
    formGroupingId?: true
    label?: true
    type?: true
    required?: true
    order?: true
    placeholder?: true
    maxLength?: true
    content?: true
    filter?: true
    minLength?: true
    multiple?: true
  }

  export type FormFieldCountAggregateInputType = {
    id?: true
    formGroupingId?: true
    label?: true
    type?: true
    required?: true
    order?: true
    placeholder?: true
    maxLength?: true
    content?: true
    filter?: true
    minLength?: true
    multiple?: true
    _all?: true
  }

  export type FormFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormField to aggregate.
     */
    where?: FormFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFields to fetch.
     */
    orderBy?: FormFieldOrderByWithRelationInput | FormFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormFields
    **/
    _count?: true | FormFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormFieldMaxAggregateInputType
  }

  export type GetFormFieldAggregateType<T extends FormFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateFormField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormField[P]>
      : GetScalarType<T[P], AggregateFormField[P]>
  }




  export type FormFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormFieldWhereInput
    orderBy?: FormFieldOrderByWithAggregationInput | FormFieldOrderByWithAggregationInput[]
    by: FormFieldScalarFieldEnum[] | FormFieldScalarFieldEnum
    having?: FormFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormFieldCountAggregateInputType | true
    _avg?: FormFieldAvgAggregateInputType
    _sum?: FormFieldSumAggregateInputType
    _min?: FormFieldMinAggregateInputType
    _max?: FormFieldMaxAggregateInputType
  }

  export type FormFieldGroupByOutputType = {
    id: string
    formGroupingId: string
    label: string
    type: $Enums.FieldType
    required: boolean
    order: number
    placeholder: string | null
    maxLength: number | null
    content: string | null
    filter: string | null
    minLength: number | null
    multiple: boolean | null
    _count: FormFieldCountAggregateOutputType | null
    _avg: FormFieldAvgAggregateOutputType | null
    _sum: FormFieldSumAggregateOutputType | null
    _min: FormFieldMinAggregateOutputType | null
    _max: FormFieldMaxAggregateOutputType | null
  }

  type GetFormFieldGroupByPayload<T extends FormFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormFieldGroupByOutputType[P]>
            : GetScalarType<T[P], FormFieldGroupByOutputType[P]>
        }
      >
    >


  export type FormFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formGroupingId?: boolean
    label?: boolean
    type?: boolean
    required?: boolean
    order?: boolean
    placeholder?: boolean
    maxLength?: boolean
    content?: boolean
    filter?: boolean
    minLength?: boolean
    multiple?: boolean
    FormGrouping?: boolean | FormGroupingDefaultArgs<ExtArgs>
    Options?: boolean | FormField$OptionsArgs<ExtArgs>
    _count?: boolean | FormFieldCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formField"]>

  export type FormFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formGroupingId?: boolean
    label?: boolean
    type?: boolean
    required?: boolean
    order?: boolean
    placeholder?: boolean
    maxLength?: boolean
    content?: boolean
    filter?: boolean
    minLength?: boolean
    multiple?: boolean
    FormGrouping?: boolean | FormGroupingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formField"]>

  export type FormFieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    formGroupingId?: boolean
    label?: boolean
    type?: boolean
    required?: boolean
    order?: boolean
    placeholder?: boolean
    maxLength?: boolean
    content?: boolean
    filter?: boolean
    minLength?: boolean
    multiple?: boolean
    FormGrouping?: boolean | FormGroupingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formField"]>

  export type FormFieldSelectScalar = {
    id?: boolean
    formGroupingId?: boolean
    label?: boolean
    type?: boolean
    required?: boolean
    order?: boolean
    placeholder?: boolean
    maxLength?: boolean
    content?: boolean
    filter?: boolean
    minLength?: boolean
    multiple?: boolean
  }

  export type FormFieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "formGroupingId" | "label" | "type" | "required" | "order" | "placeholder" | "maxLength" | "content" | "filter" | "minLength" | "multiple", ExtArgs["result"]["formField"]>
  export type FormFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FormGrouping?: boolean | FormGroupingDefaultArgs<ExtArgs>
    Options?: boolean | FormField$OptionsArgs<ExtArgs>
    _count?: boolean | FormFieldCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FormFieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FormGrouping?: boolean | FormGroupingDefaultArgs<ExtArgs>
  }
  export type FormFieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FormGrouping?: boolean | FormGroupingDefaultArgs<ExtArgs>
  }

  export type $FormFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormField"
    objects: {
      FormGrouping: Prisma.$FormGroupingPayload<ExtArgs>
      Options: Prisma.$FormFieldOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      formGroupingId: string
      label: string
      type: $Enums.FieldType
      required: boolean
      order: number
      placeholder: string | null
      maxLength: number | null
      content: string | null
      filter: string | null
      minLength: number | null
      multiple: boolean | null
    }, ExtArgs["result"]["formField"]>
    composites: {}
  }

  type FormFieldGetPayload<S extends boolean | null | undefined | FormFieldDefaultArgs> = $Result.GetResult<Prisma.$FormFieldPayload, S>

  type FormFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormFieldCountAggregateInputType | true
    }

  export interface FormFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormField'], meta: { name: 'FormField' } }
    /**
     * Find zero or one FormField that matches the filter.
     * @param {FormFieldFindUniqueArgs} args - Arguments to find a FormField
     * @example
     * // Get one FormField
     * const formField = await prisma.formField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormFieldFindUniqueArgs>(args: SelectSubset<T, FormFieldFindUniqueArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormFieldFindUniqueOrThrowArgs} args - Arguments to find a FormField
     * @example
     * // Get one FormField
     * const formField = await prisma.formField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, FormFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldFindFirstArgs} args - Arguments to find a FormField
     * @example
     * // Get one FormField
     * const formField = await prisma.formField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormFieldFindFirstArgs>(args?: SelectSubset<T, FormFieldFindFirstArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldFindFirstOrThrowArgs} args - Arguments to find a FormField
     * @example
     * // Get one FormField
     * const formField = await prisma.formField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, FormFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormFields
     * const formFields = await prisma.formField.findMany()
     * 
     * // Get first 10 FormFields
     * const formFields = await prisma.formField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formFieldWithIdOnly = await prisma.formField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormFieldFindManyArgs>(args?: SelectSubset<T, FormFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormField.
     * @param {FormFieldCreateArgs} args - Arguments to create a FormField.
     * @example
     * // Create one FormField
     * const FormField = await prisma.formField.create({
     *   data: {
     *     // ... data to create a FormField
     *   }
     * })
     * 
     */
    create<T extends FormFieldCreateArgs>(args: SelectSubset<T, FormFieldCreateArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormFields.
     * @param {FormFieldCreateManyArgs} args - Arguments to create many FormFields.
     * @example
     * // Create many FormFields
     * const formField = await prisma.formField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormFieldCreateManyArgs>(args?: SelectSubset<T, FormFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormFields and returns the data saved in the database.
     * @param {FormFieldCreateManyAndReturnArgs} args - Arguments to create many FormFields.
     * @example
     * // Create many FormFields
     * const formField = await prisma.formField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormFields and only return the `id`
     * const formFieldWithIdOnly = await prisma.formField.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, FormFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormField.
     * @param {FormFieldDeleteArgs} args - Arguments to delete one FormField.
     * @example
     * // Delete one FormField
     * const FormField = await prisma.formField.delete({
     *   where: {
     *     // ... filter to delete one FormField
     *   }
     * })
     * 
     */
    delete<T extends FormFieldDeleteArgs>(args: SelectSubset<T, FormFieldDeleteArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormField.
     * @param {FormFieldUpdateArgs} args - Arguments to update one FormField.
     * @example
     * // Update one FormField
     * const formField = await prisma.formField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormFieldUpdateArgs>(args: SelectSubset<T, FormFieldUpdateArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormFields.
     * @param {FormFieldDeleteManyArgs} args - Arguments to filter FormFields to delete.
     * @example
     * // Delete a few FormFields
     * const { count } = await prisma.formField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormFieldDeleteManyArgs>(args?: SelectSubset<T, FormFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormFields
     * const formField = await prisma.formField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormFieldUpdateManyArgs>(args: SelectSubset<T, FormFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormFields and returns the data updated in the database.
     * @param {FormFieldUpdateManyAndReturnArgs} args - Arguments to update many FormFields.
     * @example
     * // Update many FormFields
     * const formField = await prisma.formField.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormFields and only return the `id`
     * const formFieldWithIdOnly = await prisma.formField.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormFieldUpdateManyAndReturnArgs>(args: SelectSubset<T, FormFieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormField.
     * @param {FormFieldUpsertArgs} args - Arguments to update or create a FormField.
     * @example
     * // Update or create a FormField
     * const formField = await prisma.formField.upsert({
     *   create: {
     *     // ... data to create a FormField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormField we want to update
     *   }
     * })
     */
    upsert<T extends FormFieldUpsertArgs>(args: SelectSubset<T, FormFieldUpsertArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldCountArgs} args - Arguments to filter FormFields to count.
     * @example
     * // Count the number of FormFields
     * const count = await prisma.formField.count({
     *   where: {
     *     // ... the filter for the FormFields we want to count
     *   }
     * })
    **/
    count<T extends FormFieldCountArgs>(
      args?: Subset<T, FormFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormFieldAggregateArgs>(args: Subset<T, FormFieldAggregateArgs>): Prisma.PrismaPromise<GetFormFieldAggregateType<T>>

    /**
     * Group by FormField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormFieldGroupByArgs['orderBy'] }
        : { orderBy?: FormFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormField model
   */
  readonly fields: FormFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FormGrouping<T extends FormGroupingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormGroupingDefaultArgs<ExtArgs>>): Prisma__FormGroupingClient<$Result.GetResult<Prisma.$FormGroupingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Options<T extends FormField$OptionsArgs<ExtArgs> = {}>(args?: Subset<T, FormField$OptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFieldOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormField model
   */
  interface FormFieldFieldRefs {
    readonly id: FieldRef<"FormField", 'String'>
    readonly formGroupingId: FieldRef<"FormField", 'String'>
    readonly label: FieldRef<"FormField", 'String'>
    readonly type: FieldRef<"FormField", 'FieldType'>
    readonly required: FieldRef<"FormField", 'Boolean'>
    readonly order: FieldRef<"FormField", 'Int'>
    readonly placeholder: FieldRef<"FormField", 'String'>
    readonly maxLength: FieldRef<"FormField", 'Int'>
    readonly content: FieldRef<"FormField", 'String'>
    readonly filter: FieldRef<"FormField", 'String'>
    readonly minLength: FieldRef<"FormField", 'Int'>
    readonly multiple: FieldRef<"FormField", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * FormField findUnique
   */
  export type FormFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormField
     */
    omit?: FormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * Filter, which FormField to fetch.
     */
    where: FormFieldWhereUniqueInput
  }

  /**
   * FormField findUniqueOrThrow
   */
  export type FormFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormField
     */
    omit?: FormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * Filter, which FormField to fetch.
     */
    where: FormFieldWhereUniqueInput
  }

  /**
   * FormField findFirst
   */
  export type FormFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormField
     */
    omit?: FormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * Filter, which FormField to fetch.
     */
    where?: FormFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFields to fetch.
     */
    orderBy?: FormFieldOrderByWithRelationInput | FormFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormFields.
     */
    cursor?: FormFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormFields.
     */
    distinct?: FormFieldScalarFieldEnum | FormFieldScalarFieldEnum[]
  }

  /**
   * FormField findFirstOrThrow
   */
  export type FormFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormField
     */
    omit?: FormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * Filter, which FormField to fetch.
     */
    where?: FormFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFields to fetch.
     */
    orderBy?: FormFieldOrderByWithRelationInput | FormFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormFields.
     */
    cursor?: FormFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormFields.
     */
    distinct?: FormFieldScalarFieldEnum | FormFieldScalarFieldEnum[]
  }

  /**
   * FormField findMany
   */
  export type FormFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormField
     */
    omit?: FormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * Filter, which FormFields to fetch.
     */
    where?: FormFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFields to fetch.
     */
    orderBy?: FormFieldOrderByWithRelationInput | FormFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormFields.
     */
    cursor?: FormFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFields.
     */
    skip?: number
    distinct?: FormFieldScalarFieldEnum | FormFieldScalarFieldEnum[]
  }

  /**
   * FormField create
   */
  export type FormFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormField
     */
    omit?: FormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a FormField.
     */
    data: XOR<FormFieldCreateInput, FormFieldUncheckedCreateInput>
  }

  /**
   * FormField createMany
   */
  export type FormFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormFields.
     */
    data: FormFieldCreateManyInput | FormFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormField createManyAndReturn
   */
  export type FormFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormField
     */
    omit?: FormFieldOmit<ExtArgs> | null
    /**
     * The data used to create many FormFields.
     */
    data: FormFieldCreateManyInput | FormFieldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormField update
   */
  export type FormFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormField
     */
    omit?: FormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a FormField.
     */
    data: XOR<FormFieldUpdateInput, FormFieldUncheckedUpdateInput>
    /**
     * Choose, which FormField to update.
     */
    where: FormFieldWhereUniqueInput
  }

  /**
   * FormField updateMany
   */
  export type FormFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormFields.
     */
    data: XOR<FormFieldUpdateManyMutationInput, FormFieldUncheckedUpdateManyInput>
    /**
     * Filter which FormFields to update
     */
    where?: FormFieldWhereInput
    /**
     * Limit how many FormFields to update.
     */
    limit?: number
  }

  /**
   * FormField updateManyAndReturn
   */
  export type FormFieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormField
     */
    omit?: FormFieldOmit<ExtArgs> | null
    /**
     * The data used to update FormFields.
     */
    data: XOR<FormFieldUpdateManyMutationInput, FormFieldUncheckedUpdateManyInput>
    /**
     * Filter which FormFields to update
     */
    where?: FormFieldWhereInput
    /**
     * Limit how many FormFields to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormField upsert
   */
  export type FormFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormField
     */
    omit?: FormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the FormField to update in case it exists.
     */
    where: FormFieldWhereUniqueInput
    /**
     * In case the FormField found by the `where` argument doesn't exist, create a new FormField with this data.
     */
    create: XOR<FormFieldCreateInput, FormFieldUncheckedCreateInput>
    /**
     * In case the FormField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormFieldUpdateInput, FormFieldUncheckedUpdateInput>
  }

  /**
   * FormField delete
   */
  export type FormFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormField
     */
    omit?: FormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
    /**
     * Filter which FormField to delete.
     */
    where: FormFieldWhereUniqueInput
  }

  /**
   * FormField deleteMany
   */
  export type FormFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormFields to delete
     */
    where?: FormFieldWhereInput
    /**
     * Limit how many FormFields to delete.
     */
    limit?: number
  }

  /**
   * FormField.Options
   */
  export type FormField$OptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFieldOption
     */
    select?: FormFieldOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFieldOption
     */
    omit?: FormFieldOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldOptionInclude<ExtArgs> | null
    where?: FormFieldOptionWhereInput
    orderBy?: FormFieldOptionOrderByWithRelationInput | FormFieldOptionOrderByWithRelationInput[]
    cursor?: FormFieldOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormFieldOptionScalarFieldEnum | FormFieldOptionScalarFieldEnum[]
  }

  /**
   * FormField without action
   */
  export type FormFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormField
     */
    select?: FormFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormField
     */
    omit?: FormFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldInclude<ExtArgs> | null
  }


  /**
   * Model FormFieldOption
   */

  export type AggregateFormFieldOption = {
    _count: FormFieldOptionCountAggregateOutputType | null
    _min: FormFieldOptionMinAggregateOutputType | null
    _max: FormFieldOptionMaxAggregateOutputType | null
  }

  export type FormFieldOptionMinAggregateOutputType = {
    id: string | null
    fieldId: string | null
    value: string | null
  }

  export type FormFieldOptionMaxAggregateOutputType = {
    id: string | null
    fieldId: string | null
    value: string | null
  }

  export type FormFieldOptionCountAggregateOutputType = {
    id: number
    fieldId: number
    value: number
    _all: number
  }


  export type FormFieldOptionMinAggregateInputType = {
    id?: true
    fieldId?: true
    value?: true
  }

  export type FormFieldOptionMaxAggregateInputType = {
    id?: true
    fieldId?: true
    value?: true
  }

  export type FormFieldOptionCountAggregateInputType = {
    id?: true
    fieldId?: true
    value?: true
    _all?: true
  }

  export type FormFieldOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormFieldOption to aggregate.
     */
    where?: FormFieldOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFieldOptions to fetch.
     */
    orderBy?: FormFieldOptionOrderByWithRelationInput | FormFieldOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormFieldOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFieldOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFieldOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormFieldOptions
    **/
    _count?: true | FormFieldOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormFieldOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormFieldOptionMaxAggregateInputType
  }

  export type GetFormFieldOptionAggregateType<T extends FormFieldOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateFormFieldOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormFieldOption[P]>
      : GetScalarType<T[P], AggregateFormFieldOption[P]>
  }




  export type FormFieldOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormFieldOptionWhereInput
    orderBy?: FormFieldOptionOrderByWithAggregationInput | FormFieldOptionOrderByWithAggregationInput[]
    by: FormFieldOptionScalarFieldEnum[] | FormFieldOptionScalarFieldEnum
    having?: FormFieldOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormFieldOptionCountAggregateInputType | true
    _min?: FormFieldOptionMinAggregateInputType
    _max?: FormFieldOptionMaxAggregateInputType
  }

  export type FormFieldOptionGroupByOutputType = {
    id: string
    fieldId: string
    value: string
    _count: FormFieldOptionCountAggregateOutputType | null
    _min: FormFieldOptionMinAggregateOutputType | null
    _max: FormFieldOptionMaxAggregateOutputType | null
  }

  type GetFormFieldOptionGroupByPayload<T extends FormFieldOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormFieldOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormFieldOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormFieldOptionGroupByOutputType[P]>
            : GetScalarType<T[P], FormFieldOptionGroupByOutputType[P]>
        }
      >
    >


  export type FormFieldOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fieldId?: boolean
    value?: boolean
    Field?: boolean | FormFieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formFieldOption"]>

  export type FormFieldOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fieldId?: boolean
    value?: boolean
    Field?: boolean | FormFieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formFieldOption"]>

  export type FormFieldOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fieldId?: boolean
    value?: boolean
    Field?: boolean | FormFieldDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formFieldOption"]>

  export type FormFieldOptionSelectScalar = {
    id?: boolean
    fieldId?: boolean
    value?: boolean
  }

  export type FormFieldOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fieldId" | "value", ExtArgs["result"]["formFieldOption"]>
  export type FormFieldOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Field?: boolean | FormFieldDefaultArgs<ExtArgs>
  }
  export type FormFieldOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Field?: boolean | FormFieldDefaultArgs<ExtArgs>
  }
  export type FormFieldOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Field?: boolean | FormFieldDefaultArgs<ExtArgs>
  }

  export type $FormFieldOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormFieldOption"
    objects: {
      Field: Prisma.$FormFieldPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fieldId: string
      value: string
    }, ExtArgs["result"]["formFieldOption"]>
    composites: {}
  }

  type FormFieldOptionGetPayload<S extends boolean | null | undefined | FormFieldOptionDefaultArgs> = $Result.GetResult<Prisma.$FormFieldOptionPayload, S>

  type FormFieldOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormFieldOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormFieldOptionCountAggregateInputType | true
    }

  export interface FormFieldOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormFieldOption'], meta: { name: 'FormFieldOption' } }
    /**
     * Find zero or one FormFieldOption that matches the filter.
     * @param {FormFieldOptionFindUniqueArgs} args - Arguments to find a FormFieldOption
     * @example
     * // Get one FormFieldOption
     * const formFieldOption = await prisma.formFieldOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormFieldOptionFindUniqueArgs>(args: SelectSubset<T, FormFieldOptionFindUniqueArgs<ExtArgs>>): Prisma__FormFieldOptionClient<$Result.GetResult<Prisma.$FormFieldOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormFieldOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormFieldOptionFindUniqueOrThrowArgs} args - Arguments to find a FormFieldOption
     * @example
     * // Get one FormFieldOption
     * const formFieldOption = await prisma.formFieldOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormFieldOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, FormFieldOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormFieldOptionClient<$Result.GetResult<Prisma.$FormFieldOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormFieldOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldOptionFindFirstArgs} args - Arguments to find a FormFieldOption
     * @example
     * // Get one FormFieldOption
     * const formFieldOption = await prisma.formFieldOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormFieldOptionFindFirstArgs>(args?: SelectSubset<T, FormFieldOptionFindFirstArgs<ExtArgs>>): Prisma__FormFieldOptionClient<$Result.GetResult<Prisma.$FormFieldOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormFieldOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldOptionFindFirstOrThrowArgs} args - Arguments to find a FormFieldOption
     * @example
     * // Get one FormFieldOption
     * const formFieldOption = await prisma.formFieldOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormFieldOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, FormFieldOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormFieldOptionClient<$Result.GetResult<Prisma.$FormFieldOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormFieldOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormFieldOptions
     * const formFieldOptions = await prisma.formFieldOption.findMany()
     * 
     * // Get first 10 FormFieldOptions
     * const formFieldOptions = await prisma.formFieldOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formFieldOptionWithIdOnly = await prisma.formFieldOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormFieldOptionFindManyArgs>(args?: SelectSubset<T, FormFieldOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFieldOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormFieldOption.
     * @param {FormFieldOptionCreateArgs} args - Arguments to create a FormFieldOption.
     * @example
     * // Create one FormFieldOption
     * const FormFieldOption = await prisma.formFieldOption.create({
     *   data: {
     *     // ... data to create a FormFieldOption
     *   }
     * })
     * 
     */
    create<T extends FormFieldOptionCreateArgs>(args: SelectSubset<T, FormFieldOptionCreateArgs<ExtArgs>>): Prisma__FormFieldOptionClient<$Result.GetResult<Prisma.$FormFieldOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormFieldOptions.
     * @param {FormFieldOptionCreateManyArgs} args - Arguments to create many FormFieldOptions.
     * @example
     * // Create many FormFieldOptions
     * const formFieldOption = await prisma.formFieldOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormFieldOptionCreateManyArgs>(args?: SelectSubset<T, FormFieldOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormFieldOptions and returns the data saved in the database.
     * @param {FormFieldOptionCreateManyAndReturnArgs} args - Arguments to create many FormFieldOptions.
     * @example
     * // Create many FormFieldOptions
     * const formFieldOption = await prisma.formFieldOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormFieldOptions and only return the `id`
     * const formFieldOptionWithIdOnly = await prisma.formFieldOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormFieldOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, FormFieldOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFieldOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormFieldOption.
     * @param {FormFieldOptionDeleteArgs} args - Arguments to delete one FormFieldOption.
     * @example
     * // Delete one FormFieldOption
     * const FormFieldOption = await prisma.formFieldOption.delete({
     *   where: {
     *     // ... filter to delete one FormFieldOption
     *   }
     * })
     * 
     */
    delete<T extends FormFieldOptionDeleteArgs>(args: SelectSubset<T, FormFieldOptionDeleteArgs<ExtArgs>>): Prisma__FormFieldOptionClient<$Result.GetResult<Prisma.$FormFieldOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormFieldOption.
     * @param {FormFieldOptionUpdateArgs} args - Arguments to update one FormFieldOption.
     * @example
     * // Update one FormFieldOption
     * const formFieldOption = await prisma.formFieldOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormFieldOptionUpdateArgs>(args: SelectSubset<T, FormFieldOptionUpdateArgs<ExtArgs>>): Prisma__FormFieldOptionClient<$Result.GetResult<Prisma.$FormFieldOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormFieldOptions.
     * @param {FormFieldOptionDeleteManyArgs} args - Arguments to filter FormFieldOptions to delete.
     * @example
     * // Delete a few FormFieldOptions
     * const { count } = await prisma.formFieldOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormFieldOptionDeleteManyArgs>(args?: SelectSubset<T, FormFieldOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormFieldOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormFieldOptions
     * const formFieldOption = await prisma.formFieldOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormFieldOptionUpdateManyArgs>(args: SelectSubset<T, FormFieldOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormFieldOptions and returns the data updated in the database.
     * @param {FormFieldOptionUpdateManyAndReturnArgs} args - Arguments to update many FormFieldOptions.
     * @example
     * // Update many FormFieldOptions
     * const formFieldOption = await prisma.formFieldOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormFieldOptions and only return the `id`
     * const formFieldOptionWithIdOnly = await prisma.formFieldOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormFieldOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, FormFieldOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormFieldOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormFieldOption.
     * @param {FormFieldOptionUpsertArgs} args - Arguments to update or create a FormFieldOption.
     * @example
     * // Update or create a FormFieldOption
     * const formFieldOption = await prisma.formFieldOption.upsert({
     *   create: {
     *     // ... data to create a FormFieldOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormFieldOption we want to update
     *   }
     * })
     */
    upsert<T extends FormFieldOptionUpsertArgs>(args: SelectSubset<T, FormFieldOptionUpsertArgs<ExtArgs>>): Prisma__FormFieldOptionClient<$Result.GetResult<Prisma.$FormFieldOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormFieldOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldOptionCountArgs} args - Arguments to filter FormFieldOptions to count.
     * @example
     * // Count the number of FormFieldOptions
     * const count = await prisma.formFieldOption.count({
     *   where: {
     *     // ... the filter for the FormFieldOptions we want to count
     *   }
     * })
    **/
    count<T extends FormFieldOptionCountArgs>(
      args?: Subset<T, FormFieldOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormFieldOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormFieldOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormFieldOptionAggregateArgs>(args: Subset<T, FormFieldOptionAggregateArgs>): Prisma.PrismaPromise<GetFormFieldOptionAggregateType<T>>

    /**
     * Group by FormFieldOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormFieldOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormFieldOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormFieldOptionGroupByArgs['orderBy'] }
        : { orderBy?: FormFieldOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormFieldOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormFieldOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormFieldOption model
   */
  readonly fields: FormFieldOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormFieldOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormFieldOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Field<T extends FormFieldDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormFieldDefaultArgs<ExtArgs>>): Prisma__FormFieldClient<$Result.GetResult<Prisma.$FormFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormFieldOption model
   */
  interface FormFieldOptionFieldRefs {
    readonly id: FieldRef<"FormFieldOption", 'String'>
    readonly fieldId: FieldRef<"FormFieldOption", 'String'>
    readonly value: FieldRef<"FormFieldOption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FormFieldOption findUnique
   */
  export type FormFieldOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFieldOption
     */
    select?: FormFieldOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFieldOption
     */
    omit?: FormFieldOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldOptionInclude<ExtArgs> | null
    /**
     * Filter, which FormFieldOption to fetch.
     */
    where: FormFieldOptionWhereUniqueInput
  }

  /**
   * FormFieldOption findUniqueOrThrow
   */
  export type FormFieldOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFieldOption
     */
    select?: FormFieldOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFieldOption
     */
    omit?: FormFieldOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldOptionInclude<ExtArgs> | null
    /**
     * Filter, which FormFieldOption to fetch.
     */
    where: FormFieldOptionWhereUniqueInput
  }

  /**
   * FormFieldOption findFirst
   */
  export type FormFieldOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFieldOption
     */
    select?: FormFieldOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFieldOption
     */
    omit?: FormFieldOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldOptionInclude<ExtArgs> | null
    /**
     * Filter, which FormFieldOption to fetch.
     */
    where?: FormFieldOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFieldOptions to fetch.
     */
    orderBy?: FormFieldOptionOrderByWithRelationInput | FormFieldOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormFieldOptions.
     */
    cursor?: FormFieldOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFieldOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFieldOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormFieldOptions.
     */
    distinct?: FormFieldOptionScalarFieldEnum | FormFieldOptionScalarFieldEnum[]
  }

  /**
   * FormFieldOption findFirstOrThrow
   */
  export type FormFieldOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFieldOption
     */
    select?: FormFieldOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFieldOption
     */
    omit?: FormFieldOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldOptionInclude<ExtArgs> | null
    /**
     * Filter, which FormFieldOption to fetch.
     */
    where?: FormFieldOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFieldOptions to fetch.
     */
    orderBy?: FormFieldOptionOrderByWithRelationInput | FormFieldOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormFieldOptions.
     */
    cursor?: FormFieldOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFieldOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFieldOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormFieldOptions.
     */
    distinct?: FormFieldOptionScalarFieldEnum | FormFieldOptionScalarFieldEnum[]
  }

  /**
   * FormFieldOption findMany
   */
  export type FormFieldOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFieldOption
     */
    select?: FormFieldOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFieldOption
     */
    omit?: FormFieldOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldOptionInclude<ExtArgs> | null
    /**
     * Filter, which FormFieldOptions to fetch.
     */
    where?: FormFieldOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormFieldOptions to fetch.
     */
    orderBy?: FormFieldOptionOrderByWithRelationInput | FormFieldOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormFieldOptions.
     */
    cursor?: FormFieldOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormFieldOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormFieldOptions.
     */
    skip?: number
    distinct?: FormFieldOptionScalarFieldEnum | FormFieldOptionScalarFieldEnum[]
  }

  /**
   * FormFieldOption create
   */
  export type FormFieldOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFieldOption
     */
    select?: FormFieldOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFieldOption
     */
    omit?: FormFieldOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a FormFieldOption.
     */
    data: XOR<FormFieldOptionCreateInput, FormFieldOptionUncheckedCreateInput>
  }

  /**
   * FormFieldOption createMany
   */
  export type FormFieldOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormFieldOptions.
     */
    data: FormFieldOptionCreateManyInput | FormFieldOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormFieldOption createManyAndReturn
   */
  export type FormFieldOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFieldOption
     */
    select?: FormFieldOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormFieldOption
     */
    omit?: FormFieldOptionOmit<ExtArgs> | null
    /**
     * The data used to create many FormFieldOptions.
     */
    data: FormFieldOptionCreateManyInput | FormFieldOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormFieldOption update
   */
  export type FormFieldOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFieldOption
     */
    select?: FormFieldOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFieldOption
     */
    omit?: FormFieldOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a FormFieldOption.
     */
    data: XOR<FormFieldOptionUpdateInput, FormFieldOptionUncheckedUpdateInput>
    /**
     * Choose, which FormFieldOption to update.
     */
    where: FormFieldOptionWhereUniqueInput
  }

  /**
   * FormFieldOption updateMany
   */
  export type FormFieldOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormFieldOptions.
     */
    data: XOR<FormFieldOptionUpdateManyMutationInput, FormFieldOptionUncheckedUpdateManyInput>
    /**
     * Filter which FormFieldOptions to update
     */
    where?: FormFieldOptionWhereInput
    /**
     * Limit how many FormFieldOptions to update.
     */
    limit?: number
  }

  /**
   * FormFieldOption updateManyAndReturn
   */
  export type FormFieldOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFieldOption
     */
    select?: FormFieldOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormFieldOption
     */
    omit?: FormFieldOptionOmit<ExtArgs> | null
    /**
     * The data used to update FormFieldOptions.
     */
    data: XOR<FormFieldOptionUpdateManyMutationInput, FormFieldOptionUncheckedUpdateManyInput>
    /**
     * Filter which FormFieldOptions to update
     */
    where?: FormFieldOptionWhereInput
    /**
     * Limit how many FormFieldOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormFieldOption upsert
   */
  export type FormFieldOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFieldOption
     */
    select?: FormFieldOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFieldOption
     */
    omit?: FormFieldOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the FormFieldOption to update in case it exists.
     */
    where: FormFieldOptionWhereUniqueInput
    /**
     * In case the FormFieldOption found by the `where` argument doesn't exist, create a new FormFieldOption with this data.
     */
    create: XOR<FormFieldOptionCreateInput, FormFieldOptionUncheckedCreateInput>
    /**
     * In case the FormFieldOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormFieldOptionUpdateInput, FormFieldOptionUncheckedUpdateInput>
  }

  /**
   * FormFieldOption delete
   */
  export type FormFieldOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFieldOption
     */
    select?: FormFieldOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFieldOption
     */
    omit?: FormFieldOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldOptionInclude<ExtArgs> | null
    /**
     * Filter which FormFieldOption to delete.
     */
    where: FormFieldOptionWhereUniqueInput
  }

  /**
   * FormFieldOption deleteMany
   */
  export type FormFieldOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormFieldOptions to delete
     */
    where?: FormFieldOptionWhereInput
    /**
     * Limit how many FormFieldOptions to delete.
     */
    limit?: number
  }

  /**
   * FormFieldOption without action
   */
  export type FormFieldOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormFieldOption
     */
    select?: FormFieldOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormFieldOption
     */
    omit?: FormFieldOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormFieldOptionInclude<ExtArgs> | null
  }


  /**
   * Model FormSubmission
   */

  export type AggregateFormSubmission = {
    _count: FormSubmissionCountAggregateOutputType | null
    _avg: FormSubmissionAvgAggregateOutputType | null
    _sum: FormSubmissionSumAggregateOutputType | null
    _min: FormSubmissionMinAggregateOutputType | null
    _max: FormSubmissionMaxAggregateOutputType | null
  }

  export type FormSubmissionAvgAggregateOutputType = {
    id: number | null
  }

  export type FormSubmissionSumAggregateOutputType = {
    id: number | null
  }

  export type FormSubmissionMinAggregateOutputType = {
    title: string | null
    formTemplateId: string | null
    userId: string | null
    formType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    submittedAt: Date | null
    status: $Enums.FormStatus | null
    id: number | null
  }

  export type FormSubmissionMaxAggregateOutputType = {
    title: string | null
    formTemplateId: string | null
    userId: string | null
    formType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    submittedAt: Date | null
    status: $Enums.FormStatus | null
    id: number | null
  }

  export type FormSubmissionCountAggregateOutputType = {
    title: number
    formTemplateId: number
    userId: number
    formType: number
    data: number
    createdAt: number
    updatedAt: number
    submittedAt: number
    status: number
    id: number
    _all: number
  }


  export type FormSubmissionAvgAggregateInputType = {
    id?: true
  }

  export type FormSubmissionSumAggregateInputType = {
    id?: true
  }

  export type FormSubmissionMinAggregateInputType = {
    title?: true
    formTemplateId?: true
    userId?: true
    formType?: true
    createdAt?: true
    updatedAt?: true
    submittedAt?: true
    status?: true
    id?: true
  }

  export type FormSubmissionMaxAggregateInputType = {
    title?: true
    formTemplateId?: true
    userId?: true
    formType?: true
    createdAt?: true
    updatedAt?: true
    submittedAt?: true
    status?: true
    id?: true
  }

  export type FormSubmissionCountAggregateInputType = {
    title?: true
    formTemplateId?: true
    userId?: true
    formType?: true
    data?: true
    createdAt?: true
    updatedAt?: true
    submittedAt?: true
    status?: true
    id?: true
    _all?: true
  }

  export type FormSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSubmission to aggregate.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormSubmissions
    **/
    _count?: true | FormSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormSubmissionMaxAggregateInputType
  }

  export type GetFormSubmissionAggregateType<T extends FormSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateFormSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormSubmission[P]>
      : GetScalarType<T[P], AggregateFormSubmission[P]>
  }




  export type FormSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithAggregationInput | FormSubmissionOrderByWithAggregationInput[]
    by: FormSubmissionScalarFieldEnum[] | FormSubmissionScalarFieldEnum
    having?: FormSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormSubmissionCountAggregateInputType | true
    _avg?: FormSubmissionAvgAggregateInputType
    _sum?: FormSubmissionSumAggregateInputType
    _min?: FormSubmissionMinAggregateInputType
    _max?: FormSubmissionMaxAggregateInputType
  }

  export type FormSubmissionGroupByOutputType = {
    title: string | null
    formTemplateId: string
    userId: string
    formType: string | null
    data: JsonValue | null
    createdAt: Date
    updatedAt: Date
    submittedAt: Date | null
    status: $Enums.FormStatus
    id: number
    _count: FormSubmissionCountAggregateOutputType | null
    _avg: FormSubmissionAvgAggregateOutputType | null
    _sum: FormSubmissionSumAggregateOutputType | null
    _min: FormSubmissionMinAggregateOutputType | null
    _max: FormSubmissionMaxAggregateOutputType | null
  }

  type GetFormSubmissionGroupByPayload<T extends FormSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], FormSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type FormSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    title?: boolean
    formTemplateId?: boolean
    userId?: boolean
    formType?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submittedAt?: boolean
    status?: boolean
    id?: boolean
    Approvals?: boolean | FormSubmission$ApprovalsArgs<ExtArgs>
    FormTemplate?: boolean | FormTemplateDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | FormSubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formSubmission"]>

  export type FormSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    title?: boolean
    formTemplateId?: boolean
    userId?: boolean
    formType?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submittedAt?: boolean
    status?: boolean
    id?: boolean
    FormTemplate?: boolean | FormTemplateDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formSubmission"]>

  export type FormSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    title?: boolean
    formTemplateId?: boolean
    userId?: boolean
    formType?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submittedAt?: boolean
    status?: boolean
    id?: boolean
    FormTemplate?: boolean | FormTemplateDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formSubmission"]>

  export type FormSubmissionSelectScalar = {
    title?: boolean
    formTemplateId?: boolean
    userId?: boolean
    formType?: boolean
    data?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    submittedAt?: boolean
    status?: boolean
    id?: boolean
  }

  export type FormSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"title" | "formTemplateId" | "userId" | "formType" | "data" | "createdAt" | "updatedAt" | "submittedAt" | "status" | "id", ExtArgs["result"]["formSubmission"]>
  export type FormSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Approvals?: boolean | FormSubmission$ApprovalsArgs<ExtArgs>
    FormTemplate?: boolean | FormTemplateDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | FormSubmissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FormSubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FormTemplate?: boolean | FormTemplateDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FormSubmissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FormTemplate?: boolean | FormTemplateDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FormSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormSubmission"
    objects: {
      Approvals: Prisma.$FormApprovalPayload<ExtArgs>[]
      FormTemplate: Prisma.$FormTemplatePayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      title: string | null
      formTemplateId: string
      userId: string
      formType: string | null
      data: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      submittedAt: Date | null
      status: $Enums.FormStatus
      id: number
    }, ExtArgs["result"]["formSubmission"]>
    composites: {}
  }

  type FormSubmissionGetPayload<S extends boolean | null | undefined | FormSubmissionDefaultArgs> = $Result.GetResult<Prisma.$FormSubmissionPayload, S>

  type FormSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormSubmissionCountAggregateInputType | true
    }

  export interface FormSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormSubmission'], meta: { name: 'FormSubmission' } }
    /**
     * Find zero or one FormSubmission that matches the filter.
     * @param {FormSubmissionFindUniqueArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormSubmissionFindUniqueArgs>(args: SelectSubset<T, FormSubmissionFindUniqueArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormSubmissionFindUniqueOrThrowArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, FormSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindFirstArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormSubmissionFindFirstArgs>(args?: SelectSubset<T, FormSubmissionFindFirstArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindFirstOrThrowArgs} args - Arguments to find a FormSubmission
     * @example
     * // Get one FormSubmission
     * const formSubmission = await prisma.formSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, FormSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormSubmissions
     * const formSubmissions = await prisma.formSubmission.findMany()
     * 
     * // Get first 10 FormSubmissions
     * const formSubmissions = await prisma.formSubmission.findMany({ take: 10 })
     * 
     * // Only select the `title`
     * const formSubmissionWithTitleOnly = await prisma.formSubmission.findMany({ select: { title: true } })
     * 
     */
    findMany<T extends FormSubmissionFindManyArgs>(args?: SelectSubset<T, FormSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormSubmission.
     * @param {FormSubmissionCreateArgs} args - Arguments to create a FormSubmission.
     * @example
     * // Create one FormSubmission
     * const FormSubmission = await prisma.formSubmission.create({
     *   data: {
     *     // ... data to create a FormSubmission
     *   }
     * })
     * 
     */
    create<T extends FormSubmissionCreateArgs>(args: SelectSubset<T, FormSubmissionCreateArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormSubmissions.
     * @param {FormSubmissionCreateManyArgs} args - Arguments to create many FormSubmissions.
     * @example
     * // Create many FormSubmissions
     * const formSubmission = await prisma.formSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormSubmissionCreateManyArgs>(args?: SelectSubset<T, FormSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormSubmissions and returns the data saved in the database.
     * @param {FormSubmissionCreateManyAndReturnArgs} args - Arguments to create many FormSubmissions.
     * @example
     * // Create many FormSubmissions
     * const formSubmission = await prisma.formSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormSubmissions and only return the `title`
     * const formSubmissionWithTitleOnly = await prisma.formSubmission.createManyAndReturn({
     *   select: { title: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, FormSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormSubmission.
     * @param {FormSubmissionDeleteArgs} args - Arguments to delete one FormSubmission.
     * @example
     * // Delete one FormSubmission
     * const FormSubmission = await prisma.formSubmission.delete({
     *   where: {
     *     // ... filter to delete one FormSubmission
     *   }
     * })
     * 
     */
    delete<T extends FormSubmissionDeleteArgs>(args: SelectSubset<T, FormSubmissionDeleteArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormSubmission.
     * @param {FormSubmissionUpdateArgs} args - Arguments to update one FormSubmission.
     * @example
     * // Update one FormSubmission
     * const formSubmission = await prisma.formSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormSubmissionUpdateArgs>(args: SelectSubset<T, FormSubmissionUpdateArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormSubmissions.
     * @param {FormSubmissionDeleteManyArgs} args - Arguments to filter FormSubmissions to delete.
     * @example
     * // Delete a few FormSubmissions
     * const { count } = await prisma.formSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormSubmissionDeleteManyArgs>(args?: SelectSubset<T, FormSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormSubmissions
     * const formSubmission = await prisma.formSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormSubmissionUpdateManyArgs>(args: SelectSubset<T, FormSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormSubmissions and returns the data updated in the database.
     * @param {FormSubmissionUpdateManyAndReturnArgs} args - Arguments to update many FormSubmissions.
     * @example
     * // Update many FormSubmissions
     * const formSubmission = await prisma.formSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormSubmissions and only return the `title`
     * const formSubmissionWithTitleOnly = await prisma.formSubmission.updateManyAndReturn({
     *   select: { title: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, FormSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormSubmission.
     * @param {FormSubmissionUpsertArgs} args - Arguments to update or create a FormSubmission.
     * @example
     * // Update or create a FormSubmission
     * const formSubmission = await prisma.formSubmission.upsert({
     *   create: {
     *     // ... data to create a FormSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormSubmission we want to update
     *   }
     * })
     */
    upsert<T extends FormSubmissionUpsertArgs>(args: SelectSubset<T, FormSubmissionUpsertArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionCountArgs} args - Arguments to filter FormSubmissions to count.
     * @example
     * // Count the number of FormSubmissions
     * const count = await prisma.formSubmission.count({
     *   where: {
     *     // ... the filter for the FormSubmissions we want to count
     *   }
     * })
    **/
    count<T extends FormSubmissionCountArgs>(
      args?: Subset<T, FormSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormSubmissionAggregateArgs>(args: Subset<T, FormSubmissionAggregateArgs>): Prisma.PrismaPromise<GetFormSubmissionAggregateType<T>>

    /**
     * Group by FormSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: FormSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormSubmission model
   */
  readonly fields: FormSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Approvals<T extends FormSubmission$ApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, FormSubmission$ApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FormTemplate<T extends FormTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormTemplateDefaultArgs<ExtArgs>>): Prisma__FormTemplateClient<$Result.GetResult<Prisma.$FormTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormSubmission model
   */
  interface FormSubmissionFieldRefs {
    readonly title: FieldRef<"FormSubmission", 'String'>
    readonly formTemplateId: FieldRef<"FormSubmission", 'String'>
    readonly userId: FieldRef<"FormSubmission", 'String'>
    readonly formType: FieldRef<"FormSubmission", 'String'>
    readonly data: FieldRef<"FormSubmission", 'Json'>
    readonly createdAt: FieldRef<"FormSubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"FormSubmission", 'DateTime'>
    readonly submittedAt: FieldRef<"FormSubmission", 'DateTime'>
    readonly status: FieldRef<"FormSubmission", 'FormStatus'>
    readonly id: FieldRef<"FormSubmission", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FormSubmission findUnique
   */
  export type FormSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission findUniqueOrThrow
   */
  export type FormSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission findFirst
   */
  export type FormSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSubmissions.
     */
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission findFirstOrThrow
   */
  export type FormSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmission to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormSubmissions.
     */
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission findMany
   */
  export type FormSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which FormSubmissions to fetch.
     */
    where?: FormSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormSubmissions to fetch.
     */
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormSubmissions.
     */
    cursor?: FormSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormSubmissions.
     */
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * FormSubmission create
   */
  export type FormSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a FormSubmission.
     */
    data: XOR<FormSubmissionCreateInput, FormSubmissionUncheckedCreateInput>
  }

  /**
   * FormSubmission createMany
   */
  export type FormSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormSubmissions.
     */
    data: FormSubmissionCreateManyInput | FormSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormSubmission createManyAndReturn
   */
  export type FormSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many FormSubmissions.
     */
    data: FormSubmissionCreateManyInput | FormSubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormSubmission update
   */
  export type FormSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a FormSubmission.
     */
    data: XOR<FormSubmissionUpdateInput, FormSubmissionUncheckedUpdateInput>
    /**
     * Choose, which FormSubmission to update.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission updateMany
   */
  export type FormSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormSubmissions.
     */
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which FormSubmissions to update
     */
    where?: FormSubmissionWhereInput
    /**
     * Limit how many FormSubmissions to update.
     */
    limit?: number
  }

  /**
   * FormSubmission updateManyAndReturn
   */
  export type FormSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update FormSubmissions.
     */
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which FormSubmissions to update
     */
    where?: FormSubmissionWhereInput
    /**
     * Limit how many FormSubmissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormSubmission upsert
   */
  export type FormSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the FormSubmission to update in case it exists.
     */
    where: FormSubmissionWhereUniqueInput
    /**
     * In case the FormSubmission found by the `where` argument doesn't exist, create a new FormSubmission with this data.
     */
    create: XOR<FormSubmissionCreateInput, FormSubmissionUncheckedCreateInput>
    /**
     * In case the FormSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormSubmissionUpdateInput, FormSubmissionUncheckedUpdateInput>
  }

  /**
   * FormSubmission delete
   */
  export type FormSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    /**
     * Filter which FormSubmission to delete.
     */
    where: FormSubmissionWhereUniqueInput
  }

  /**
   * FormSubmission deleteMany
   */
  export type FormSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormSubmissions to delete
     */
    where?: FormSubmissionWhereInput
    /**
     * Limit how many FormSubmissions to delete.
     */
    limit?: number
  }

  /**
   * FormSubmission.Approvals
   */
  export type FormSubmission$ApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormApproval
     */
    select?: FormApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormApproval
     */
    omit?: FormApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormApprovalInclude<ExtArgs> | null
    where?: FormApprovalWhereInput
    orderBy?: FormApprovalOrderByWithRelationInput | FormApprovalOrderByWithRelationInput[]
    cursor?: FormApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormApprovalScalarFieldEnum | FormApprovalScalarFieldEnum[]
  }

  /**
   * FormSubmission without action
   */
  export type FormSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model FormApproval
   */

  export type AggregateFormApproval = {
    _count: FormApprovalCountAggregateOutputType | null
    _avg: FormApprovalAvgAggregateOutputType | null
    _sum: FormApprovalSumAggregateOutputType | null
    _min: FormApprovalMinAggregateOutputType | null
    _max: FormApprovalMaxAggregateOutputType | null
  }

  export type FormApprovalAvgAggregateOutputType = {
    formSubmissionId: number | null
  }

  export type FormApprovalSumAggregateOutputType = {
    formSubmissionId: number | null
  }

  export type FormApprovalMinAggregateOutputType = {
    id: string | null
    signedBy: string | null
    submittedAt: Date | null
    updatedAt: Date | null
    signature: string | null
    comment: string | null
    formSubmissionId: number | null
  }

  export type FormApprovalMaxAggregateOutputType = {
    id: string | null
    signedBy: string | null
    submittedAt: Date | null
    updatedAt: Date | null
    signature: string | null
    comment: string | null
    formSubmissionId: number | null
  }

  export type FormApprovalCountAggregateOutputType = {
    id: number
    signedBy: number
    submittedAt: number
    updatedAt: number
    signature: number
    comment: number
    formSubmissionId: number
    _all: number
  }


  export type FormApprovalAvgAggregateInputType = {
    formSubmissionId?: true
  }

  export type FormApprovalSumAggregateInputType = {
    formSubmissionId?: true
  }

  export type FormApprovalMinAggregateInputType = {
    id?: true
    signedBy?: true
    submittedAt?: true
    updatedAt?: true
    signature?: true
    comment?: true
    formSubmissionId?: true
  }

  export type FormApprovalMaxAggregateInputType = {
    id?: true
    signedBy?: true
    submittedAt?: true
    updatedAt?: true
    signature?: true
    comment?: true
    formSubmissionId?: true
  }

  export type FormApprovalCountAggregateInputType = {
    id?: true
    signedBy?: true
    submittedAt?: true
    updatedAt?: true
    signature?: true
    comment?: true
    formSubmissionId?: true
    _all?: true
  }

  export type FormApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormApproval to aggregate.
     */
    where?: FormApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormApprovals to fetch.
     */
    orderBy?: FormApprovalOrderByWithRelationInput | FormApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormApprovals
    **/
    _count?: true | FormApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormApprovalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormApprovalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormApprovalMaxAggregateInputType
  }

  export type GetFormApprovalAggregateType<T extends FormApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateFormApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormApproval[P]>
      : GetScalarType<T[P], AggregateFormApproval[P]>
  }




  export type FormApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormApprovalWhereInput
    orderBy?: FormApprovalOrderByWithAggregationInput | FormApprovalOrderByWithAggregationInput[]
    by: FormApprovalScalarFieldEnum[] | FormApprovalScalarFieldEnum
    having?: FormApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormApprovalCountAggregateInputType | true
    _avg?: FormApprovalAvgAggregateInputType
    _sum?: FormApprovalSumAggregateInputType
    _min?: FormApprovalMinAggregateInputType
    _max?: FormApprovalMaxAggregateInputType
  }

  export type FormApprovalGroupByOutputType = {
    id: string
    signedBy: string | null
    submittedAt: Date
    updatedAt: Date
    signature: string | null
    comment: string | null
    formSubmissionId: number
    _count: FormApprovalCountAggregateOutputType | null
    _avg: FormApprovalAvgAggregateOutputType | null
    _sum: FormApprovalSumAggregateOutputType | null
    _min: FormApprovalMinAggregateOutputType | null
    _max: FormApprovalMaxAggregateOutputType | null
  }

  type GetFormApprovalGroupByPayload<T extends FormApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], FormApprovalGroupByOutputType[P]>
        }
      >
    >


  export type FormApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    signedBy?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    signature?: boolean
    comment?: boolean
    formSubmissionId?: boolean
    FormSubmission?: boolean | FormSubmissionDefaultArgs<ExtArgs>
    Approver?: boolean | FormApproval$ApproverArgs<ExtArgs>
  }, ExtArgs["result"]["formApproval"]>

  export type FormApprovalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    signedBy?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    signature?: boolean
    comment?: boolean
    formSubmissionId?: boolean
    FormSubmission?: boolean | FormSubmissionDefaultArgs<ExtArgs>
    Approver?: boolean | FormApproval$ApproverArgs<ExtArgs>
  }, ExtArgs["result"]["formApproval"]>

  export type FormApprovalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    signedBy?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    signature?: boolean
    comment?: boolean
    formSubmissionId?: boolean
    FormSubmission?: boolean | FormSubmissionDefaultArgs<ExtArgs>
    Approver?: boolean | FormApproval$ApproverArgs<ExtArgs>
  }, ExtArgs["result"]["formApproval"]>

  export type FormApprovalSelectScalar = {
    id?: boolean
    signedBy?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    signature?: boolean
    comment?: boolean
    formSubmissionId?: boolean
  }

  export type FormApprovalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "signedBy" | "submittedAt" | "updatedAt" | "signature" | "comment" | "formSubmissionId", ExtArgs["result"]["formApproval"]>
  export type FormApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FormSubmission?: boolean | FormSubmissionDefaultArgs<ExtArgs>
    Approver?: boolean | FormApproval$ApproverArgs<ExtArgs>
  }
  export type FormApprovalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FormSubmission?: boolean | FormSubmissionDefaultArgs<ExtArgs>
    Approver?: boolean | FormApproval$ApproverArgs<ExtArgs>
  }
  export type FormApprovalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    FormSubmission?: boolean | FormSubmissionDefaultArgs<ExtArgs>
    Approver?: boolean | FormApproval$ApproverArgs<ExtArgs>
  }

  export type $FormApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormApproval"
    objects: {
      FormSubmission: Prisma.$FormSubmissionPayload<ExtArgs>
      Approver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      signedBy: string | null
      submittedAt: Date
      updatedAt: Date
      signature: string | null
      comment: string | null
      formSubmissionId: number
    }, ExtArgs["result"]["formApproval"]>
    composites: {}
  }

  type FormApprovalGetPayload<S extends boolean | null | undefined | FormApprovalDefaultArgs> = $Result.GetResult<Prisma.$FormApprovalPayload, S>

  type FormApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormApprovalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormApprovalCountAggregateInputType | true
    }

  export interface FormApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormApproval'], meta: { name: 'FormApproval' } }
    /**
     * Find zero or one FormApproval that matches the filter.
     * @param {FormApprovalFindUniqueArgs} args - Arguments to find a FormApproval
     * @example
     * // Get one FormApproval
     * const formApproval = await prisma.formApproval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormApprovalFindUniqueArgs>(args: SelectSubset<T, FormApprovalFindUniqueArgs<ExtArgs>>): Prisma__FormApprovalClient<$Result.GetResult<Prisma.$FormApprovalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormApproval that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormApprovalFindUniqueOrThrowArgs} args - Arguments to find a FormApproval
     * @example
     * // Get one FormApproval
     * const formApproval = await prisma.formApproval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, FormApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormApprovalClient<$Result.GetResult<Prisma.$FormApprovalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormApproval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormApprovalFindFirstArgs} args - Arguments to find a FormApproval
     * @example
     * // Get one FormApproval
     * const formApproval = await prisma.formApproval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormApprovalFindFirstArgs>(args?: SelectSubset<T, FormApprovalFindFirstArgs<ExtArgs>>): Prisma__FormApprovalClient<$Result.GetResult<Prisma.$FormApprovalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormApproval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormApprovalFindFirstOrThrowArgs} args - Arguments to find a FormApproval
     * @example
     * // Get one FormApproval
     * const formApproval = await prisma.formApproval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, FormApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormApprovalClient<$Result.GetResult<Prisma.$FormApprovalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormApprovals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormApprovals
     * const formApprovals = await prisma.formApproval.findMany()
     * 
     * // Get first 10 FormApprovals
     * const formApprovals = await prisma.formApproval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formApprovalWithIdOnly = await prisma.formApproval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormApprovalFindManyArgs>(args?: SelectSubset<T, FormApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormApproval.
     * @param {FormApprovalCreateArgs} args - Arguments to create a FormApproval.
     * @example
     * // Create one FormApproval
     * const FormApproval = await prisma.formApproval.create({
     *   data: {
     *     // ... data to create a FormApproval
     *   }
     * })
     * 
     */
    create<T extends FormApprovalCreateArgs>(args: SelectSubset<T, FormApprovalCreateArgs<ExtArgs>>): Prisma__FormApprovalClient<$Result.GetResult<Prisma.$FormApprovalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormApprovals.
     * @param {FormApprovalCreateManyArgs} args - Arguments to create many FormApprovals.
     * @example
     * // Create many FormApprovals
     * const formApproval = await prisma.formApproval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormApprovalCreateManyArgs>(args?: SelectSubset<T, FormApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormApprovals and returns the data saved in the database.
     * @param {FormApprovalCreateManyAndReturnArgs} args - Arguments to create many FormApprovals.
     * @example
     * // Create many FormApprovals
     * const formApproval = await prisma.formApproval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormApprovals and only return the `id`
     * const formApprovalWithIdOnly = await prisma.formApproval.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormApprovalCreateManyAndReturnArgs>(args?: SelectSubset<T, FormApprovalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormApprovalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormApproval.
     * @param {FormApprovalDeleteArgs} args - Arguments to delete one FormApproval.
     * @example
     * // Delete one FormApproval
     * const FormApproval = await prisma.formApproval.delete({
     *   where: {
     *     // ... filter to delete one FormApproval
     *   }
     * })
     * 
     */
    delete<T extends FormApprovalDeleteArgs>(args: SelectSubset<T, FormApprovalDeleteArgs<ExtArgs>>): Prisma__FormApprovalClient<$Result.GetResult<Prisma.$FormApprovalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormApproval.
     * @param {FormApprovalUpdateArgs} args - Arguments to update one FormApproval.
     * @example
     * // Update one FormApproval
     * const formApproval = await prisma.formApproval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormApprovalUpdateArgs>(args: SelectSubset<T, FormApprovalUpdateArgs<ExtArgs>>): Prisma__FormApprovalClient<$Result.GetResult<Prisma.$FormApprovalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormApprovals.
     * @param {FormApprovalDeleteManyArgs} args - Arguments to filter FormApprovals to delete.
     * @example
     * // Delete a few FormApprovals
     * const { count } = await prisma.formApproval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormApprovalDeleteManyArgs>(args?: SelectSubset<T, FormApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormApprovals
     * const formApproval = await prisma.formApproval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormApprovalUpdateManyArgs>(args: SelectSubset<T, FormApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormApprovals and returns the data updated in the database.
     * @param {FormApprovalUpdateManyAndReturnArgs} args - Arguments to update many FormApprovals.
     * @example
     * // Update many FormApprovals
     * const formApproval = await prisma.formApproval.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormApprovals and only return the `id`
     * const formApprovalWithIdOnly = await prisma.formApproval.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormApprovalUpdateManyAndReturnArgs>(args: SelectSubset<T, FormApprovalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormApprovalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormApproval.
     * @param {FormApprovalUpsertArgs} args - Arguments to update or create a FormApproval.
     * @example
     * // Update or create a FormApproval
     * const formApproval = await prisma.formApproval.upsert({
     *   create: {
     *     // ... data to create a FormApproval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormApproval we want to update
     *   }
     * })
     */
    upsert<T extends FormApprovalUpsertArgs>(args: SelectSubset<T, FormApprovalUpsertArgs<ExtArgs>>): Prisma__FormApprovalClient<$Result.GetResult<Prisma.$FormApprovalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormApprovalCountArgs} args - Arguments to filter FormApprovals to count.
     * @example
     * // Count the number of FormApprovals
     * const count = await prisma.formApproval.count({
     *   where: {
     *     // ... the filter for the FormApprovals we want to count
     *   }
     * })
    **/
    count<T extends FormApprovalCountArgs>(
      args?: Subset<T, FormApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormApprovalAggregateArgs>(args: Subset<T, FormApprovalAggregateArgs>): Prisma.PrismaPromise<GetFormApprovalAggregateType<T>>

    /**
     * Group by FormApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormApprovalGroupByArgs['orderBy'] }
        : { orderBy?: FormApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormApproval model
   */
  readonly fields: FormApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormApproval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    FormSubmission<T extends FormSubmissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormSubmissionDefaultArgs<ExtArgs>>): Prisma__FormSubmissionClient<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Approver<T extends FormApproval$ApproverArgs<ExtArgs> = {}>(args?: Subset<T, FormApproval$ApproverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormApproval model
   */
  interface FormApprovalFieldRefs {
    readonly id: FieldRef<"FormApproval", 'String'>
    readonly signedBy: FieldRef<"FormApproval", 'String'>
    readonly submittedAt: FieldRef<"FormApproval", 'DateTime'>
    readonly updatedAt: FieldRef<"FormApproval", 'DateTime'>
    readonly signature: FieldRef<"FormApproval", 'String'>
    readonly comment: FieldRef<"FormApproval", 'String'>
    readonly formSubmissionId: FieldRef<"FormApproval", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FormApproval findUnique
   */
  export type FormApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormApproval
     */
    select?: FormApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormApproval
     */
    omit?: FormApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormApprovalInclude<ExtArgs> | null
    /**
     * Filter, which FormApproval to fetch.
     */
    where: FormApprovalWhereUniqueInput
  }

  /**
   * FormApproval findUniqueOrThrow
   */
  export type FormApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormApproval
     */
    select?: FormApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormApproval
     */
    omit?: FormApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormApprovalInclude<ExtArgs> | null
    /**
     * Filter, which FormApproval to fetch.
     */
    where: FormApprovalWhereUniqueInput
  }

  /**
   * FormApproval findFirst
   */
  export type FormApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormApproval
     */
    select?: FormApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormApproval
     */
    omit?: FormApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormApprovalInclude<ExtArgs> | null
    /**
     * Filter, which FormApproval to fetch.
     */
    where?: FormApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormApprovals to fetch.
     */
    orderBy?: FormApprovalOrderByWithRelationInput | FormApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormApprovals.
     */
    cursor?: FormApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormApprovals.
     */
    distinct?: FormApprovalScalarFieldEnum | FormApprovalScalarFieldEnum[]
  }

  /**
   * FormApproval findFirstOrThrow
   */
  export type FormApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormApproval
     */
    select?: FormApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormApproval
     */
    omit?: FormApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormApprovalInclude<ExtArgs> | null
    /**
     * Filter, which FormApproval to fetch.
     */
    where?: FormApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormApprovals to fetch.
     */
    orderBy?: FormApprovalOrderByWithRelationInput | FormApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormApprovals.
     */
    cursor?: FormApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormApprovals.
     */
    distinct?: FormApprovalScalarFieldEnum | FormApprovalScalarFieldEnum[]
  }

  /**
   * FormApproval findMany
   */
  export type FormApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormApproval
     */
    select?: FormApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormApproval
     */
    omit?: FormApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormApprovalInclude<ExtArgs> | null
    /**
     * Filter, which FormApprovals to fetch.
     */
    where?: FormApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormApprovals to fetch.
     */
    orderBy?: FormApprovalOrderByWithRelationInput | FormApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormApprovals.
     */
    cursor?: FormApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormApprovals.
     */
    skip?: number
    distinct?: FormApprovalScalarFieldEnum | FormApprovalScalarFieldEnum[]
  }

  /**
   * FormApproval create
   */
  export type FormApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormApproval
     */
    select?: FormApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormApproval
     */
    omit?: FormApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a FormApproval.
     */
    data: XOR<FormApprovalCreateInput, FormApprovalUncheckedCreateInput>
  }

  /**
   * FormApproval createMany
   */
  export type FormApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormApprovals.
     */
    data: FormApprovalCreateManyInput | FormApprovalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormApproval createManyAndReturn
   */
  export type FormApprovalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormApproval
     */
    select?: FormApprovalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormApproval
     */
    omit?: FormApprovalOmit<ExtArgs> | null
    /**
     * The data used to create many FormApprovals.
     */
    data: FormApprovalCreateManyInput | FormApprovalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormApprovalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormApproval update
   */
  export type FormApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormApproval
     */
    select?: FormApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormApproval
     */
    omit?: FormApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a FormApproval.
     */
    data: XOR<FormApprovalUpdateInput, FormApprovalUncheckedUpdateInput>
    /**
     * Choose, which FormApproval to update.
     */
    where: FormApprovalWhereUniqueInput
  }

  /**
   * FormApproval updateMany
   */
  export type FormApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormApprovals.
     */
    data: XOR<FormApprovalUpdateManyMutationInput, FormApprovalUncheckedUpdateManyInput>
    /**
     * Filter which FormApprovals to update
     */
    where?: FormApprovalWhereInput
    /**
     * Limit how many FormApprovals to update.
     */
    limit?: number
  }

  /**
   * FormApproval updateManyAndReturn
   */
  export type FormApprovalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormApproval
     */
    select?: FormApprovalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormApproval
     */
    omit?: FormApprovalOmit<ExtArgs> | null
    /**
     * The data used to update FormApprovals.
     */
    data: XOR<FormApprovalUpdateManyMutationInput, FormApprovalUncheckedUpdateManyInput>
    /**
     * Filter which FormApprovals to update
     */
    where?: FormApprovalWhereInput
    /**
     * Limit how many FormApprovals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormApprovalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FormApproval upsert
   */
  export type FormApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormApproval
     */
    select?: FormApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormApproval
     */
    omit?: FormApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the FormApproval to update in case it exists.
     */
    where: FormApprovalWhereUniqueInput
    /**
     * In case the FormApproval found by the `where` argument doesn't exist, create a new FormApproval with this data.
     */
    create: XOR<FormApprovalCreateInput, FormApprovalUncheckedCreateInput>
    /**
     * In case the FormApproval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormApprovalUpdateInput, FormApprovalUncheckedUpdateInput>
  }

  /**
   * FormApproval delete
   */
  export type FormApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormApproval
     */
    select?: FormApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormApproval
     */
    omit?: FormApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormApprovalInclude<ExtArgs> | null
    /**
     * Filter which FormApproval to delete.
     */
    where: FormApprovalWhereUniqueInput
  }

  /**
   * FormApproval deleteMany
   */
  export type FormApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormApprovals to delete
     */
    where?: FormApprovalWhereInput
    /**
     * Limit how many FormApprovals to delete.
     */
    limit?: number
  }

  /**
   * FormApproval.Approver
   */
  export type FormApproval$ApproverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * FormApproval without action
   */
  export type FormApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormApproval
     */
    select?: FormApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormApproval
     */
    omit?: FormApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormApprovalInclude<ExtArgs> | null
  }


  /**
   * Model Jobsite
   */

  export type AggregateJobsite = {
    _count: JobsiteCountAggregateOutputType | null
    _avg: JobsiteAvgAggregateOutputType | null
    _sum: JobsiteSumAggregateOutputType | null
    _min: JobsiteMinAggregateOutputType | null
    _max: JobsiteMaxAggregateOutputType | null
  }

  export type JobsiteAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    radiusMeters: number | null
  }

  export type JobsiteSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    radiusMeters: number | null
  }

  export type JobsiteMinAggregateOutputType = {
    id: string | null
    qrId: string | null
    name: string | null
    description: string | null
    creationReason: string | null
    approvalStatus: $Enums.ApprovalStatus | null
    addressId: string | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
    archiveDate: Date | null
    createdById: string | null
    createdVia: $Enums.CreatedVia | null
    code: string | null
    latitude: number | null
    longitude: number | null
    radiusMeters: number | null
    status: $Enums.FormTemplateStatus | null
  }

  export type JobsiteMaxAggregateOutputType = {
    id: string | null
    qrId: string | null
    name: string | null
    description: string | null
    creationReason: string | null
    approvalStatus: $Enums.ApprovalStatus | null
    addressId: string | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
    archiveDate: Date | null
    createdById: string | null
    createdVia: $Enums.CreatedVia | null
    code: string | null
    latitude: number | null
    longitude: number | null
    radiusMeters: number | null
    status: $Enums.FormTemplateStatus | null
  }

  export type JobsiteCountAggregateOutputType = {
    id: number
    qrId: number
    name: number
    description: number
    creationReason: number
    approvalStatus: number
    addressId: number
    comment: number
    createdAt: number
    updatedAt: number
    archiveDate: number
    createdById: number
    createdVia: number
    code: number
    latitude: number
    longitude: number
    radiusMeters: number
    status: number
    _all: number
  }


  export type JobsiteAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    radiusMeters?: true
  }

  export type JobsiteSumAggregateInputType = {
    latitude?: true
    longitude?: true
    radiusMeters?: true
  }

  export type JobsiteMinAggregateInputType = {
    id?: true
    qrId?: true
    name?: true
    description?: true
    creationReason?: true
    approvalStatus?: true
    addressId?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    archiveDate?: true
    createdById?: true
    createdVia?: true
    code?: true
    latitude?: true
    longitude?: true
    radiusMeters?: true
    status?: true
  }

  export type JobsiteMaxAggregateInputType = {
    id?: true
    qrId?: true
    name?: true
    description?: true
    creationReason?: true
    approvalStatus?: true
    addressId?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    archiveDate?: true
    createdById?: true
    createdVia?: true
    code?: true
    latitude?: true
    longitude?: true
    radiusMeters?: true
    status?: true
  }

  export type JobsiteCountAggregateInputType = {
    id?: true
    qrId?: true
    name?: true
    description?: true
    creationReason?: true
    approvalStatus?: true
    addressId?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    archiveDate?: true
    createdById?: true
    createdVia?: true
    code?: true
    latitude?: true
    longitude?: true
    radiusMeters?: true
    status?: true
    _all?: true
  }

  export type JobsiteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobsite to aggregate.
     */
    where?: JobsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobsites to fetch.
     */
    orderBy?: JobsiteOrderByWithRelationInput | JobsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobsites
    **/
    _count?: true | JobsiteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobsiteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobsiteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobsiteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobsiteMaxAggregateInputType
  }

  export type GetJobsiteAggregateType<T extends JobsiteAggregateArgs> = {
        [P in keyof T & keyof AggregateJobsite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobsite[P]>
      : GetScalarType<T[P], AggregateJobsite[P]>
  }




  export type JobsiteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsiteWhereInput
    orderBy?: JobsiteOrderByWithAggregationInput | JobsiteOrderByWithAggregationInput[]
    by: JobsiteScalarFieldEnum[] | JobsiteScalarFieldEnum
    having?: JobsiteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobsiteCountAggregateInputType | true
    _avg?: JobsiteAvgAggregateInputType
    _sum?: JobsiteSumAggregateInputType
    _min?: JobsiteMinAggregateInputType
    _max?: JobsiteMaxAggregateInputType
  }

  export type JobsiteGroupByOutputType = {
    id: string
    qrId: string
    name: string
    description: string
    creationReason: string | null
    approvalStatus: $Enums.ApprovalStatus
    addressId: string | null
    comment: string | null
    createdAt: Date
    updatedAt: Date
    archiveDate: Date | null
    createdById: string | null
    createdVia: $Enums.CreatedVia
    code: string | null
    latitude: number | null
    longitude: number | null
    radiusMeters: number | null
    status: $Enums.FormTemplateStatus
    _count: JobsiteCountAggregateOutputType | null
    _avg: JobsiteAvgAggregateOutputType | null
    _sum: JobsiteSumAggregateOutputType | null
    _min: JobsiteMinAggregateOutputType | null
    _max: JobsiteMaxAggregateOutputType | null
  }

  type GetJobsiteGroupByPayload<T extends JobsiteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobsiteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobsiteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobsiteGroupByOutputType[P]>
            : GetScalarType<T[P], JobsiteGroupByOutputType[P]>
        }
      >
    >


  export type JobsiteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qrId?: boolean
    name?: boolean
    description?: boolean
    creationReason?: boolean
    approvalStatus?: boolean
    addressId?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archiveDate?: boolean
    createdById?: boolean
    createdVia?: boolean
    code?: boolean
    latitude?: boolean
    longitude?: boolean
    radiusMeters?: boolean
    status?: boolean
    Address?: boolean | Jobsite$AddressArgs<ExtArgs>
    createdBy?: boolean | Jobsite$createdByArgs<ExtArgs>
    TimeSheets?: boolean | Jobsite$TimeSheetsArgs<ExtArgs>
    CCTags?: boolean | Jobsite$CCTagsArgs<ExtArgs>
    _count?: boolean | JobsiteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobsite"]>

  export type JobsiteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qrId?: boolean
    name?: boolean
    description?: boolean
    creationReason?: boolean
    approvalStatus?: boolean
    addressId?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archiveDate?: boolean
    createdById?: boolean
    createdVia?: boolean
    code?: boolean
    latitude?: boolean
    longitude?: boolean
    radiusMeters?: boolean
    status?: boolean
    Address?: boolean | Jobsite$AddressArgs<ExtArgs>
    createdBy?: boolean | Jobsite$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["jobsite"]>

  export type JobsiteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    qrId?: boolean
    name?: boolean
    description?: boolean
    creationReason?: boolean
    approvalStatus?: boolean
    addressId?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archiveDate?: boolean
    createdById?: boolean
    createdVia?: boolean
    code?: boolean
    latitude?: boolean
    longitude?: boolean
    radiusMeters?: boolean
    status?: boolean
    Address?: boolean | Jobsite$AddressArgs<ExtArgs>
    createdBy?: boolean | Jobsite$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["jobsite"]>

  export type JobsiteSelectScalar = {
    id?: boolean
    qrId?: boolean
    name?: boolean
    description?: boolean
    creationReason?: boolean
    approvalStatus?: boolean
    addressId?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archiveDate?: boolean
    createdById?: boolean
    createdVia?: boolean
    code?: boolean
    latitude?: boolean
    longitude?: boolean
    radiusMeters?: boolean
    status?: boolean
  }

  export type JobsiteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "qrId" | "name" | "description" | "creationReason" | "approvalStatus" | "addressId" | "comment" | "createdAt" | "updatedAt" | "archiveDate" | "createdById" | "createdVia" | "code" | "latitude" | "longitude" | "radiusMeters" | "status", ExtArgs["result"]["jobsite"]>
  export type JobsiteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Address?: boolean | Jobsite$AddressArgs<ExtArgs>
    createdBy?: boolean | Jobsite$createdByArgs<ExtArgs>
    TimeSheets?: boolean | Jobsite$TimeSheetsArgs<ExtArgs>
    CCTags?: boolean | Jobsite$CCTagsArgs<ExtArgs>
    _count?: boolean | JobsiteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type JobsiteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Address?: boolean | Jobsite$AddressArgs<ExtArgs>
    createdBy?: boolean | Jobsite$createdByArgs<ExtArgs>
  }
  export type JobsiteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Address?: boolean | Jobsite$AddressArgs<ExtArgs>
    createdBy?: boolean | Jobsite$createdByArgs<ExtArgs>
  }

  export type $JobsitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Jobsite"
    objects: {
      Address: Prisma.$AddressPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      TimeSheets: Prisma.$TimeSheetPayload<ExtArgs>[]
      CCTags: Prisma.$CCTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      qrId: string
      name: string
      description: string
      creationReason: string | null
      approvalStatus: $Enums.ApprovalStatus
      addressId: string | null
      comment: string | null
      createdAt: Date
      updatedAt: Date
      archiveDate: Date | null
      createdById: string | null
      createdVia: $Enums.CreatedVia
      code: string | null
      latitude: number | null
      longitude: number | null
      radiusMeters: number | null
      status: $Enums.FormTemplateStatus
    }, ExtArgs["result"]["jobsite"]>
    composites: {}
  }

  type JobsiteGetPayload<S extends boolean | null | undefined | JobsiteDefaultArgs> = $Result.GetResult<Prisma.$JobsitePayload, S>

  type JobsiteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JobsiteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobsiteCountAggregateInputType | true
    }

  export interface JobsiteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Jobsite'], meta: { name: 'Jobsite' } }
    /**
     * Find zero or one Jobsite that matches the filter.
     * @param {JobsiteFindUniqueArgs} args - Arguments to find a Jobsite
     * @example
     * // Get one Jobsite
     * const jobsite = await prisma.jobsite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobsiteFindUniqueArgs>(args: SelectSubset<T, JobsiteFindUniqueArgs<ExtArgs>>): Prisma__JobsiteClient<$Result.GetResult<Prisma.$JobsitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Jobsite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JobsiteFindUniqueOrThrowArgs} args - Arguments to find a Jobsite
     * @example
     * // Get one Jobsite
     * const jobsite = await prisma.jobsite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobsiteFindUniqueOrThrowArgs>(args: SelectSubset<T, JobsiteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobsiteClient<$Result.GetResult<Prisma.$JobsitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobsite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsiteFindFirstArgs} args - Arguments to find a Jobsite
     * @example
     * // Get one Jobsite
     * const jobsite = await prisma.jobsite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobsiteFindFirstArgs>(args?: SelectSubset<T, JobsiteFindFirstArgs<ExtArgs>>): Prisma__JobsiteClient<$Result.GetResult<Prisma.$JobsitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobsite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsiteFindFirstOrThrowArgs} args - Arguments to find a Jobsite
     * @example
     * // Get one Jobsite
     * const jobsite = await prisma.jobsite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobsiteFindFirstOrThrowArgs>(args?: SelectSubset<T, JobsiteFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobsiteClient<$Result.GetResult<Prisma.$JobsitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobsites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsiteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobsites
     * const jobsites = await prisma.jobsite.findMany()
     * 
     * // Get first 10 Jobsites
     * const jobsites = await prisma.jobsite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobsiteWithIdOnly = await prisma.jobsite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobsiteFindManyArgs>(args?: SelectSubset<T, JobsiteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Jobsite.
     * @param {JobsiteCreateArgs} args - Arguments to create a Jobsite.
     * @example
     * // Create one Jobsite
     * const Jobsite = await prisma.jobsite.create({
     *   data: {
     *     // ... data to create a Jobsite
     *   }
     * })
     * 
     */
    create<T extends JobsiteCreateArgs>(args: SelectSubset<T, JobsiteCreateArgs<ExtArgs>>): Prisma__JobsiteClient<$Result.GetResult<Prisma.$JobsitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobsites.
     * @param {JobsiteCreateManyArgs} args - Arguments to create many Jobsites.
     * @example
     * // Create many Jobsites
     * const jobsite = await prisma.jobsite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobsiteCreateManyArgs>(args?: SelectSubset<T, JobsiteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobsites and returns the data saved in the database.
     * @param {JobsiteCreateManyAndReturnArgs} args - Arguments to create many Jobsites.
     * @example
     * // Create many Jobsites
     * const jobsite = await prisma.jobsite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobsites and only return the `id`
     * const jobsiteWithIdOnly = await prisma.jobsite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobsiteCreateManyAndReturnArgs>(args?: SelectSubset<T, JobsiteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Jobsite.
     * @param {JobsiteDeleteArgs} args - Arguments to delete one Jobsite.
     * @example
     * // Delete one Jobsite
     * const Jobsite = await prisma.jobsite.delete({
     *   where: {
     *     // ... filter to delete one Jobsite
     *   }
     * })
     * 
     */
    delete<T extends JobsiteDeleteArgs>(args: SelectSubset<T, JobsiteDeleteArgs<ExtArgs>>): Prisma__JobsiteClient<$Result.GetResult<Prisma.$JobsitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Jobsite.
     * @param {JobsiteUpdateArgs} args - Arguments to update one Jobsite.
     * @example
     * // Update one Jobsite
     * const jobsite = await prisma.jobsite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobsiteUpdateArgs>(args: SelectSubset<T, JobsiteUpdateArgs<ExtArgs>>): Prisma__JobsiteClient<$Result.GetResult<Prisma.$JobsitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobsites.
     * @param {JobsiteDeleteManyArgs} args - Arguments to filter Jobsites to delete.
     * @example
     * // Delete a few Jobsites
     * const { count } = await prisma.jobsite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobsiteDeleteManyArgs>(args?: SelectSubset<T, JobsiteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobsites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsiteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobsites
     * const jobsite = await prisma.jobsite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobsiteUpdateManyArgs>(args: SelectSubset<T, JobsiteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobsites and returns the data updated in the database.
     * @param {JobsiteUpdateManyAndReturnArgs} args - Arguments to update many Jobsites.
     * @example
     * // Update many Jobsites
     * const jobsite = await prisma.jobsite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Jobsites and only return the `id`
     * const jobsiteWithIdOnly = await prisma.jobsite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JobsiteUpdateManyAndReturnArgs>(args: SelectSubset<T, JobsiteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Jobsite.
     * @param {JobsiteUpsertArgs} args - Arguments to update or create a Jobsite.
     * @example
     * // Update or create a Jobsite
     * const jobsite = await prisma.jobsite.upsert({
     *   create: {
     *     // ... data to create a Jobsite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobsite we want to update
     *   }
     * })
     */
    upsert<T extends JobsiteUpsertArgs>(args: SelectSubset<T, JobsiteUpsertArgs<ExtArgs>>): Prisma__JobsiteClient<$Result.GetResult<Prisma.$JobsitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobsites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsiteCountArgs} args - Arguments to filter Jobsites to count.
     * @example
     * // Count the number of Jobsites
     * const count = await prisma.jobsite.count({
     *   where: {
     *     // ... the filter for the Jobsites we want to count
     *   }
     * })
    **/
    count<T extends JobsiteCountArgs>(
      args?: Subset<T, JobsiteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobsiteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobsite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsiteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobsiteAggregateArgs>(args: Subset<T, JobsiteAggregateArgs>): Prisma.PrismaPromise<GetJobsiteAggregateType<T>>

    /**
     * Group by Jobsite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsiteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobsiteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobsiteGroupByArgs['orderBy'] }
        : { orderBy?: JobsiteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobsiteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobsiteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Jobsite model
   */
  readonly fields: JobsiteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Jobsite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobsiteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Address<T extends Jobsite$AddressArgs<ExtArgs> = {}>(args?: Subset<T, Jobsite$AddressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Jobsite$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Jobsite$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    TimeSheets<T extends Jobsite$TimeSheetsArgs<ExtArgs> = {}>(args?: Subset<T, Jobsite$TimeSheetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CCTags<T extends Jobsite$CCTagsArgs<ExtArgs> = {}>(args?: Subset<T, Jobsite$CCTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CCTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Jobsite model
   */
  interface JobsiteFieldRefs {
    readonly id: FieldRef<"Jobsite", 'String'>
    readonly qrId: FieldRef<"Jobsite", 'String'>
    readonly name: FieldRef<"Jobsite", 'String'>
    readonly description: FieldRef<"Jobsite", 'String'>
    readonly creationReason: FieldRef<"Jobsite", 'String'>
    readonly approvalStatus: FieldRef<"Jobsite", 'ApprovalStatus'>
    readonly addressId: FieldRef<"Jobsite", 'String'>
    readonly comment: FieldRef<"Jobsite", 'String'>
    readonly createdAt: FieldRef<"Jobsite", 'DateTime'>
    readonly updatedAt: FieldRef<"Jobsite", 'DateTime'>
    readonly archiveDate: FieldRef<"Jobsite", 'DateTime'>
    readonly createdById: FieldRef<"Jobsite", 'String'>
    readonly createdVia: FieldRef<"Jobsite", 'CreatedVia'>
    readonly code: FieldRef<"Jobsite", 'String'>
    readonly latitude: FieldRef<"Jobsite", 'Float'>
    readonly longitude: FieldRef<"Jobsite", 'Float'>
    readonly radiusMeters: FieldRef<"Jobsite", 'Float'>
    readonly status: FieldRef<"Jobsite", 'FormTemplateStatus'>
  }
    

  // Custom InputTypes
  /**
   * Jobsite findUnique
   */
  export type JobsiteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobsite
     */
    select?: JobsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobsite
     */
    omit?: JobsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsiteInclude<ExtArgs> | null
    /**
     * Filter, which Jobsite to fetch.
     */
    where: JobsiteWhereUniqueInput
  }

  /**
   * Jobsite findUniqueOrThrow
   */
  export type JobsiteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobsite
     */
    select?: JobsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobsite
     */
    omit?: JobsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsiteInclude<ExtArgs> | null
    /**
     * Filter, which Jobsite to fetch.
     */
    where: JobsiteWhereUniqueInput
  }

  /**
   * Jobsite findFirst
   */
  export type JobsiteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobsite
     */
    select?: JobsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobsite
     */
    omit?: JobsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsiteInclude<ExtArgs> | null
    /**
     * Filter, which Jobsite to fetch.
     */
    where?: JobsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobsites to fetch.
     */
    orderBy?: JobsiteOrderByWithRelationInput | JobsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobsites.
     */
    cursor?: JobsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobsites.
     */
    distinct?: JobsiteScalarFieldEnum | JobsiteScalarFieldEnum[]
  }

  /**
   * Jobsite findFirstOrThrow
   */
  export type JobsiteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobsite
     */
    select?: JobsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobsite
     */
    omit?: JobsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsiteInclude<ExtArgs> | null
    /**
     * Filter, which Jobsite to fetch.
     */
    where?: JobsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobsites to fetch.
     */
    orderBy?: JobsiteOrderByWithRelationInput | JobsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobsites.
     */
    cursor?: JobsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobsites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobsites.
     */
    distinct?: JobsiteScalarFieldEnum | JobsiteScalarFieldEnum[]
  }

  /**
   * Jobsite findMany
   */
  export type JobsiteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobsite
     */
    select?: JobsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobsite
     */
    omit?: JobsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsiteInclude<ExtArgs> | null
    /**
     * Filter, which Jobsites to fetch.
     */
    where?: JobsiteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobsites to fetch.
     */
    orderBy?: JobsiteOrderByWithRelationInput | JobsiteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobsites.
     */
    cursor?: JobsiteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobsites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobsites.
     */
    skip?: number
    distinct?: JobsiteScalarFieldEnum | JobsiteScalarFieldEnum[]
  }

  /**
   * Jobsite create
   */
  export type JobsiteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobsite
     */
    select?: JobsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobsite
     */
    omit?: JobsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsiteInclude<ExtArgs> | null
    /**
     * The data needed to create a Jobsite.
     */
    data: XOR<JobsiteCreateInput, JobsiteUncheckedCreateInput>
  }

  /**
   * Jobsite createMany
   */
  export type JobsiteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobsites.
     */
    data: JobsiteCreateManyInput | JobsiteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Jobsite createManyAndReturn
   */
  export type JobsiteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobsite
     */
    select?: JobsiteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Jobsite
     */
    omit?: JobsiteOmit<ExtArgs> | null
    /**
     * The data used to create many Jobsites.
     */
    data: JobsiteCreateManyInput | JobsiteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsiteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Jobsite update
   */
  export type JobsiteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobsite
     */
    select?: JobsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobsite
     */
    omit?: JobsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsiteInclude<ExtArgs> | null
    /**
     * The data needed to update a Jobsite.
     */
    data: XOR<JobsiteUpdateInput, JobsiteUncheckedUpdateInput>
    /**
     * Choose, which Jobsite to update.
     */
    where: JobsiteWhereUniqueInput
  }

  /**
   * Jobsite updateMany
   */
  export type JobsiteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobsites.
     */
    data: XOR<JobsiteUpdateManyMutationInput, JobsiteUncheckedUpdateManyInput>
    /**
     * Filter which Jobsites to update
     */
    where?: JobsiteWhereInput
    /**
     * Limit how many Jobsites to update.
     */
    limit?: number
  }

  /**
   * Jobsite updateManyAndReturn
   */
  export type JobsiteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobsite
     */
    select?: JobsiteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Jobsite
     */
    omit?: JobsiteOmit<ExtArgs> | null
    /**
     * The data used to update Jobsites.
     */
    data: XOR<JobsiteUpdateManyMutationInput, JobsiteUncheckedUpdateManyInput>
    /**
     * Filter which Jobsites to update
     */
    where?: JobsiteWhereInput
    /**
     * Limit how many Jobsites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsiteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Jobsite upsert
   */
  export type JobsiteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobsite
     */
    select?: JobsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobsite
     */
    omit?: JobsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsiteInclude<ExtArgs> | null
    /**
     * The filter to search for the Jobsite to update in case it exists.
     */
    where: JobsiteWhereUniqueInput
    /**
     * In case the Jobsite found by the `where` argument doesn't exist, create a new Jobsite with this data.
     */
    create: XOR<JobsiteCreateInput, JobsiteUncheckedCreateInput>
    /**
     * In case the Jobsite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobsiteUpdateInput, JobsiteUncheckedUpdateInput>
  }

  /**
   * Jobsite delete
   */
  export type JobsiteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobsite
     */
    select?: JobsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobsite
     */
    omit?: JobsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsiteInclude<ExtArgs> | null
    /**
     * Filter which Jobsite to delete.
     */
    where: JobsiteWhereUniqueInput
  }

  /**
   * Jobsite deleteMany
   */
  export type JobsiteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobsites to delete
     */
    where?: JobsiteWhereInput
    /**
     * Limit how many Jobsites to delete.
     */
    limit?: number
  }

  /**
   * Jobsite.Address
   */
  export type Jobsite$AddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Jobsite.createdBy
   */
  export type Jobsite$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Jobsite.TimeSheets
   */
  export type Jobsite$TimeSheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheet
     */
    select?: TimeSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheet
     */
    omit?: TimeSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetInclude<ExtArgs> | null
    where?: TimeSheetWhereInput
    orderBy?: TimeSheetOrderByWithRelationInput | TimeSheetOrderByWithRelationInput[]
    cursor?: TimeSheetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeSheetScalarFieldEnum | TimeSheetScalarFieldEnum[]
  }

  /**
   * Jobsite.CCTags
   */
  export type Jobsite$CCTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CCTag
     */
    select?: CCTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CCTag
     */
    omit?: CCTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CCTagInclude<ExtArgs> | null
    where?: CCTagWhereInput
    orderBy?: CCTagOrderByWithRelationInput | CCTagOrderByWithRelationInput[]
    cursor?: CCTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CCTagScalarFieldEnum | CCTagScalarFieldEnum[]
  }

  /**
   * Jobsite without action
   */
  export type JobsiteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobsite
     */
    select?: JobsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobsite
     */
    omit?: JobsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsiteInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    id: number | null
  }

  export type ReportSumAggregateOutputType = {
    id: number | null
  }

  export type ReportMinAggregateOutputType = {
    name: string | null
    description: string | null
    companyId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    visibility: $Enums.ReportVisibility | null
    id: number | null
  }

  export type ReportMaxAggregateOutputType = {
    name: string | null
    description: string | null
    companyId: string | null
    createdAt: Date | null
    createdBy: string | null
    updatedAt: Date | null
    visibility: $Enums.ReportVisibility | null
    id: number | null
  }

  export type ReportCountAggregateOutputType = {
    name: number
    description: number
    companyId: number
    createdAt: number
    createdBy: number
    updatedAt: number
    parameters: number
    visibility: number
    tags: number
    id: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    id?: true
  }

  export type ReportSumAggregateInputType = {
    id?: true
  }

  export type ReportMinAggregateInputType = {
    name?: true
    description?: true
    companyId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    visibility?: true
    id?: true
  }

  export type ReportMaxAggregateInputType = {
    name?: true
    description?: true
    companyId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    visibility?: true
    id?: true
  }

  export type ReportCountAggregateInputType = {
    name?: true
    description?: true
    companyId?: true
    createdAt?: true
    createdBy?: true
    updatedAt?: true
    parameters?: true
    visibility?: true
    tags?: true
    id?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    name: string
    description: string
    companyId: string
    createdAt: Date
    createdBy: string
    updatedAt: Date
    parameters: JsonValue | null
    visibility: $Enums.ReportVisibility
    tags: string[]
    id: number
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    companyId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    parameters?: boolean
    visibility?: boolean
    tags?: boolean
    id?: boolean
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
    ReportRuns?: boolean | Report$ReportRunsArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    companyId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    parameters?: boolean
    visibility?: boolean
    tags?: boolean
    id?: boolean
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    description?: boolean
    companyId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    parameters?: boolean
    visibility?: boolean
    tags?: boolean
    id?: boolean
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    name?: boolean
    description?: boolean
    companyId?: boolean
    createdAt?: boolean
    createdBy?: boolean
    updatedAt?: boolean
    parameters?: boolean
    visibility?: boolean
    tags?: boolean
    id?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "description" | "companyId" | "createdAt" | "createdBy" | "updatedAt" | "parameters" | "visibility" | "tags" | "id", ExtArgs["result"]["report"]>
  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
    ReportRuns?: boolean | Report$ReportRunsArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type ReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      Company: Prisma.$CompanyPayload<ExtArgs>
      ReportRuns: Prisma.$ReportRunPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      description: string
      companyId: string
      createdAt: Date
      createdBy: string
      updatedAt: Date
      parameters: Prisma.JsonValue | null
      visibility: $Enums.ReportVisibility
      tags: string[]
      id: number
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const reportWithNameOnly = await prisma.report.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `name`
     * const reportWithNameOnly = await prisma.report.createManyAndReturn({
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports and returns the data updated in the database.
     * @param {ReportUpdateManyAndReturnArgs} args - Arguments to update many Reports.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reports and only return the `name`
     * const reportWithNameOnly = await prisma.report.updateManyAndReturn({
     *   select: { name: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ReportRuns<T extends Report$ReportRunsArgs<ExtArgs> = {}>(args?: Subset<T, Report$ReportRunsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly name: FieldRef<"Report", 'String'>
    readonly description: FieldRef<"Report", 'String'>
    readonly companyId: FieldRef<"Report", 'String'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly createdBy: FieldRef<"Report", 'String'>
    readonly updatedAt: FieldRef<"Report", 'DateTime'>
    readonly parameters: FieldRef<"Report", 'Json'>
    readonly visibility: FieldRef<"Report", 'ReportVisibility'>
    readonly tags: FieldRef<"Report", 'String[]'>
    readonly id: FieldRef<"Report", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report updateManyAndReturn
   */
  export type ReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report.ReportRuns
   */
  export type Report$ReportRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportRun
     */
    select?: ReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportRun
     */
    omit?: ReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportRunInclude<ExtArgs> | null
    where?: ReportRunWhereInput
    orderBy?: ReportRunOrderByWithRelationInput | ReportRunOrderByWithRelationInput[]
    cursor?: ReportRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportRunScalarFieldEnum | ReportRunScalarFieldEnum[]
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model ReportRun
   */

  export type AggregateReportRun = {
    _count: ReportRunCountAggregateOutputType | null
    _avg: ReportRunAvgAggregateOutputType | null
    _sum: ReportRunSumAggregateOutputType | null
    _min: ReportRunMinAggregateOutputType | null
    _max: ReportRunMaxAggregateOutputType | null
  }

  export type ReportRunAvgAggregateOutputType = {
    duration: number | null
    reportId: number | null
  }

  export type ReportRunSumAggregateOutputType = {
    duration: number | null
    reportId: number | null
  }

  export type ReportRunMinAggregateOutputType = {
    id: string | null
    runAt: Date | null
    status: $Enums.ReportStatus | null
    duration: number | null
    startDate: Date | null
    endDate: Date | null
    lastExportedAt: Date | null
    reportId: number | null
  }

  export type ReportRunMaxAggregateOutputType = {
    id: string | null
    runAt: Date | null
    status: $Enums.ReportStatus | null
    duration: number | null
    startDate: Date | null
    endDate: Date | null
    lastExportedAt: Date | null
    reportId: number | null
  }

  export type ReportRunCountAggregateOutputType = {
    id: number
    runAt: number
    status: number
    results: number
    duration: number
    startDate: number
    endDate: number
    customParams: number
    exportFormats: number
    lastExportedAt: number
    reportId: number
    _all: number
  }


  export type ReportRunAvgAggregateInputType = {
    duration?: true
    reportId?: true
  }

  export type ReportRunSumAggregateInputType = {
    duration?: true
    reportId?: true
  }

  export type ReportRunMinAggregateInputType = {
    id?: true
    runAt?: true
    status?: true
    duration?: true
    startDate?: true
    endDate?: true
    lastExportedAt?: true
    reportId?: true
  }

  export type ReportRunMaxAggregateInputType = {
    id?: true
    runAt?: true
    status?: true
    duration?: true
    startDate?: true
    endDate?: true
    lastExportedAt?: true
    reportId?: true
  }

  export type ReportRunCountAggregateInputType = {
    id?: true
    runAt?: true
    status?: true
    results?: true
    duration?: true
    startDate?: true
    endDate?: true
    customParams?: true
    exportFormats?: true
    lastExportedAt?: true
    reportId?: true
    _all?: true
  }

  export type ReportRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportRun to aggregate.
     */
    where?: ReportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportRuns to fetch.
     */
    orderBy?: ReportRunOrderByWithRelationInput | ReportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportRuns
    **/
    _count?: true | ReportRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportRunAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportRunSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportRunMaxAggregateInputType
  }

  export type GetReportRunAggregateType<T extends ReportRunAggregateArgs> = {
        [P in keyof T & keyof AggregateReportRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportRun[P]>
      : GetScalarType<T[P], AggregateReportRun[P]>
  }




  export type ReportRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportRunWhereInput
    orderBy?: ReportRunOrderByWithAggregationInput | ReportRunOrderByWithAggregationInput[]
    by: ReportRunScalarFieldEnum[] | ReportRunScalarFieldEnum
    having?: ReportRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportRunCountAggregateInputType | true
    _avg?: ReportRunAvgAggregateInputType
    _sum?: ReportRunSumAggregateInputType
    _min?: ReportRunMinAggregateInputType
    _max?: ReportRunMaxAggregateInputType
  }

  export type ReportRunGroupByOutputType = {
    id: string
    runAt: Date
    status: $Enums.ReportStatus
    results: JsonValue | null
    duration: number | null
    startDate: Date | null
    endDate: Date | null
    customParams: JsonValue | null
    exportFormats: string[]
    lastExportedAt: Date | null
    reportId: number
    _count: ReportRunCountAggregateOutputType | null
    _avg: ReportRunAvgAggregateOutputType | null
    _sum: ReportRunSumAggregateOutputType | null
    _min: ReportRunMinAggregateOutputType | null
    _max: ReportRunMaxAggregateOutputType | null
  }

  type GetReportRunGroupByPayload<T extends ReportRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportRunGroupByOutputType[P]>
            : GetScalarType<T[P], ReportRunGroupByOutputType[P]>
        }
      >
    >


  export type ReportRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runAt?: boolean
    status?: boolean
    results?: boolean
    duration?: boolean
    startDate?: boolean
    endDate?: boolean
    customParams?: boolean
    exportFormats?: boolean
    lastExportedAt?: boolean
    reportId?: boolean
    Report?: boolean | ReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportRun"]>

  export type ReportRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runAt?: boolean
    status?: boolean
    results?: boolean
    duration?: boolean
    startDate?: boolean
    endDate?: boolean
    customParams?: boolean
    exportFormats?: boolean
    lastExportedAt?: boolean
    reportId?: boolean
    Report?: boolean | ReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportRun"]>

  export type ReportRunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runAt?: boolean
    status?: boolean
    results?: boolean
    duration?: boolean
    startDate?: boolean
    endDate?: boolean
    customParams?: boolean
    exportFormats?: boolean
    lastExportedAt?: boolean
    reportId?: boolean
    Report?: boolean | ReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportRun"]>

  export type ReportRunSelectScalar = {
    id?: boolean
    runAt?: boolean
    status?: boolean
    results?: boolean
    duration?: boolean
    startDate?: boolean
    endDate?: boolean
    customParams?: boolean
    exportFormats?: boolean
    lastExportedAt?: boolean
    reportId?: boolean
  }

  export type ReportRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runAt" | "status" | "results" | "duration" | "startDate" | "endDate" | "customParams" | "exportFormats" | "lastExportedAt" | "reportId", ExtArgs["result"]["reportRun"]>
  export type ReportRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Report?: boolean | ReportDefaultArgs<ExtArgs>
  }
  export type ReportRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Report?: boolean | ReportDefaultArgs<ExtArgs>
  }
  export type ReportRunIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Report?: boolean | ReportDefaultArgs<ExtArgs>
  }

  export type $ReportRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportRun"
    objects: {
      Report: Prisma.$ReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runAt: Date
      status: $Enums.ReportStatus
      results: Prisma.JsonValue | null
      duration: number | null
      startDate: Date | null
      endDate: Date | null
      customParams: Prisma.JsonValue | null
      exportFormats: string[]
      lastExportedAt: Date | null
      reportId: number
    }, ExtArgs["result"]["reportRun"]>
    composites: {}
  }

  type ReportRunGetPayload<S extends boolean | null | undefined | ReportRunDefaultArgs> = $Result.GetResult<Prisma.$ReportRunPayload, S>

  type ReportRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportRunCountAggregateInputType | true
    }

  export interface ReportRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportRun'], meta: { name: 'ReportRun' } }
    /**
     * Find zero or one ReportRun that matches the filter.
     * @param {ReportRunFindUniqueArgs} args - Arguments to find a ReportRun
     * @example
     * // Get one ReportRun
     * const reportRun = await prisma.reportRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportRunFindUniqueArgs>(args: SelectSubset<T, ReportRunFindUniqueArgs<ExtArgs>>): Prisma__ReportRunClient<$Result.GetResult<Prisma.$ReportRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportRunFindUniqueOrThrowArgs} args - Arguments to find a ReportRun
     * @example
     * // Get one ReportRun
     * const reportRun = await prisma.reportRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportRunFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportRunClient<$Result.GetResult<Prisma.$ReportRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportRunFindFirstArgs} args - Arguments to find a ReportRun
     * @example
     * // Get one ReportRun
     * const reportRun = await prisma.reportRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportRunFindFirstArgs>(args?: SelectSubset<T, ReportRunFindFirstArgs<ExtArgs>>): Prisma__ReportRunClient<$Result.GetResult<Prisma.$ReportRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportRunFindFirstOrThrowArgs} args - Arguments to find a ReportRun
     * @example
     * // Get one ReportRun
     * const reportRun = await prisma.reportRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportRunFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportRunClient<$Result.GetResult<Prisma.$ReportRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportRuns
     * const reportRuns = await prisma.reportRun.findMany()
     * 
     * // Get first 10 ReportRuns
     * const reportRuns = await prisma.reportRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportRunWithIdOnly = await prisma.reportRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportRunFindManyArgs>(args?: SelectSubset<T, ReportRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportRun.
     * @param {ReportRunCreateArgs} args - Arguments to create a ReportRun.
     * @example
     * // Create one ReportRun
     * const ReportRun = await prisma.reportRun.create({
     *   data: {
     *     // ... data to create a ReportRun
     *   }
     * })
     * 
     */
    create<T extends ReportRunCreateArgs>(args: SelectSubset<T, ReportRunCreateArgs<ExtArgs>>): Prisma__ReportRunClient<$Result.GetResult<Prisma.$ReportRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportRuns.
     * @param {ReportRunCreateManyArgs} args - Arguments to create many ReportRuns.
     * @example
     * // Create many ReportRuns
     * const reportRun = await prisma.reportRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportRunCreateManyArgs>(args?: SelectSubset<T, ReportRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportRuns and returns the data saved in the database.
     * @param {ReportRunCreateManyAndReturnArgs} args - Arguments to create many ReportRuns.
     * @example
     * // Create many ReportRuns
     * const reportRun = await prisma.reportRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportRuns and only return the `id`
     * const reportRunWithIdOnly = await prisma.reportRun.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportRunCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportRunPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportRun.
     * @param {ReportRunDeleteArgs} args - Arguments to delete one ReportRun.
     * @example
     * // Delete one ReportRun
     * const ReportRun = await prisma.reportRun.delete({
     *   where: {
     *     // ... filter to delete one ReportRun
     *   }
     * })
     * 
     */
    delete<T extends ReportRunDeleteArgs>(args: SelectSubset<T, ReportRunDeleteArgs<ExtArgs>>): Prisma__ReportRunClient<$Result.GetResult<Prisma.$ReportRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportRun.
     * @param {ReportRunUpdateArgs} args - Arguments to update one ReportRun.
     * @example
     * // Update one ReportRun
     * const reportRun = await prisma.reportRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportRunUpdateArgs>(args: SelectSubset<T, ReportRunUpdateArgs<ExtArgs>>): Prisma__ReportRunClient<$Result.GetResult<Prisma.$ReportRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportRuns.
     * @param {ReportRunDeleteManyArgs} args - Arguments to filter ReportRuns to delete.
     * @example
     * // Delete a few ReportRuns
     * const { count } = await prisma.reportRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportRunDeleteManyArgs>(args?: SelectSubset<T, ReportRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportRuns
     * const reportRun = await prisma.reportRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportRunUpdateManyArgs>(args: SelectSubset<T, ReportRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportRuns and returns the data updated in the database.
     * @param {ReportRunUpdateManyAndReturnArgs} args - Arguments to update many ReportRuns.
     * @example
     * // Update many ReportRuns
     * const reportRun = await prisma.reportRun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportRuns and only return the `id`
     * const reportRunWithIdOnly = await prisma.reportRun.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportRunUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportRunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportRunPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportRun.
     * @param {ReportRunUpsertArgs} args - Arguments to update or create a ReportRun.
     * @example
     * // Update or create a ReportRun
     * const reportRun = await prisma.reportRun.upsert({
     *   create: {
     *     // ... data to create a ReportRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportRun we want to update
     *   }
     * })
     */
    upsert<T extends ReportRunUpsertArgs>(args: SelectSubset<T, ReportRunUpsertArgs<ExtArgs>>): Prisma__ReportRunClient<$Result.GetResult<Prisma.$ReportRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportRunCountArgs} args - Arguments to filter ReportRuns to count.
     * @example
     * // Count the number of ReportRuns
     * const count = await prisma.reportRun.count({
     *   where: {
     *     // ... the filter for the ReportRuns we want to count
     *   }
     * })
    **/
    count<T extends ReportRunCountArgs>(
      args?: Subset<T, ReportRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportRunAggregateArgs>(args: Subset<T, ReportRunAggregateArgs>): Prisma.PrismaPromise<GetReportRunAggregateType<T>>

    /**
     * Group by ReportRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportRunGroupByArgs['orderBy'] }
        : { orderBy?: ReportRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportRun model
   */
  readonly fields: ReportRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Report<T extends ReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReportDefaultArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportRun model
   */
  interface ReportRunFieldRefs {
    readonly id: FieldRef<"ReportRun", 'String'>
    readonly runAt: FieldRef<"ReportRun", 'DateTime'>
    readonly status: FieldRef<"ReportRun", 'ReportStatus'>
    readonly results: FieldRef<"ReportRun", 'Json'>
    readonly duration: FieldRef<"ReportRun", 'Int'>
    readonly startDate: FieldRef<"ReportRun", 'DateTime'>
    readonly endDate: FieldRef<"ReportRun", 'DateTime'>
    readonly customParams: FieldRef<"ReportRun", 'Json'>
    readonly exportFormats: FieldRef<"ReportRun", 'String[]'>
    readonly lastExportedAt: FieldRef<"ReportRun", 'DateTime'>
    readonly reportId: FieldRef<"ReportRun", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ReportRun findUnique
   */
  export type ReportRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportRun
     */
    select?: ReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportRun
     */
    omit?: ReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportRunInclude<ExtArgs> | null
    /**
     * Filter, which ReportRun to fetch.
     */
    where: ReportRunWhereUniqueInput
  }

  /**
   * ReportRun findUniqueOrThrow
   */
  export type ReportRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportRun
     */
    select?: ReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportRun
     */
    omit?: ReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportRunInclude<ExtArgs> | null
    /**
     * Filter, which ReportRun to fetch.
     */
    where: ReportRunWhereUniqueInput
  }

  /**
   * ReportRun findFirst
   */
  export type ReportRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportRun
     */
    select?: ReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportRun
     */
    omit?: ReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportRunInclude<ExtArgs> | null
    /**
     * Filter, which ReportRun to fetch.
     */
    where?: ReportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportRuns to fetch.
     */
    orderBy?: ReportRunOrderByWithRelationInput | ReportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportRuns.
     */
    cursor?: ReportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportRuns.
     */
    distinct?: ReportRunScalarFieldEnum | ReportRunScalarFieldEnum[]
  }

  /**
   * ReportRun findFirstOrThrow
   */
  export type ReportRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportRun
     */
    select?: ReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportRun
     */
    omit?: ReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportRunInclude<ExtArgs> | null
    /**
     * Filter, which ReportRun to fetch.
     */
    where?: ReportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportRuns to fetch.
     */
    orderBy?: ReportRunOrderByWithRelationInput | ReportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportRuns.
     */
    cursor?: ReportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportRuns.
     */
    distinct?: ReportRunScalarFieldEnum | ReportRunScalarFieldEnum[]
  }

  /**
   * ReportRun findMany
   */
  export type ReportRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportRun
     */
    select?: ReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportRun
     */
    omit?: ReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportRunInclude<ExtArgs> | null
    /**
     * Filter, which ReportRuns to fetch.
     */
    where?: ReportRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportRuns to fetch.
     */
    orderBy?: ReportRunOrderByWithRelationInput | ReportRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportRuns.
     */
    cursor?: ReportRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportRuns.
     */
    skip?: number
    distinct?: ReportRunScalarFieldEnum | ReportRunScalarFieldEnum[]
  }

  /**
   * ReportRun create
   */
  export type ReportRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportRun
     */
    select?: ReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportRun
     */
    omit?: ReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportRunInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportRun.
     */
    data: XOR<ReportRunCreateInput, ReportRunUncheckedCreateInput>
  }

  /**
   * ReportRun createMany
   */
  export type ReportRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportRuns.
     */
    data: ReportRunCreateManyInput | ReportRunCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportRun createManyAndReturn
   */
  export type ReportRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportRun
     */
    select?: ReportRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportRun
     */
    omit?: ReportRunOmit<ExtArgs> | null
    /**
     * The data used to create many ReportRuns.
     */
    data: ReportRunCreateManyInput | ReportRunCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportRun update
   */
  export type ReportRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportRun
     */
    select?: ReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportRun
     */
    omit?: ReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportRunInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportRun.
     */
    data: XOR<ReportRunUpdateInput, ReportRunUncheckedUpdateInput>
    /**
     * Choose, which ReportRun to update.
     */
    where: ReportRunWhereUniqueInput
  }

  /**
   * ReportRun updateMany
   */
  export type ReportRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportRuns.
     */
    data: XOR<ReportRunUpdateManyMutationInput, ReportRunUncheckedUpdateManyInput>
    /**
     * Filter which ReportRuns to update
     */
    where?: ReportRunWhereInput
    /**
     * Limit how many ReportRuns to update.
     */
    limit?: number
  }

  /**
   * ReportRun updateManyAndReturn
   */
  export type ReportRunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportRun
     */
    select?: ReportRunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportRun
     */
    omit?: ReportRunOmit<ExtArgs> | null
    /**
     * The data used to update ReportRuns.
     */
    data: XOR<ReportRunUpdateManyMutationInput, ReportRunUncheckedUpdateManyInput>
    /**
     * Filter which ReportRuns to update
     */
    where?: ReportRunWhereInput
    /**
     * Limit how many ReportRuns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportRunIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportRun upsert
   */
  export type ReportRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportRun
     */
    select?: ReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportRun
     */
    omit?: ReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportRunInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportRun to update in case it exists.
     */
    where: ReportRunWhereUniqueInput
    /**
     * In case the ReportRun found by the `where` argument doesn't exist, create a new ReportRun with this data.
     */
    create: XOR<ReportRunCreateInput, ReportRunUncheckedCreateInput>
    /**
     * In case the ReportRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportRunUpdateInput, ReportRunUncheckedUpdateInput>
  }

  /**
   * ReportRun delete
   */
  export type ReportRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportRun
     */
    select?: ReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportRun
     */
    omit?: ReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportRunInclude<ExtArgs> | null
    /**
     * Filter which ReportRun to delete.
     */
    where: ReportRunWhereUniqueInput
  }

  /**
   * ReportRun deleteMany
   */
  export type ReportRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportRuns to delete
     */
    where?: ReportRunWhereInput
    /**
     * Limit how many ReportRuns to delete.
     */
    limit?: number
  }

  /**
   * ReportRun without action
   */
  export type ReportRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportRun
     */
    select?: ReportRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportRun
     */
    omit?: ReportRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportRunInclude<ExtArgs> | null
  }


  /**
   * Model TimeSheet
   */

  export type AggregateTimeSheet = {
    _count: TimeSheetCountAggregateOutputType | null
    _avg: TimeSheetAvgAggregateOutputType | null
    _sum: TimeSheetSumAggregateOutputType | null
    _min: TimeSheetMinAggregateOutputType | null
    _max: TimeSheetMaxAggregateOutputType | null
  }

  export type TimeSheetAvgAggregateOutputType = {
    clockInLat: number | null
    clockInLng: number | null
    clockOutLat: number | null
    clockOutLng: number | null
    id: number | null
  }

  export type TimeSheetSumAggregateOutputType = {
    clockInLat: number | null
    clockInLng: number | null
    clockOutLat: number | null
    clockOutLng: number | null
    id: number | null
  }

  export type TimeSheetMinAggregateOutputType = {
    date: Date | null
    userId: string | null
    jobsiteId: string | null
    costcode: string | null
    nu: string | null
    Fp: string | null
    startTime: Date | null
    endTime: Date | null
    comment: string | null
    statusComment: string | null
    location: string | null
    status: $Enums.ApprovalStatus | null
    workType: $Enums.WorkType | null
    editedByUserId: string | null
    newTimeSheetId: string | null
    createdByAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    clockInLat: number | null
    clockInLng: number | null
    clockOutLat: number | null
    clockOutLng: number | null
    withinFenceIn: boolean | null
    withinFenceOut: boolean | null
    wasInjured: boolean | null
    id: number | null
  }

  export type TimeSheetMaxAggregateOutputType = {
    date: Date | null
    userId: string | null
    jobsiteId: string | null
    costcode: string | null
    nu: string | null
    Fp: string | null
    startTime: Date | null
    endTime: Date | null
    comment: string | null
    statusComment: string | null
    location: string | null
    status: $Enums.ApprovalStatus | null
    workType: $Enums.WorkType | null
    editedByUserId: string | null
    newTimeSheetId: string | null
    createdByAdmin: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    clockInLat: number | null
    clockInLng: number | null
    clockOutLat: number | null
    clockOutLng: number | null
    withinFenceIn: boolean | null
    withinFenceOut: boolean | null
    wasInjured: boolean | null
    id: number | null
  }

  export type TimeSheetCountAggregateOutputType = {
    date: number
    userId: number
    jobsiteId: number
    costcode: number
    nu: number
    Fp: number
    startTime: number
    endTime: number
    comment: number
    statusComment: number
    location: number
    status: number
    workType: number
    editedByUserId: number
    newTimeSheetId: number
    createdByAdmin: number
    createdAt: number
    updatedAt: number
    clockInLat: number
    clockInLng: number
    clockOutLat: number
    clockOutLng: number
    withinFenceIn: number
    withinFenceOut: number
    wasInjured: number
    id: number
    _all: number
  }


  export type TimeSheetAvgAggregateInputType = {
    clockInLat?: true
    clockInLng?: true
    clockOutLat?: true
    clockOutLng?: true
    id?: true
  }

  export type TimeSheetSumAggregateInputType = {
    clockInLat?: true
    clockInLng?: true
    clockOutLat?: true
    clockOutLng?: true
    id?: true
  }

  export type TimeSheetMinAggregateInputType = {
    date?: true
    userId?: true
    jobsiteId?: true
    costcode?: true
    nu?: true
    Fp?: true
    startTime?: true
    endTime?: true
    comment?: true
    statusComment?: true
    location?: true
    status?: true
    workType?: true
    editedByUserId?: true
    newTimeSheetId?: true
    createdByAdmin?: true
    createdAt?: true
    updatedAt?: true
    clockInLat?: true
    clockInLng?: true
    clockOutLat?: true
    clockOutLng?: true
    withinFenceIn?: true
    withinFenceOut?: true
    wasInjured?: true
    id?: true
  }

  export type TimeSheetMaxAggregateInputType = {
    date?: true
    userId?: true
    jobsiteId?: true
    costcode?: true
    nu?: true
    Fp?: true
    startTime?: true
    endTime?: true
    comment?: true
    statusComment?: true
    location?: true
    status?: true
    workType?: true
    editedByUserId?: true
    newTimeSheetId?: true
    createdByAdmin?: true
    createdAt?: true
    updatedAt?: true
    clockInLat?: true
    clockInLng?: true
    clockOutLat?: true
    clockOutLng?: true
    withinFenceIn?: true
    withinFenceOut?: true
    wasInjured?: true
    id?: true
  }

  export type TimeSheetCountAggregateInputType = {
    date?: true
    userId?: true
    jobsiteId?: true
    costcode?: true
    nu?: true
    Fp?: true
    startTime?: true
    endTime?: true
    comment?: true
    statusComment?: true
    location?: true
    status?: true
    workType?: true
    editedByUserId?: true
    newTimeSheetId?: true
    createdByAdmin?: true
    createdAt?: true
    updatedAt?: true
    clockInLat?: true
    clockInLng?: true
    clockOutLat?: true
    clockOutLng?: true
    withinFenceIn?: true
    withinFenceOut?: true
    wasInjured?: true
    id?: true
    _all?: true
  }

  export type TimeSheetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSheet to aggregate.
     */
    where?: TimeSheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSheets to fetch.
     */
    orderBy?: TimeSheetOrderByWithRelationInput | TimeSheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeSheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeSheets
    **/
    _count?: true | TimeSheetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeSheetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeSheetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeSheetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeSheetMaxAggregateInputType
  }

  export type GetTimeSheetAggregateType<T extends TimeSheetAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeSheet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeSheet[P]>
      : GetScalarType<T[P], AggregateTimeSheet[P]>
  }




  export type TimeSheetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSheetWhereInput
    orderBy?: TimeSheetOrderByWithAggregationInput | TimeSheetOrderByWithAggregationInput[]
    by: TimeSheetScalarFieldEnum[] | TimeSheetScalarFieldEnum
    having?: TimeSheetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeSheetCountAggregateInputType | true
    _avg?: TimeSheetAvgAggregateInputType
    _sum?: TimeSheetSumAggregateInputType
    _min?: TimeSheetMinAggregateInputType
    _max?: TimeSheetMaxAggregateInputType
  }

  export type TimeSheetGroupByOutputType = {
    date: Date
    userId: string
    jobsiteId: string
    costcode: string
    nu: string
    Fp: string
    startTime: Date
    endTime: Date | null
    comment: string | null
    statusComment: string | null
    location: string | null
    status: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId: string | null
    newTimeSheetId: string | null
    createdByAdmin: boolean
    createdAt: Date
    updatedAt: Date
    clockInLat: number | null
    clockInLng: number | null
    clockOutLat: number | null
    clockOutLng: number | null
    withinFenceIn: boolean | null
    withinFenceOut: boolean | null
    wasInjured: boolean | null
    id: number
    _count: TimeSheetCountAggregateOutputType | null
    _avg: TimeSheetAvgAggregateOutputType | null
    _sum: TimeSheetSumAggregateOutputType | null
    _min: TimeSheetMinAggregateOutputType | null
    _max: TimeSheetMaxAggregateOutputType | null
  }

  type GetTimeSheetGroupByPayload<T extends TimeSheetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeSheetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeSheetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeSheetGroupByOutputType[P]>
            : GetScalarType<T[P], TimeSheetGroupByOutputType[P]>
        }
      >
    >


  export type TimeSheetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    date?: boolean
    userId?: boolean
    jobsiteId?: boolean
    costcode?: boolean
    nu?: boolean
    Fp?: boolean
    startTime?: boolean
    endTime?: boolean
    comment?: boolean
    statusComment?: boolean
    location?: boolean
    status?: boolean
    workType?: boolean
    editedByUserId?: boolean
    newTimeSheetId?: boolean
    createdByAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clockInLat?: boolean
    clockInLng?: boolean
    clockOutLat?: boolean
    clockOutLng?: boolean
    withinFenceIn?: boolean
    withinFenceOut?: boolean
    wasInjured?: boolean
    id?: boolean
    EmployeeEquipmentLogs?: boolean | TimeSheet$EmployeeEquipmentLogsArgs<ExtArgs>
    MaintenanceLogs?: boolean | TimeSheet$MaintenanceLogsArgs<ExtArgs>
    TascoLogs?: boolean | TimeSheet$TascoLogsArgs<ExtArgs>
    CostCode?: boolean | CostCodeDefaultArgs<ExtArgs>
    Jobsite?: boolean | JobsiteDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    ChangeLogs?: boolean | TimeSheet$ChangeLogsArgs<ExtArgs>
    TruckingLogs?: boolean | TimeSheet$TruckingLogsArgs<ExtArgs>
    Maintenance?: boolean | TimeSheet$MaintenanceArgs<ExtArgs>
    _count?: boolean | TimeSheetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSheet"]>

  export type TimeSheetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    date?: boolean
    userId?: boolean
    jobsiteId?: boolean
    costcode?: boolean
    nu?: boolean
    Fp?: boolean
    startTime?: boolean
    endTime?: boolean
    comment?: boolean
    statusComment?: boolean
    location?: boolean
    status?: boolean
    workType?: boolean
    editedByUserId?: boolean
    newTimeSheetId?: boolean
    createdByAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clockInLat?: boolean
    clockInLng?: boolean
    clockOutLat?: boolean
    clockOutLng?: boolean
    withinFenceIn?: boolean
    withinFenceOut?: boolean
    wasInjured?: boolean
    id?: boolean
    CostCode?: boolean | CostCodeDefaultArgs<ExtArgs>
    Jobsite?: boolean | JobsiteDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSheet"]>

  export type TimeSheetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    date?: boolean
    userId?: boolean
    jobsiteId?: boolean
    costcode?: boolean
    nu?: boolean
    Fp?: boolean
    startTime?: boolean
    endTime?: boolean
    comment?: boolean
    statusComment?: boolean
    location?: boolean
    status?: boolean
    workType?: boolean
    editedByUserId?: boolean
    newTimeSheetId?: boolean
    createdByAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clockInLat?: boolean
    clockInLng?: boolean
    clockOutLat?: boolean
    clockOutLng?: boolean
    withinFenceIn?: boolean
    withinFenceOut?: boolean
    wasInjured?: boolean
    id?: boolean
    CostCode?: boolean | CostCodeDefaultArgs<ExtArgs>
    Jobsite?: boolean | JobsiteDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSheet"]>

  export type TimeSheetSelectScalar = {
    date?: boolean
    userId?: boolean
    jobsiteId?: boolean
    costcode?: boolean
    nu?: boolean
    Fp?: boolean
    startTime?: boolean
    endTime?: boolean
    comment?: boolean
    statusComment?: boolean
    location?: boolean
    status?: boolean
    workType?: boolean
    editedByUserId?: boolean
    newTimeSheetId?: boolean
    createdByAdmin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clockInLat?: boolean
    clockInLng?: boolean
    clockOutLat?: boolean
    clockOutLng?: boolean
    withinFenceIn?: boolean
    withinFenceOut?: boolean
    wasInjured?: boolean
    id?: boolean
  }

  export type TimeSheetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"date" | "userId" | "jobsiteId" | "costcode" | "nu" | "Fp" | "startTime" | "endTime" | "comment" | "statusComment" | "location" | "status" | "workType" | "editedByUserId" | "newTimeSheetId" | "createdByAdmin" | "createdAt" | "updatedAt" | "clockInLat" | "clockInLng" | "clockOutLat" | "clockOutLng" | "withinFenceIn" | "withinFenceOut" | "wasInjured" | "id", ExtArgs["result"]["timeSheet"]>
  export type TimeSheetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeEquipmentLogs?: boolean | TimeSheet$EmployeeEquipmentLogsArgs<ExtArgs>
    MaintenanceLogs?: boolean | TimeSheet$MaintenanceLogsArgs<ExtArgs>
    TascoLogs?: boolean | TimeSheet$TascoLogsArgs<ExtArgs>
    CostCode?: boolean | CostCodeDefaultArgs<ExtArgs>
    Jobsite?: boolean | JobsiteDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    ChangeLogs?: boolean | TimeSheet$ChangeLogsArgs<ExtArgs>
    TruckingLogs?: boolean | TimeSheet$TruckingLogsArgs<ExtArgs>
    Maintenance?: boolean | TimeSheet$MaintenanceArgs<ExtArgs>
    _count?: boolean | TimeSheetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TimeSheetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CostCode?: boolean | CostCodeDefaultArgs<ExtArgs>
    Jobsite?: boolean | JobsiteDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TimeSheetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CostCode?: boolean | CostCodeDefaultArgs<ExtArgs>
    Jobsite?: boolean | JobsiteDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TimeSheetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeSheet"
    objects: {
      EmployeeEquipmentLogs: Prisma.$EmployeeEquipmentLogPayload<ExtArgs>[]
      MaintenanceLogs: Prisma.$MaintenanceLogPayload<ExtArgs>[]
      TascoLogs: Prisma.$TascoLogPayload<ExtArgs>[]
      CostCode: Prisma.$CostCodePayload<ExtArgs>
      Jobsite: Prisma.$JobsitePayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
      ChangeLogs: Prisma.$TimeSheetChangeLogPayload<ExtArgs>[]
      TruckingLogs: Prisma.$TruckingLogPayload<ExtArgs>[]
      Maintenance: Prisma.$mechanicProjectsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      date: Date
      userId: string
      jobsiteId: string
      costcode: string
      nu: string
      Fp: string
      startTime: Date
      endTime: Date | null
      comment: string | null
      statusComment: string | null
      location: string | null
      status: $Enums.ApprovalStatus
      workType: $Enums.WorkType
      editedByUserId: string | null
      newTimeSheetId: string | null
      createdByAdmin: boolean
      createdAt: Date
      updatedAt: Date
      clockInLat: number | null
      clockInLng: number | null
      clockOutLat: number | null
      clockOutLng: number | null
      withinFenceIn: boolean | null
      withinFenceOut: boolean | null
      wasInjured: boolean | null
      id: number
    }, ExtArgs["result"]["timeSheet"]>
    composites: {}
  }

  type TimeSheetGetPayload<S extends boolean | null | undefined | TimeSheetDefaultArgs> = $Result.GetResult<Prisma.$TimeSheetPayload, S>

  type TimeSheetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimeSheetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimeSheetCountAggregateInputType | true
    }

  export interface TimeSheetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeSheet'], meta: { name: 'TimeSheet' } }
    /**
     * Find zero or one TimeSheet that matches the filter.
     * @param {TimeSheetFindUniqueArgs} args - Arguments to find a TimeSheet
     * @example
     * // Get one TimeSheet
     * const timeSheet = await prisma.timeSheet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeSheetFindUniqueArgs>(args: SelectSubset<T, TimeSheetFindUniqueArgs<ExtArgs>>): Prisma__TimeSheetClient<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimeSheet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimeSheetFindUniqueOrThrowArgs} args - Arguments to find a TimeSheet
     * @example
     * // Get one TimeSheet
     * const timeSheet = await prisma.timeSheet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeSheetFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeSheetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeSheetClient<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeSheet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSheetFindFirstArgs} args - Arguments to find a TimeSheet
     * @example
     * // Get one TimeSheet
     * const timeSheet = await prisma.timeSheet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeSheetFindFirstArgs>(args?: SelectSubset<T, TimeSheetFindFirstArgs<ExtArgs>>): Prisma__TimeSheetClient<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeSheet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSheetFindFirstOrThrowArgs} args - Arguments to find a TimeSheet
     * @example
     * // Get one TimeSheet
     * const timeSheet = await prisma.timeSheet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeSheetFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeSheetFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeSheetClient<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimeSheets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSheetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeSheets
     * const timeSheets = await prisma.timeSheet.findMany()
     * 
     * // Get first 10 TimeSheets
     * const timeSheets = await prisma.timeSheet.findMany({ take: 10 })
     * 
     * // Only select the `date`
     * const timeSheetWithDateOnly = await prisma.timeSheet.findMany({ select: { date: true } })
     * 
     */
    findMany<T extends TimeSheetFindManyArgs>(args?: SelectSubset<T, TimeSheetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimeSheet.
     * @param {TimeSheetCreateArgs} args - Arguments to create a TimeSheet.
     * @example
     * // Create one TimeSheet
     * const TimeSheet = await prisma.timeSheet.create({
     *   data: {
     *     // ... data to create a TimeSheet
     *   }
     * })
     * 
     */
    create<T extends TimeSheetCreateArgs>(args: SelectSubset<T, TimeSheetCreateArgs<ExtArgs>>): Prisma__TimeSheetClient<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimeSheets.
     * @param {TimeSheetCreateManyArgs} args - Arguments to create many TimeSheets.
     * @example
     * // Create many TimeSheets
     * const timeSheet = await prisma.timeSheet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeSheetCreateManyArgs>(args?: SelectSubset<T, TimeSheetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeSheets and returns the data saved in the database.
     * @param {TimeSheetCreateManyAndReturnArgs} args - Arguments to create many TimeSheets.
     * @example
     * // Create many TimeSheets
     * const timeSheet = await prisma.timeSheet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeSheets and only return the `date`
     * const timeSheetWithDateOnly = await prisma.timeSheet.createManyAndReturn({
     *   select: { date: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeSheetCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeSheetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimeSheet.
     * @param {TimeSheetDeleteArgs} args - Arguments to delete one TimeSheet.
     * @example
     * // Delete one TimeSheet
     * const TimeSheet = await prisma.timeSheet.delete({
     *   where: {
     *     // ... filter to delete one TimeSheet
     *   }
     * })
     * 
     */
    delete<T extends TimeSheetDeleteArgs>(args: SelectSubset<T, TimeSheetDeleteArgs<ExtArgs>>): Prisma__TimeSheetClient<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimeSheet.
     * @param {TimeSheetUpdateArgs} args - Arguments to update one TimeSheet.
     * @example
     * // Update one TimeSheet
     * const timeSheet = await prisma.timeSheet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeSheetUpdateArgs>(args: SelectSubset<T, TimeSheetUpdateArgs<ExtArgs>>): Prisma__TimeSheetClient<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimeSheets.
     * @param {TimeSheetDeleteManyArgs} args - Arguments to filter TimeSheets to delete.
     * @example
     * // Delete a few TimeSheets
     * const { count } = await prisma.timeSheet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeSheetDeleteManyArgs>(args?: SelectSubset<T, TimeSheetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSheetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeSheets
     * const timeSheet = await prisma.timeSheet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeSheetUpdateManyArgs>(args: SelectSubset<T, TimeSheetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSheets and returns the data updated in the database.
     * @param {TimeSheetUpdateManyAndReturnArgs} args - Arguments to update many TimeSheets.
     * @example
     * // Update many TimeSheets
     * const timeSheet = await prisma.timeSheet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimeSheets and only return the `date`
     * const timeSheetWithDateOnly = await prisma.timeSheet.updateManyAndReturn({
     *   select: { date: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimeSheetUpdateManyAndReturnArgs>(args: SelectSubset<T, TimeSheetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimeSheet.
     * @param {TimeSheetUpsertArgs} args - Arguments to update or create a TimeSheet.
     * @example
     * // Update or create a TimeSheet
     * const timeSheet = await prisma.timeSheet.upsert({
     *   create: {
     *     // ... data to create a TimeSheet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeSheet we want to update
     *   }
     * })
     */
    upsert<T extends TimeSheetUpsertArgs>(args: SelectSubset<T, TimeSheetUpsertArgs<ExtArgs>>): Prisma__TimeSheetClient<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimeSheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSheetCountArgs} args - Arguments to filter TimeSheets to count.
     * @example
     * // Count the number of TimeSheets
     * const count = await prisma.timeSheet.count({
     *   where: {
     *     // ... the filter for the TimeSheets we want to count
     *   }
     * })
    **/
    count<T extends TimeSheetCountArgs>(
      args?: Subset<T, TimeSheetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeSheetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeSheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSheetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeSheetAggregateArgs>(args: Subset<T, TimeSheetAggregateArgs>): Prisma.PrismaPromise<GetTimeSheetAggregateType<T>>

    /**
     * Group by TimeSheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSheetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeSheetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeSheetGroupByArgs['orderBy'] }
        : { orderBy?: TimeSheetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeSheetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeSheetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeSheet model
   */
  readonly fields: TimeSheetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeSheet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeSheetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EmployeeEquipmentLogs<T extends TimeSheet$EmployeeEquipmentLogsArgs<ExtArgs> = {}>(args?: Subset<T, TimeSheet$EmployeeEquipmentLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeEquipmentLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MaintenanceLogs<T extends TimeSheet$MaintenanceLogsArgs<ExtArgs> = {}>(args?: Subset<T, TimeSheet$MaintenanceLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TascoLogs<T extends TimeSheet$TascoLogsArgs<ExtArgs> = {}>(args?: Subset<T, TimeSheet$TascoLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TascoLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    CostCode<T extends CostCodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CostCodeDefaultArgs<ExtArgs>>): Prisma__CostCodeClient<$Result.GetResult<Prisma.$CostCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Jobsite<T extends JobsiteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobsiteDefaultArgs<ExtArgs>>): Prisma__JobsiteClient<$Result.GetResult<Prisma.$JobsitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ChangeLogs<T extends TimeSheet$ChangeLogsArgs<ExtArgs> = {}>(args?: Subset<T, TimeSheet$ChangeLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSheetChangeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TruckingLogs<T extends TimeSheet$TruckingLogsArgs<ExtArgs> = {}>(args?: Subset<T, TimeSheet$TruckingLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Maintenance<T extends TimeSheet$MaintenanceArgs<ExtArgs> = {}>(args?: Subset<T, TimeSheet$MaintenanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mechanicProjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeSheet model
   */
  interface TimeSheetFieldRefs {
    readonly date: FieldRef<"TimeSheet", 'DateTime'>
    readonly userId: FieldRef<"TimeSheet", 'String'>
    readonly jobsiteId: FieldRef<"TimeSheet", 'String'>
    readonly costcode: FieldRef<"TimeSheet", 'String'>
    readonly nu: FieldRef<"TimeSheet", 'String'>
    readonly Fp: FieldRef<"TimeSheet", 'String'>
    readonly startTime: FieldRef<"TimeSheet", 'DateTime'>
    readonly endTime: FieldRef<"TimeSheet", 'DateTime'>
    readonly comment: FieldRef<"TimeSheet", 'String'>
    readonly statusComment: FieldRef<"TimeSheet", 'String'>
    readonly location: FieldRef<"TimeSheet", 'String'>
    readonly status: FieldRef<"TimeSheet", 'ApprovalStatus'>
    readonly workType: FieldRef<"TimeSheet", 'WorkType'>
    readonly editedByUserId: FieldRef<"TimeSheet", 'String'>
    readonly newTimeSheetId: FieldRef<"TimeSheet", 'String'>
    readonly createdByAdmin: FieldRef<"TimeSheet", 'Boolean'>
    readonly createdAt: FieldRef<"TimeSheet", 'DateTime'>
    readonly updatedAt: FieldRef<"TimeSheet", 'DateTime'>
    readonly clockInLat: FieldRef<"TimeSheet", 'Float'>
    readonly clockInLng: FieldRef<"TimeSheet", 'Float'>
    readonly clockOutLat: FieldRef<"TimeSheet", 'Float'>
    readonly clockOutLng: FieldRef<"TimeSheet", 'Float'>
    readonly withinFenceIn: FieldRef<"TimeSheet", 'Boolean'>
    readonly withinFenceOut: FieldRef<"TimeSheet", 'Boolean'>
    readonly wasInjured: FieldRef<"TimeSheet", 'Boolean'>
    readonly id: FieldRef<"TimeSheet", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TimeSheet findUnique
   */
  export type TimeSheetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheet
     */
    select?: TimeSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheet
     */
    omit?: TimeSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetInclude<ExtArgs> | null
    /**
     * Filter, which TimeSheet to fetch.
     */
    where: TimeSheetWhereUniqueInput
  }

  /**
   * TimeSheet findUniqueOrThrow
   */
  export type TimeSheetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheet
     */
    select?: TimeSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheet
     */
    omit?: TimeSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetInclude<ExtArgs> | null
    /**
     * Filter, which TimeSheet to fetch.
     */
    where: TimeSheetWhereUniqueInput
  }

  /**
   * TimeSheet findFirst
   */
  export type TimeSheetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheet
     */
    select?: TimeSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheet
     */
    omit?: TimeSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetInclude<ExtArgs> | null
    /**
     * Filter, which TimeSheet to fetch.
     */
    where?: TimeSheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSheets to fetch.
     */
    orderBy?: TimeSheetOrderByWithRelationInput | TimeSheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSheets.
     */
    cursor?: TimeSheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSheets.
     */
    distinct?: TimeSheetScalarFieldEnum | TimeSheetScalarFieldEnum[]
  }

  /**
   * TimeSheet findFirstOrThrow
   */
  export type TimeSheetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheet
     */
    select?: TimeSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheet
     */
    omit?: TimeSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetInclude<ExtArgs> | null
    /**
     * Filter, which TimeSheet to fetch.
     */
    where?: TimeSheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSheets to fetch.
     */
    orderBy?: TimeSheetOrderByWithRelationInput | TimeSheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSheets.
     */
    cursor?: TimeSheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSheets.
     */
    distinct?: TimeSheetScalarFieldEnum | TimeSheetScalarFieldEnum[]
  }

  /**
   * TimeSheet findMany
   */
  export type TimeSheetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheet
     */
    select?: TimeSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheet
     */
    omit?: TimeSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetInclude<ExtArgs> | null
    /**
     * Filter, which TimeSheets to fetch.
     */
    where?: TimeSheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSheets to fetch.
     */
    orderBy?: TimeSheetOrderByWithRelationInput | TimeSheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeSheets.
     */
    cursor?: TimeSheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSheets.
     */
    skip?: number
    distinct?: TimeSheetScalarFieldEnum | TimeSheetScalarFieldEnum[]
  }

  /**
   * TimeSheet create
   */
  export type TimeSheetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheet
     */
    select?: TimeSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheet
     */
    omit?: TimeSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeSheet.
     */
    data: XOR<TimeSheetCreateInput, TimeSheetUncheckedCreateInput>
  }

  /**
   * TimeSheet createMany
   */
  export type TimeSheetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeSheets.
     */
    data: TimeSheetCreateManyInput | TimeSheetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeSheet createManyAndReturn
   */
  export type TimeSheetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheet
     */
    select?: TimeSheetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheet
     */
    omit?: TimeSheetOmit<ExtArgs> | null
    /**
     * The data used to create many TimeSheets.
     */
    data: TimeSheetCreateManyInput | TimeSheetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeSheet update
   */
  export type TimeSheetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheet
     */
    select?: TimeSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheet
     */
    omit?: TimeSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeSheet.
     */
    data: XOR<TimeSheetUpdateInput, TimeSheetUncheckedUpdateInput>
    /**
     * Choose, which TimeSheet to update.
     */
    where: TimeSheetWhereUniqueInput
  }

  /**
   * TimeSheet updateMany
   */
  export type TimeSheetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeSheets.
     */
    data: XOR<TimeSheetUpdateManyMutationInput, TimeSheetUncheckedUpdateManyInput>
    /**
     * Filter which TimeSheets to update
     */
    where?: TimeSheetWhereInput
    /**
     * Limit how many TimeSheets to update.
     */
    limit?: number
  }

  /**
   * TimeSheet updateManyAndReturn
   */
  export type TimeSheetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheet
     */
    select?: TimeSheetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheet
     */
    omit?: TimeSheetOmit<ExtArgs> | null
    /**
     * The data used to update TimeSheets.
     */
    data: XOR<TimeSheetUpdateManyMutationInput, TimeSheetUncheckedUpdateManyInput>
    /**
     * Filter which TimeSheets to update
     */
    where?: TimeSheetWhereInput
    /**
     * Limit how many TimeSheets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeSheet upsert
   */
  export type TimeSheetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheet
     */
    select?: TimeSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheet
     */
    omit?: TimeSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeSheet to update in case it exists.
     */
    where: TimeSheetWhereUniqueInput
    /**
     * In case the TimeSheet found by the `where` argument doesn't exist, create a new TimeSheet with this data.
     */
    create: XOR<TimeSheetCreateInput, TimeSheetUncheckedCreateInput>
    /**
     * In case the TimeSheet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeSheetUpdateInput, TimeSheetUncheckedUpdateInput>
  }

  /**
   * TimeSheet delete
   */
  export type TimeSheetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheet
     */
    select?: TimeSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheet
     */
    omit?: TimeSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetInclude<ExtArgs> | null
    /**
     * Filter which TimeSheet to delete.
     */
    where: TimeSheetWhereUniqueInput
  }

  /**
   * TimeSheet deleteMany
   */
  export type TimeSheetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSheets to delete
     */
    where?: TimeSheetWhereInput
    /**
     * Limit how many TimeSheets to delete.
     */
    limit?: number
  }

  /**
   * TimeSheet.EmployeeEquipmentLogs
   */
  export type TimeSheet$EmployeeEquipmentLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeEquipmentLog
     */
    select?: EmployeeEquipmentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeEquipmentLog
     */
    omit?: EmployeeEquipmentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeEquipmentLogInclude<ExtArgs> | null
    where?: EmployeeEquipmentLogWhereInput
    orderBy?: EmployeeEquipmentLogOrderByWithRelationInput | EmployeeEquipmentLogOrderByWithRelationInput[]
    cursor?: EmployeeEquipmentLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeEquipmentLogScalarFieldEnum | EmployeeEquipmentLogScalarFieldEnum[]
  }

  /**
   * TimeSheet.MaintenanceLogs
   */
  export type TimeSheet$MaintenanceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    where?: MaintenanceLogWhereInput
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    cursor?: MaintenanceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceLogScalarFieldEnum | MaintenanceLogScalarFieldEnum[]
  }

  /**
   * TimeSheet.TascoLogs
   */
  export type TimeSheet$TascoLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLog
     */
    select?: TascoLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoLog
     */
    omit?: TascoLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoLogInclude<ExtArgs> | null
    where?: TascoLogWhereInput
    orderBy?: TascoLogOrderByWithRelationInput | TascoLogOrderByWithRelationInput[]
    cursor?: TascoLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TascoLogScalarFieldEnum | TascoLogScalarFieldEnum[]
  }

  /**
   * TimeSheet.ChangeLogs
   */
  export type TimeSheet$ChangeLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheetChangeLog
     */
    select?: TimeSheetChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheetChangeLog
     */
    omit?: TimeSheetChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetChangeLogInclude<ExtArgs> | null
    where?: TimeSheetChangeLogWhereInput
    orderBy?: TimeSheetChangeLogOrderByWithRelationInput | TimeSheetChangeLogOrderByWithRelationInput[]
    cursor?: TimeSheetChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeSheetChangeLogScalarFieldEnum | TimeSheetChangeLogScalarFieldEnum[]
  }

  /**
   * TimeSheet.TruckingLogs
   */
  export type TimeSheet$TruckingLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogInclude<ExtArgs> | null
    where?: TruckingLogWhereInput
    orderBy?: TruckingLogOrderByWithRelationInput | TruckingLogOrderByWithRelationInput[]
    cursor?: TruckingLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TruckingLogScalarFieldEnum | TruckingLogScalarFieldEnum[]
  }

  /**
   * TimeSheet.Maintenance
   */
  export type TimeSheet$MaintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mechanicProjects
     */
    select?: mechanicProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mechanicProjects
     */
    omit?: mechanicProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mechanicProjectsInclude<ExtArgs> | null
    where?: mechanicProjectsWhereInput
    orderBy?: mechanicProjectsOrderByWithRelationInput | mechanicProjectsOrderByWithRelationInput[]
    cursor?: mechanicProjectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MechanicProjectsScalarFieldEnum | MechanicProjectsScalarFieldEnum[]
  }

  /**
   * TimeSheet without action
   */
  export type TimeSheetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheet
     */
    select?: TimeSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheet
     */
    omit?: TimeSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetInclude<ExtArgs> | null
  }


  /**
   * Model mechanicProjects
   */

  export type AggregateMechanicProjects = {
    _count: MechanicProjectsCountAggregateOutputType | null
    _avg: MechanicProjectsAvgAggregateOutputType | null
    _sum: MechanicProjectsSumAggregateOutputType | null
    _min: MechanicProjectsMinAggregateOutputType | null
    _max: MechanicProjectsMaxAggregateOutputType | null
  }

  export type MechanicProjectsAvgAggregateOutputType = {
    id: number | null
    timeSheetId: number | null
    hours: number | null
  }

  export type MechanicProjectsSumAggregateOutputType = {
    id: number | null
    timeSheetId: number | null
    hours: number | null
  }

  export type MechanicProjectsMinAggregateOutputType = {
    id: number | null
    timeSheetId: number | null
    hours: number | null
    equipmentId: string | null
    description: string | null
  }

  export type MechanicProjectsMaxAggregateOutputType = {
    id: number | null
    timeSheetId: number | null
    hours: number | null
    equipmentId: string | null
    description: string | null
  }

  export type MechanicProjectsCountAggregateOutputType = {
    id: number
    timeSheetId: number
    hours: number
    equipmentId: number
    description: number
    _all: number
  }


  export type MechanicProjectsAvgAggregateInputType = {
    id?: true
    timeSheetId?: true
    hours?: true
  }

  export type MechanicProjectsSumAggregateInputType = {
    id?: true
    timeSheetId?: true
    hours?: true
  }

  export type MechanicProjectsMinAggregateInputType = {
    id?: true
    timeSheetId?: true
    hours?: true
    equipmentId?: true
    description?: true
  }

  export type MechanicProjectsMaxAggregateInputType = {
    id?: true
    timeSheetId?: true
    hours?: true
    equipmentId?: true
    description?: true
  }

  export type MechanicProjectsCountAggregateInputType = {
    id?: true
    timeSheetId?: true
    hours?: true
    equipmentId?: true
    description?: true
    _all?: true
  }

  export type MechanicProjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mechanicProjects to aggregate.
     */
    where?: mechanicProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mechanicProjects to fetch.
     */
    orderBy?: mechanicProjectsOrderByWithRelationInput | mechanicProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mechanicProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mechanicProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mechanicProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mechanicProjects
    **/
    _count?: true | MechanicProjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MechanicProjectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MechanicProjectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MechanicProjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MechanicProjectsMaxAggregateInputType
  }

  export type GetMechanicProjectsAggregateType<T extends MechanicProjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateMechanicProjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMechanicProjects[P]>
      : GetScalarType<T[P], AggregateMechanicProjects[P]>
  }




  export type mechanicProjectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mechanicProjectsWhereInput
    orderBy?: mechanicProjectsOrderByWithAggregationInput | mechanicProjectsOrderByWithAggregationInput[]
    by: MechanicProjectsScalarFieldEnum[] | MechanicProjectsScalarFieldEnum
    having?: mechanicProjectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MechanicProjectsCountAggregateInputType | true
    _avg?: MechanicProjectsAvgAggregateInputType
    _sum?: MechanicProjectsSumAggregateInputType
    _min?: MechanicProjectsMinAggregateInputType
    _max?: MechanicProjectsMaxAggregateInputType
  }

  export type MechanicProjectsGroupByOutputType = {
    id: number
    timeSheetId: number
    hours: number | null
    equipmentId: string
    description: string | null
    _count: MechanicProjectsCountAggregateOutputType | null
    _avg: MechanicProjectsAvgAggregateOutputType | null
    _sum: MechanicProjectsSumAggregateOutputType | null
    _min: MechanicProjectsMinAggregateOutputType | null
    _max: MechanicProjectsMaxAggregateOutputType | null
  }

  type GetMechanicProjectsGroupByPayload<T extends mechanicProjectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MechanicProjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MechanicProjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MechanicProjectsGroupByOutputType[P]>
            : GetScalarType<T[P], MechanicProjectsGroupByOutputType[P]>
        }
      >
    >


  export type mechanicProjectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timeSheetId?: boolean
    hours?: boolean
    equipmentId?: boolean
    description?: boolean
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mechanicProjects"]>

  export type mechanicProjectsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timeSheetId?: boolean
    hours?: boolean
    equipmentId?: boolean
    description?: boolean
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mechanicProjects"]>

  export type mechanicProjectsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timeSheetId?: boolean
    hours?: boolean
    equipmentId?: boolean
    description?: boolean
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mechanicProjects"]>

  export type mechanicProjectsSelectScalar = {
    id?: boolean
    timeSheetId?: boolean
    hours?: boolean
    equipmentId?: boolean
    description?: boolean
  }

  export type mechanicProjectsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timeSheetId" | "hours" | "equipmentId" | "description", ExtArgs["result"]["mechanicProjects"]>
  export type mechanicProjectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }
  export type mechanicProjectsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }
  export type mechanicProjectsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }

  export type $mechanicProjectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mechanicProjects"
    objects: {
      Equipment: Prisma.$EquipmentPayload<ExtArgs>
      TimeSheet: Prisma.$TimeSheetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      timeSheetId: number
      hours: number | null
      equipmentId: string
      description: string | null
    }, ExtArgs["result"]["mechanicProjects"]>
    composites: {}
  }

  type mechanicProjectsGetPayload<S extends boolean | null | undefined | mechanicProjectsDefaultArgs> = $Result.GetResult<Prisma.$mechanicProjectsPayload, S>

  type mechanicProjectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mechanicProjectsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MechanicProjectsCountAggregateInputType | true
    }

  export interface mechanicProjectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mechanicProjects'], meta: { name: 'mechanicProjects' } }
    /**
     * Find zero or one MechanicProjects that matches the filter.
     * @param {mechanicProjectsFindUniqueArgs} args - Arguments to find a MechanicProjects
     * @example
     * // Get one MechanicProjects
     * const mechanicProjects = await prisma.mechanicProjects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mechanicProjectsFindUniqueArgs>(args: SelectSubset<T, mechanicProjectsFindUniqueArgs<ExtArgs>>): Prisma__mechanicProjectsClient<$Result.GetResult<Prisma.$mechanicProjectsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MechanicProjects that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mechanicProjectsFindUniqueOrThrowArgs} args - Arguments to find a MechanicProjects
     * @example
     * // Get one MechanicProjects
     * const mechanicProjects = await prisma.mechanicProjects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mechanicProjectsFindUniqueOrThrowArgs>(args: SelectSubset<T, mechanicProjectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mechanicProjectsClient<$Result.GetResult<Prisma.$mechanicProjectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MechanicProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mechanicProjectsFindFirstArgs} args - Arguments to find a MechanicProjects
     * @example
     * // Get one MechanicProjects
     * const mechanicProjects = await prisma.mechanicProjects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mechanicProjectsFindFirstArgs>(args?: SelectSubset<T, mechanicProjectsFindFirstArgs<ExtArgs>>): Prisma__mechanicProjectsClient<$Result.GetResult<Prisma.$mechanicProjectsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MechanicProjects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mechanicProjectsFindFirstOrThrowArgs} args - Arguments to find a MechanicProjects
     * @example
     * // Get one MechanicProjects
     * const mechanicProjects = await prisma.mechanicProjects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mechanicProjectsFindFirstOrThrowArgs>(args?: SelectSubset<T, mechanicProjectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__mechanicProjectsClient<$Result.GetResult<Prisma.$mechanicProjectsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MechanicProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mechanicProjectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MechanicProjects
     * const mechanicProjects = await prisma.mechanicProjects.findMany()
     * 
     * // Get first 10 MechanicProjects
     * const mechanicProjects = await prisma.mechanicProjects.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mechanicProjectsWithIdOnly = await prisma.mechanicProjects.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mechanicProjectsFindManyArgs>(args?: SelectSubset<T, mechanicProjectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mechanicProjectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MechanicProjects.
     * @param {mechanicProjectsCreateArgs} args - Arguments to create a MechanicProjects.
     * @example
     * // Create one MechanicProjects
     * const MechanicProjects = await prisma.mechanicProjects.create({
     *   data: {
     *     // ... data to create a MechanicProjects
     *   }
     * })
     * 
     */
    create<T extends mechanicProjectsCreateArgs>(args: SelectSubset<T, mechanicProjectsCreateArgs<ExtArgs>>): Prisma__mechanicProjectsClient<$Result.GetResult<Prisma.$mechanicProjectsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MechanicProjects.
     * @param {mechanicProjectsCreateManyArgs} args - Arguments to create many MechanicProjects.
     * @example
     * // Create many MechanicProjects
     * const mechanicProjects = await prisma.mechanicProjects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mechanicProjectsCreateManyArgs>(args?: SelectSubset<T, mechanicProjectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MechanicProjects and returns the data saved in the database.
     * @param {mechanicProjectsCreateManyAndReturnArgs} args - Arguments to create many MechanicProjects.
     * @example
     * // Create many MechanicProjects
     * const mechanicProjects = await prisma.mechanicProjects.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MechanicProjects and only return the `id`
     * const mechanicProjectsWithIdOnly = await prisma.mechanicProjects.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mechanicProjectsCreateManyAndReturnArgs>(args?: SelectSubset<T, mechanicProjectsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mechanicProjectsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MechanicProjects.
     * @param {mechanicProjectsDeleteArgs} args - Arguments to delete one MechanicProjects.
     * @example
     * // Delete one MechanicProjects
     * const MechanicProjects = await prisma.mechanicProjects.delete({
     *   where: {
     *     // ... filter to delete one MechanicProjects
     *   }
     * })
     * 
     */
    delete<T extends mechanicProjectsDeleteArgs>(args: SelectSubset<T, mechanicProjectsDeleteArgs<ExtArgs>>): Prisma__mechanicProjectsClient<$Result.GetResult<Prisma.$mechanicProjectsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MechanicProjects.
     * @param {mechanicProjectsUpdateArgs} args - Arguments to update one MechanicProjects.
     * @example
     * // Update one MechanicProjects
     * const mechanicProjects = await prisma.mechanicProjects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mechanicProjectsUpdateArgs>(args: SelectSubset<T, mechanicProjectsUpdateArgs<ExtArgs>>): Prisma__mechanicProjectsClient<$Result.GetResult<Prisma.$mechanicProjectsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MechanicProjects.
     * @param {mechanicProjectsDeleteManyArgs} args - Arguments to filter MechanicProjects to delete.
     * @example
     * // Delete a few MechanicProjects
     * const { count } = await prisma.mechanicProjects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mechanicProjectsDeleteManyArgs>(args?: SelectSubset<T, mechanicProjectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MechanicProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mechanicProjectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MechanicProjects
     * const mechanicProjects = await prisma.mechanicProjects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mechanicProjectsUpdateManyArgs>(args: SelectSubset<T, mechanicProjectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MechanicProjects and returns the data updated in the database.
     * @param {mechanicProjectsUpdateManyAndReturnArgs} args - Arguments to update many MechanicProjects.
     * @example
     * // Update many MechanicProjects
     * const mechanicProjects = await prisma.mechanicProjects.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MechanicProjects and only return the `id`
     * const mechanicProjectsWithIdOnly = await prisma.mechanicProjects.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mechanicProjectsUpdateManyAndReturnArgs>(args: SelectSubset<T, mechanicProjectsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mechanicProjectsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MechanicProjects.
     * @param {mechanicProjectsUpsertArgs} args - Arguments to update or create a MechanicProjects.
     * @example
     * // Update or create a MechanicProjects
     * const mechanicProjects = await prisma.mechanicProjects.upsert({
     *   create: {
     *     // ... data to create a MechanicProjects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MechanicProjects we want to update
     *   }
     * })
     */
    upsert<T extends mechanicProjectsUpsertArgs>(args: SelectSubset<T, mechanicProjectsUpsertArgs<ExtArgs>>): Prisma__mechanicProjectsClient<$Result.GetResult<Prisma.$mechanicProjectsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MechanicProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mechanicProjectsCountArgs} args - Arguments to filter MechanicProjects to count.
     * @example
     * // Count the number of MechanicProjects
     * const count = await prisma.mechanicProjects.count({
     *   where: {
     *     // ... the filter for the MechanicProjects we want to count
     *   }
     * })
    **/
    count<T extends mechanicProjectsCountArgs>(
      args?: Subset<T, mechanicProjectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MechanicProjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MechanicProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MechanicProjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MechanicProjectsAggregateArgs>(args: Subset<T, MechanicProjectsAggregateArgs>): Prisma.PrismaPromise<GetMechanicProjectsAggregateType<T>>

    /**
     * Group by MechanicProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mechanicProjectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mechanicProjectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mechanicProjectsGroupByArgs['orderBy'] }
        : { orderBy?: mechanicProjectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mechanicProjectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMechanicProjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mechanicProjects model
   */
  readonly fields: mechanicProjectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mechanicProjects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mechanicProjectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    TimeSheet<T extends TimeSheetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TimeSheetDefaultArgs<ExtArgs>>): Prisma__TimeSheetClient<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mechanicProjects model
   */
  interface mechanicProjectsFieldRefs {
    readonly id: FieldRef<"mechanicProjects", 'Int'>
    readonly timeSheetId: FieldRef<"mechanicProjects", 'Int'>
    readonly hours: FieldRef<"mechanicProjects", 'Float'>
    readonly equipmentId: FieldRef<"mechanicProjects", 'String'>
    readonly description: FieldRef<"mechanicProjects", 'String'>
  }
    

  // Custom InputTypes
  /**
   * mechanicProjects findUnique
   */
  export type mechanicProjectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mechanicProjects
     */
    select?: mechanicProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mechanicProjects
     */
    omit?: mechanicProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mechanicProjectsInclude<ExtArgs> | null
    /**
     * Filter, which mechanicProjects to fetch.
     */
    where: mechanicProjectsWhereUniqueInput
  }

  /**
   * mechanicProjects findUniqueOrThrow
   */
  export type mechanicProjectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mechanicProjects
     */
    select?: mechanicProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mechanicProjects
     */
    omit?: mechanicProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mechanicProjectsInclude<ExtArgs> | null
    /**
     * Filter, which mechanicProjects to fetch.
     */
    where: mechanicProjectsWhereUniqueInput
  }

  /**
   * mechanicProjects findFirst
   */
  export type mechanicProjectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mechanicProjects
     */
    select?: mechanicProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mechanicProjects
     */
    omit?: mechanicProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mechanicProjectsInclude<ExtArgs> | null
    /**
     * Filter, which mechanicProjects to fetch.
     */
    where?: mechanicProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mechanicProjects to fetch.
     */
    orderBy?: mechanicProjectsOrderByWithRelationInput | mechanicProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mechanicProjects.
     */
    cursor?: mechanicProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mechanicProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mechanicProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mechanicProjects.
     */
    distinct?: MechanicProjectsScalarFieldEnum | MechanicProjectsScalarFieldEnum[]
  }

  /**
   * mechanicProjects findFirstOrThrow
   */
  export type mechanicProjectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mechanicProjects
     */
    select?: mechanicProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mechanicProjects
     */
    omit?: mechanicProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mechanicProjectsInclude<ExtArgs> | null
    /**
     * Filter, which mechanicProjects to fetch.
     */
    where?: mechanicProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mechanicProjects to fetch.
     */
    orderBy?: mechanicProjectsOrderByWithRelationInput | mechanicProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mechanicProjects.
     */
    cursor?: mechanicProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mechanicProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mechanicProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mechanicProjects.
     */
    distinct?: MechanicProjectsScalarFieldEnum | MechanicProjectsScalarFieldEnum[]
  }

  /**
   * mechanicProjects findMany
   */
  export type mechanicProjectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mechanicProjects
     */
    select?: mechanicProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mechanicProjects
     */
    omit?: mechanicProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mechanicProjectsInclude<ExtArgs> | null
    /**
     * Filter, which mechanicProjects to fetch.
     */
    where?: mechanicProjectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mechanicProjects to fetch.
     */
    orderBy?: mechanicProjectsOrderByWithRelationInput | mechanicProjectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mechanicProjects.
     */
    cursor?: mechanicProjectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mechanicProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mechanicProjects.
     */
    skip?: number
    distinct?: MechanicProjectsScalarFieldEnum | MechanicProjectsScalarFieldEnum[]
  }

  /**
   * mechanicProjects create
   */
  export type mechanicProjectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mechanicProjects
     */
    select?: mechanicProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mechanicProjects
     */
    omit?: mechanicProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mechanicProjectsInclude<ExtArgs> | null
    /**
     * The data needed to create a mechanicProjects.
     */
    data: XOR<mechanicProjectsCreateInput, mechanicProjectsUncheckedCreateInput>
  }

  /**
   * mechanicProjects createMany
   */
  export type mechanicProjectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mechanicProjects.
     */
    data: mechanicProjectsCreateManyInput | mechanicProjectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mechanicProjects createManyAndReturn
   */
  export type mechanicProjectsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mechanicProjects
     */
    select?: mechanicProjectsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mechanicProjects
     */
    omit?: mechanicProjectsOmit<ExtArgs> | null
    /**
     * The data used to create many mechanicProjects.
     */
    data: mechanicProjectsCreateManyInput | mechanicProjectsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mechanicProjectsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * mechanicProjects update
   */
  export type mechanicProjectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mechanicProjects
     */
    select?: mechanicProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mechanicProjects
     */
    omit?: mechanicProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mechanicProjectsInclude<ExtArgs> | null
    /**
     * The data needed to update a mechanicProjects.
     */
    data: XOR<mechanicProjectsUpdateInput, mechanicProjectsUncheckedUpdateInput>
    /**
     * Choose, which mechanicProjects to update.
     */
    where: mechanicProjectsWhereUniqueInput
  }

  /**
   * mechanicProjects updateMany
   */
  export type mechanicProjectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mechanicProjects.
     */
    data: XOR<mechanicProjectsUpdateManyMutationInput, mechanicProjectsUncheckedUpdateManyInput>
    /**
     * Filter which mechanicProjects to update
     */
    where?: mechanicProjectsWhereInput
    /**
     * Limit how many mechanicProjects to update.
     */
    limit?: number
  }

  /**
   * mechanicProjects updateManyAndReturn
   */
  export type mechanicProjectsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mechanicProjects
     */
    select?: mechanicProjectsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mechanicProjects
     */
    omit?: mechanicProjectsOmit<ExtArgs> | null
    /**
     * The data used to update mechanicProjects.
     */
    data: XOR<mechanicProjectsUpdateManyMutationInput, mechanicProjectsUncheckedUpdateManyInput>
    /**
     * Filter which mechanicProjects to update
     */
    where?: mechanicProjectsWhereInput
    /**
     * Limit how many mechanicProjects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mechanicProjectsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * mechanicProjects upsert
   */
  export type mechanicProjectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mechanicProjects
     */
    select?: mechanicProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mechanicProjects
     */
    omit?: mechanicProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mechanicProjectsInclude<ExtArgs> | null
    /**
     * The filter to search for the mechanicProjects to update in case it exists.
     */
    where: mechanicProjectsWhereUniqueInput
    /**
     * In case the mechanicProjects found by the `where` argument doesn't exist, create a new mechanicProjects with this data.
     */
    create: XOR<mechanicProjectsCreateInput, mechanicProjectsUncheckedCreateInput>
    /**
     * In case the mechanicProjects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mechanicProjectsUpdateInput, mechanicProjectsUncheckedUpdateInput>
  }

  /**
   * mechanicProjects delete
   */
  export type mechanicProjectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mechanicProjects
     */
    select?: mechanicProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mechanicProjects
     */
    omit?: mechanicProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mechanicProjectsInclude<ExtArgs> | null
    /**
     * Filter which mechanicProjects to delete.
     */
    where: mechanicProjectsWhereUniqueInput
  }

  /**
   * mechanicProjects deleteMany
   */
  export type mechanicProjectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mechanicProjects to delete
     */
    where?: mechanicProjectsWhereInput
    /**
     * Limit how many mechanicProjects to delete.
     */
    limit?: number
  }

  /**
   * mechanicProjects without action
   */
  export type mechanicProjectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mechanicProjects
     */
    select?: mechanicProjectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mechanicProjects
     */
    omit?: mechanicProjectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mechanicProjectsInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceLog
   */

  export type AggregateMaintenanceLog = {
    _count: MaintenanceLogCountAggregateOutputType | null
    _avg: MaintenanceLogAvgAggregateOutputType | null
    _sum: MaintenanceLogSumAggregateOutputType | null
    _min: MaintenanceLogMinAggregateOutputType | null
    _max: MaintenanceLogMaxAggregateOutputType | null
  }

  export type MaintenanceLogAvgAggregateOutputType = {
    timeSheetId: number | null
  }

  export type MaintenanceLogSumAggregateOutputType = {
    timeSheetId: number | null
  }

  export type MaintenanceLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    maintenanceId: string | null
    startTime: Date | null
    endTime: Date | null
    comment: string | null
    timeSheetId: number | null
  }

  export type MaintenanceLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    maintenanceId: string | null
    startTime: Date | null
    endTime: Date | null
    comment: string | null
    timeSheetId: number | null
  }

  export type MaintenanceLogCountAggregateOutputType = {
    id: number
    userId: number
    maintenanceId: number
    startTime: number
    endTime: number
    comment: number
    timeSheetId: number
    _all: number
  }


  export type MaintenanceLogAvgAggregateInputType = {
    timeSheetId?: true
  }

  export type MaintenanceLogSumAggregateInputType = {
    timeSheetId?: true
  }

  export type MaintenanceLogMinAggregateInputType = {
    id?: true
    userId?: true
    maintenanceId?: true
    startTime?: true
    endTime?: true
    comment?: true
    timeSheetId?: true
  }

  export type MaintenanceLogMaxAggregateInputType = {
    id?: true
    userId?: true
    maintenanceId?: true
    startTime?: true
    endTime?: true
    comment?: true
    timeSheetId?: true
  }

  export type MaintenanceLogCountAggregateInputType = {
    id?: true
    userId?: true
    maintenanceId?: true
    startTime?: true
    endTime?: true
    comment?: true
    timeSheetId?: true
    _all?: true
  }

  export type MaintenanceLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceLog to aggregate.
     */
    where?: MaintenanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceLogs to fetch.
     */
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceLogs
    **/
    _count?: true | MaintenanceLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintenanceLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintenanceLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceLogMaxAggregateInputType
  }

  export type GetMaintenanceLogAggregateType<T extends MaintenanceLogAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceLog[P]>
      : GetScalarType<T[P], AggregateMaintenanceLog[P]>
  }




  export type MaintenanceLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceLogWhereInput
    orderBy?: MaintenanceLogOrderByWithAggregationInput | MaintenanceLogOrderByWithAggregationInput[]
    by: MaintenanceLogScalarFieldEnum[] | MaintenanceLogScalarFieldEnum
    having?: MaintenanceLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceLogCountAggregateInputType | true
    _avg?: MaintenanceLogAvgAggregateInputType
    _sum?: MaintenanceLogSumAggregateInputType
    _min?: MaintenanceLogMinAggregateInputType
    _max?: MaintenanceLogMaxAggregateInputType
  }

  export type MaintenanceLogGroupByOutputType = {
    id: string
    userId: string
    maintenanceId: string
    startTime: Date
    endTime: Date | null
    comment: string | null
    timeSheetId: number
    _count: MaintenanceLogCountAggregateOutputType | null
    _avg: MaintenanceLogAvgAggregateOutputType | null
    _sum: MaintenanceLogSumAggregateOutputType | null
    _min: MaintenanceLogMinAggregateOutputType | null
    _max: MaintenanceLogMaxAggregateOutputType | null
  }

  type GetMaintenanceLogGroupByPayload<T extends MaintenanceLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceLogGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceLogGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    maintenanceId?: boolean
    startTime?: boolean
    endTime?: boolean
    comment?: boolean
    timeSheetId?: boolean
    Maintenance?: boolean | MaintenanceDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceLog"]>

  export type MaintenanceLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    maintenanceId?: boolean
    startTime?: boolean
    endTime?: boolean
    comment?: boolean
    timeSheetId?: boolean
    Maintenance?: boolean | MaintenanceDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceLog"]>

  export type MaintenanceLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    maintenanceId?: boolean
    startTime?: boolean
    endTime?: boolean
    comment?: boolean
    timeSheetId?: boolean
    Maintenance?: boolean | MaintenanceDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceLog"]>

  export type MaintenanceLogSelectScalar = {
    id?: boolean
    userId?: boolean
    maintenanceId?: boolean
    startTime?: boolean
    endTime?: boolean
    comment?: boolean
    timeSheetId?: boolean
  }

  export type MaintenanceLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "maintenanceId" | "startTime" | "endTime" | "comment" | "timeSheetId", ExtArgs["result"]["maintenanceLog"]>
  export type MaintenanceLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Maintenance?: boolean | MaintenanceDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MaintenanceLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Maintenance?: boolean | MaintenanceDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MaintenanceLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Maintenance?: boolean | MaintenanceDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MaintenanceLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceLog"
    objects: {
      Maintenance: Prisma.$MaintenancePayload<ExtArgs>
      TimeSheet: Prisma.$TimeSheetPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      maintenanceId: string
      startTime: Date
      endTime: Date | null
      comment: string | null
      timeSheetId: number
    }, ExtArgs["result"]["maintenanceLog"]>
    composites: {}
  }

  type MaintenanceLogGetPayload<S extends boolean | null | undefined | MaintenanceLogDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceLogPayload, S>

  type MaintenanceLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenanceLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenanceLogCountAggregateInputType | true
    }

  export interface MaintenanceLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceLog'], meta: { name: 'MaintenanceLog' } }
    /**
     * Find zero or one MaintenanceLog that matches the filter.
     * @param {MaintenanceLogFindUniqueArgs} args - Arguments to find a MaintenanceLog
     * @example
     * // Get one MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceLogFindUniqueArgs>(args: SelectSubset<T, MaintenanceLogFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaintenanceLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceLogFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceLog
     * @example
     * // Get one MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceLogFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogFindFirstArgs} args - Arguments to find a MaintenanceLog
     * @example
     * // Get one MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceLogFindFirstArgs>(args?: SelectSubset<T, MaintenanceLogFindFirstArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogFindFirstOrThrowArgs} args - Arguments to find a MaintenanceLog
     * @example
     * // Get one MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceLogFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaintenanceLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceLogs
     * const maintenanceLogs = await prisma.maintenanceLog.findMany()
     * 
     * // Get first 10 MaintenanceLogs
     * const maintenanceLogs = await prisma.maintenanceLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceLogWithIdOnly = await prisma.maintenanceLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceLogFindManyArgs>(args?: SelectSubset<T, MaintenanceLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaintenanceLog.
     * @param {MaintenanceLogCreateArgs} args - Arguments to create a MaintenanceLog.
     * @example
     * // Create one MaintenanceLog
     * const MaintenanceLog = await prisma.maintenanceLog.create({
     *   data: {
     *     // ... data to create a MaintenanceLog
     *   }
     * })
     * 
     */
    create<T extends MaintenanceLogCreateArgs>(args: SelectSubset<T, MaintenanceLogCreateArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaintenanceLogs.
     * @param {MaintenanceLogCreateManyArgs} args - Arguments to create many MaintenanceLogs.
     * @example
     * // Create many MaintenanceLogs
     * const maintenanceLog = await prisma.maintenanceLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceLogCreateManyArgs>(args?: SelectSubset<T, MaintenanceLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceLogs and returns the data saved in the database.
     * @param {MaintenanceLogCreateManyAndReturnArgs} args - Arguments to create many MaintenanceLogs.
     * @example
     * // Create many MaintenanceLogs
     * const maintenanceLog = await prisma.maintenanceLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceLogs and only return the `id`
     * const maintenanceLogWithIdOnly = await prisma.maintenanceLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceLogCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaintenanceLog.
     * @param {MaintenanceLogDeleteArgs} args - Arguments to delete one MaintenanceLog.
     * @example
     * // Delete one MaintenanceLog
     * const MaintenanceLog = await prisma.maintenanceLog.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceLog
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceLogDeleteArgs>(args: SelectSubset<T, MaintenanceLogDeleteArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaintenanceLog.
     * @param {MaintenanceLogUpdateArgs} args - Arguments to update one MaintenanceLog.
     * @example
     * // Update one MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceLogUpdateArgs>(args: SelectSubset<T, MaintenanceLogUpdateArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaintenanceLogs.
     * @param {MaintenanceLogDeleteManyArgs} args - Arguments to filter MaintenanceLogs to delete.
     * @example
     * // Delete a few MaintenanceLogs
     * const { count } = await prisma.maintenanceLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceLogDeleteManyArgs>(args?: SelectSubset<T, MaintenanceLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceLogs
     * const maintenanceLog = await prisma.maintenanceLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceLogUpdateManyArgs>(args: SelectSubset<T, MaintenanceLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceLogs and returns the data updated in the database.
     * @param {MaintenanceLogUpdateManyAndReturnArgs} args - Arguments to update many MaintenanceLogs.
     * @example
     * // Update many MaintenanceLogs
     * const maintenanceLog = await prisma.maintenanceLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaintenanceLogs and only return the `id`
     * const maintenanceLogWithIdOnly = await prisma.maintenanceLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenanceLogUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenanceLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaintenanceLog.
     * @param {MaintenanceLogUpsertArgs} args - Arguments to update or create a MaintenanceLog.
     * @example
     * // Update or create a MaintenanceLog
     * const maintenanceLog = await prisma.maintenanceLog.upsert({
     *   create: {
     *     // ... data to create a MaintenanceLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceLog we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceLogUpsertArgs>(args: SelectSubset<T, MaintenanceLogUpsertArgs<ExtArgs>>): Prisma__MaintenanceLogClient<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaintenanceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogCountArgs} args - Arguments to filter MaintenanceLogs to count.
     * @example
     * // Count the number of MaintenanceLogs
     * const count = await prisma.maintenanceLog.count({
     *   where: {
     *     // ... the filter for the MaintenanceLogs we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceLogCountArgs>(
      args?: Subset<T, MaintenanceLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceLogAggregateArgs>(args: Subset<T, MaintenanceLogAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceLogAggregateType<T>>

    /**
     * Group by MaintenanceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceLogGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceLog model
   */
  readonly fields: MaintenanceLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Maintenance<T extends MaintenanceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceDefaultArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    TimeSheet<T extends TimeSheetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TimeSheetDefaultArgs<ExtArgs>>): Prisma__TimeSheetClient<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceLog model
   */
  interface MaintenanceLogFieldRefs {
    readonly id: FieldRef<"MaintenanceLog", 'String'>
    readonly userId: FieldRef<"MaintenanceLog", 'String'>
    readonly maintenanceId: FieldRef<"MaintenanceLog", 'String'>
    readonly startTime: FieldRef<"MaintenanceLog", 'DateTime'>
    readonly endTime: FieldRef<"MaintenanceLog", 'DateTime'>
    readonly comment: FieldRef<"MaintenanceLog", 'String'>
    readonly timeSheetId: FieldRef<"MaintenanceLog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceLog findUnique
   */
  export type MaintenanceLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceLog to fetch.
     */
    where: MaintenanceLogWhereUniqueInput
  }

  /**
   * MaintenanceLog findUniqueOrThrow
   */
  export type MaintenanceLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceLog to fetch.
     */
    where: MaintenanceLogWhereUniqueInput
  }

  /**
   * MaintenanceLog findFirst
   */
  export type MaintenanceLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceLog to fetch.
     */
    where?: MaintenanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceLogs to fetch.
     */
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceLogs.
     */
    cursor?: MaintenanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceLogs.
     */
    distinct?: MaintenanceLogScalarFieldEnum | MaintenanceLogScalarFieldEnum[]
  }

  /**
   * MaintenanceLog findFirstOrThrow
   */
  export type MaintenanceLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceLog to fetch.
     */
    where?: MaintenanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceLogs to fetch.
     */
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceLogs.
     */
    cursor?: MaintenanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceLogs.
     */
    distinct?: MaintenanceLogScalarFieldEnum | MaintenanceLogScalarFieldEnum[]
  }

  /**
   * MaintenanceLog findMany
   */
  export type MaintenanceLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceLogs to fetch.
     */
    where?: MaintenanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceLogs to fetch.
     */
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceLogs.
     */
    cursor?: MaintenanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceLogs.
     */
    skip?: number
    distinct?: MaintenanceLogScalarFieldEnum | MaintenanceLogScalarFieldEnum[]
  }

  /**
   * MaintenanceLog create
   */
  export type MaintenanceLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceLog.
     */
    data: XOR<MaintenanceLogCreateInput, MaintenanceLogUncheckedCreateInput>
  }

  /**
   * MaintenanceLog createMany
   */
  export type MaintenanceLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceLogs.
     */
    data: MaintenanceLogCreateManyInput | MaintenanceLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MaintenanceLog createManyAndReturn
   */
  export type MaintenanceLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * The data used to create many MaintenanceLogs.
     */
    data: MaintenanceLogCreateManyInput | MaintenanceLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceLog update
   */
  export type MaintenanceLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceLog.
     */
    data: XOR<MaintenanceLogUpdateInput, MaintenanceLogUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceLog to update.
     */
    where: MaintenanceLogWhereUniqueInput
  }

  /**
   * MaintenanceLog updateMany
   */
  export type MaintenanceLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceLogs.
     */
    data: XOR<MaintenanceLogUpdateManyMutationInput, MaintenanceLogUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceLogs to update
     */
    where?: MaintenanceLogWhereInput
    /**
     * Limit how many MaintenanceLogs to update.
     */
    limit?: number
  }

  /**
   * MaintenanceLog updateManyAndReturn
   */
  export type MaintenanceLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * The data used to update MaintenanceLogs.
     */
    data: XOR<MaintenanceLogUpdateManyMutationInput, MaintenanceLogUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceLogs to update
     */
    where?: MaintenanceLogWhereInput
    /**
     * Limit how many MaintenanceLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceLog upsert
   */
  export type MaintenanceLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceLog to update in case it exists.
     */
    where: MaintenanceLogWhereUniqueInput
    /**
     * In case the MaintenanceLog found by the `where` argument doesn't exist, create a new MaintenanceLog with this data.
     */
    create: XOR<MaintenanceLogCreateInput, MaintenanceLogUncheckedCreateInput>
    /**
     * In case the MaintenanceLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceLogUpdateInput, MaintenanceLogUncheckedUpdateInput>
  }

  /**
   * MaintenanceLog delete
   */
  export type MaintenanceLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceLog to delete.
     */
    where: MaintenanceLogWhereUniqueInput
  }

  /**
   * MaintenanceLog deleteMany
   */
  export type MaintenanceLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceLogs to delete
     */
    where?: MaintenanceLogWhereInput
    /**
     * Limit how many MaintenanceLogs to delete.
     */
    limit?: number
  }

  /**
   * MaintenanceLog without action
   */
  export type MaintenanceLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
  }


  /**
   * Model Maintenance
   */

  export type AggregateMaintenance = {
    _count: MaintenanceCountAggregateOutputType | null
    _avg: MaintenanceAvgAggregateOutputType | null
    _sum: MaintenanceSumAggregateOutputType | null
    _min: MaintenanceMinAggregateOutputType | null
    _max: MaintenanceMaxAggregateOutputType | null
  }

  export type MaintenanceAvgAggregateOutputType = {
    totalHoursLaboured: number | null
  }

  export type MaintenanceSumAggregateOutputType = {
    totalHoursLaboured: number | null
  }

  export type MaintenanceMinAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    equipmentIssue: string | null
    employeeEquipmentLogId: string | null
    additionalInfo: string | null
    location: string | null
    problemDiagnosis: string | null
    solution: string | null
    totalHoursLaboured: number | null
    createdAt: Date | null
    priority: $Enums.Priority | null
    delay: Date | null
    delayReasoning: string | null
    repaired: boolean | null
    selected: boolean | null
    hasBeenDelayed: boolean | null
    createdBy: string | null
  }

  export type MaintenanceMaxAggregateOutputType = {
    id: string | null
    equipmentId: string | null
    equipmentIssue: string | null
    employeeEquipmentLogId: string | null
    additionalInfo: string | null
    location: string | null
    problemDiagnosis: string | null
    solution: string | null
    totalHoursLaboured: number | null
    createdAt: Date | null
    priority: $Enums.Priority | null
    delay: Date | null
    delayReasoning: string | null
    repaired: boolean | null
    selected: boolean | null
    hasBeenDelayed: boolean | null
    createdBy: string | null
  }

  export type MaintenanceCountAggregateOutputType = {
    id: number
    equipmentId: number
    equipmentIssue: number
    employeeEquipmentLogId: number
    additionalInfo: number
    location: number
    problemDiagnosis: number
    solution: number
    totalHoursLaboured: number
    createdAt: number
    priority: number
    delay: number
    delayReasoning: number
    repaired: number
    selected: number
    hasBeenDelayed: number
    createdBy: number
    _all: number
  }


  export type MaintenanceAvgAggregateInputType = {
    totalHoursLaboured?: true
  }

  export type MaintenanceSumAggregateInputType = {
    totalHoursLaboured?: true
  }

  export type MaintenanceMinAggregateInputType = {
    id?: true
    equipmentId?: true
    equipmentIssue?: true
    employeeEquipmentLogId?: true
    additionalInfo?: true
    location?: true
    problemDiagnosis?: true
    solution?: true
    totalHoursLaboured?: true
    createdAt?: true
    priority?: true
    delay?: true
    delayReasoning?: true
    repaired?: true
    selected?: true
    hasBeenDelayed?: true
    createdBy?: true
  }

  export type MaintenanceMaxAggregateInputType = {
    id?: true
    equipmentId?: true
    equipmentIssue?: true
    employeeEquipmentLogId?: true
    additionalInfo?: true
    location?: true
    problemDiagnosis?: true
    solution?: true
    totalHoursLaboured?: true
    createdAt?: true
    priority?: true
    delay?: true
    delayReasoning?: true
    repaired?: true
    selected?: true
    hasBeenDelayed?: true
    createdBy?: true
  }

  export type MaintenanceCountAggregateInputType = {
    id?: true
    equipmentId?: true
    equipmentIssue?: true
    employeeEquipmentLogId?: true
    additionalInfo?: true
    location?: true
    problemDiagnosis?: true
    solution?: true
    totalHoursLaboured?: true
    createdAt?: true
    priority?: true
    delay?: true
    delayReasoning?: true
    repaired?: true
    selected?: true
    hasBeenDelayed?: true
    createdBy?: true
    _all?: true
  }

  export type MaintenanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maintenance to aggregate.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Maintenances
    **/
    _count?: true | MaintenanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintenanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintenanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceMaxAggregateInputType
  }

  export type GetMaintenanceAggregateType<T extends MaintenanceAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenance[P]>
      : GetScalarType<T[P], AggregateMaintenance[P]>
  }




  export type MaintenanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithAggregationInput | MaintenanceOrderByWithAggregationInput[]
    by: MaintenanceScalarFieldEnum[] | MaintenanceScalarFieldEnum
    having?: MaintenanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceCountAggregateInputType | true
    _avg?: MaintenanceAvgAggregateInputType
    _sum?: MaintenanceSumAggregateInputType
    _min?: MaintenanceMinAggregateInputType
    _max?: MaintenanceMaxAggregateInputType
  }

  export type MaintenanceGroupByOutputType = {
    id: string
    equipmentId: string
    equipmentIssue: string | null
    employeeEquipmentLogId: string | null
    additionalInfo: string | null
    location: string | null
    problemDiagnosis: string | null
    solution: string | null
    totalHoursLaboured: number | null
    createdAt: Date
    priority: $Enums.Priority
    delay: Date | null
    delayReasoning: string | null
    repaired: boolean
    selected: boolean
    hasBeenDelayed: boolean
    createdBy: string | null
    _count: MaintenanceCountAggregateOutputType | null
    _avg: MaintenanceAvgAggregateOutputType | null
    _sum: MaintenanceSumAggregateOutputType | null
    _min: MaintenanceMinAggregateOutputType | null
    _max: MaintenanceMaxAggregateOutputType | null
  }

  type GetMaintenanceGroupByPayload<T extends MaintenanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    equipmentIssue?: boolean
    employeeEquipmentLogId?: boolean
    additionalInfo?: boolean
    location?: boolean
    problemDiagnosis?: boolean
    solution?: boolean
    totalHoursLaboured?: boolean
    createdAt?: boolean
    priority?: boolean
    delay?: boolean
    delayReasoning?: boolean
    repaired?: boolean
    selected?: boolean
    hasBeenDelayed?: boolean
    createdBy?: boolean
    EmployeeEquipmentLog?: boolean | Maintenance$EmployeeEquipmentLogArgs<ExtArgs>
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    MaintenanceLogs?: boolean | Maintenance$MaintenanceLogsArgs<ExtArgs>
    _count?: boolean | MaintenanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance"]>

  export type MaintenanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    equipmentIssue?: boolean
    employeeEquipmentLogId?: boolean
    additionalInfo?: boolean
    location?: boolean
    problemDiagnosis?: boolean
    solution?: boolean
    totalHoursLaboured?: boolean
    createdAt?: boolean
    priority?: boolean
    delay?: boolean
    delayReasoning?: boolean
    repaired?: boolean
    selected?: boolean
    hasBeenDelayed?: boolean
    createdBy?: boolean
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance"]>

  export type MaintenanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    equipmentId?: boolean
    equipmentIssue?: boolean
    employeeEquipmentLogId?: boolean
    additionalInfo?: boolean
    location?: boolean
    problemDiagnosis?: boolean
    solution?: boolean
    totalHoursLaboured?: boolean
    createdAt?: boolean
    priority?: boolean
    delay?: boolean
    delayReasoning?: boolean
    repaired?: boolean
    selected?: boolean
    hasBeenDelayed?: boolean
    createdBy?: boolean
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance"]>

  export type MaintenanceSelectScalar = {
    id?: boolean
    equipmentId?: boolean
    equipmentIssue?: boolean
    employeeEquipmentLogId?: boolean
    additionalInfo?: boolean
    location?: boolean
    problemDiagnosis?: boolean
    solution?: boolean
    totalHoursLaboured?: boolean
    createdAt?: boolean
    priority?: boolean
    delay?: boolean
    delayReasoning?: boolean
    repaired?: boolean
    selected?: boolean
    hasBeenDelayed?: boolean
    createdBy?: boolean
  }

  export type MaintenanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "equipmentId" | "equipmentIssue" | "employeeEquipmentLogId" | "additionalInfo" | "location" | "problemDiagnosis" | "solution" | "totalHoursLaboured" | "createdAt" | "priority" | "delay" | "delayReasoning" | "repaired" | "selected" | "hasBeenDelayed" | "createdBy", ExtArgs["result"]["maintenance"]>
  export type MaintenanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeEquipmentLog?: boolean | Maintenance$EmployeeEquipmentLogArgs<ExtArgs>
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
    MaintenanceLogs?: boolean | Maintenance$MaintenanceLogsArgs<ExtArgs>
    _count?: boolean | MaintenanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MaintenanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type MaintenanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }

  export type $MaintenancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Maintenance"
    objects: {
      EmployeeEquipmentLog: Prisma.$EmployeeEquipmentLogPayload<ExtArgs>[]
      Equipment: Prisma.$EquipmentPayload<ExtArgs>
      MaintenanceLogs: Prisma.$MaintenanceLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      equipmentId: string
      equipmentIssue: string | null
      employeeEquipmentLogId: string | null
      additionalInfo: string | null
      location: string | null
      problemDiagnosis: string | null
      solution: string | null
      totalHoursLaboured: number | null
      createdAt: Date
      priority: $Enums.Priority
      delay: Date | null
      delayReasoning: string | null
      repaired: boolean
      selected: boolean
      hasBeenDelayed: boolean
      createdBy: string | null
    }, ExtArgs["result"]["maintenance"]>
    composites: {}
  }

  type MaintenanceGetPayload<S extends boolean | null | undefined | MaintenanceDefaultArgs> = $Result.GetResult<Prisma.$MaintenancePayload, S>

  type MaintenanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenanceCountAggregateInputType | true
    }

  export interface MaintenanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Maintenance'], meta: { name: 'Maintenance' } }
    /**
     * Find zero or one Maintenance that matches the filter.
     * @param {MaintenanceFindUniqueArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceFindUniqueArgs>(args: SelectSubset<T, MaintenanceFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Maintenance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceFindUniqueOrThrowArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintenance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindFirstArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceFindFirstArgs>(args?: SelectSubset<T, MaintenanceFindFirstArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintenance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindFirstOrThrowArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Maintenances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maintenances
     * const maintenances = await prisma.maintenance.findMany()
     * 
     * // Get first 10 Maintenances
     * const maintenances = await prisma.maintenance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceWithIdOnly = await prisma.maintenance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceFindManyArgs>(args?: SelectSubset<T, MaintenanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Maintenance.
     * @param {MaintenanceCreateArgs} args - Arguments to create a Maintenance.
     * @example
     * // Create one Maintenance
     * const Maintenance = await prisma.maintenance.create({
     *   data: {
     *     // ... data to create a Maintenance
     *   }
     * })
     * 
     */
    create<T extends MaintenanceCreateArgs>(args: SelectSubset<T, MaintenanceCreateArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Maintenances.
     * @param {MaintenanceCreateManyArgs} args - Arguments to create many Maintenances.
     * @example
     * // Create many Maintenances
     * const maintenance = await prisma.maintenance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceCreateManyArgs>(args?: SelectSubset<T, MaintenanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maintenances and returns the data saved in the database.
     * @param {MaintenanceCreateManyAndReturnArgs} args - Arguments to create many Maintenances.
     * @example
     * // Create many Maintenances
     * const maintenance = await prisma.maintenance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maintenances and only return the `id`
     * const maintenanceWithIdOnly = await prisma.maintenance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Maintenance.
     * @param {MaintenanceDeleteArgs} args - Arguments to delete one Maintenance.
     * @example
     * // Delete one Maintenance
     * const Maintenance = await prisma.maintenance.delete({
     *   where: {
     *     // ... filter to delete one Maintenance
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceDeleteArgs>(args: SelectSubset<T, MaintenanceDeleteArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Maintenance.
     * @param {MaintenanceUpdateArgs} args - Arguments to update one Maintenance.
     * @example
     * // Update one Maintenance
     * const maintenance = await prisma.maintenance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceUpdateArgs>(args: SelectSubset<T, MaintenanceUpdateArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Maintenances.
     * @param {MaintenanceDeleteManyArgs} args - Arguments to filter Maintenances to delete.
     * @example
     * // Delete a few Maintenances
     * const { count } = await prisma.maintenance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceDeleteManyArgs>(args?: SelectSubset<T, MaintenanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maintenances
     * const maintenance = await prisma.maintenance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceUpdateManyArgs>(args: SelectSubset<T, MaintenanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintenances and returns the data updated in the database.
     * @param {MaintenanceUpdateManyAndReturnArgs} args - Arguments to update many Maintenances.
     * @example
     * // Update many Maintenances
     * const maintenance = await prisma.maintenance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Maintenances and only return the `id`
     * const maintenanceWithIdOnly = await prisma.maintenance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenanceUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Maintenance.
     * @param {MaintenanceUpsertArgs} args - Arguments to update or create a Maintenance.
     * @example
     * // Update or create a Maintenance
     * const maintenance = await prisma.maintenance.upsert({
     *   create: {
     *     // ... data to create a Maintenance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maintenance we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceUpsertArgs>(args: SelectSubset<T, MaintenanceUpsertArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Maintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceCountArgs} args - Arguments to filter Maintenances to count.
     * @example
     * // Count the number of Maintenances
     * const count = await prisma.maintenance.count({
     *   where: {
     *     // ... the filter for the Maintenances we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceCountArgs>(
      args?: Subset<T, MaintenanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceAggregateArgs>(args: Subset<T, MaintenanceAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceAggregateType<T>>

    /**
     * Group by Maintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Maintenance model
   */
  readonly fields: MaintenanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Maintenance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EmployeeEquipmentLog<T extends Maintenance$EmployeeEquipmentLogArgs<ExtArgs> = {}>(args?: Subset<T, Maintenance$EmployeeEquipmentLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeEquipmentLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    MaintenanceLogs<T extends Maintenance$MaintenanceLogsArgs<ExtArgs> = {}>(args?: Subset<T, Maintenance$MaintenanceLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Maintenance model
   */
  interface MaintenanceFieldRefs {
    readonly id: FieldRef<"Maintenance", 'String'>
    readonly equipmentId: FieldRef<"Maintenance", 'String'>
    readonly equipmentIssue: FieldRef<"Maintenance", 'String'>
    readonly employeeEquipmentLogId: FieldRef<"Maintenance", 'String'>
    readonly additionalInfo: FieldRef<"Maintenance", 'String'>
    readonly location: FieldRef<"Maintenance", 'String'>
    readonly problemDiagnosis: FieldRef<"Maintenance", 'String'>
    readonly solution: FieldRef<"Maintenance", 'String'>
    readonly totalHoursLaboured: FieldRef<"Maintenance", 'Float'>
    readonly createdAt: FieldRef<"Maintenance", 'DateTime'>
    readonly priority: FieldRef<"Maintenance", 'Priority'>
    readonly delay: FieldRef<"Maintenance", 'DateTime'>
    readonly delayReasoning: FieldRef<"Maintenance", 'String'>
    readonly repaired: FieldRef<"Maintenance", 'Boolean'>
    readonly selected: FieldRef<"Maintenance", 'Boolean'>
    readonly hasBeenDelayed: FieldRef<"Maintenance", 'Boolean'>
    readonly createdBy: FieldRef<"Maintenance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Maintenance findUnique
   */
  export type MaintenanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance findUniqueOrThrow
   */
  export type MaintenanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance findFirst
   */
  export type MaintenanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maintenances.
     */
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance findFirstOrThrow
   */
  export type MaintenanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maintenances.
     */
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance findMany
   */
  export type MaintenanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenances to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance create
   */
  export type MaintenanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Maintenance.
     */
    data: XOR<MaintenanceCreateInput, MaintenanceUncheckedCreateInput>
  }

  /**
   * Maintenance createMany
   */
  export type MaintenanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Maintenances.
     */
    data: MaintenanceCreateManyInput | MaintenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Maintenance createManyAndReturn
   */
  export type MaintenanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * The data used to create many Maintenances.
     */
    data: MaintenanceCreateManyInput | MaintenanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Maintenance update
   */
  export type MaintenanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Maintenance.
     */
    data: XOR<MaintenanceUpdateInput, MaintenanceUncheckedUpdateInput>
    /**
     * Choose, which Maintenance to update.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance updateMany
   */
  export type MaintenanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Maintenances.
     */
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which Maintenances to update
     */
    where?: MaintenanceWhereInput
    /**
     * Limit how many Maintenances to update.
     */
    limit?: number
  }

  /**
   * Maintenance updateManyAndReturn
   */
  export type MaintenanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * The data used to update Maintenances.
     */
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which Maintenances to update
     */
    where?: MaintenanceWhereInput
    /**
     * Limit how many Maintenances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Maintenance upsert
   */
  export type MaintenanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Maintenance to update in case it exists.
     */
    where: MaintenanceWhereUniqueInput
    /**
     * In case the Maintenance found by the `where` argument doesn't exist, create a new Maintenance with this data.
     */
    create: XOR<MaintenanceCreateInput, MaintenanceUncheckedCreateInput>
    /**
     * In case the Maintenance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceUpdateInput, MaintenanceUncheckedUpdateInput>
  }

  /**
   * Maintenance delete
   */
  export type MaintenanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter which Maintenance to delete.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance deleteMany
   */
  export type MaintenanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maintenances to delete
     */
    where?: MaintenanceWhereInput
    /**
     * Limit how many Maintenances to delete.
     */
    limit?: number
  }

  /**
   * Maintenance.EmployeeEquipmentLog
   */
  export type Maintenance$EmployeeEquipmentLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeEquipmentLog
     */
    select?: EmployeeEquipmentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeEquipmentLog
     */
    omit?: EmployeeEquipmentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeEquipmentLogInclude<ExtArgs> | null
    where?: EmployeeEquipmentLogWhereInput
    orderBy?: EmployeeEquipmentLogOrderByWithRelationInput | EmployeeEquipmentLogOrderByWithRelationInput[]
    cursor?: EmployeeEquipmentLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeEquipmentLogScalarFieldEnum | EmployeeEquipmentLogScalarFieldEnum[]
  }

  /**
   * Maintenance.MaintenanceLogs
   */
  export type Maintenance$MaintenanceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    where?: MaintenanceLogWhereInput
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    cursor?: MaintenanceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceLogScalarFieldEnum | MaintenanceLogScalarFieldEnum[]
  }

  /**
   * Maintenance without action
   */
  export type MaintenanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
  }


  /**
   * Model TascoLog
   */

  export type AggregateTascoLog = {
    _count: TascoLogCountAggregateOutputType | null
    _avg: TascoLogAvgAggregateOutputType | null
    _sum: TascoLogSumAggregateOutputType | null
    _min: TascoLogMinAggregateOutputType | null
    _max: TascoLogMaxAggregateOutputType | null
  }

  export type TascoLogAvgAggregateOutputType = {
    LoadQuantity: number | null
    timeSheetId: number | null
  }

  export type TascoLogSumAggregateOutputType = {
    LoadQuantity: number | null
    timeSheetId: number | null
  }

  export type TascoLogMinAggregateOutputType = {
    id: string | null
    shiftType: string | null
    equipmentId: string | null
    laborType: string | null
    materialType: string | null
    LoadQuantity: number | null
    screenType: $Enums.LoadType | null
    timeSheetId: number | null
  }

  export type TascoLogMaxAggregateOutputType = {
    id: string | null
    shiftType: string | null
    equipmentId: string | null
    laborType: string | null
    materialType: string | null
    LoadQuantity: number | null
    screenType: $Enums.LoadType | null
    timeSheetId: number | null
  }

  export type TascoLogCountAggregateOutputType = {
    id: number
    shiftType: number
    equipmentId: number
    laborType: number
    materialType: number
    LoadQuantity: number
    screenType: number
    timeSheetId: number
    _all: number
  }


  export type TascoLogAvgAggregateInputType = {
    LoadQuantity?: true
    timeSheetId?: true
  }

  export type TascoLogSumAggregateInputType = {
    LoadQuantity?: true
    timeSheetId?: true
  }

  export type TascoLogMinAggregateInputType = {
    id?: true
    shiftType?: true
    equipmentId?: true
    laborType?: true
    materialType?: true
    LoadQuantity?: true
    screenType?: true
    timeSheetId?: true
  }

  export type TascoLogMaxAggregateInputType = {
    id?: true
    shiftType?: true
    equipmentId?: true
    laborType?: true
    materialType?: true
    LoadQuantity?: true
    screenType?: true
    timeSheetId?: true
  }

  export type TascoLogCountAggregateInputType = {
    id?: true
    shiftType?: true
    equipmentId?: true
    laborType?: true
    materialType?: true
    LoadQuantity?: true
    screenType?: true
    timeSheetId?: true
    _all?: true
  }

  export type TascoLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TascoLog to aggregate.
     */
    where?: TascoLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TascoLogs to fetch.
     */
    orderBy?: TascoLogOrderByWithRelationInput | TascoLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TascoLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TascoLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TascoLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TascoLogs
    **/
    _count?: true | TascoLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TascoLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TascoLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TascoLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TascoLogMaxAggregateInputType
  }

  export type GetTascoLogAggregateType<T extends TascoLogAggregateArgs> = {
        [P in keyof T & keyof AggregateTascoLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTascoLog[P]>
      : GetScalarType<T[P], AggregateTascoLog[P]>
  }




  export type TascoLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TascoLogWhereInput
    orderBy?: TascoLogOrderByWithAggregationInput | TascoLogOrderByWithAggregationInput[]
    by: TascoLogScalarFieldEnum[] | TascoLogScalarFieldEnum
    having?: TascoLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TascoLogCountAggregateInputType | true
    _avg?: TascoLogAvgAggregateInputType
    _sum?: TascoLogSumAggregateInputType
    _min?: TascoLogMinAggregateInputType
    _max?: TascoLogMaxAggregateInputType
  }

  export type TascoLogGroupByOutputType = {
    id: string
    shiftType: string
    equipmentId: string | null
    laborType: string | null
    materialType: string | null
    LoadQuantity: number
    screenType: $Enums.LoadType | null
    timeSheetId: number
    _count: TascoLogCountAggregateOutputType | null
    _avg: TascoLogAvgAggregateOutputType | null
    _sum: TascoLogSumAggregateOutputType | null
    _min: TascoLogMinAggregateOutputType | null
    _max: TascoLogMaxAggregateOutputType | null
  }

  type GetTascoLogGroupByPayload<T extends TascoLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TascoLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TascoLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TascoLogGroupByOutputType[P]>
            : GetScalarType<T[P], TascoLogGroupByOutputType[P]>
        }
      >
    >


  export type TascoLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shiftType?: boolean
    equipmentId?: boolean
    laborType?: boolean
    materialType?: boolean
    LoadQuantity?: boolean
    screenType?: boolean
    timeSheetId?: boolean
    RefuelLogs?: boolean | TascoLog$RefuelLogsArgs<ExtArgs>
    TascoFLoads?: boolean | TascoLog$TascoFLoadsArgs<ExtArgs>
    Equipment?: boolean | TascoLog$EquipmentArgs<ExtArgs>
    TascoMaterialTypes?: boolean | TascoLog$TascoMaterialTypesArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
    _count?: boolean | TascoLogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tascoLog"]>

  export type TascoLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shiftType?: boolean
    equipmentId?: boolean
    laborType?: boolean
    materialType?: boolean
    LoadQuantity?: boolean
    screenType?: boolean
    timeSheetId?: boolean
    Equipment?: boolean | TascoLog$EquipmentArgs<ExtArgs>
    TascoMaterialTypes?: boolean | TascoLog$TascoMaterialTypesArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tascoLog"]>

  export type TascoLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shiftType?: boolean
    equipmentId?: boolean
    laborType?: boolean
    materialType?: boolean
    LoadQuantity?: boolean
    screenType?: boolean
    timeSheetId?: boolean
    Equipment?: boolean | TascoLog$EquipmentArgs<ExtArgs>
    TascoMaterialTypes?: boolean | TascoLog$TascoMaterialTypesArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tascoLog"]>

  export type TascoLogSelectScalar = {
    id?: boolean
    shiftType?: boolean
    equipmentId?: boolean
    laborType?: boolean
    materialType?: boolean
    LoadQuantity?: boolean
    screenType?: boolean
    timeSheetId?: boolean
  }

  export type TascoLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shiftType" | "equipmentId" | "laborType" | "materialType" | "LoadQuantity" | "screenType" | "timeSheetId", ExtArgs["result"]["tascoLog"]>
  export type TascoLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    RefuelLogs?: boolean | TascoLog$RefuelLogsArgs<ExtArgs>
    TascoFLoads?: boolean | TascoLog$TascoFLoadsArgs<ExtArgs>
    Equipment?: boolean | TascoLog$EquipmentArgs<ExtArgs>
    TascoMaterialTypes?: boolean | TascoLog$TascoMaterialTypesArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
    _count?: boolean | TascoLogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TascoLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | TascoLog$EquipmentArgs<ExtArgs>
    TascoMaterialTypes?: boolean | TascoLog$TascoMaterialTypesArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }
  export type TascoLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | TascoLog$EquipmentArgs<ExtArgs>
    TascoMaterialTypes?: boolean | TascoLog$TascoMaterialTypesArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }

  export type $TascoLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TascoLog"
    objects: {
      RefuelLogs: Prisma.$RefuelLogPayload<ExtArgs>[]
      TascoFLoads: Prisma.$TascoFLoadsPayload<ExtArgs>[]
      Equipment: Prisma.$EquipmentPayload<ExtArgs> | null
      TascoMaterialTypes: Prisma.$TascoMaterialTypesPayload<ExtArgs> | null
      TimeSheet: Prisma.$TimeSheetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shiftType: string
      equipmentId: string | null
      laborType: string | null
      materialType: string | null
      LoadQuantity: number
      screenType: $Enums.LoadType | null
      timeSheetId: number
    }, ExtArgs["result"]["tascoLog"]>
    composites: {}
  }

  type TascoLogGetPayload<S extends boolean | null | undefined | TascoLogDefaultArgs> = $Result.GetResult<Prisma.$TascoLogPayload, S>

  type TascoLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TascoLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TascoLogCountAggregateInputType | true
    }

  export interface TascoLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TascoLog'], meta: { name: 'TascoLog' } }
    /**
     * Find zero or one TascoLog that matches the filter.
     * @param {TascoLogFindUniqueArgs} args - Arguments to find a TascoLog
     * @example
     * // Get one TascoLog
     * const tascoLog = await prisma.tascoLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TascoLogFindUniqueArgs>(args: SelectSubset<T, TascoLogFindUniqueArgs<ExtArgs>>): Prisma__TascoLogClient<$Result.GetResult<Prisma.$TascoLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TascoLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TascoLogFindUniqueOrThrowArgs} args - Arguments to find a TascoLog
     * @example
     * // Get one TascoLog
     * const tascoLog = await prisma.tascoLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TascoLogFindUniqueOrThrowArgs>(args: SelectSubset<T, TascoLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TascoLogClient<$Result.GetResult<Prisma.$TascoLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TascoLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoLogFindFirstArgs} args - Arguments to find a TascoLog
     * @example
     * // Get one TascoLog
     * const tascoLog = await prisma.tascoLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TascoLogFindFirstArgs>(args?: SelectSubset<T, TascoLogFindFirstArgs<ExtArgs>>): Prisma__TascoLogClient<$Result.GetResult<Prisma.$TascoLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TascoLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoLogFindFirstOrThrowArgs} args - Arguments to find a TascoLog
     * @example
     * // Get one TascoLog
     * const tascoLog = await prisma.tascoLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TascoLogFindFirstOrThrowArgs>(args?: SelectSubset<T, TascoLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TascoLogClient<$Result.GetResult<Prisma.$TascoLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TascoLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TascoLogs
     * const tascoLogs = await prisma.tascoLog.findMany()
     * 
     * // Get first 10 TascoLogs
     * const tascoLogs = await prisma.tascoLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tascoLogWithIdOnly = await prisma.tascoLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TascoLogFindManyArgs>(args?: SelectSubset<T, TascoLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TascoLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TascoLog.
     * @param {TascoLogCreateArgs} args - Arguments to create a TascoLog.
     * @example
     * // Create one TascoLog
     * const TascoLog = await prisma.tascoLog.create({
     *   data: {
     *     // ... data to create a TascoLog
     *   }
     * })
     * 
     */
    create<T extends TascoLogCreateArgs>(args: SelectSubset<T, TascoLogCreateArgs<ExtArgs>>): Prisma__TascoLogClient<$Result.GetResult<Prisma.$TascoLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TascoLogs.
     * @param {TascoLogCreateManyArgs} args - Arguments to create many TascoLogs.
     * @example
     * // Create many TascoLogs
     * const tascoLog = await prisma.tascoLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TascoLogCreateManyArgs>(args?: SelectSubset<T, TascoLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TascoLogs and returns the data saved in the database.
     * @param {TascoLogCreateManyAndReturnArgs} args - Arguments to create many TascoLogs.
     * @example
     * // Create many TascoLogs
     * const tascoLog = await prisma.tascoLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TascoLogs and only return the `id`
     * const tascoLogWithIdOnly = await prisma.tascoLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TascoLogCreateManyAndReturnArgs>(args?: SelectSubset<T, TascoLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TascoLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TascoLog.
     * @param {TascoLogDeleteArgs} args - Arguments to delete one TascoLog.
     * @example
     * // Delete one TascoLog
     * const TascoLog = await prisma.tascoLog.delete({
     *   where: {
     *     // ... filter to delete one TascoLog
     *   }
     * })
     * 
     */
    delete<T extends TascoLogDeleteArgs>(args: SelectSubset<T, TascoLogDeleteArgs<ExtArgs>>): Prisma__TascoLogClient<$Result.GetResult<Prisma.$TascoLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TascoLog.
     * @param {TascoLogUpdateArgs} args - Arguments to update one TascoLog.
     * @example
     * // Update one TascoLog
     * const tascoLog = await prisma.tascoLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TascoLogUpdateArgs>(args: SelectSubset<T, TascoLogUpdateArgs<ExtArgs>>): Prisma__TascoLogClient<$Result.GetResult<Prisma.$TascoLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TascoLogs.
     * @param {TascoLogDeleteManyArgs} args - Arguments to filter TascoLogs to delete.
     * @example
     * // Delete a few TascoLogs
     * const { count } = await prisma.tascoLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TascoLogDeleteManyArgs>(args?: SelectSubset<T, TascoLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TascoLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TascoLogs
     * const tascoLog = await prisma.tascoLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TascoLogUpdateManyArgs>(args: SelectSubset<T, TascoLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TascoLogs and returns the data updated in the database.
     * @param {TascoLogUpdateManyAndReturnArgs} args - Arguments to update many TascoLogs.
     * @example
     * // Update many TascoLogs
     * const tascoLog = await prisma.tascoLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TascoLogs and only return the `id`
     * const tascoLogWithIdOnly = await prisma.tascoLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TascoLogUpdateManyAndReturnArgs>(args: SelectSubset<T, TascoLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TascoLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TascoLog.
     * @param {TascoLogUpsertArgs} args - Arguments to update or create a TascoLog.
     * @example
     * // Update or create a TascoLog
     * const tascoLog = await prisma.tascoLog.upsert({
     *   create: {
     *     // ... data to create a TascoLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TascoLog we want to update
     *   }
     * })
     */
    upsert<T extends TascoLogUpsertArgs>(args: SelectSubset<T, TascoLogUpsertArgs<ExtArgs>>): Prisma__TascoLogClient<$Result.GetResult<Prisma.$TascoLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TascoLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoLogCountArgs} args - Arguments to filter TascoLogs to count.
     * @example
     * // Count the number of TascoLogs
     * const count = await prisma.tascoLog.count({
     *   where: {
     *     // ... the filter for the TascoLogs we want to count
     *   }
     * })
    **/
    count<T extends TascoLogCountArgs>(
      args?: Subset<T, TascoLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TascoLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TascoLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TascoLogAggregateArgs>(args: Subset<T, TascoLogAggregateArgs>): Prisma.PrismaPromise<GetTascoLogAggregateType<T>>

    /**
     * Group by TascoLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TascoLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TascoLogGroupByArgs['orderBy'] }
        : { orderBy?: TascoLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TascoLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTascoLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TascoLog model
   */
  readonly fields: TascoLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TascoLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TascoLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    RefuelLogs<T extends TascoLog$RefuelLogsArgs<ExtArgs> = {}>(args?: Subset<T, TascoLog$RefuelLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefuelLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TascoFLoads<T extends TascoLog$TascoFLoadsArgs<ExtArgs> = {}>(args?: Subset<T, TascoLog$TascoFLoadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TascoFLoadsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Equipment<T extends TascoLog$EquipmentArgs<ExtArgs> = {}>(args?: Subset<T, TascoLog$EquipmentArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    TascoMaterialTypes<T extends TascoLog$TascoMaterialTypesArgs<ExtArgs> = {}>(args?: Subset<T, TascoLog$TascoMaterialTypesArgs<ExtArgs>>): Prisma__TascoMaterialTypesClient<$Result.GetResult<Prisma.$TascoMaterialTypesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    TimeSheet<T extends TimeSheetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TimeSheetDefaultArgs<ExtArgs>>): Prisma__TimeSheetClient<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TascoLog model
   */
  interface TascoLogFieldRefs {
    readonly id: FieldRef<"TascoLog", 'String'>
    readonly shiftType: FieldRef<"TascoLog", 'String'>
    readonly equipmentId: FieldRef<"TascoLog", 'String'>
    readonly laborType: FieldRef<"TascoLog", 'String'>
    readonly materialType: FieldRef<"TascoLog", 'String'>
    readonly LoadQuantity: FieldRef<"TascoLog", 'Int'>
    readonly screenType: FieldRef<"TascoLog", 'LoadType'>
    readonly timeSheetId: FieldRef<"TascoLog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TascoLog findUnique
   */
  export type TascoLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLog
     */
    select?: TascoLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoLog
     */
    omit?: TascoLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoLogInclude<ExtArgs> | null
    /**
     * Filter, which TascoLog to fetch.
     */
    where: TascoLogWhereUniqueInput
  }

  /**
   * TascoLog findUniqueOrThrow
   */
  export type TascoLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLog
     */
    select?: TascoLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoLog
     */
    omit?: TascoLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoLogInclude<ExtArgs> | null
    /**
     * Filter, which TascoLog to fetch.
     */
    where: TascoLogWhereUniqueInput
  }

  /**
   * TascoLog findFirst
   */
  export type TascoLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLog
     */
    select?: TascoLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoLog
     */
    omit?: TascoLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoLogInclude<ExtArgs> | null
    /**
     * Filter, which TascoLog to fetch.
     */
    where?: TascoLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TascoLogs to fetch.
     */
    orderBy?: TascoLogOrderByWithRelationInput | TascoLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TascoLogs.
     */
    cursor?: TascoLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TascoLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TascoLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TascoLogs.
     */
    distinct?: TascoLogScalarFieldEnum | TascoLogScalarFieldEnum[]
  }

  /**
   * TascoLog findFirstOrThrow
   */
  export type TascoLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLog
     */
    select?: TascoLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoLog
     */
    omit?: TascoLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoLogInclude<ExtArgs> | null
    /**
     * Filter, which TascoLog to fetch.
     */
    where?: TascoLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TascoLogs to fetch.
     */
    orderBy?: TascoLogOrderByWithRelationInput | TascoLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TascoLogs.
     */
    cursor?: TascoLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TascoLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TascoLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TascoLogs.
     */
    distinct?: TascoLogScalarFieldEnum | TascoLogScalarFieldEnum[]
  }

  /**
   * TascoLog findMany
   */
  export type TascoLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLog
     */
    select?: TascoLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoLog
     */
    omit?: TascoLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoLogInclude<ExtArgs> | null
    /**
     * Filter, which TascoLogs to fetch.
     */
    where?: TascoLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TascoLogs to fetch.
     */
    orderBy?: TascoLogOrderByWithRelationInput | TascoLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TascoLogs.
     */
    cursor?: TascoLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TascoLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TascoLogs.
     */
    skip?: number
    distinct?: TascoLogScalarFieldEnum | TascoLogScalarFieldEnum[]
  }

  /**
   * TascoLog create
   */
  export type TascoLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLog
     */
    select?: TascoLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoLog
     */
    omit?: TascoLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoLogInclude<ExtArgs> | null
    /**
     * The data needed to create a TascoLog.
     */
    data: XOR<TascoLogCreateInput, TascoLogUncheckedCreateInput>
  }

  /**
   * TascoLog createMany
   */
  export type TascoLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TascoLogs.
     */
    data: TascoLogCreateManyInput | TascoLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TascoLog createManyAndReturn
   */
  export type TascoLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLog
     */
    select?: TascoLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TascoLog
     */
    omit?: TascoLogOmit<ExtArgs> | null
    /**
     * The data used to create many TascoLogs.
     */
    data: TascoLogCreateManyInput | TascoLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TascoLog update
   */
  export type TascoLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLog
     */
    select?: TascoLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoLog
     */
    omit?: TascoLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoLogInclude<ExtArgs> | null
    /**
     * The data needed to update a TascoLog.
     */
    data: XOR<TascoLogUpdateInput, TascoLogUncheckedUpdateInput>
    /**
     * Choose, which TascoLog to update.
     */
    where: TascoLogWhereUniqueInput
  }

  /**
   * TascoLog updateMany
   */
  export type TascoLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TascoLogs.
     */
    data: XOR<TascoLogUpdateManyMutationInput, TascoLogUncheckedUpdateManyInput>
    /**
     * Filter which TascoLogs to update
     */
    where?: TascoLogWhereInput
    /**
     * Limit how many TascoLogs to update.
     */
    limit?: number
  }

  /**
   * TascoLog updateManyAndReturn
   */
  export type TascoLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLog
     */
    select?: TascoLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TascoLog
     */
    omit?: TascoLogOmit<ExtArgs> | null
    /**
     * The data used to update TascoLogs.
     */
    data: XOR<TascoLogUpdateManyMutationInput, TascoLogUncheckedUpdateManyInput>
    /**
     * Filter which TascoLogs to update
     */
    where?: TascoLogWhereInput
    /**
     * Limit how many TascoLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TascoLog upsert
   */
  export type TascoLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLog
     */
    select?: TascoLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoLog
     */
    omit?: TascoLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoLogInclude<ExtArgs> | null
    /**
     * The filter to search for the TascoLog to update in case it exists.
     */
    where: TascoLogWhereUniqueInput
    /**
     * In case the TascoLog found by the `where` argument doesn't exist, create a new TascoLog with this data.
     */
    create: XOR<TascoLogCreateInput, TascoLogUncheckedCreateInput>
    /**
     * In case the TascoLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TascoLogUpdateInput, TascoLogUncheckedUpdateInput>
  }

  /**
   * TascoLog delete
   */
  export type TascoLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLog
     */
    select?: TascoLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoLog
     */
    omit?: TascoLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoLogInclude<ExtArgs> | null
    /**
     * Filter which TascoLog to delete.
     */
    where: TascoLogWhereUniqueInput
  }

  /**
   * TascoLog deleteMany
   */
  export type TascoLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TascoLogs to delete
     */
    where?: TascoLogWhereInput
    /**
     * Limit how many TascoLogs to delete.
     */
    limit?: number
  }

  /**
   * TascoLog.RefuelLogs
   */
  export type TascoLog$RefuelLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefuelLog
     */
    select?: RefuelLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefuelLog
     */
    omit?: RefuelLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefuelLogInclude<ExtArgs> | null
    where?: RefuelLogWhereInput
    orderBy?: RefuelLogOrderByWithRelationInput | RefuelLogOrderByWithRelationInput[]
    cursor?: RefuelLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefuelLogScalarFieldEnum | RefuelLogScalarFieldEnum[]
  }

  /**
   * TascoLog.TascoFLoads
   */
  export type TascoLog$TascoFLoadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoFLoads
     */
    select?: TascoFLoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoFLoads
     */
    omit?: TascoFLoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoFLoadsInclude<ExtArgs> | null
    where?: TascoFLoadsWhereInput
    orderBy?: TascoFLoadsOrderByWithRelationInput | TascoFLoadsOrderByWithRelationInput[]
    cursor?: TascoFLoadsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TascoFLoadsScalarFieldEnum | TascoFLoadsScalarFieldEnum[]
  }

  /**
   * TascoLog.Equipment
   */
  export type TascoLog$EquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
  }

  /**
   * TascoLog.TascoMaterialTypes
   */
  export type TascoLog$TascoMaterialTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoMaterialTypes
     */
    select?: TascoMaterialTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoMaterialTypes
     */
    omit?: TascoMaterialTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoMaterialTypesInclude<ExtArgs> | null
    where?: TascoMaterialTypesWhereInput
  }

  /**
   * TascoLog without action
   */
  export type TascoLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLog
     */
    select?: TascoLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoLog
     */
    omit?: TascoLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoLogInclude<ExtArgs> | null
  }


  /**
   * Model TascoFLoads
   */

  export type AggregateTascoFLoads = {
    _count: TascoFLoadsCountAggregateOutputType | null
    _avg: TascoFLoadsAvgAggregateOutputType | null
    _sum: TascoFLoadsSumAggregateOutputType | null
    _min: TascoFLoadsMinAggregateOutputType | null
    _max: TascoFLoadsMaxAggregateOutputType | null
  }

  export type TascoFLoadsAvgAggregateOutputType = {
    id: number | null
    weight: number | null
  }

  export type TascoFLoadsSumAggregateOutputType = {
    id: number | null
    weight: number | null
  }

  export type TascoFLoadsMinAggregateOutputType = {
    id: number | null
    tascoLogId: string | null
    weight: number | null
    screenType: $Enums.LoadType | null
  }

  export type TascoFLoadsMaxAggregateOutputType = {
    id: number | null
    tascoLogId: string | null
    weight: number | null
    screenType: $Enums.LoadType | null
  }

  export type TascoFLoadsCountAggregateOutputType = {
    id: number
    tascoLogId: number
    weight: number
    screenType: number
    _all: number
  }


  export type TascoFLoadsAvgAggregateInputType = {
    id?: true
    weight?: true
  }

  export type TascoFLoadsSumAggregateInputType = {
    id?: true
    weight?: true
  }

  export type TascoFLoadsMinAggregateInputType = {
    id?: true
    tascoLogId?: true
    weight?: true
    screenType?: true
  }

  export type TascoFLoadsMaxAggregateInputType = {
    id?: true
    tascoLogId?: true
    weight?: true
    screenType?: true
  }

  export type TascoFLoadsCountAggregateInputType = {
    id?: true
    tascoLogId?: true
    weight?: true
    screenType?: true
    _all?: true
  }

  export type TascoFLoadsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TascoFLoads to aggregate.
     */
    where?: TascoFLoadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TascoFLoads to fetch.
     */
    orderBy?: TascoFLoadsOrderByWithRelationInput | TascoFLoadsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TascoFLoadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TascoFLoads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TascoFLoads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TascoFLoads
    **/
    _count?: true | TascoFLoadsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TascoFLoadsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TascoFLoadsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TascoFLoadsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TascoFLoadsMaxAggregateInputType
  }

  export type GetTascoFLoadsAggregateType<T extends TascoFLoadsAggregateArgs> = {
        [P in keyof T & keyof AggregateTascoFLoads]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTascoFLoads[P]>
      : GetScalarType<T[P], AggregateTascoFLoads[P]>
  }




  export type TascoFLoadsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TascoFLoadsWhereInput
    orderBy?: TascoFLoadsOrderByWithAggregationInput | TascoFLoadsOrderByWithAggregationInput[]
    by: TascoFLoadsScalarFieldEnum[] | TascoFLoadsScalarFieldEnum
    having?: TascoFLoadsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TascoFLoadsCountAggregateInputType | true
    _avg?: TascoFLoadsAvgAggregateInputType
    _sum?: TascoFLoadsSumAggregateInputType
    _min?: TascoFLoadsMinAggregateInputType
    _max?: TascoFLoadsMaxAggregateInputType
  }

  export type TascoFLoadsGroupByOutputType = {
    id: number
    tascoLogId: string
    weight: number | null
    screenType: $Enums.LoadType | null
    _count: TascoFLoadsCountAggregateOutputType | null
    _avg: TascoFLoadsAvgAggregateOutputType | null
    _sum: TascoFLoadsSumAggregateOutputType | null
    _min: TascoFLoadsMinAggregateOutputType | null
    _max: TascoFLoadsMaxAggregateOutputType | null
  }

  type GetTascoFLoadsGroupByPayload<T extends TascoFLoadsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TascoFLoadsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TascoFLoadsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TascoFLoadsGroupByOutputType[P]>
            : GetScalarType<T[P], TascoFLoadsGroupByOutputType[P]>
        }
      >
    >


  export type TascoFLoadsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tascoLogId?: boolean
    weight?: boolean
    screenType?: boolean
    TascoLog?: boolean | TascoLogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tascoFLoads"]>

  export type TascoFLoadsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tascoLogId?: boolean
    weight?: boolean
    screenType?: boolean
    TascoLog?: boolean | TascoLogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tascoFLoads"]>

  export type TascoFLoadsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tascoLogId?: boolean
    weight?: boolean
    screenType?: boolean
    TascoLog?: boolean | TascoLogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tascoFLoads"]>

  export type TascoFLoadsSelectScalar = {
    id?: boolean
    tascoLogId?: boolean
    weight?: boolean
    screenType?: boolean
  }

  export type TascoFLoadsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tascoLogId" | "weight" | "screenType", ExtArgs["result"]["tascoFLoads"]>
  export type TascoFLoadsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TascoLog?: boolean | TascoLogDefaultArgs<ExtArgs>
  }
  export type TascoFLoadsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TascoLog?: boolean | TascoLogDefaultArgs<ExtArgs>
  }
  export type TascoFLoadsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TascoLog?: boolean | TascoLogDefaultArgs<ExtArgs>
  }

  export type $TascoFLoadsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TascoFLoads"
    objects: {
      TascoLog: Prisma.$TascoLogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tascoLogId: string
      weight: number | null
      screenType: $Enums.LoadType | null
    }, ExtArgs["result"]["tascoFLoads"]>
    composites: {}
  }

  type TascoFLoadsGetPayload<S extends boolean | null | undefined | TascoFLoadsDefaultArgs> = $Result.GetResult<Prisma.$TascoFLoadsPayload, S>

  type TascoFLoadsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TascoFLoadsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TascoFLoadsCountAggregateInputType | true
    }

  export interface TascoFLoadsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TascoFLoads'], meta: { name: 'TascoFLoads' } }
    /**
     * Find zero or one TascoFLoads that matches the filter.
     * @param {TascoFLoadsFindUniqueArgs} args - Arguments to find a TascoFLoads
     * @example
     * // Get one TascoFLoads
     * const tascoFLoads = await prisma.tascoFLoads.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TascoFLoadsFindUniqueArgs>(args: SelectSubset<T, TascoFLoadsFindUniqueArgs<ExtArgs>>): Prisma__TascoFLoadsClient<$Result.GetResult<Prisma.$TascoFLoadsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TascoFLoads that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TascoFLoadsFindUniqueOrThrowArgs} args - Arguments to find a TascoFLoads
     * @example
     * // Get one TascoFLoads
     * const tascoFLoads = await prisma.tascoFLoads.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TascoFLoadsFindUniqueOrThrowArgs>(args: SelectSubset<T, TascoFLoadsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TascoFLoadsClient<$Result.GetResult<Prisma.$TascoFLoadsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TascoFLoads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoFLoadsFindFirstArgs} args - Arguments to find a TascoFLoads
     * @example
     * // Get one TascoFLoads
     * const tascoFLoads = await prisma.tascoFLoads.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TascoFLoadsFindFirstArgs>(args?: SelectSubset<T, TascoFLoadsFindFirstArgs<ExtArgs>>): Prisma__TascoFLoadsClient<$Result.GetResult<Prisma.$TascoFLoadsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TascoFLoads that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoFLoadsFindFirstOrThrowArgs} args - Arguments to find a TascoFLoads
     * @example
     * // Get one TascoFLoads
     * const tascoFLoads = await prisma.tascoFLoads.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TascoFLoadsFindFirstOrThrowArgs>(args?: SelectSubset<T, TascoFLoadsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TascoFLoadsClient<$Result.GetResult<Prisma.$TascoFLoadsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TascoFLoads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoFLoadsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TascoFLoads
     * const tascoFLoads = await prisma.tascoFLoads.findMany()
     * 
     * // Get first 10 TascoFLoads
     * const tascoFLoads = await prisma.tascoFLoads.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tascoFLoadsWithIdOnly = await prisma.tascoFLoads.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TascoFLoadsFindManyArgs>(args?: SelectSubset<T, TascoFLoadsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TascoFLoadsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TascoFLoads.
     * @param {TascoFLoadsCreateArgs} args - Arguments to create a TascoFLoads.
     * @example
     * // Create one TascoFLoads
     * const TascoFLoads = await prisma.tascoFLoads.create({
     *   data: {
     *     // ... data to create a TascoFLoads
     *   }
     * })
     * 
     */
    create<T extends TascoFLoadsCreateArgs>(args: SelectSubset<T, TascoFLoadsCreateArgs<ExtArgs>>): Prisma__TascoFLoadsClient<$Result.GetResult<Prisma.$TascoFLoadsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TascoFLoads.
     * @param {TascoFLoadsCreateManyArgs} args - Arguments to create many TascoFLoads.
     * @example
     * // Create many TascoFLoads
     * const tascoFLoads = await prisma.tascoFLoads.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TascoFLoadsCreateManyArgs>(args?: SelectSubset<T, TascoFLoadsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TascoFLoads and returns the data saved in the database.
     * @param {TascoFLoadsCreateManyAndReturnArgs} args - Arguments to create many TascoFLoads.
     * @example
     * // Create many TascoFLoads
     * const tascoFLoads = await prisma.tascoFLoads.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TascoFLoads and only return the `id`
     * const tascoFLoadsWithIdOnly = await prisma.tascoFLoads.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TascoFLoadsCreateManyAndReturnArgs>(args?: SelectSubset<T, TascoFLoadsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TascoFLoadsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TascoFLoads.
     * @param {TascoFLoadsDeleteArgs} args - Arguments to delete one TascoFLoads.
     * @example
     * // Delete one TascoFLoads
     * const TascoFLoads = await prisma.tascoFLoads.delete({
     *   where: {
     *     // ... filter to delete one TascoFLoads
     *   }
     * })
     * 
     */
    delete<T extends TascoFLoadsDeleteArgs>(args: SelectSubset<T, TascoFLoadsDeleteArgs<ExtArgs>>): Prisma__TascoFLoadsClient<$Result.GetResult<Prisma.$TascoFLoadsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TascoFLoads.
     * @param {TascoFLoadsUpdateArgs} args - Arguments to update one TascoFLoads.
     * @example
     * // Update one TascoFLoads
     * const tascoFLoads = await prisma.tascoFLoads.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TascoFLoadsUpdateArgs>(args: SelectSubset<T, TascoFLoadsUpdateArgs<ExtArgs>>): Prisma__TascoFLoadsClient<$Result.GetResult<Prisma.$TascoFLoadsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TascoFLoads.
     * @param {TascoFLoadsDeleteManyArgs} args - Arguments to filter TascoFLoads to delete.
     * @example
     * // Delete a few TascoFLoads
     * const { count } = await prisma.tascoFLoads.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TascoFLoadsDeleteManyArgs>(args?: SelectSubset<T, TascoFLoadsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TascoFLoads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoFLoadsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TascoFLoads
     * const tascoFLoads = await prisma.tascoFLoads.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TascoFLoadsUpdateManyArgs>(args: SelectSubset<T, TascoFLoadsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TascoFLoads and returns the data updated in the database.
     * @param {TascoFLoadsUpdateManyAndReturnArgs} args - Arguments to update many TascoFLoads.
     * @example
     * // Update many TascoFLoads
     * const tascoFLoads = await prisma.tascoFLoads.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TascoFLoads and only return the `id`
     * const tascoFLoadsWithIdOnly = await prisma.tascoFLoads.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TascoFLoadsUpdateManyAndReturnArgs>(args: SelectSubset<T, TascoFLoadsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TascoFLoadsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TascoFLoads.
     * @param {TascoFLoadsUpsertArgs} args - Arguments to update or create a TascoFLoads.
     * @example
     * // Update or create a TascoFLoads
     * const tascoFLoads = await prisma.tascoFLoads.upsert({
     *   create: {
     *     // ... data to create a TascoFLoads
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TascoFLoads we want to update
     *   }
     * })
     */
    upsert<T extends TascoFLoadsUpsertArgs>(args: SelectSubset<T, TascoFLoadsUpsertArgs<ExtArgs>>): Prisma__TascoFLoadsClient<$Result.GetResult<Prisma.$TascoFLoadsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TascoFLoads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoFLoadsCountArgs} args - Arguments to filter TascoFLoads to count.
     * @example
     * // Count the number of TascoFLoads
     * const count = await prisma.tascoFLoads.count({
     *   where: {
     *     // ... the filter for the TascoFLoads we want to count
     *   }
     * })
    **/
    count<T extends TascoFLoadsCountArgs>(
      args?: Subset<T, TascoFLoadsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TascoFLoadsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TascoFLoads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoFLoadsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TascoFLoadsAggregateArgs>(args: Subset<T, TascoFLoadsAggregateArgs>): Prisma.PrismaPromise<GetTascoFLoadsAggregateType<T>>

    /**
     * Group by TascoFLoads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoFLoadsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TascoFLoadsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TascoFLoadsGroupByArgs['orderBy'] }
        : { orderBy?: TascoFLoadsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TascoFLoadsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTascoFLoadsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TascoFLoads model
   */
  readonly fields: TascoFLoadsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TascoFLoads.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TascoFLoadsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TascoLog<T extends TascoLogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TascoLogDefaultArgs<ExtArgs>>): Prisma__TascoLogClient<$Result.GetResult<Prisma.$TascoLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TascoFLoads model
   */
  interface TascoFLoadsFieldRefs {
    readonly id: FieldRef<"TascoFLoads", 'Int'>
    readonly tascoLogId: FieldRef<"TascoFLoads", 'String'>
    readonly weight: FieldRef<"TascoFLoads", 'Float'>
    readonly screenType: FieldRef<"TascoFLoads", 'LoadType'>
  }
    

  // Custom InputTypes
  /**
   * TascoFLoads findUnique
   */
  export type TascoFLoadsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoFLoads
     */
    select?: TascoFLoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoFLoads
     */
    omit?: TascoFLoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoFLoadsInclude<ExtArgs> | null
    /**
     * Filter, which TascoFLoads to fetch.
     */
    where: TascoFLoadsWhereUniqueInput
  }

  /**
   * TascoFLoads findUniqueOrThrow
   */
  export type TascoFLoadsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoFLoads
     */
    select?: TascoFLoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoFLoads
     */
    omit?: TascoFLoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoFLoadsInclude<ExtArgs> | null
    /**
     * Filter, which TascoFLoads to fetch.
     */
    where: TascoFLoadsWhereUniqueInput
  }

  /**
   * TascoFLoads findFirst
   */
  export type TascoFLoadsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoFLoads
     */
    select?: TascoFLoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoFLoads
     */
    omit?: TascoFLoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoFLoadsInclude<ExtArgs> | null
    /**
     * Filter, which TascoFLoads to fetch.
     */
    where?: TascoFLoadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TascoFLoads to fetch.
     */
    orderBy?: TascoFLoadsOrderByWithRelationInput | TascoFLoadsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TascoFLoads.
     */
    cursor?: TascoFLoadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TascoFLoads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TascoFLoads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TascoFLoads.
     */
    distinct?: TascoFLoadsScalarFieldEnum | TascoFLoadsScalarFieldEnum[]
  }

  /**
   * TascoFLoads findFirstOrThrow
   */
  export type TascoFLoadsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoFLoads
     */
    select?: TascoFLoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoFLoads
     */
    omit?: TascoFLoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoFLoadsInclude<ExtArgs> | null
    /**
     * Filter, which TascoFLoads to fetch.
     */
    where?: TascoFLoadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TascoFLoads to fetch.
     */
    orderBy?: TascoFLoadsOrderByWithRelationInput | TascoFLoadsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TascoFLoads.
     */
    cursor?: TascoFLoadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TascoFLoads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TascoFLoads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TascoFLoads.
     */
    distinct?: TascoFLoadsScalarFieldEnum | TascoFLoadsScalarFieldEnum[]
  }

  /**
   * TascoFLoads findMany
   */
  export type TascoFLoadsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoFLoads
     */
    select?: TascoFLoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoFLoads
     */
    omit?: TascoFLoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoFLoadsInclude<ExtArgs> | null
    /**
     * Filter, which TascoFLoads to fetch.
     */
    where?: TascoFLoadsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TascoFLoads to fetch.
     */
    orderBy?: TascoFLoadsOrderByWithRelationInput | TascoFLoadsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TascoFLoads.
     */
    cursor?: TascoFLoadsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TascoFLoads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TascoFLoads.
     */
    skip?: number
    distinct?: TascoFLoadsScalarFieldEnum | TascoFLoadsScalarFieldEnum[]
  }

  /**
   * TascoFLoads create
   */
  export type TascoFLoadsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoFLoads
     */
    select?: TascoFLoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoFLoads
     */
    omit?: TascoFLoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoFLoadsInclude<ExtArgs> | null
    /**
     * The data needed to create a TascoFLoads.
     */
    data: XOR<TascoFLoadsCreateInput, TascoFLoadsUncheckedCreateInput>
  }

  /**
   * TascoFLoads createMany
   */
  export type TascoFLoadsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TascoFLoads.
     */
    data: TascoFLoadsCreateManyInput | TascoFLoadsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TascoFLoads createManyAndReturn
   */
  export type TascoFLoadsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoFLoads
     */
    select?: TascoFLoadsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TascoFLoads
     */
    omit?: TascoFLoadsOmit<ExtArgs> | null
    /**
     * The data used to create many TascoFLoads.
     */
    data: TascoFLoadsCreateManyInput | TascoFLoadsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoFLoadsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TascoFLoads update
   */
  export type TascoFLoadsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoFLoads
     */
    select?: TascoFLoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoFLoads
     */
    omit?: TascoFLoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoFLoadsInclude<ExtArgs> | null
    /**
     * The data needed to update a TascoFLoads.
     */
    data: XOR<TascoFLoadsUpdateInput, TascoFLoadsUncheckedUpdateInput>
    /**
     * Choose, which TascoFLoads to update.
     */
    where: TascoFLoadsWhereUniqueInput
  }

  /**
   * TascoFLoads updateMany
   */
  export type TascoFLoadsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TascoFLoads.
     */
    data: XOR<TascoFLoadsUpdateManyMutationInput, TascoFLoadsUncheckedUpdateManyInput>
    /**
     * Filter which TascoFLoads to update
     */
    where?: TascoFLoadsWhereInput
    /**
     * Limit how many TascoFLoads to update.
     */
    limit?: number
  }

  /**
   * TascoFLoads updateManyAndReturn
   */
  export type TascoFLoadsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoFLoads
     */
    select?: TascoFLoadsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TascoFLoads
     */
    omit?: TascoFLoadsOmit<ExtArgs> | null
    /**
     * The data used to update TascoFLoads.
     */
    data: XOR<TascoFLoadsUpdateManyMutationInput, TascoFLoadsUncheckedUpdateManyInput>
    /**
     * Filter which TascoFLoads to update
     */
    where?: TascoFLoadsWhereInput
    /**
     * Limit how many TascoFLoads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoFLoadsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TascoFLoads upsert
   */
  export type TascoFLoadsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoFLoads
     */
    select?: TascoFLoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoFLoads
     */
    omit?: TascoFLoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoFLoadsInclude<ExtArgs> | null
    /**
     * The filter to search for the TascoFLoads to update in case it exists.
     */
    where: TascoFLoadsWhereUniqueInput
    /**
     * In case the TascoFLoads found by the `where` argument doesn't exist, create a new TascoFLoads with this data.
     */
    create: XOR<TascoFLoadsCreateInput, TascoFLoadsUncheckedCreateInput>
    /**
     * In case the TascoFLoads was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TascoFLoadsUpdateInput, TascoFLoadsUncheckedUpdateInput>
  }

  /**
   * TascoFLoads delete
   */
  export type TascoFLoadsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoFLoads
     */
    select?: TascoFLoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoFLoads
     */
    omit?: TascoFLoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoFLoadsInclude<ExtArgs> | null
    /**
     * Filter which TascoFLoads to delete.
     */
    where: TascoFLoadsWhereUniqueInput
  }

  /**
   * TascoFLoads deleteMany
   */
  export type TascoFLoadsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TascoFLoads to delete
     */
    where?: TascoFLoadsWhereInput
    /**
     * Limit how many TascoFLoads to delete.
     */
    limit?: number
  }

  /**
   * TascoFLoads without action
   */
  export type TascoFLoadsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoFLoads
     */
    select?: TascoFLoadsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoFLoads
     */
    omit?: TascoFLoadsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoFLoadsInclude<ExtArgs> | null
  }


  /**
   * Model TascoMaterialTypes
   */

  export type AggregateTascoMaterialTypes = {
    _count: TascoMaterialTypesCountAggregateOutputType | null
    _min: TascoMaterialTypesMinAggregateOutputType | null
    _max: TascoMaterialTypesMaxAggregateOutputType | null
  }

  export type TascoMaterialTypesMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type TascoMaterialTypesMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type TascoMaterialTypesCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type TascoMaterialTypesMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type TascoMaterialTypesMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type TascoMaterialTypesCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type TascoMaterialTypesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TascoMaterialTypes to aggregate.
     */
    where?: TascoMaterialTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TascoMaterialTypes to fetch.
     */
    orderBy?: TascoMaterialTypesOrderByWithRelationInput | TascoMaterialTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TascoMaterialTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TascoMaterialTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TascoMaterialTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TascoMaterialTypes
    **/
    _count?: true | TascoMaterialTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TascoMaterialTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TascoMaterialTypesMaxAggregateInputType
  }

  export type GetTascoMaterialTypesAggregateType<T extends TascoMaterialTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateTascoMaterialTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTascoMaterialTypes[P]>
      : GetScalarType<T[P], AggregateTascoMaterialTypes[P]>
  }




  export type TascoMaterialTypesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TascoMaterialTypesWhereInput
    orderBy?: TascoMaterialTypesOrderByWithAggregationInput | TascoMaterialTypesOrderByWithAggregationInput[]
    by: TascoMaterialTypesScalarFieldEnum[] | TascoMaterialTypesScalarFieldEnum
    having?: TascoMaterialTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TascoMaterialTypesCountAggregateInputType | true
    _min?: TascoMaterialTypesMinAggregateInputType
    _max?: TascoMaterialTypesMaxAggregateInputType
  }

  export type TascoMaterialTypesGroupByOutputType = {
    id: string
    name: string
    _count: TascoMaterialTypesCountAggregateOutputType | null
    _min: TascoMaterialTypesMinAggregateOutputType | null
    _max: TascoMaterialTypesMaxAggregateOutputType | null
  }

  type GetTascoMaterialTypesGroupByPayload<T extends TascoMaterialTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TascoMaterialTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TascoMaterialTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TascoMaterialTypesGroupByOutputType[P]>
            : GetScalarType<T[P], TascoMaterialTypesGroupByOutputType[P]>
        }
      >
    >


  export type TascoMaterialTypesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    TascoLog?: boolean | TascoMaterialTypes$TascoLogArgs<ExtArgs>
    _count?: boolean | TascoMaterialTypesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tascoMaterialTypes"]>

  export type TascoMaterialTypesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["tascoMaterialTypes"]>

  export type TascoMaterialTypesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["tascoMaterialTypes"]>

  export type TascoMaterialTypesSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type TascoMaterialTypesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["tascoMaterialTypes"]>
  export type TascoMaterialTypesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TascoLog?: boolean | TascoMaterialTypes$TascoLogArgs<ExtArgs>
    _count?: boolean | TascoMaterialTypesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TascoMaterialTypesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TascoMaterialTypesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TascoMaterialTypesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TascoMaterialTypes"
    objects: {
      TascoLog: Prisma.$TascoLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["tascoMaterialTypes"]>
    composites: {}
  }

  type TascoMaterialTypesGetPayload<S extends boolean | null | undefined | TascoMaterialTypesDefaultArgs> = $Result.GetResult<Prisma.$TascoMaterialTypesPayload, S>

  type TascoMaterialTypesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TascoMaterialTypesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TascoMaterialTypesCountAggregateInputType | true
    }

  export interface TascoMaterialTypesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TascoMaterialTypes'], meta: { name: 'TascoMaterialTypes' } }
    /**
     * Find zero or one TascoMaterialTypes that matches the filter.
     * @param {TascoMaterialTypesFindUniqueArgs} args - Arguments to find a TascoMaterialTypes
     * @example
     * // Get one TascoMaterialTypes
     * const tascoMaterialTypes = await prisma.tascoMaterialTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TascoMaterialTypesFindUniqueArgs>(args: SelectSubset<T, TascoMaterialTypesFindUniqueArgs<ExtArgs>>): Prisma__TascoMaterialTypesClient<$Result.GetResult<Prisma.$TascoMaterialTypesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TascoMaterialTypes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TascoMaterialTypesFindUniqueOrThrowArgs} args - Arguments to find a TascoMaterialTypes
     * @example
     * // Get one TascoMaterialTypes
     * const tascoMaterialTypes = await prisma.tascoMaterialTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TascoMaterialTypesFindUniqueOrThrowArgs>(args: SelectSubset<T, TascoMaterialTypesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TascoMaterialTypesClient<$Result.GetResult<Prisma.$TascoMaterialTypesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TascoMaterialTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoMaterialTypesFindFirstArgs} args - Arguments to find a TascoMaterialTypes
     * @example
     * // Get one TascoMaterialTypes
     * const tascoMaterialTypes = await prisma.tascoMaterialTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TascoMaterialTypesFindFirstArgs>(args?: SelectSubset<T, TascoMaterialTypesFindFirstArgs<ExtArgs>>): Prisma__TascoMaterialTypesClient<$Result.GetResult<Prisma.$TascoMaterialTypesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TascoMaterialTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoMaterialTypesFindFirstOrThrowArgs} args - Arguments to find a TascoMaterialTypes
     * @example
     * // Get one TascoMaterialTypes
     * const tascoMaterialTypes = await prisma.tascoMaterialTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TascoMaterialTypesFindFirstOrThrowArgs>(args?: SelectSubset<T, TascoMaterialTypesFindFirstOrThrowArgs<ExtArgs>>): Prisma__TascoMaterialTypesClient<$Result.GetResult<Prisma.$TascoMaterialTypesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TascoMaterialTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoMaterialTypesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TascoMaterialTypes
     * const tascoMaterialTypes = await prisma.tascoMaterialTypes.findMany()
     * 
     * // Get first 10 TascoMaterialTypes
     * const tascoMaterialTypes = await prisma.tascoMaterialTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tascoMaterialTypesWithIdOnly = await prisma.tascoMaterialTypes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TascoMaterialTypesFindManyArgs>(args?: SelectSubset<T, TascoMaterialTypesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TascoMaterialTypesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TascoMaterialTypes.
     * @param {TascoMaterialTypesCreateArgs} args - Arguments to create a TascoMaterialTypes.
     * @example
     * // Create one TascoMaterialTypes
     * const TascoMaterialTypes = await prisma.tascoMaterialTypes.create({
     *   data: {
     *     // ... data to create a TascoMaterialTypes
     *   }
     * })
     * 
     */
    create<T extends TascoMaterialTypesCreateArgs>(args: SelectSubset<T, TascoMaterialTypesCreateArgs<ExtArgs>>): Prisma__TascoMaterialTypesClient<$Result.GetResult<Prisma.$TascoMaterialTypesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TascoMaterialTypes.
     * @param {TascoMaterialTypesCreateManyArgs} args - Arguments to create many TascoMaterialTypes.
     * @example
     * // Create many TascoMaterialTypes
     * const tascoMaterialTypes = await prisma.tascoMaterialTypes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TascoMaterialTypesCreateManyArgs>(args?: SelectSubset<T, TascoMaterialTypesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TascoMaterialTypes and returns the data saved in the database.
     * @param {TascoMaterialTypesCreateManyAndReturnArgs} args - Arguments to create many TascoMaterialTypes.
     * @example
     * // Create many TascoMaterialTypes
     * const tascoMaterialTypes = await prisma.tascoMaterialTypes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TascoMaterialTypes and only return the `id`
     * const tascoMaterialTypesWithIdOnly = await prisma.tascoMaterialTypes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TascoMaterialTypesCreateManyAndReturnArgs>(args?: SelectSubset<T, TascoMaterialTypesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TascoMaterialTypesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TascoMaterialTypes.
     * @param {TascoMaterialTypesDeleteArgs} args - Arguments to delete one TascoMaterialTypes.
     * @example
     * // Delete one TascoMaterialTypes
     * const TascoMaterialTypes = await prisma.tascoMaterialTypes.delete({
     *   where: {
     *     // ... filter to delete one TascoMaterialTypes
     *   }
     * })
     * 
     */
    delete<T extends TascoMaterialTypesDeleteArgs>(args: SelectSubset<T, TascoMaterialTypesDeleteArgs<ExtArgs>>): Prisma__TascoMaterialTypesClient<$Result.GetResult<Prisma.$TascoMaterialTypesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TascoMaterialTypes.
     * @param {TascoMaterialTypesUpdateArgs} args - Arguments to update one TascoMaterialTypes.
     * @example
     * // Update one TascoMaterialTypes
     * const tascoMaterialTypes = await prisma.tascoMaterialTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TascoMaterialTypesUpdateArgs>(args: SelectSubset<T, TascoMaterialTypesUpdateArgs<ExtArgs>>): Prisma__TascoMaterialTypesClient<$Result.GetResult<Prisma.$TascoMaterialTypesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TascoMaterialTypes.
     * @param {TascoMaterialTypesDeleteManyArgs} args - Arguments to filter TascoMaterialTypes to delete.
     * @example
     * // Delete a few TascoMaterialTypes
     * const { count } = await prisma.tascoMaterialTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TascoMaterialTypesDeleteManyArgs>(args?: SelectSubset<T, TascoMaterialTypesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TascoMaterialTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoMaterialTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TascoMaterialTypes
     * const tascoMaterialTypes = await prisma.tascoMaterialTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TascoMaterialTypesUpdateManyArgs>(args: SelectSubset<T, TascoMaterialTypesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TascoMaterialTypes and returns the data updated in the database.
     * @param {TascoMaterialTypesUpdateManyAndReturnArgs} args - Arguments to update many TascoMaterialTypes.
     * @example
     * // Update many TascoMaterialTypes
     * const tascoMaterialTypes = await prisma.tascoMaterialTypes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TascoMaterialTypes and only return the `id`
     * const tascoMaterialTypesWithIdOnly = await prisma.tascoMaterialTypes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TascoMaterialTypesUpdateManyAndReturnArgs>(args: SelectSubset<T, TascoMaterialTypesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TascoMaterialTypesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TascoMaterialTypes.
     * @param {TascoMaterialTypesUpsertArgs} args - Arguments to update or create a TascoMaterialTypes.
     * @example
     * // Update or create a TascoMaterialTypes
     * const tascoMaterialTypes = await prisma.tascoMaterialTypes.upsert({
     *   create: {
     *     // ... data to create a TascoMaterialTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TascoMaterialTypes we want to update
     *   }
     * })
     */
    upsert<T extends TascoMaterialTypesUpsertArgs>(args: SelectSubset<T, TascoMaterialTypesUpsertArgs<ExtArgs>>): Prisma__TascoMaterialTypesClient<$Result.GetResult<Prisma.$TascoMaterialTypesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TascoMaterialTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoMaterialTypesCountArgs} args - Arguments to filter TascoMaterialTypes to count.
     * @example
     * // Count the number of TascoMaterialTypes
     * const count = await prisma.tascoMaterialTypes.count({
     *   where: {
     *     // ... the filter for the TascoMaterialTypes we want to count
     *   }
     * })
    **/
    count<T extends TascoMaterialTypesCountArgs>(
      args?: Subset<T, TascoMaterialTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TascoMaterialTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TascoMaterialTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoMaterialTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TascoMaterialTypesAggregateArgs>(args: Subset<T, TascoMaterialTypesAggregateArgs>): Prisma.PrismaPromise<GetTascoMaterialTypesAggregateType<T>>

    /**
     * Group by TascoMaterialTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TascoMaterialTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TascoMaterialTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TascoMaterialTypesGroupByArgs['orderBy'] }
        : { orderBy?: TascoMaterialTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TascoMaterialTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTascoMaterialTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TascoMaterialTypes model
   */
  readonly fields: TascoMaterialTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TascoMaterialTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TascoMaterialTypesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TascoLog<T extends TascoMaterialTypes$TascoLogArgs<ExtArgs> = {}>(args?: Subset<T, TascoMaterialTypes$TascoLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TascoLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TascoMaterialTypes model
   */
  interface TascoMaterialTypesFieldRefs {
    readonly id: FieldRef<"TascoMaterialTypes", 'String'>
    readonly name: FieldRef<"TascoMaterialTypes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TascoMaterialTypes findUnique
   */
  export type TascoMaterialTypesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoMaterialTypes
     */
    select?: TascoMaterialTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoMaterialTypes
     */
    omit?: TascoMaterialTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoMaterialTypesInclude<ExtArgs> | null
    /**
     * Filter, which TascoMaterialTypes to fetch.
     */
    where: TascoMaterialTypesWhereUniqueInput
  }

  /**
   * TascoMaterialTypes findUniqueOrThrow
   */
  export type TascoMaterialTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoMaterialTypes
     */
    select?: TascoMaterialTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoMaterialTypes
     */
    omit?: TascoMaterialTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoMaterialTypesInclude<ExtArgs> | null
    /**
     * Filter, which TascoMaterialTypes to fetch.
     */
    where: TascoMaterialTypesWhereUniqueInput
  }

  /**
   * TascoMaterialTypes findFirst
   */
  export type TascoMaterialTypesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoMaterialTypes
     */
    select?: TascoMaterialTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoMaterialTypes
     */
    omit?: TascoMaterialTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoMaterialTypesInclude<ExtArgs> | null
    /**
     * Filter, which TascoMaterialTypes to fetch.
     */
    where?: TascoMaterialTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TascoMaterialTypes to fetch.
     */
    orderBy?: TascoMaterialTypesOrderByWithRelationInput | TascoMaterialTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TascoMaterialTypes.
     */
    cursor?: TascoMaterialTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TascoMaterialTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TascoMaterialTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TascoMaterialTypes.
     */
    distinct?: TascoMaterialTypesScalarFieldEnum | TascoMaterialTypesScalarFieldEnum[]
  }

  /**
   * TascoMaterialTypes findFirstOrThrow
   */
  export type TascoMaterialTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoMaterialTypes
     */
    select?: TascoMaterialTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoMaterialTypes
     */
    omit?: TascoMaterialTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoMaterialTypesInclude<ExtArgs> | null
    /**
     * Filter, which TascoMaterialTypes to fetch.
     */
    where?: TascoMaterialTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TascoMaterialTypes to fetch.
     */
    orderBy?: TascoMaterialTypesOrderByWithRelationInput | TascoMaterialTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TascoMaterialTypes.
     */
    cursor?: TascoMaterialTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TascoMaterialTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TascoMaterialTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TascoMaterialTypes.
     */
    distinct?: TascoMaterialTypesScalarFieldEnum | TascoMaterialTypesScalarFieldEnum[]
  }

  /**
   * TascoMaterialTypes findMany
   */
  export type TascoMaterialTypesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoMaterialTypes
     */
    select?: TascoMaterialTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoMaterialTypes
     */
    omit?: TascoMaterialTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoMaterialTypesInclude<ExtArgs> | null
    /**
     * Filter, which TascoMaterialTypes to fetch.
     */
    where?: TascoMaterialTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TascoMaterialTypes to fetch.
     */
    orderBy?: TascoMaterialTypesOrderByWithRelationInput | TascoMaterialTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TascoMaterialTypes.
     */
    cursor?: TascoMaterialTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TascoMaterialTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TascoMaterialTypes.
     */
    skip?: number
    distinct?: TascoMaterialTypesScalarFieldEnum | TascoMaterialTypesScalarFieldEnum[]
  }

  /**
   * TascoMaterialTypes create
   */
  export type TascoMaterialTypesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoMaterialTypes
     */
    select?: TascoMaterialTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoMaterialTypes
     */
    omit?: TascoMaterialTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoMaterialTypesInclude<ExtArgs> | null
    /**
     * The data needed to create a TascoMaterialTypes.
     */
    data: XOR<TascoMaterialTypesCreateInput, TascoMaterialTypesUncheckedCreateInput>
  }

  /**
   * TascoMaterialTypes createMany
   */
  export type TascoMaterialTypesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TascoMaterialTypes.
     */
    data: TascoMaterialTypesCreateManyInput | TascoMaterialTypesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TascoMaterialTypes createManyAndReturn
   */
  export type TascoMaterialTypesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoMaterialTypes
     */
    select?: TascoMaterialTypesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TascoMaterialTypes
     */
    omit?: TascoMaterialTypesOmit<ExtArgs> | null
    /**
     * The data used to create many TascoMaterialTypes.
     */
    data: TascoMaterialTypesCreateManyInput | TascoMaterialTypesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TascoMaterialTypes update
   */
  export type TascoMaterialTypesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoMaterialTypes
     */
    select?: TascoMaterialTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoMaterialTypes
     */
    omit?: TascoMaterialTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoMaterialTypesInclude<ExtArgs> | null
    /**
     * The data needed to update a TascoMaterialTypes.
     */
    data: XOR<TascoMaterialTypesUpdateInput, TascoMaterialTypesUncheckedUpdateInput>
    /**
     * Choose, which TascoMaterialTypes to update.
     */
    where: TascoMaterialTypesWhereUniqueInput
  }

  /**
   * TascoMaterialTypes updateMany
   */
  export type TascoMaterialTypesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TascoMaterialTypes.
     */
    data: XOR<TascoMaterialTypesUpdateManyMutationInput, TascoMaterialTypesUncheckedUpdateManyInput>
    /**
     * Filter which TascoMaterialTypes to update
     */
    where?: TascoMaterialTypesWhereInput
    /**
     * Limit how many TascoMaterialTypes to update.
     */
    limit?: number
  }

  /**
   * TascoMaterialTypes updateManyAndReturn
   */
  export type TascoMaterialTypesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoMaterialTypes
     */
    select?: TascoMaterialTypesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TascoMaterialTypes
     */
    omit?: TascoMaterialTypesOmit<ExtArgs> | null
    /**
     * The data used to update TascoMaterialTypes.
     */
    data: XOR<TascoMaterialTypesUpdateManyMutationInput, TascoMaterialTypesUncheckedUpdateManyInput>
    /**
     * Filter which TascoMaterialTypes to update
     */
    where?: TascoMaterialTypesWhereInput
    /**
     * Limit how many TascoMaterialTypes to update.
     */
    limit?: number
  }

  /**
   * TascoMaterialTypes upsert
   */
  export type TascoMaterialTypesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoMaterialTypes
     */
    select?: TascoMaterialTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoMaterialTypes
     */
    omit?: TascoMaterialTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoMaterialTypesInclude<ExtArgs> | null
    /**
     * The filter to search for the TascoMaterialTypes to update in case it exists.
     */
    where: TascoMaterialTypesWhereUniqueInput
    /**
     * In case the TascoMaterialTypes found by the `where` argument doesn't exist, create a new TascoMaterialTypes with this data.
     */
    create: XOR<TascoMaterialTypesCreateInput, TascoMaterialTypesUncheckedCreateInput>
    /**
     * In case the TascoMaterialTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TascoMaterialTypesUpdateInput, TascoMaterialTypesUncheckedUpdateInput>
  }

  /**
   * TascoMaterialTypes delete
   */
  export type TascoMaterialTypesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoMaterialTypes
     */
    select?: TascoMaterialTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoMaterialTypes
     */
    omit?: TascoMaterialTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoMaterialTypesInclude<ExtArgs> | null
    /**
     * Filter which TascoMaterialTypes to delete.
     */
    where: TascoMaterialTypesWhereUniqueInput
  }

  /**
   * TascoMaterialTypes deleteMany
   */
  export type TascoMaterialTypesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TascoMaterialTypes to delete
     */
    where?: TascoMaterialTypesWhereInput
    /**
     * Limit how many TascoMaterialTypes to delete.
     */
    limit?: number
  }

  /**
   * TascoMaterialTypes.TascoLog
   */
  export type TascoMaterialTypes$TascoLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLog
     */
    select?: TascoLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoLog
     */
    omit?: TascoLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoLogInclude<ExtArgs> | null
    where?: TascoLogWhereInput
    orderBy?: TascoLogOrderByWithRelationInput | TascoLogOrderByWithRelationInput[]
    cursor?: TascoLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TascoLogScalarFieldEnum | TascoLogScalarFieldEnum[]
  }

  /**
   * TascoMaterialTypes without action
   */
  export type TascoMaterialTypesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoMaterialTypes
     */
    select?: TascoMaterialTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoMaterialTypes
     */
    omit?: TascoMaterialTypesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoMaterialTypesInclude<ExtArgs> | null
  }


  /**
   * Model TruckingLog
   */

  export type AggregateTruckingLog = {
    _count: TruckingLogCountAggregateOutputType | null
    _avg: TruckingLogAvgAggregateOutputType | null
    _sum: TruckingLogSumAggregateOutputType | null
    _min: TruckingLogMinAggregateOutputType | null
    _max: TruckingLogMaxAggregateOutputType | null
  }

  export type TruckingLogAvgAggregateOutputType = {
    startingMileage: number | null
    endingMileage: number | null
    timeSheetId: number | null
  }

  export type TruckingLogSumAggregateOutputType = {
    startingMileage: number | null
    endingMileage: number | null
    timeSheetId: number | null
  }

  export type TruckingLogMinAggregateOutputType = {
    id: string | null
    laborType: string | null
    taskName: string | null
    equipmentId: string | null
    startingMileage: number | null
    endingMileage: number | null
    truckLaborLogId: string | null
    trailerNumber: string | null
    truckNumber: string | null
    timeSheetId: number | null
  }

  export type TruckingLogMaxAggregateOutputType = {
    id: string | null
    laborType: string | null
    taskName: string | null
    equipmentId: string | null
    startingMileage: number | null
    endingMileage: number | null
    truckLaborLogId: string | null
    trailerNumber: string | null
    truckNumber: string | null
    timeSheetId: number | null
  }

  export type TruckingLogCountAggregateOutputType = {
    id: number
    laborType: number
    taskName: number
    equipmentId: number
    startingMileage: number
    endingMileage: number
    truckLaborLogId: number
    trailerNumber: number
    truckNumber: number
    timeSheetId: number
    _all: number
  }


  export type TruckingLogAvgAggregateInputType = {
    startingMileage?: true
    endingMileage?: true
    timeSheetId?: true
  }

  export type TruckingLogSumAggregateInputType = {
    startingMileage?: true
    endingMileage?: true
    timeSheetId?: true
  }

  export type TruckingLogMinAggregateInputType = {
    id?: true
    laborType?: true
    taskName?: true
    equipmentId?: true
    startingMileage?: true
    endingMileage?: true
    truckLaborLogId?: true
    trailerNumber?: true
    truckNumber?: true
    timeSheetId?: true
  }

  export type TruckingLogMaxAggregateInputType = {
    id?: true
    laborType?: true
    taskName?: true
    equipmentId?: true
    startingMileage?: true
    endingMileage?: true
    truckLaborLogId?: true
    trailerNumber?: true
    truckNumber?: true
    timeSheetId?: true
  }

  export type TruckingLogCountAggregateInputType = {
    id?: true
    laborType?: true
    taskName?: true
    equipmentId?: true
    startingMileage?: true
    endingMileage?: true
    truckLaborLogId?: true
    trailerNumber?: true
    truckNumber?: true
    timeSheetId?: true
    _all?: true
  }

  export type TruckingLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TruckingLog to aggregate.
     */
    where?: TruckingLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TruckingLogs to fetch.
     */
    orderBy?: TruckingLogOrderByWithRelationInput | TruckingLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TruckingLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TruckingLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TruckingLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TruckingLogs
    **/
    _count?: true | TruckingLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TruckingLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TruckingLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TruckingLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TruckingLogMaxAggregateInputType
  }

  export type GetTruckingLogAggregateType<T extends TruckingLogAggregateArgs> = {
        [P in keyof T & keyof AggregateTruckingLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTruckingLog[P]>
      : GetScalarType<T[P], AggregateTruckingLog[P]>
  }




  export type TruckingLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TruckingLogWhereInput
    orderBy?: TruckingLogOrderByWithAggregationInput | TruckingLogOrderByWithAggregationInput[]
    by: TruckingLogScalarFieldEnum[] | TruckingLogScalarFieldEnum
    having?: TruckingLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TruckingLogCountAggregateInputType | true
    _avg?: TruckingLogAvgAggregateInputType
    _sum?: TruckingLogSumAggregateInputType
    _min?: TruckingLogMinAggregateInputType
    _max?: TruckingLogMaxAggregateInputType
  }

  export type TruckingLogGroupByOutputType = {
    id: string
    laborType: string
    taskName: string | null
    equipmentId: string | null
    startingMileage: number | null
    endingMileage: number | null
    truckLaborLogId: string | null
    trailerNumber: string | null
    truckNumber: string | null
    timeSheetId: number
    _count: TruckingLogCountAggregateOutputType | null
    _avg: TruckingLogAvgAggregateOutputType | null
    _sum: TruckingLogSumAggregateOutputType | null
    _min: TruckingLogMinAggregateOutputType | null
    _max: TruckingLogMaxAggregateOutputType | null
  }

  type GetTruckingLogGroupByPayload<T extends TruckingLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TruckingLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TruckingLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TruckingLogGroupByOutputType[P]>
            : GetScalarType<T[P], TruckingLogGroupByOutputType[P]>
        }
      >
    >


  export type TruckingLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    laborType?: boolean
    taskName?: boolean
    equipmentId?: boolean
    startingMileage?: boolean
    endingMileage?: boolean
    truckLaborLogId?: boolean
    trailerNumber?: boolean
    truckNumber?: boolean
    timeSheetId?: boolean
    EquipmentHauled?: boolean | TruckingLog$EquipmentHauledArgs<ExtArgs>
    Materials?: boolean | TruckingLog$MaterialsArgs<ExtArgs>
    RefuelLogs?: boolean | TruckingLog$RefuelLogsArgs<ExtArgs>
    StateMileages?: boolean | TruckingLog$StateMileagesArgs<ExtArgs>
    Equipment?: boolean | TruckingLog$EquipmentArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
    Trailer?: boolean | TruckingLog$TrailerArgs<ExtArgs>
    Truck?: boolean | TruckingLog$TruckArgs<ExtArgs>
    _count?: boolean | TruckingLogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["truckingLog"]>

  export type TruckingLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    laborType?: boolean
    taskName?: boolean
    equipmentId?: boolean
    startingMileage?: boolean
    endingMileage?: boolean
    truckLaborLogId?: boolean
    trailerNumber?: boolean
    truckNumber?: boolean
    timeSheetId?: boolean
    Equipment?: boolean | TruckingLog$EquipmentArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
    Trailer?: boolean | TruckingLog$TrailerArgs<ExtArgs>
    Truck?: boolean | TruckingLog$TruckArgs<ExtArgs>
  }, ExtArgs["result"]["truckingLog"]>

  export type TruckingLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    laborType?: boolean
    taskName?: boolean
    equipmentId?: boolean
    startingMileage?: boolean
    endingMileage?: boolean
    truckLaborLogId?: boolean
    trailerNumber?: boolean
    truckNumber?: boolean
    timeSheetId?: boolean
    Equipment?: boolean | TruckingLog$EquipmentArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
    Trailer?: boolean | TruckingLog$TrailerArgs<ExtArgs>
    Truck?: boolean | TruckingLog$TruckArgs<ExtArgs>
  }, ExtArgs["result"]["truckingLog"]>

  export type TruckingLogSelectScalar = {
    id?: boolean
    laborType?: boolean
    taskName?: boolean
    equipmentId?: boolean
    startingMileage?: boolean
    endingMileage?: boolean
    truckLaborLogId?: boolean
    trailerNumber?: boolean
    truckNumber?: boolean
    timeSheetId?: boolean
  }

  export type TruckingLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "laborType" | "taskName" | "equipmentId" | "startingMileage" | "endingMileage" | "truckLaborLogId" | "trailerNumber" | "truckNumber" | "timeSheetId", ExtArgs["result"]["truckingLog"]>
  export type TruckingLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EquipmentHauled?: boolean | TruckingLog$EquipmentHauledArgs<ExtArgs>
    Materials?: boolean | TruckingLog$MaterialsArgs<ExtArgs>
    RefuelLogs?: boolean | TruckingLog$RefuelLogsArgs<ExtArgs>
    StateMileages?: boolean | TruckingLog$StateMileagesArgs<ExtArgs>
    Equipment?: boolean | TruckingLog$EquipmentArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
    Trailer?: boolean | TruckingLog$TrailerArgs<ExtArgs>
    Truck?: boolean | TruckingLog$TruckArgs<ExtArgs>
    _count?: boolean | TruckingLogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TruckingLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | TruckingLog$EquipmentArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
    Trailer?: boolean | TruckingLog$TrailerArgs<ExtArgs>
    Truck?: boolean | TruckingLog$TruckArgs<ExtArgs>
  }
  export type TruckingLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | TruckingLog$EquipmentArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
    Trailer?: boolean | TruckingLog$TrailerArgs<ExtArgs>
    Truck?: boolean | TruckingLog$TruckArgs<ExtArgs>
  }

  export type $TruckingLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TruckingLog"
    objects: {
      EquipmentHauled: Prisma.$EquipmentHauledPayload<ExtArgs>[]
      Materials: Prisma.$MaterialPayload<ExtArgs>[]
      RefuelLogs: Prisma.$RefuelLogPayload<ExtArgs>[]
      StateMileages: Prisma.$StateMileagePayload<ExtArgs>[]
      Equipment: Prisma.$EquipmentPayload<ExtArgs> | null
      TimeSheet: Prisma.$TimeSheetPayload<ExtArgs>
      Trailer: Prisma.$EquipmentPayload<ExtArgs> | null
      Truck: Prisma.$EquipmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      laborType: string
      taskName: string | null
      equipmentId: string | null
      startingMileage: number | null
      endingMileage: number | null
      truckLaborLogId: string | null
      trailerNumber: string | null
      truckNumber: string | null
      timeSheetId: number
    }, ExtArgs["result"]["truckingLog"]>
    composites: {}
  }

  type TruckingLogGetPayload<S extends boolean | null | undefined | TruckingLogDefaultArgs> = $Result.GetResult<Prisma.$TruckingLogPayload, S>

  type TruckingLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TruckingLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TruckingLogCountAggregateInputType | true
    }

  export interface TruckingLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TruckingLog'], meta: { name: 'TruckingLog' } }
    /**
     * Find zero or one TruckingLog that matches the filter.
     * @param {TruckingLogFindUniqueArgs} args - Arguments to find a TruckingLog
     * @example
     * // Get one TruckingLog
     * const truckingLog = await prisma.truckingLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TruckingLogFindUniqueArgs>(args: SelectSubset<T, TruckingLogFindUniqueArgs<ExtArgs>>): Prisma__TruckingLogClient<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TruckingLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TruckingLogFindUniqueOrThrowArgs} args - Arguments to find a TruckingLog
     * @example
     * // Get one TruckingLog
     * const truckingLog = await prisma.truckingLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TruckingLogFindUniqueOrThrowArgs>(args: SelectSubset<T, TruckingLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TruckingLogClient<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TruckingLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckingLogFindFirstArgs} args - Arguments to find a TruckingLog
     * @example
     * // Get one TruckingLog
     * const truckingLog = await prisma.truckingLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TruckingLogFindFirstArgs>(args?: SelectSubset<T, TruckingLogFindFirstArgs<ExtArgs>>): Prisma__TruckingLogClient<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TruckingLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckingLogFindFirstOrThrowArgs} args - Arguments to find a TruckingLog
     * @example
     * // Get one TruckingLog
     * const truckingLog = await prisma.truckingLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TruckingLogFindFirstOrThrowArgs>(args?: SelectSubset<T, TruckingLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TruckingLogClient<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TruckingLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckingLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TruckingLogs
     * const truckingLogs = await prisma.truckingLog.findMany()
     * 
     * // Get first 10 TruckingLogs
     * const truckingLogs = await prisma.truckingLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const truckingLogWithIdOnly = await prisma.truckingLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TruckingLogFindManyArgs>(args?: SelectSubset<T, TruckingLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TruckingLog.
     * @param {TruckingLogCreateArgs} args - Arguments to create a TruckingLog.
     * @example
     * // Create one TruckingLog
     * const TruckingLog = await prisma.truckingLog.create({
     *   data: {
     *     // ... data to create a TruckingLog
     *   }
     * })
     * 
     */
    create<T extends TruckingLogCreateArgs>(args: SelectSubset<T, TruckingLogCreateArgs<ExtArgs>>): Prisma__TruckingLogClient<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TruckingLogs.
     * @param {TruckingLogCreateManyArgs} args - Arguments to create many TruckingLogs.
     * @example
     * // Create many TruckingLogs
     * const truckingLog = await prisma.truckingLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TruckingLogCreateManyArgs>(args?: SelectSubset<T, TruckingLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TruckingLogs and returns the data saved in the database.
     * @param {TruckingLogCreateManyAndReturnArgs} args - Arguments to create many TruckingLogs.
     * @example
     * // Create many TruckingLogs
     * const truckingLog = await prisma.truckingLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TruckingLogs and only return the `id`
     * const truckingLogWithIdOnly = await prisma.truckingLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TruckingLogCreateManyAndReturnArgs>(args?: SelectSubset<T, TruckingLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TruckingLog.
     * @param {TruckingLogDeleteArgs} args - Arguments to delete one TruckingLog.
     * @example
     * // Delete one TruckingLog
     * const TruckingLog = await prisma.truckingLog.delete({
     *   where: {
     *     // ... filter to delete one TruckingLog
     *   }
     * })
     * 
     */
    delete<T extends TruckingLogDeleteArgs>(args: SelectSubset<T, TruckingLogDeleteArgs<ExtArgs>>): Prisma__TruckingLogClient<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TruckingLog.
     * @param {TruckingLogUpdateArgs} args - Arguments to update one TruckingLog.
     * @example
     * // Update one TruckingLog
     * const truckingLog = await prisma.truckingLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TruckingLogUpdateArgs>(args: SelectSubset<T, TruckingLogUpdateArgs<ExtArgs>>): Prisma__TruckingLogClient<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TruckingLogs.
     * @param {TruckingLogDeleteManyArgs} args - Arguments to filter TruckingLogs to delete.
     * @example
     * // Delete a few TruckingLogs
     * const { count } = await prisma.truckingLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TruckingLogDeleteManyArgs>(args?: SelectSubset<T, TruckingLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TruckingLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckingLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TruckingLogs
     * const truckingLog = await prisma.truckingLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TruckingLogUpdateManyArgs>(args: SelectSubset<T, TruckingLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TruckingLogs and returns the data updated in the database.
     * @param {TruckingLogUpdateManyAndReturnArgs} args - Arguments to update many TruckingLogs.
     * @example
     * // Update many TruckingLogs
     * const truckingLog = await prisma.truckingLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TruckingLogs and only return the `id`
     * const truckingLogWithIdOnly = await prisma.truckingLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TruckingLogUpdateManyAndReturnArgs>(args: SelectSubset<T, TruckingLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TruckingLog.
     * @param {TruckingLogUpsertArgs} args - Arguments to update or create a TruckingLog.
     * @example
     * // Update or create a TruckingLog
     * const truckingLog = await prisma.truckingLog.upsert({
     *   create: {
     *     // ... data to create a TruckingLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TruckingLog we want to update
     *   }
     * })
     */
    upsert<T extends TruckingLogUpsertArgs>(args: SelectSubset<T, TruckingLogUpsertArgs<ExtArgs>>): Prisma__TruckingLogClient<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TruckingLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckingLogCountArgs} args - Arguments to filter TruckingLogs to count.
     * @example
     * // Count the number of TruckingLogs
     * const count = await prisma.truckingLog.count({
     *   where: {
     *     // ... the filter for the TruckingLogs we want to count
     *   }
     * })
    **/
    count<T extends TruckingLogCountArgs>(
      args?: Subset<T, TruckingLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TruckingLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TruckingLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckingLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TruckingLogAggregateArgs>(args: Subset<T, TruckingLogAggregateArgs>): Prisma.PrismaPromise<GetTruckingLogAggregateType<T>>

    /**
     * Group by TruckingLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TruckingLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TruckingLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TruckingLogGroupByArgs['orderBy'] }
        : { orderBy?: TruckingLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TruckingLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTruckingLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TruckingLog model
   */
  readonly fields: TruckingLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TruckingLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TruckingLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EquipmentHauled<T extends TruckingLog$EquipmentHauledArgs<ExtArgs> = {}>(args?: Subset<T, TruckingLog$EquipmentHauledArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentHauledPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Materials<T extends TruckingLog$MaterialsArgs<ExtArgs> = {}>(args?: Subset<T, TruckingLog$MaterialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RefuelLogs<T extends TruckingLog$RefuelLogsArgs<ExtArgs> = {}>(args?: Subset<T, TruckingLog$RefuelLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefuelLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    StateMileages<T extends TruckingLog$StateMileagesArgs<ExtArgs> = {}>(args?: Subset<T, TruckingLog$StateMileagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StateMileagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Equipment<T extends TruckingLog$EquipmentArgs<ExtArgs> = {}>(args?: Subset<T, TruckingLog$EquipmentArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    TimeSheet<T extends TimeSheetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TimeSheetDefaultArgs<ExtArgs>>): Prisma__TimeSheetClient<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Trailer<T extends TruckingLog$TrailerArgs<ExtArgs> = {}>(args?: Subset<T, TruckingLog$TrailerArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Truck<T extends TruckingLog$TruckArgs<ExtArgs> = {}>(args?: Subset<T, TruckingLog$TruckArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TruckingLog model
   */
  interface TruckingLogFieldRefs {
    readonly id: FieldRef<"TruckingLog", 'String'>
    readonly laborType: FieldRef<"TruckingLog", 'String'>
    readonly taskName: FieldRef<"TruckingLog", 'String'>
    readonly equipmentId: FieldRef<"TruckingLog", 'String'>
    readonly startingMileage: FieldRef<"TruckingLog", 'Int'>
    readonly endingMileage: FieldRef<"TruckingLog", 'Int'>
    readonly truckLaborLogId: FieldRef<"TruckingLog", 'String'>
    readonly trailerNumber: FieldRef<"TruckingLog", 'String'>
    readonly truckNumber: FieldRef<"TruckingLog", 'String'>
    readonly timeSheetId: FieldRef<"TruckingLog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TruckingLog findUnique
   */
  export type TruckingLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogInclude<ExtArgs> | null
    /**
     * Filter, which TruckingLog to fetch.
     */
    where: TruckingLogWhereUniqueInput
  }

  /**
   * TruckingLog findUniqueOrThrow
   */
  export type TruckingLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogInclude<ExtArgs> | null
    /**
     * Filter, which TruckingLog to fetch.
     */
    where: TruckingLogWhereUniqueInput
  }

  /**
   * TruckingLog findFirst
   */
  export type TruckingLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogInclude<ExtArgs> | null
    /**
     * Filter, which TruckingLog to fetch.
     */
    where?: TruckingLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TruckingLogs to fetch.
     */
    orderBy?: TruckingLogOrderByWithRelationInput | TruckingLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TruckingLogs.
     */
    cursor?: TruckingLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TruckingLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TruckingLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TruckingLogs.
     */
    distinct?: TruckingLogScalarFieldEnum | TruckingLogScalarFieldEnum[]
  }

  /**
   * TruckingLog findFirstOrThrow
   */
  export type TruckingLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogInclude<ExtArgs> | null
    /**
     * Filter, which TruckingLog to fetch.
     */
    where?: TruckingLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TruckingLogs to fetch.
     */
    orderBy?: TruckingLogOrderByWithRelationInput | TruckingLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TruckingLogs.
     */
    cursor?: TruckingLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TruckingLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TruckingLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TruckingLogs.
     */
    distinct?: TruckingLogScalarFieldEnum | TruckingLogScalarFieldEnum[]
  }

  /**
   * TruckingLog findMany
   */
  export type TruckingLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogInclude<ExtArgs> | null
    /**
     * Filter, which TruckingLogs to fetch.
     */
    where?: TruckingLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TruckingLogs to fetch.
     */
    orderBy?: TruckingLogOrderByWithRelationInput | TruckingLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TruckingLogs.
     */
    cursor?: TruckingLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TruckingLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TruckingLogs.
     */
    skip?: number
    distinct?: TruckingLogScalarFieldEnum | TruckingLogScalarFieldEnum[]
  }

  /**
   * TruckingLog create
   */
  export type TruckingLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogInclude<ExtArgs> | null
    /**
     * The data needed to create a TruckingLog.
     */
    data: XOR<TruckingLogCreateInput, TruckingLogUncheckedCreateInput>
  }

  /**
   * TruckingLog createMany
   */
  export type TruckingLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TruckingLogs.
     */
    data: TruckingLogCreateManyInput | TruckingLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TruckingLog createManyAndReturn
   */
  export type TruckingLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * The data used to create many TruckingLogs.
     */
    data: TruckingLogCreateManyInput | TruckingLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TruckingLog update
   */
  export type TruckingLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogInclude<ExtArgs> | null
    /**
     * The data needed to update a TruckingLog.
     */
    data: XOR<TruckingLogUpdateInput, TruckingLogUncheckedUpdateInput>
    /**
     * Choose, which TruckingLog to update.
     */
    where: TruckingLogWhereUniqueInput
  }

  /**
   * TruckingLog updateMany
   */
  export type TruckingLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TruckingLogs.
     */
    data: XOR<TruckingLogUpdateManyMutationInput, TruckingLogUncheckedUpdateManyInput>
    /**
     * Filter which TruckingLogs to update
     */
    where?: TruckingLogWhereInput
    /**
     * Limit how many TruckingLogs to update.
     */
    limit?: number
  }

  /**
   * TruckingLog updateManyAndReturn
   */
  export type TruckingLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * The data used to update TruckingLogs.
     */
    data: XOR<TruckingLogUpdateManyMutationInput, TruckingLogUncheckedUpdateManyInput>
    /**
     * Filter which TruckingLogs to update
     */
    where?: TruckingLogWhereInput
    /**
     * Limit how many TruckingLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TruckingLog upsert
   */
  export type TruckingLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogInclude<ExtArgs> | null
    /**
     * The filter to search for the TruckingLog to update in case it exists.
     */
    where: TruckingLogWhereUniqueInput
    /**
     * In case the TruckingLog found by the `where` argument doesn't exist, create a new TruckingLog with this data.
     */
    create: XOR<TruckingLogCreateInput, TruckingLogUncheckedCreateInput>
    /**
     * In case the TruckingLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TruckingLogUpdateInput, TruckingLogUncheckedUpdateInput>
  }

  /**
   * TruckingLog delete
   */
  export type TruckingLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogInclude<ExtArgs> | null
    /**
     * Filter which TruckingLog to delete.
     */
    where: TruckingLogWhereUniqueInput
  }

  /**
   * TruckingLog deleteMany
   */
  export type TruckingLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TruckingLogs to delete
     */
    where?: TruckingLogWhereInput
    /**
     * Limit how many TruckingLogs to delete.
     */
    limit?: number
  }

  /**
   * TruckingLog.EquipmentHauled
   */
  export type TruckingLog$EquipmentHauledArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentHauled
     */
    select?: EquipmentHauledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentHauled
     */
    omit?: EquipmentHauledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentHauledInclude<ExtArgs> | null
    where?: EquipmentHauledWhereInput
    orderBy?: EquipmentHauledOrderByWithRelationInput | EquipmentHauledOrderByWithRelationInput[]
    cursor?: EquipmentHauledWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentHauledScalarFieldEnum | EquipmentHauledScalarFieldEnum[]
  }

  /**
   * TruckingLog.Materials
   */
  export type TruckingLog$MaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * TruckingLog.RefuelLogs
   */
  export type TruckingLog$RefuelLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefuelLog
     */
    select?: RefuelLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefuelLog
     */
    omit?: RefuelLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefuelLogInclude<ExtArgs> | null
    where?: RefuelLogWhereInput
    orderBy?: RefuelLogOrderByWithRelationInput | RefuelLogOrderByWithRelationInput[]
    cursor?: RefuelLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefuelLogScalarFieldEnum | RefuelLogScalarFieldEnum[]
  }

  /**
   * TruckingLog.StateMileages
   */
  export type TruckingLog$StateMileagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateMileage
     */
    select?: StateMileageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StateMileage
     */
    omit?: StateMileageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateMileageInclude<ExtArgs> | null
    where?: StateMileageWhereInput
    orderBy?: StateMileageOrderByWithRelationInput | StateMileageOrderByWithRelationInput[]
    cursor?: StateMileageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StateMileageScalarFieldEnum | StateMileageScalarFieldEnum[]
  }

  /**
   * TruckingLog.Equipment
   */
  export type TruckingLog$EquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
  }

  /**
   * TruckingLog.Trailer
   */
  export type TruckingLog$TrailerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
  }

  /**
   * TruckingLog.Truck
   */
  export type TruckingLog$TruckArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
  }

  /**
   * TruckingLog without action
   */
  export type TruckingLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogInclude<ExtArgs> | null
  }


  /**
   * Model StateMileage
   */

  export type AggregateStateMileage = {
    _count: StateMileageCountAggregateOutputType | null
    _avg: StateMileageAvgAggregateOutputType | null
    _sum: StateMileageSumAggregateOutputType | null
    _min: StateMileageMinAggregateOutputType | null
    _max: StateMileageMaxAggregateOutputType | null
  }

  export type StateMileageAvgAggregateOutputType = {
    stateLineMileage: number | null
  }

  export type StateMileageSumAggregateOutputType = {
    stateLineMileage: number | null
  }

  export type StateMileageMinAggregateOutputType = {
    id: string | null
    truckingLogId: string | null
    state: string | null
    stateLineMileage: number | null
  }

  export type StateMileageMaxAggregateOutputType = {
    id: string | null
    truckingLogId: string | null
    state: string | null
    stateLineMileage: number | null
  }

  export type StateMileageCountAggregateOutputType = {
    id: number
    truckingLogId: number
    state: number
    stateLineMileage: number
    _all: number
  }


  export type StateMileageAvgAggregateInputType = {
    stateLineMileage?: true
  }

  export type StateMileageSumAggregateInputType = {
    stateLineMileage?: true
  }

  export type StateMileageMinAggregateInputType = {
    id?: true
    truckingLogId?: true
    state?: true
    stateLineMileage?: true
  }

  export type StateMileageMaxAggregateInputType = {
    id?: true
    truckingLogId?: true
    state?: true
    stateLineMileage?: true
  }

  export type StateMileageCountAggregateInputType = {
    id?: true
    truckingLogId?: true
    state?: true
    stateLineMileage?: true
    _all?: true
  }

  export type StateMileageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StateMileage to aggregate.
     */
    where?: StateMileageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StateMileages to fetch.
     */
    orderBy?: StateMileageOrderByWithRelationInput | StateMileageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StateMileageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StateMileages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StateMileages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StateMileages
    **/
    _count?: true | StateMileageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StateMileageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StateMileageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StateMileageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StateMileageMaxAggregateInputType
  }

  export type GetStateMileageAggregateType<T extends StateMileageAggregateArgs> = {
        [P in keyof T & keyof AggregateStateMileage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStateMileage[P]>
      : GetScalarType<T[P], AggregateStateMileage[P]>
  }




  export type StateMileageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StateMileageWhereInput
    orderBy?: StateMileageOrderByWithAggregationInput | StateMileageOrderByWithAggregationInput[]
    by: StateMileageScalarFieldEnum[] | StateMileageScalarFieldEnum
    having?: StateMileageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StateMileageCountAggregateInputType | true
    _avg?: StateMileageAvgAggregateInputType
    _sum?: StateMileageSumAggregateInputType
    _min?: StateMileageMinAggregateInputType
    _max?: StateMileageMaxAggregateInputType
  }

  export type StateMileageGroupByOutputType = {
    id: string
    truckingLogId: string
    state: string | null
    stateLineMileage: number | null
    _count: StateMileageCountAggregateOutputType | null
    _avg: StateMileageAvgAggregateOutputType | null
    _sum: StateMileageSumAggregateOutputType | null
    _min: StateMileageMinAggregateOutputType | null
    _max: StateMileageMaxAggregateOutputType | null
  }

  type GetStateMileageGroupByPayload<T extends StateMileageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StateMileageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StateMileageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StateMileageGroupByOutputType[P]>
            : GetScalarType<T[P], StateMileageGroupByOutputType[P]>
        }
      >
    >


  export type StateMileageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckingLogId?: boolean
    state?: boolean
    stateLineMileage?: boolean
    TruckingLog?: boolean | TruckingLogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stateMileage"]>

  export type StateMileageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckingLogId?: boolean
    state?: boolean
    stateLineMileage?: boolean
    TruckingLog?: boolean | TruckingLogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stateMileage"]>

  export type StateMileageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckingLogId?: boolean
    state?: boolean
    stateLineMileage?: boolean
    TruckingLog?: boolean | TruckingLogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stateMileage"]>

  export type StateMileageSelectScalar = {
    id?: boolean
    truckingLogId?: boolean
    state?: boolean
    stateLineMileage?: boolean
  }

  export type StateMileageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "truckingLogId" | "state" | "stateLineMileage", ExtArgs["result"]["stateMileage"]>
  export type StateMileageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TruckingLog?: boolean | TruckingLogDefaultArgs<ExtArgs>
  }
  export type StateMileageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TruckingLog?: boolean | TruckingLogDefaultArgs<ExtArgs>
  }
  export type StateMileageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TruckingLog?: boolean | TruckingLogDefaultArgs<ExtArgs>
  }

  export type $StateMileagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StateMileage"
    objects: {
      TruckingLog: Prisma.$TruckingLogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      truckingLogId: string
      state: string | null
      stateLineMileage: number | null
    }, ExtArgs["result"]["stateMileage"]>
    composites: {}
  }

  type StateMileageGetPayload<S extends boolean | null | undefined | StateMileageDefaultArgs> = $Result.GetResult<Prisma.$StateMileagePayload, S>

  type StateMileageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StateMileageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StateMileageCountAggregateInputType | true
    }

  export interface StateMileageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StateMileage'], meta: { name: 'StateMileage' } }
    /**
     * Find zero or one StateMileage that matches the filter.
     * @param {StateMileageFindUniqueArgs} args - Arguments to find a StateMileage
     * @example
     * // Get one StateMileage
     * const stateMileage = await prisma.stateMileage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StateMileageFindUniqueArgs>(args: SelectSubset<T, StateMileageFindUniqueArgs<ExtArgs>>): Prisma__StateMileageClient<$Result.GetResult<Prisma.$StateMileagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StateMileage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StateMileageFindUniqueOrThrowArgs} args - Arguments to find a StateMileage
     * @example
     * // Get one StateMileage
     * const stateMileage = await prisma.stateMileage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StateMileageFindUniqueOrThrowArgs>(args: SelectSubset<T, StateMileageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StateMileageClient<$Result.GetResult<Prisma.$StateMileagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StateMileage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateMileageFindFirstArgs} args - Arguments to find a StateMileage
     * @example
     * // Get one StateMileage
     * const stateMileage = await prisma.stateMileage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StateMileageFindFirstArgs>(args?: SelectSubset<T, StateMileageFindFirstArgs<ExtArgs>>): Prisma__StateMileageClient<$Result.GetResult<Prisma.$StateMileagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StateMileage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateMileageFindFirstOrThrowArgs} args - Arguments to find a StateMileage
     * @example
     * // Get one StateMileage
     * const stateMileage = await prisma.stateMileage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StateMileageFindFirstOrThrowArgs>(args?: SelectSubset<T, StateMileageFindFirstOrThrowArgs<ExtArgs>>): Prisma__StateMileageClient<$Result.GetResult<Prisma.$StateMileagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StateMileages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateMileageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StateMileages
     * const stateMileages = await prisma.stateMileage.findMany()
     * 
     * // Get first 10 StateMileages
     * const stateMileages = await prisma.stateMileage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stateMileageWithIdOnly = await prisma.stateMileage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StateMileageFindManyArgs>(args?: SelectSubset<T, StateMileageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StateMileagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StateMileage.
     * @param {StateMileageCreateArgs} args - Arguments to create a StateMileage.
     * @example
     * // Create one StateMileage
     * const StateMileage = await prisma.stateMileage.create({
     *   data: {
     *     // ... data to create a StateMileage
     *   }
     * })
     * 
     */
    create<T extends StateMileageCreateArgs>(args: SelectSubset<T, StateMileageCreateArgs<ExtArgs>>): Prisma__StateMileageClient<$Result.GetResult<Prisma.$StateMileagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StateMileages.
     * @param {StateMileageCreateManyArgs} args - Arguments to create many StateMileages.
     * @example
     * // Create many StateMileages
     * const stateMileage = await prisma.stateMileage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StateMileageCreateManyArgs>(args?: SelectSubset<T, StateMileageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StateMileages and returns the data saved in the database.
     * @param {StateMileageCreateManyAndReturnArgs} args - Arguments to create many StateMileages.
     * @example
     * // Create many StateMileages
     * const stateMileage = await prisma.stateMileage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StateMileages and only return the `id`
     * const stateMileageWithIdOnly = await prisma.stateMileage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StateMileageCreateManyAndReturnArgs>(args?: SelectSubset<T, StateMileageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StateMileagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StateMileage.
     * @param {StateMileageDeleteArgs} args - Arguments to delete one StateMileage.
     * @example
     * // Delete one StateMileage
     * const StateMileage = await prisma.stateMileage.delete({
     *   where: {
     *     // ... filter to delete one StateMileage
     *   }
     * })
     * 
     */
    delete<T extends StateMileageDeleteArgs>(args: SelectSubset<T, StateMileageDeleteArgs<ExtArgs>>): Prisma__StateMileageClient<$Result.GetResult<Prisma.$StateMileagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StateMileage.
     * @param {StateMileageUpdateArgs} args - Arguments to update one StateMileage.
     * @example
     * // Update one StateMileage
     * const stateMileage = await prisma.stateMileage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StateMileageUpdateArgs>(args: SelectSubset<T, StateMileageUpdateArgs<ExtArgs>>): Prisma__StateMileageClient<$Result.GetResult<Prisma.$StateMileagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StateMileages.
     * @param {StateMileageDeleteManyArgs} args - Arguments to filter StateMileages to delete.
     * @example
     * // Delete a few StateMileages
     * const { count } = await prisma.stateMileage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StateMileageDeleteManyArgs>(args?: SelectSubset<T, StateMileageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StateMileages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateMileageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StateMileages
     * const stateMileage = await prisma.stateMileage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StateMileageUpdateManyArgs>(args: SelectSubset<T, StateMileageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StateMileages and returns the data updated in the database.
     * @param {StateMileageUpdateManyAndReturnArgs} args - Arguments to update many StateMileages.
     * @example
     * // Update many StateMileages
     * const stateMileage = await prisma.stateMileage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StateMileages and only return the `id`
     * const stateMileageWithIdOnly = await prisma.stateMileage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StateMileageUpdateManyAndReturnArgs>(args: SelectSubset<T, StateMileageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StateMileagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StateMileage.
     * @param {StateMileageUpsertArgs} args - Arguments to update or create a StateMileage.
     * @example
     * // Update or create a StateMileage
     * const stateMileage = await prisma.stateMileage.upsert({
     *   create: {
     *     // ... data to create a StateMileage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StateMileage we want to update
     *   }
     * })
     */
    upsert<T extends StateMileageUpsertArgs>(args: SelectSubset<T, StateMileageUpsertArgs<ExtArgs>>): Prisma__StateMileageClient<$Result.GetResult<Prisma.$StateMileagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StateMileages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateMileageCountArgs} args - Arguments to filter StateMileages to count.
     * @example
     * // Count the number of StateMileages
     * const count = await prisma.stateMileage.count({
     *   where: {
     *     // ... the filter for the StateMileages we want to count
     *   }
     * })
    **/
    count<T extends StateMileageCountArgs>(
      args?: Subset<T, StateMileageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StateMileageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StateMileage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateMileageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StateMileageAggregateArgs>(args: Subset<T, StateMileageAggregateArgs>): Prisma.PrismaPromise<GetStateMileageAggregateType<T>>

    /**
     * Group by StateMileage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateMileageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StateMileageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StateMileageGroupByArgs['orderBy'] }
        : { orderBy?: StateMileageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StateMileageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStateMileageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StateMileage model
   */
  readonly fields: StateMileageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StateMileage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StateMileageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TruckingLog<T extends TruckingLogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TruckingLogDefaultArgs<ExtArgs>>): Prisma__TruckingLogClient<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StateMileage model
   */
  interface StateMileageFieldRefs {
    readonly id: FieldRef<"StateMileage", 'String'>
    readonly truckingLogId: FieldRef<"StateMileage", 'String'>
    readonly state: FieldRef<"StateMileage", 'String'>
    readonly stateLineMileage: FieldRef<"StateMileage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StateMileage findUnique
   */
  export type StateMileageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateMileage
     */
    select?: StateMileageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StateMileage
     */
    omit?: StateMileageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateMileageInclude<ExtArgs> | null
    /**
     * Filter, which StateMileage to fetch.
     */
    where: StateMileageWhereUniqueInput
  }

  /**
   * StateMileage findUniqueOrThrow
   */
  export type StateMileageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateMileage
     */
    select?: StateMileageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StateMileage
     */
    omit?: StateMileageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateMileageInclude<ExtArgs> | null
    /**
     * Filter, which StateMileage to fetch.
     */
    where: StateMileageWhereUniqueInput
  }

  /**
   * StateMileage findFirst
   */
  export type StateMileageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateMileage
     */
    select?: StateMileageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StateMileage
     */
    omit?: StateMileageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateMileageInclude<ExtArgs> | null
    /**
     * Filter, which StateMileage to fetch.
     */
    where?: StateMileageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StateMileages to fetch.
     */
    orderBy?: StateMileageOrderByWithRelationInput | StateMileageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StateMileages.
     */
    cursor?: StateMileageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StateMileages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StateMileages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StateMileages.
     */
    distinct?: StateMileageScalarFieldEnum | StateMileageScalarFieldEnum[]
  }

  /**
   * StateMileage findFirstOrThrow
   */
  export type StateMileageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateMileage
     */
    select?: StateMileageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StateMileage
     */
    omit?: StateMileageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateMileageInclude<ExtArgs> | null
    /**
     * Filter, which StateMileage to fetch.
     */
    where?: StateMileageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StateMileages to fetch.
     */
    orderBy?: StateMileageOrderByWithRelationInput | StateMileageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StateMileages.
     */
    cursor?: StateMileageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StateMileages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StateMileages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StateMileages.
     */
    distinct?: StateMileageScalarFieldEnum | StateMileageScalarFieldEnum[]
  }

  /**
   * StateMileage findMany
   */
  export type StateMileageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateMileage
     */
    select?: StateMileageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StateMileage
     */
    omit?: StateMileageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateMileageInclude<ExtArgs> | null
    /**
     * Filter, which StateMileages to fetch.
     */
    where?: StateMileageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StateMileages to fetch.
     */
    orderBy?: StateMileageOrderByWithRelationInput | StateMileageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StateMileages.
     */
    cursor?: StateMileageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StateMileages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StateMileages.
     */
    skip?: number
    distinct?: StateMileageScalarFieldEnum | StateMileageScalarFieldEnum[]
  }

  /**
   * StateMileage create
   */
  export type StateMileageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateMileage
     */
    select?: StateMileageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StateMileage
     */
    omit?: StateMileageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateMileageInclude<ExtArgs> | null
    /**
     * The data needed to create a StateMileage.
     */
    data: XOR<StateMileageCreateInput, StateMileageUncheckedCreateInput>
  }

  /**
   * StateMileage createMany
   */
  export type StateMileageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StateMileages.
     */
    data: StateMileageCreateManyInput | StateMileageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StateMileage createManyAndReturn
   */
  export type StateMileageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateMileage
     */
    select?: StateMileageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StateMileage
     */
    omit?: StateMileageOmit<ExtArgs> | null
    /**
     * The data used to create many StateMileages.
     */
    data: StateMileageCreateManyInput | StateMileageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateMileageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StateMileage update
   */
  export type StateMileageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateMileage
     */
    select?: StateMileageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StateMileage
     */
    omit?: StateMileageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateMileageInclude<ExtArgs> | null
    /**
     * The data needed to update a StateMileage.
     */
    data: XOR<StateMileageUpdateInput, StateMileageUncheckedUpdateInput>
    /**
     * Choose, which StateMileage to update.
     */
    where: StateMileageWhereUniqueInput
  }

  /**
   * StateMileage updateMany
   */
  export type StateMileageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StateMileages.
     */
    data: XOR<StateMileageUpdateManyMutationInput, StateMileageUncheckedUpdateManyInput>
    /**
     * Filter which StateMileages to update
     */
    where?: StateMileageWhereInput
    /**
     * Limit how many StateMileages to update.
     */
    limit?: number
  }

  /**
   * StateMileage updateManyAndReturn
   */
  export type StateMileageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateMileage
     */
    select?: StateMileageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StateMileage
     */
    omit?: StateMileageOmit<ExtArgs> | null
    /**
     * The data used to update StateMileages.
     */
    data: XOR<StateMileageUpdateManyMutationInput, StateMileageUncheckedUpdateManyInput>
    /**
     * Filter which StateMileages to update
     */
    where?: StateMileageWhereInput
    /**
     * Limit how many StateMileages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateMileageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StateMileage upsert
   */
  export type StateMileageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateMileage
     */
    select?: StateMileageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StateMileage
     */
    omit?: StateMileageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateMileageInclude<ExtArgs> | null
    /**
     * The filter to search for the StateMileage to update in case it exists.
     */
    where: StateMileageWhereUniqueInput
    /**
     * In case the StateMileage found by the `where` argument doesn't exist, create a new StateMileage with this data.
     */
    create: XOR<StateMileageCreateInput, StateMileageUncheckedCreateInput>
    /**
     * In case the StateMileage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StateMileageUpdateInput, StateMileageUncheckedUpdateInput>
  }

  /**
   * StateMileage delete
   */
  export type StateMileageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateMileage
     */
    select?: StateMileageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StateMileage
     */
    omit?: StateMileageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateMileageInclude<ExtArgs> | null
    /**
     * Filter which StateMileage to delete.
     */
    where: StateMileageWhereUniqueInput
  }

  /**
   * StateMileage deleteMany
   */
  export type StateMileageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StateMileages to delete
     */
    where?: StateMileageWhereInput
    /**
     * Limit how many StateMileages to delete.
     */
    limit?: number
  }

  /**
   * StateMileage without action
   */
  export type StateMileageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateMileage
     */
    select?: StateMileageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StateMileage
     */
    omit?: StateMileageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateMileageInclude<ExtArgs> | null
  }


  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialAvgAggregateOutputType = {
    quantity: number | null
    materialWeight: number | null
  }

  export type MaterialSumAggregateOutputType = {
    quantity: number | null
    materialWeight: number | null
  }

  export type MaterialMinAggregateOutputType = {
    id: string | null
    truckingLogId: string | null
    LocationOfMaterial: string | null
    name: string | null
    quantity: number | null
    materialWeight: number | null
    loadType: $Enums.LoadType | null
    createdAt: Date | null
    unit: $Enums.materialUnit | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: string | null
    truckingLogId: string | null
    LocationOfMaterial: string | null
    name: string | null
    quantity: number | null
    materialWeight: number | null
    loadType: $Enums.LoadType | null
    createdAt: Date | null
    unit: $Enums.materialUnit | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    truckingLogId: number
    LocationOfMaterial: number
    name: number
    quantity: number
    materialWeight: number
    loadType: number
    createdAt: number
    unit: number
    _all: number
  }


  export type MaterialAvgAggregateInputType = {
    quantity?: true
    materialWeight?: true
  }

  export type MaterialSumAggregateInputType = {
    quantity?: true
    materialWeight?: true
  }

  export type MaterialMinAggregateInputType = {
    id?: true
    truckingLogId?: true
    LocationOfMaterial?: true
    name?: true
    quantity?: true
    materialWeight?: true
    loadType?: true
    createdAt?: true
    unit?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    truckingLogId?: true
    LocationOfMaterial?: true
    name?: true
    quantity?: true
    materialWeight?: true
    loadType?: true
    createdAt?: true
    unit?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    truckingLogId?: true
    LocationOfMaterial?: true
    name?: true
    quantity?: true
    materialWeight?: true
    loadType?: true
    createdAt?: true
    unit?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _avg?: MaterialAvgAggregateInputType
    _sum?: MaterialSumAggregateInputType
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: string
    truckingLogId: string
    LocationOfMaterial: string | null
    name: string | null
    quantity: number | null
    materialWeight: number | null
    loadType: $Enums.LoadType | null
    createdAt: Date | null
    unit: $Enums.materialUnit | null
    _count: MaterialCountAggregateOutputType | null
    _avg: MaterialAvgAggregateOutputType | null
    _sum: MaterialSumAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckingLogId?: boolean
    LocationOfMaterial?: boolean
    name?: boolean
    quantity?: boolean
    materialWeight?: boolean
    loadType?: boolean
    createdAt?: boolean
    unit?: boolean
    TruckingLog?: boolean | TruckingLogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckingLogId?: boolean
    LocationOfMaterial?: boolean
    name?: boolean
    quantity?: boolean
    materialWeight?: boolean
    loadType?: boolean
    createdAt?: boolean
    unit?: boolean
    TruckingLog?: boolean | TruckingLogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckingLogId?: boolean
    LocationOfMaterial?: boolean
    name?: boolean
    quantity?: boolean
    materialWeight?: boolean
    loadType?: boolean
    createdAt?: boolean
    unit?: boolean
    TruckingLog?: boolean | TruckingLogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectScalar = {
    id?: boolean
    truckingLogId?: boolean
    LocationOfMaterial?: boolean
    name?: boolean
    quantity?: boolean
    materialWeight?: boolean
    loadType?: boolean
    createdAt?: boolean
    unit?: boolean
  }

  export type MaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "truckingLogId" | "LocationOfMaterial" | "name" | "quantity" | "materialWeight" | "loadType" | "createdAt" | "unit", ExtArgs["result"]["material"]>
  export type MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TruckingLog?: boolean | TruckingLogDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TruckingLog?: boolean | TruckingLogDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TruckingLog?: boolean | TruckingLogDefaultArgs<ExtArgs>
  }

  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {
      TruckingLog: Prisma.$TruckingLogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      truckingLogId: string
      LocationOfMaterial: string | null
      name: string | null
      quantity: number | null
      materialWeight: number | null
      loadType: $Enums.LoadType | null
      createdAt: Date | null
      unit: $Enums.materialUnit | null
    }, ExtArgs["result"]["material"]>
    composites: {}
  }

  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialFindUniqueArgs>(args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Material that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialFindFirstArgs>(args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialFindManyArgs>(args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
     */
    create<T extends MaterialCreateArgs>(args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materials.
     * @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCreateManyArgs>(args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materials and returns the data saved in the database.
     * @param {MaterialCreateManyAndReturnArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
     */
    delete<T extends MaterialDeleteArgs>(args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialUpdateArgs>(args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialDeleteManyArgs>(args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialUpdateManyArgs>(args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials and returns the data updated in the database.
     * @param {MaterialUpdateManyAndReturnArgs} args - Arguments to update many Materials.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
     */
    upsert<T extends MaterialUpsertArgs>(args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TruckingLog<T extends TruckingLogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TruckingLogDefaultArgs<ExtArgs>>): Prisma__TruckingLogClient<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Material model
   */
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'String'>
    readonly truckingLogId: FieldRef<"Material", 'String'>
    readonly LocationOfMaterial: FieldRef<"Material", 'String'>
    readonly name: FieldRef<"Material", 'String'>
    readonly quantity: FieldRef<"Material", 'Float'>
    readonly materialWeight: FieldRef<"Material", 'Float'>
    readonly loadType: FieldRef<"Material", 'LoadType'>
    readonly createdAt: FieldRef<"Material", 'DateTime'>
    readonly unit: FieldRef<"Material", 'materialUnit'>
  }
    

  // Custom InputTypes
  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }

  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material createManyAndReturn
   */
  export type MaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
  }

  /**
   * Material updateManyAndReturn
   */
  export type MaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }

  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to delete.
     */
    limit?: number
  }

  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
  }


  /**
   * Model RefuelLog
   */

  export type AggregateRefuelLog = {
    _count: RefuelLogCountAggregateOutputType | null
    _avg: RefuelLogAvgAggregateOutputType | null
    _sum: RefuelLogSumAggregateOutputType | null
    _min: RefuelLogMinAggregateOutputType | null
    _max: RefuelLogMaxAggregateOutputType | null
  }

  export type RefuelLogAvgAggregateOutputType = {
    gallonsRefueled: number | null
    milesAtFueling: number | null
  }

  export type RefuelLogSumAggregateOutputType = {
    gallonsRefueled: number | null
    milesAtFueling: number | null
  }

  export type RefuelLogMinAggregateOutputType = {
    id: string | null
    employeeEquipmentLogId: string | null
    truckingLogId: string | null
    tascoLogId: string | null
    gallonsRefueled: number | null
    milesAtFueling: number | null
  }

  export type RefuelLogMaxAggregateOutputType = {
    id: string | null
    employeeEquipmentLogId: string | null
    truckingLogId: string | null
    tascoLogId: string | null
    gallonsRefueled: number | null
    milesAtFueling: number | null
  }

  export type RefuelLogCountAggregateOutputType = {
    id: number
    employeeEquipmentLogId: number
    truckingLogId: number
    tascoLogId: number
    gallonsRefueled: number
    milesAtFueling: number
    _all: number
  }


  export type RefuelLogAvgAggregateInputType = {
    gallonsRefueled?: true
    milesAtFueling?: true
  }

  export type RefuelLogSumAggregateInputType = {
    gallonsRefueled?: true
    milesAtFueling?: true
  }

  export type RefuelLogMinAggregateInputType = {
    id?: true
    employeeEquipmentLogId?: true
    truckingLogId?: true
    tascoLogId?: true
    gallonsRefueled?: true
    milesAtFueling?: true
  }

  export type RefuelLogMaxAggregateInputType = {
    id?: true
    employeeEquipmentLogId?: true
    truckingLogId?: true
    tascoLogId?: true
    gallonsRefueled?: true
    milesAtFueling?: true
  }

  export type RefuelLogCountAggregateInputType = {
    id?: true
    employeeEquipmentLogId?: true
    truckingLogId?: true
    tascoLogId?: true
    gallonsRefueled?: true
    milesAtFueling?: true
    _all?: true
  }

  export type RefuelLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefuelLog to aggregate.
     */
    where?: RefuelLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefuelLogs to fetch.
     */
    orderBy?: RefuelLogOrderByWithRelationInput | RefuelLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefuelLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefuelLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefuelLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefuelLogs
    **/
    _count?: true | RefuelLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefuelLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefuelLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefuelLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefuelLogMaxAggregateInputType
  }

  export type GetRefuelLogAggregateType<T extends RefuelLogAggregateArgs> = {
        [P in keyof T & keyof AggregateRefuelLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefuelLog[P]>
      : GetScalarType<T[P], AggregateRefuelLog[P]>
  }




  export type RefuelLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefuelLogWhereInput
    orderBy?: RefuelLogOrderByWithAggregationInput | RefuelLogOrderByWithAggregationInput[]
    by: RefuelLogScalarFieldEnum[] | RefuelLogScalarFieldEnum
    having?: RefuelLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefuelLogCountAggregateInputType | true
    _avg?: RefuelLogAvgAggregateInputType
    _sum?: RefuelLogSumAggregateInputType
    _min?: RefuelLogMinAggregateInputType
    _max?: RefuelLogMaxAggregateInputType
  }

  export type RefuelLogGroupByOutputType = {
    id: string
    employeeEquipmentLogId: string | null
    truckingLogId: string | null
    tascoLogId: string | null
    gallonsRefueled: number | null
    milesAtFueling: number | null
    _count: RefuelLogCountAggregateOutputType | null
    _avg: RefuelLogAvgAggregateOutputType | null
    _sum: RefuelLogSumAggregateOutputType | null
    _min: RefuelLogMinAggregateOutputType | null
    _max: RefuelLogMaxAggregateOutputType | null
  }

  type GetRefuelLogGroupByPayload<T extends RefuelLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefuelLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefuelLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefuelLogGroupByOutputType[P]>
            : GetScalarType<T[P], RefuelLogGroupByOutputType[P]>
        }
      >
    >


  export type RefuelLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeEquipmentLogId?: boolean
    truckingLogId?: boolean
    tascoLogId?: boolean
    gallonsRefueled?: boolean
    milesAtFueling?: boolean
    EmployeeEquipmentLog?: boolean | RefuelLog$EmployeeEquipmentLogArgs<ExtArgs>
    TascoLog?: boolean | RefuelLog$TascoLogArgs<ExtArgs>
    TruckingLog?: boolean | RefuelLog$TruckingLogArgs<ExtArgs>
  }, ExtArgs["result"]["refuelLog"]>

  export type RefuelLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeEquipmentLogId?: boolean
    truckingLogId?: boolean
    tascoLogId?: boolean
    gallonsRefueled?: boolean
    milesAtFueling?: boolean
    EmployeeEquipmentLog?: boolean | RefuelLog$EmployeeEquipmentLogArgs<ExtArgs>
    TascoLog?: boolean | RefuelLog$TascoLogArgs<ExtArgs>
    TruckingLog?: boolean | RefuelLog$TruckingLogArgs<ExtArgs>
  }, ExtArgs["result"]["refuelLog"]>

  export type RefuelLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeEquipmentLogId?: boolean
    truckingLogId?: boolean
    tascoLogId?: boolean
    gallonsRefueled?: boolean
    milesAtFueling?: boolean
    EmployeeEquipmentLog?: boolean | RefuelLog$EmployeeEquipmentLogArgs<ExtArgs>
    TascoLog?: boolean | RefuelLog$TascoLogArgs<ExtArgs>
    TruckingLog?: boolean | RefuelLog$TruckingLogArgs<ExtArgs>
  }, ExtArgs["result"]["refuelLog"]>

  export type RefuelLogSelectScalar = {
    id?: boolean
    employeeEquipmentLogId?: boolean
    truckingLogId?: boolean
    tascoLogId?: boolean
    gallonsRefueled?: boolean
    milesAtFueling?: boolean
  }

  export type RefuelLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeEquipmentLogId" | "truckingLogId" | "tascoLogId" | "gallonsRefueled" | "milesAtFueling", ExtArgs["result"]["refuelLog"]>
  export type RefuelLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeEquipmentLog?: boolean | RefuelLog$EmployeeEquipmentLogArgs<ExtArgs>
    TascoLog?: boolean | RefuelLog$TascoLogArgs<ExtArgs>
    TruckingLog?: boolean | RefuelLog$TruckingLogArgs<ExtArgs>
  }
  export type RefuelLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeEquipmentLog?: boolean | RefuelLog$EmployeeEquipmentLogArgs<ExtArgs>
    TascoLog?: boolean | RefuelLog$TascoLogArgs<ExtArgs>
    TruckingLog?: boolean | RefuelLog$TruckingLogArgs<ExtArgs>
  }
  export type RefuelLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    EmployeeEquipmentLog?: boolean | RefuelLog$EmployeeEquipmentLogArgs<ExtArgs>
    TascoLog?: boolean | RefuelLog$TascoLogArgs<ExtArgs>
    TruckingLog?: boolean | RefuelLog$TruckingLogArgs<ExtArgs>
  }

  export type $RefuelLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefuelLog"
    objects: {
      EmployeeEquipmentLog: Prisma.$EmployeeEquipmentLogPayload<ExtArgs> | null
      TascoLog: Prisma.$TascoLogPayload<ExtArgs> | null
      TruckingLog: Prisma.$TruckingLogPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeEquipmentLogId: string | null
      truckingLogId: string | null
      tascoLogId: string | null
      gallonsRefueled: number | null
      milesAtFueling: number | null
    }, ExtArgs["result"]["refuelLog"]>
    composites: {}
  }

  type RefuelLogGetPayload<S extends boolean | null | undefined | RefuelLogDefaultArgs> = $Result.GetResult<Prisma.$RefuelLogPayload, S>

  type RefuelLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefuelLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefuelLogCountAggregateInputType | true
    }

  export interface RefuelLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefuelLog'], meta: { name: 'RefuelLog' } }
    /**
     * Find zero or one RefuelLog that matches the filter.
     * @param {RefuelLogFindUniqueArgs} args - Arguments to find a RefuelLog
     * @example
     * // Get one RefuelLog
     * const refuelLog = await prisma.refuelLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefuelLogFindUniqueArgs>(args: SelectSubset<T, RefuelLogFindUniqueArgs<ExtArgs>>): Prisma__RefuelLogClient<$Result.GetResult<Prisma.$RefuelLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefuelLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefuelLogFindUniqueOrThrowArgs} args - Arguments to find a RefuelLog
     * @example
     * // Get one RefuelLog
     * const refuelLog = await prisma.refuelLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefuelLogFindUniqueOrThrowArgs>(args: SelectSubset<T, RefuelLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefuelLogClient<$Result.GetResult<Prisma.$RefuelLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefuelLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefuelLogFindFirstArgs} args - Arguments to find a RefuelLog
     * @example
     * // Get one RefuelLog
     * const refuelLog = await prisma.refuelLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefuelLogFindFirstArgs>(args?: SelectSubset<T, RefuelLogFindFirstArgs<ExtArgs>>): Prisma__RefuelLogClient<$Result.GetResult<Prisma.$RefuelLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefuelLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefuelLogFindFirstOrThrowArgs} args - Arguments to find a RefuelLog
     * @example
     * // Get one RefuelLog
     * const refuelLog = await prisma.refuelLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefuelLogFindFirstOrThrowArgs>(args?: SelectSubset<T, RefuelLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefuelLogClient<$Result.GetResult<Prisma.$RefuelLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefuelLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefuelLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefuelLogs
     * const refuelLogs = await prisma.refuelLog.findMany()
     * 
     * // Get first 10 RefuelLogs
     * const refuelLogs = await prisma.refuelLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refuelLogWithIdOnly = await prisma.refuelLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefuelLogFindManyArgs>(args?: SelectSubset<T, RefuelLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefuelLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefuelLog.
     * @param {RefuelLogCreateArgs} args - Arguments to create a RefuelLog.
     * @example
     * // Create one RefuelLog
     * const RefuelLog = await prisma.refuelLog.create({
     *   data: {
     *     // ... data to create a RefuelLog
     *   }
     * })
     * 
     */
    create<T extends RefuelLogCreateArgs>(args: SelectSubset<T, RefuelLogCreateArgs<ExtArgs>>): Prisma__RefuelLogClient<$Result.GetResult<Prisma.$RefuelLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefuelLogs.
     * @param {RefuelLogCreateManyArgs} args - Arguments to create many RefuelLogs.
     * @example
     * // Create many RefuelLogs
     * const refuelLog = await prisma.refuelLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefuelLogCreateManyArgs>(args?: SelectSubset<T, RefuelLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefuelLogs and returns the data saved in the database.
     * @param {RefuelLogCreateManyAndReturnArgs} args - Arguments to create many RefuelLogs.
     * @example
     * // Create many RefuelLogs
     * const refuelLog = await prisma.refuelLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefuelLogs and only return the `id`
     * const refuelLogWithIdOnly = await prisma.refuelLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefuelLogCreateManyAndReturnArgs>(args?: SelectSubset<T, RefuelLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefuelLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefuelLog.
     * @param {RefuelLogDeleteArgs} args - Arguments to delete one RefuelLog.
     * @example
     * // Delete one RefuelLog
     * const RefuelLog = await prisma.refuelLog.delete({
     *   where: {
     *     // ... filter to delete one RefuelLog
     *   }
     * })
     * 
     */
    delete<T extends RefuelLogDeleteArgs>(args: SelectSubset<T, RefuelLogDeleteArgs<ExtArgs>>): Prisma__RefuelLogClient<$Result.GetResult<Prisma.$RefuelLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefuelLog.
     * @param {RefuelLogUpdateArgs} args - Arguments to update one RefuelLog.
     * @example
     * // Update one RefuelLog
     * const refuelLog = await prisma.refuelLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefuelLogUpdateArgs>(args: SelectSubset<T, RefuelLogUpdateArgs<ExtArgs>>): Prisma__RefuelLogClient<$Result.GetResult<Prisma.$RefuelLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefuelLogs.
     * @param {RefuelLogDeleteManyArgs} args - Arguments to filter RefuelLogs to delete.
     * @example
     * // Delete a few RefuelLogs
     * const { count } = await prisma.refuelLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefuelLogDeleteManyArgs>(args?: SelectSubset<T, RefuelLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefuelLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefuelLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefuelLogs
     * const refuelLog = await prisma.refuelLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefuelLogUpdateManyArgs>(args: SelectSubset<T, RefuelLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefuelLogs and returns the data updated in the database.
     * @param {RefuelLogUpdateManyAndReturnArgs} args - Arguments to update many RefuelLogs.
     * @example
     * // Update many RefuelLogs
     * const refuelLog = await prisma.refuelLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefuelLogs and only return the `id`
     * const refuelLogWithIdOnly = await prisma.refuelLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefuelLogUpdateManyAndReturnArgs>(args: SelectSubset<T, RefuelLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefuelLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefuelLog.
     * @param {RefuelLogUpsertArgs} args - Arguments to update or create a RefuelLog.
     * @example
     * // Update or create a RefuelLog
     * const refuelLog = await prisma.refuelLog.upsert({
     *   create: {
     *     // ... data to create a RefuelLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefuelLog we want to update
     *   }
     * })
     */
    upsert<T extends RefuelLogUpsertArgs>(args: SelectSubset<T, RefuelLogUpsertArgs<ExtArgs>>): Prisma__RefuelLogClient<$Result.GetResult<Prisma.$RefuelLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefuelLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefuelLogCountArgs} args - Arguments to filter RefuelLogs to count.
     * @example
     * // Count the number of RefuelLogs
     * const count = await prisma.refuelLog.count({
     *   where: {
     *     // ... the filter for the RefuelLogs we want to count
     *   }
     * })
    **/
    count<T extends RefuelLogCountArgs>(
      args?: Subset<T, RefuelLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefuelLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefuelLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefuelLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefuelLogAggregateArgs>(args: Subset<T, RefuelLogAggregateArgs>): Prisma.PrismaPromise<GetRefuelLogAggregateType<T>>

    /**
     * Group by RefuelLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefuelLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefuelLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefuelLogGroupByArgs['orderBy'] }
        : { orderBy?: RefuelLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefuelLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefuelLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefuelLog model
   */
  readonly fields: RefuelLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefuelLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefuelLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    EmployeeEquipmentLog<T extends RefuelLog$EmployeeEquipmentLogArgs<ExtArgs> = {}>(args?: Subset<T, RefuelLog$EmployeeEquipmentLogArgs<ExtArgs>>): Prisma__EmployeeEquipmentLogClient<$Result.GetResult<Prisma.$EmployeeEquipmentLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    TascoLog<T extends RefuelLog$TascoLogArgs<ExtArgs> = {}>(args?: Subset<T, RefuelLog$TascoLogArgs<ExtArgs>>): Prisma__TascoLogClient<$Result.GetResult<Prisma.$TascoLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    TruckingLog<T extends RefuelLog$TruckingLogArgs<ExtArgs> = {}>(args?: Subset<T, RefuelLog$TruckingLogArgs<ExtArgs>>): Prisma__TruckingLogClient<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefuelLog model
   */
  interface RefuelLogFieldRefs {
    readonly id: FieldRef<"RefuelLog", 'String'>
    readonly employeeEquipmentLogId: FieldRef<"RefuelLog", 'String'>
    readonly truckingLogId: FieldRef<"RefuelLog", 'String'>
    readonly tascoLogId: FieldRef<"RefuelLog", 'String'>
    readonly gallonsRefueled: FieldRef<"RefuelLog", 'Float'>
    readonly milesAtFueling: FieldRef<"RefuelLog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RefuelLog findUnique
   */
  export type RefuelLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefuelLog
     */
    select?: RefuelLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefuelLog
     */
    omit?: RefuelLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefuelLogInclude<ExtArgs> | null
    /**
     * Filter, which RefuelLog to fetch.
     */
    where: RefuelLogWhereUniqueInput
  }

  /**
   * RefuelLog findUniqueOrThrow
   */
  export type RefuelLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefuelLog
     */
    select?: RefuelLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefuelLog
     */
    omit?: RefuelLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefuelLogInclude<ExtArgs> | null
    /**
     * Filter, which RefuelLog to fetch.
     */
    where: RefuelLogWhereUniqueInput
  }

  /**
   * RefuelLog findFirst
   */
  export type RefuelLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefuelLog
     */
    select?: RefuelLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefuelLog
     */
    omit?: RefuelLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefuelLogInclude<ExtArgs> | null
    /**
     * Filter, which RefuelLog to fetch.
     */
    where?: RefuelLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefuelLogs to fetch.
     */
    orderBy?: RefuelLogOrderByWithRelationInput | RefuelLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefuelLogs.
     */
    cursor?: RefuelLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefuelLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefuelLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefuelLogs.
     */
    distinct?: RefuelLogScalarFieldEnum | RefuelLogScalarFieldEnum[]
  }

  /**
   * RefuelLog findFirstOrThrow
   */
  export type RefuelLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefuelLog
     */
    select?: RefuelLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefuelLog
     */
    omit?: RefuelLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefuelLogInclude<ExtArgs> | null
    /**
     * Filter, which RefuelLog to fetch.
     */
    where?: RefuelLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefuelLogs to fetch.
     */
    orderBy?: RefuelLogOrderByWithRelationInput | RefuelLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefuelLogs.
     */
    cursor?: RefuelLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefuelLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefuelLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefuelLogs.
     */
    distinct?: RefuelLogScalarFieldEnum | RefuelLogScalarFieldEnum[]
  }

  /**
   * RefuelLog findMany
   */
  export type RefuelLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefuelLog
     */
    select?: RefuelLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefuelLog
     */
    omit?: RefuelLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefuelLogInclude<ExtArgs> | null
    /**
     * Filter, which RefuelLogs to fetch.
     */
    where?: RefuelLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefuelLogs to fetch.
     */
    orderBy?: RefuelLogOrderByWithRelationInput | RefuelLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefuelLogs.
     */
    cursor?: RefuelLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefuelLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefuelLogs.
     */
    skip?: number
    distinct?: RefuelLogScalarFieldEnum | RefuelLogScalarFieldEnum[]
  }

  /**
   * RefuelLog create
   */
  export type RefuelLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefuelLog
     */
    select?: RefuelLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefuelLog
     */
    omit?: RefuelLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefuelLogInclude<ExtArgs> | null
    /**
     * The data needed to create a RefuelLog.
     */
    data?: XOR<RefuelLogCreateInput, RefuelLogUncheckedCreateInput>
  }

  /**
   * RefuelLog createMany
   */
  export type RefuelLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefuelLogs.
     */
    data: RefuelLogCreateManyInput | RefuelLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefuelLog createManyAndReturn
   */
  export type RefuelLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefuelLog
     */
    select?: RefuelLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefuelLog
     */
    omit?: RefuelLogOmit<ExtArgs> | null
    /**
     * The data used to create many RefuelLogs.
     */
    data: RefuelLogCreateManyInput | RefuelLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefuelLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefuelLog update
   */
  export type RefuelLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefuelLog
     */
    select?: RefuelLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefuelLog
     */
    omit?: RefuelLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefuelLogInclude<ExtArgs> | null
    /**
     * The data needed to update a RefuelLog.
     */
    data: XOR<RefuelLogUpdateInput, RefuelLogUncheckedUpdateInput>
    /**
     * Choose, which RefuelLog to update.
     */
    where: RefuelLogWhereUniqueInput
  }

  /**
   * RefuelLog updateMany
   */
  export type RefuelLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefuelLogs.
     */
    data: XOR<RefuelLogUpdateManyMutationInput, RefuelLogUncheckedUpdateManyInput>
    /**
     * Filter which RefuelLogs to update
     */
    where?: RefuelLogWhereInput
    /**
     * Limit how many RefuelLogs to update.
     */
    limit?: number
  }

  /**
   * RefuelLog updateManyAndReturn
   */
  export type RefuelLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefuelLog
     */
    select?: RefuelLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefuelLog
     */
    omit?: RefuelLogOmit<ExtArgs> | null
    /**
     * The data used to update RefuelLogs.
     */
    data: XOR<RefuelLogUpdateManyMutationInput, RefuelLogUncheckedUpdateManyInput>
    /**
     * Filter which RefuelLogs to update
     */
    where?: RefuelLogWhereInput
    /**
     * Limit how many RefuelLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefuelLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefuelLog upsert
   */
  export type RefuelLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefuelLog
     */
    select?: RefuelLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefuelLog
     */
    omit?: RefuelLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefuelLogInclude<ExtArgs> | null
    /**
     * The filter to search for the RefuelLog to update in case it exists.
     */
    where: RefuelLogWhereUniqueInput
    /**
     * In case the RefuelLog found by the `where` argument doesn't exist, create a new RefuelLog with this data.
     */
    create: XOR<RefuelLogCreateInput, RefuelLogUncheckedCreateInput>
    /**
     * In case the RefuelLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefuelLogUpdateInput, RefuelLogUncheckedUpdateInput>
  }

  /**
   * RefuelLog delete
   */
  export type RefuelLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefuelLog
     */
    select?: RefuelLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefuelLog
     */
    omit?: RefuelLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefuelLogInclude<ExtArgs> | null
    /**
     * Filter which RefuelLog to delete.
     */
    where: RefuelLogWhereUniqueInput
  }

  /**
   * RefuelLog deleteMany
   */
  export type RefuelLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefuelLogs to delete
     */
    where?: RefuelLogWhereInput
    /**
     * Limit how many RefuelLogs to delete.
     */
    limit?: number
  }

  /**
   * RefuelLog.EmployeeEquipmentLog
   */
  export type RefuelLog$EmployeeEquipmentLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeEquipmentLog
     */
    select?: EmployeeEquipmentLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeEquipmentLog
     */
    omit?: EmployeeEquipmentLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeEquipmentLogInclude<ExtArgs> | null
    where?: EmployeeEquipmentLogWhereInput
  }

  /**
   * RefuelLog.TascoLog
   */
  export type RefuelLog$TascoLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TascoLog
     */
    select?: TascoLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TascoLog
     */
    omit?: TascoLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TascoLogInclude<ExtArgs> | null
    where?: TascoLogWhereInput
  }

  /**
   * RefuelLog.TruckingLog
   */
  export type RefuelLog$TruckingLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogInclude<ExtArgs> | null
    where?: TruckingLogWhereInput
  }

  /**
   * RefuelLog without action
   */
  export type RefuelLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefuelLog
     */
    select?: RefuelLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefuelLog
     */
    omit?: RefuelLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefuelLogInclude<ExtArgs> | null
  }


  /**
   * Model EquipmentHauled
   */

  export type AggregateEquipmentHauled = {
    _count: EquipmentHauledCountAggregateOutputType | null
    _avg: EquipmentHauledAvgAggregateOutputType | null
    _sum: EquipmentHauledSumAggregateOutputType | null
    _min: EquipmentHauledMinAggregateOutputType | null
    _max: EquipmentHauledMaxAggregateOutputType | null
  }

  export type EquipmentHauledAvgAggregateOutputType = {
    endMileage: number | null
    startMileage: number | null
  }

  export type EquipmentHauledSumAggregateOutputType = {
    endMileage: number | null
    startMileage: number | null
  }

  export type EquipmentHauledMinAggregateOutputType = {
    id: string | null
    truckingLogId: string | null
    equipmentId: string | null
    createdAt: Date | null
    endMileage: number | null
    startMileage: number | null
    destination: string | null
    source: string | null
  }

  export type EquipmentHauledMaxAggregateOutputType = {
    id: string | null
    truckingLogId: string | null
    equipmentId: string | null
    createdAt: Date | null
    endMileage: number | null
    startMileage: number | null
    destination: string | null
    source: string | null
  }

  export type EquipmentHauledCountAggregateOutputType = {
    id: number
    truckingLogId: number
    equipmentId: number
    createdAt: number
    endMileage: number
    startMileage: number
    destination: number
    source: number
    _all: number
  }


  export type EquipmentHauledAvgAggregateInputType = {
    endMileage?: true
    startMileage?: true
  }

  export type EquipmentHauledSumAggregateInputType = {
    endMileage?: true
    startMileage?: true
  }

  export type EquipmentHauledMinAggregateInputType = {
    id?: true
    truckingLogId?: true
    equipmentId?: true
    createdAt?: true
    endMileage?: true
    startMileage?: true
    destination?: true
    source?: true
  }

  export type EquipmentHauledMaxAggregateInputType = {
    id?: true
    truckingLogId?: true
    equipmentId?: true
    createdAt?: true
    endMileage?: true
    startMileage?: true
    destination?: true
    source?: true
  }

  export type EquipmentHauledCountAggregateInputType = {
    id?: true
    truckingLogId?: true
    equipmentId?: true
    createdAt?: true
    endMileage?: true
    startMileage?: true
    destination?: true
    source?: true
    _all?: true
  }

  export type EquipmentHauledAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentHauled to aggregate.
     */
    where?: EquipmentHauledWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentHauleds to fetch.
     */
    orderBy?: EquipmentHauledOrderByWithRelationInput | EquipmentHauledOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentHauledWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentHauleds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentHauleds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EquipmentHauleds
    **/
    _count?: true | EquipmentHauledCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentHauledAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentHauledSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentHauledMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentHauledMaxAggregateInputType
  }

  export type GetEquipmentHauledAggregateType<T extends EquipmentHauledAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipmentHauled]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipmentHauled[P]>
      : GetScalarType<T[P], AggregateEquipmentHauled[P]>
  }




  export type EquipmentHauledGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentHauledWhereInput
    orderBy?: EquipmentHauledOrderByWithAggregationInput | EquipmentHauledOrderByWithAggregationInput[]
    by: EquipmentHauledScalarFieldEnum[] | EquipmentHauledScalarFieldEnum
    having?: EquipmentHauledScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentHauledCountAggregateInputType | true
    _avg?: EquipmentHauledAvgAggregateInputType
    _sum?: EquipmentHauledSumAggregateInputType
    _min?: EquipmentHauledMinAggregateInputType
    _max?: EquipmentHauledMaxAggregateInputType
  }

  export type EquipmentHauledGroupByOutputType = {
    id: string
    truckingLogId: string | null
    equipmentId: string | null
    createdAt: Date
    endMileage: number | null
    startMileage: number | null
    destination: string | null
    source: string | null
    _count: EquipmentHauledCountAggregateOutputType | null
    _avg: EquipmentHauledAvgAggregateOutputType | null
    _sum: EquipmentHauledSumAggregateOutputType | null
    _min: EquipmentHauledMinAggregateOutputType | null
    _max: EquipmentHauledMaxAggregateOutputType | null
  }

  type GetEquipmentHauledGroupByPayload<T extends EquipmentHauledGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentHauledGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentHauledGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentHauledGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentHauledGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentHauledSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckingLogId?: boolean
    equipmentId?: boolean
    createdAt?: boolean
    endMileage?: boolean
    startMileage?: boolean
    destination?: boolean
    source?: boolean
    Equipment?: boolean | EquipmentHauled$EquipmentArgs<ExtArgs>
    TruckingLog?: boolean | EquipmentHauled$TruckingLogArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentHauled"]>

  export type EquipmentHauledSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckingLogId?: boolean
    equipmentId?: boolean
    createdAt?: boolean
    endMileage?: boolean
    startMileage?: boolean
    destination?: boolean
    source?: boolean
    Equipment?: boolean | EquipmentHauled$EquipmentArgs<ExtArgs>
    TruckingLog?: boolean | EquipmentHauled$TruckingLogArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentHauled"]>

  export type EquipmentHauledSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    truckingLogId?: boolean
    equipmentId?: boolean
    createdAt?: boolean
    endMileage?: boolean
    startMileage?: boolean
    destination?: boolean
    source?: boolean
    Equipment?: boolean | EquipmentHauled$EquipmentArgs<ExtArgs>
    TruckingLog?: boolean | EquipmentHauled$TruckingLogArgs<ExtArgs>
  }, ExtArgs["result"]["equipmentHauled"]>

  export type EquipmentHauledSelectScalar = {
    id?: boolean
    truckingLogId?: boolean
    equipmentId?: boolean
    createdAt?: boolean
    endMileage?: boolean
    startMileage?: boolean
    destination?: boolean
    source?: boolean
  }

  export type EquipmentHauledOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "truckingLogId" | "equipmentId" | "createdAt" | "endMileage" | "startMileage" | "destination" | "source", ExtArgs["result"]["equipmentHauled"]>
  export type EquipmentHauledInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EquipmentHauled$EquipmentArgs<ExtArgs>
    TruckingLog?: boolean | EquipmentHauled$TruckingLogArgs<ExtArgs>
  }
  export type EquipmentHauledIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EquipmentHauled$EquipmentArgs<ExtArgs>
    TruckingLog?: boolean | EquipmentHauled$TruckingLogArgs<ExtArgs>
  }
  export type EquipmentHauledIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Equipment?: boolean | EquipmentHauled$EquipmentArgs<ExtArgs>
    TruckingLog?: boolean | EquipmentHauled$TruckingLogArgs<ExtArgs>
  }

  export type $EquipmentHauledPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EquipmentHauled"
    objects: {
      Equipment: Prisma.$EquipmentPayload<ExtArgs> | null
      TruckingLog: Prisma.$TruckingLogPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      truckingLogId: string | null
      equipmentId: string | null
      createdAt: Date
      endMileage: number | null
      startMileage: number | null
      destination: string | null
      source: string | null
    }, ExtArgs["result"]["equipmentHauled"]>
    composites: {}
  }

  type EquipmentHauledGetPayload<S extends boolean | null | undefined | EquipmentHauledDefaultArgs> = $Result.GetResult<Prisma.$EquipmentHauledPayload, S>

  type EquipmentHauledCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentHauledFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentHauledCountAggregateInputType | true
    }

  export interface EquipmentHauledDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EquipmentHauled'], meta: { name: 'EquipmentHauled' } }
    /**
     * Find zero or one EquipmentHauled that matches the filter.
     * @param {EquipmentHauledFindUniqueArgs} args - Arguments to find a EquipmentHauled
     * @example
     * // Get one EquipmentHauled
     * const equipmentHauled = await prisma.equipmentHauled.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentHauledFindUniqueArgs>(args: SelectSubset<T, EquipmentHauledFindUniqueArgs<ExtArgs>>): Prisma__EquipmentHauledClient<$Result.GetResult<Prisma.$EquipmentHauledPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EquipmentHauled that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentHauledFindUniqueOrThrowArgs} args - Arguments to find a EquipmentHauled
     * @example
     * // Get one EquipmentHauled
     * const equipmentHauled = await prisma.equipmentHauled.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentHauledFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentHauledFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentHauledClient<$Result.GetResult<Prisma.$EquipmentHauledPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentHauled that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentHauledFindFirstArgs} args - Arguments to find a EquipmentHauled
     * @example
     * // Get one EquipmentHauled
     * const equipmentHauled = await prisma.equipmentHauled.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentHauledFindFirstArgs>(args?: SelectSubset<T, EquipmentHauledFindFirstArgs<ExtArgs>>): Prisma__EquipmentHauledClient<$Result.GetResult<Prisma.$EquipmentHauledPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EquipmentHauled that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentHauledFindFirstOrThrowArgs} args - Arguments to find a EquipmentHauled
     * @example
     * // Get one EquipmentHauled
     * const equipmentHauled = await prisma.equipmentHauled.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentHauledFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentHauledFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentHauledClient<$Result.GetResult<Prisma.$EquipmentHauledPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EquipmentHauleds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentHauledFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EquipmentHauleds
     * const equipmentHauleds = await prisma.equipmentHauled.findMany()
     * 
     * // Get first 10 EquipmentHauleds
     * const equipmentHauleds = await prisma.equipmentHauled.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentHauledWithIdOnly = await prisma.equipmentHauled.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentHauledFindManyArgs>(args?: SelectSubset<T, EquipmentHauledFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentHauledPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EquipmentHauled.
     * @param {EquipmentHauledCreateArgs} args - Arguments to create a EquipmentHauled.
     * @example
     * // Create one EquipmentHauled
     * const EquipmentHauled = await prisma.equipmentHauled.create({
     *   data: {
     *     // ... data to create a EquipmentHauled
     *   }
     * })
     * 
     */
    create<T extends EquipmentHauledCreateArgs>(args: SelectSubset<T, EquipmentHauledCreateArgs<ExtArgs>>): Prisma__EquipmentHauledClient<$Result.GetResult<Prisma.$EquipmentHauledPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EquipmentHauleds.
     * @param {EquipmentHauledCreateManyArgs} args - Arguments to create many EquipmentHauleds.
     * @example
     * // Create many EquipmentHauleds
     * const equipmentHauled = await prisma.equipmentHauled.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentHauledCreateManyArgs>(args?: SelectSubset<T, EquipmentHauledCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EquipmentHauleds and returns the data saved in the database.
     * @param {EquipmentHauledCreateManyAndReturnArgs} args - Arguments to create many EquipmentHauleds.
     * @example
     * // Create many EquipmentHauleds
     * const equipmentHauled = await prisma.equipmentHauled.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EquipmentHauleds and only return the `id`
     * const equipmentHauledWithIdOnly = await prisma.equipmentHauled.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentHauledCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentHauledCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentHauledPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EquipmentHauled.
     * @param {EquipmentHauledDeleteArgs} args - Arguments to delete one EquipmentHauled.
     * @example
     * // Delete one EquipmentHauled
     * const EquipmentHauled = await prisma.equipmentHauled.delete({
     *   where: {
     *     // ... filter to delete one EquipmentHauled
     *   }
     * })
     * 
     */
    delete<T extends EquipmentHauledDeleteArgs>(args: SelectSubset<T, EquipmentHauledDeleteArgs<ExtArgs>>): Prisma__EquipmentHauledClient<$Result.GetResult<Prisma.$EquipmentHauledPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EquipmentHauled.
     * @param {EquipmentHauledUpdateArgs} args - Arguments to update one EquipmentHauled.
     * @example
     * // Update one EquipmentHauled
     * const equipmentHauled = await prisma.equipmentHauled.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentHauledUpdateArgs>(args: SelectSubset<T, EquipmentHauledUpdateArgs<ExtArgs>>): Prisma__EquipmentHauledClient<$Result.GetResult<Prisma.$EquipmentHauledPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EquipmentHauleds.
     * @param {EquipmentHauledDeleteManyArgs} args - Arguments to filter EquipmentHauleds to delete.
     * @example
     * // Delete a few EquipmentHauleds
     * const { count } = await prisma.equipmentHauled.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentHauledDeleteManyArgs>(args?: SelectSubset<T, EquipmentHauledDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentHauleds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentHauledUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EquipmentHauleds
     * const equipmentHauled = await prisma.equipmentHauled.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentHauledUpdateManyArgs>(args: SelectSubset<T, EquipmentHauledUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EquipmentHauleds and returns the data updated in the database.
     * @param {EquipmentHauledUpdateManyAndReturnArgs} args - Arguments to update many EquipmentHauleds.
     * @example
     * // Update many EquipmentHauleds
     * const equipmentHauled = await prisma.equipmentHauled.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EquipmentHauleds and only return the `id`
     * const equipmentHauledWithIdOnly = await prisma.equipmentHauled.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipmentHauledUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipmentHauledUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentHauledPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EquipmentHauled.
     * @param {EquipmentHauledUpsertArgs} args - Arguments to update or create a EquipmentHauled.
     * @example
     * // Update or create a EquipmentHauled
     * const equipmentHauled = await prisma.equipmentHauled.upsert({
     *   create: {
     *     // ... data to create a EquipmentHauled
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EquipmentHauled we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentHauledUpsertArgs>(args: SelectSubset<T, EquipmentHauledUpsertArgs<ExtArgs>>): Prisma__EquipmentHauledClient<$Result.GetResult<Prisma.$EquipmentHauledPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EquipmentHauleds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentHauledCountArgs} args - Arguments to filter EquipmentHauleds to count.
     * @example
     * // Count the number of EquipmentHauleds
     * const count = await prisma.equipmentHauled.count({
     *   where: {
     *     // ... the filter for the EquipmentHauleds we want to count
     *   }
     * })
    **/
    count<T extends EquipmentHauledCountArgs>(
      args?: Subset<T, EquipmentHauledCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentHauledCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EquipmentHauled.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentHauledAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentHauledAggregateArgs>(args: Subset<T, EquipmentHauledAggregateArgs>): Prisma.PrismaPromise<GetEquipmentHauledAggregateType<T>>

    /**
     * Group by EquipmentHauled.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentHauledGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentHauledGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentHauledGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentHauledGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentHauledGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentHauledGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EquipmentHauled model
   */
  readonly fields: EquipmentHauledFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EquipmentHauled.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentHauledClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Equipment<T extends EquipmentHauled$EquipmentArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentHauled$EquipmentArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    TruckingLog<T extends EquipmentHauled$TruckingLogArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentHauled$TruckingLogArgs<ExtArgs>>): Prisma__TruckingLogClient<$Result.GetResult<Prisma.$TruckingLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EquipmentHauled model
   */
  interface EquipmentHauledFieldRefs {
    readonly id: FieldRef<"EquipmentHauled", 'String'>
    readonly truckingLogId: FieldRef<"EquipmentHauled", 'String'>
    readonly equipmentId: FieldRef<"EquipmentHauled", 'String'>
    readonly createdAt: FieldRef<"EquipmentHauled", 'DateTime'>
    readonly endMileage: FieldRef<"EquipmentHauled", 'Int'>
    readonly startMileage: FieldRef<"EquipmentHauled", 'Int'>
    readonly destination: FieldRef<"EquipmentHauled", 'String'>
    readonly source: FieldRef<"EquipmentHauled", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EquipmentHauled findUnique
   */
  export type EquipmentHauledFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentHauled
     */
    select?: EquipmentHauledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentHauled
     */
    omit?: EquipmentHauledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentHauledInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentHauled to fetch.
     */
    where: EquipmentHauledWhereUniqueInput
  }

  /**
   * EquipmentHauled findUniqueOrThrow
   */
  export type EquipmentHauledFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentHauled
     */
    select?: EquipmentHauledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentHauled
     */
    omit?: EquipmentHauledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentHauledInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentHauled to fetch.
     */
    where: EquipmentHauledWhereUniqueInput
  }

  /**
   * EquipmentHauled findFirst
   */
  export type EquipmentHauledFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentHauled
     */
    select?: EquipmentHauledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentHauled
     */
    omit?: EquipmentHauledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentHauledInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentHauled to fetch.
     */
    where?: EquipmentHauledWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentHauleds to fetch.
     */
    orderBy?: EquipmentHauledOrderByWithRelationInput | EquipmentHauledOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentHauleds.
     */
    cursor?: EquipmentHauledWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentHauleds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentHauleds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentHauleds.
     */
    distinct?: EquipmentHauledScalarFieldEnum | EquipmentHauledScalarFieldEnum[]
  }

  /**
   * EquipmentHauled findFirstOrThrow
   */
  export type EquipmentHauledFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentHauled
     */
    select?: EquipmentHauledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentHauled
     */
    omit?: EquipmentHauledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentHauledInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentHauled to fetch.
     */
    where?: EquipmentHauledWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentHauleds to fetch.
     */
    orderBy?: EquipmentHauledOrderByWithRelationInput | EquipmentHauledOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EquipmentHauleds.
     */
    cursor?: EquipmentHauledWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentHauleds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentHauleds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EquipmentHauleds.
     */
    distinct?: EquipmentHauledScalarFieldEnum | EquipmentHauledScalarFieldEnum[]
  }

  /**
   * EquipmentHauled findMany
   */
  export type EquipmentHauledFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentHauled
     */
    select?: EquipmentHauledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentHauled
     */
    omit?: EquipmentHauledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentHauledInclude<ExtArgs> | null
    /**
     * Filter, which EquipmentHauleds to fetch.
     */
    where?: EquipmentHauledWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EquipmentHauleds to fetch.
     */
    orderBy?: EquipmentHauledOrderByWithRelationInput | EquipmentHauledOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EquipmentHauleds.
     */
    cursor?: EquipmentHauledWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EquipmentHauleds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EquipmentHauleds.
     */
    skip?: number
    distinct?: EquipmentHauledScalarFieldEnum | EquipmentHauledScalarFieldEnum[]
  }

  /**
   * EquipmentHauled create
   */
  export type EquipmentHauledCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentHauled
     */
    select?: EquipmentHauledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentHauled
     */
    omit?: EquipmentHauledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentHauledInclude<ExtArgs> | null
    /**
     * The data needed to create a EquipmentHauled.
     */
    data?: XOR<EquipmentHauledCreateInput, EquipmentHauledUncheckedCreateInput>
  }

  /**
   * EquipmentHauled createMany
   */
  export type EquipmentHauledCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EquipmentHauleds.
     */
    data: EquipmentHauledCreateManyInput | EquipmentHauledCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EquipmentHauled createManyAndReturn
   */
  export type EquipmentHauledCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentHauled
     */
    select?: EquipmentHauledSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentHauled
     */
    omit?: EquipmentHauledOmit<ExtArgs> | null
    /**
     * The data used to create many EquipmentHauleds.
     */
    data: EquipmentHauledCreateManyInput | EquipmentHauledCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentHauledIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipmentHauled update
   */
  export type EquipmentHauledUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentHauled
     */
    select?: EquipmentHauledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentHauled
     */
    omit?: EquipmentHauledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentHauledInclude<ExtArgs> | null
    /**
     * The data needed to update a EquipmentHauled.
     */
    data: XOR<EquipmentHauledUpdateInput, EquipmentHauledUncheckedUpdateInput>
    /**
     * Choose, which EquipmentHauled to update.
     */
    where: EquipmentHauledWhereUniqueInput
  }

  /**
   * EquipmentHauled updateMany
   */
  export type EquipmentHauledUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EquipmentHauleds.
     */
    data: XOR<EquipmentHauledUpdateManyMutationInput, EquipmentHauledUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentHauleds to update
     */
    where?: EquipmentHauledWhereInput
    /**
     * Limit how many EquipmentHauleds to update.
     */
    limit?: number
  }

  /**
   * EquipmentHauled updateManyAndReturn
   */
  export type EquipmentHauledUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentHauled
     */
    select?: EquipmentHauledSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentHauled
     */
    omit?: EquipmentHauledOmit<ExtArgs> | null
    /**
     * The data used to update EquipmentHauleds.
     */
    data: XOR<EquipmentHauledUpdateManyMutationInput, EquipmentHauledUncheckedUpdateManyInput>
    /**
     * Filter which EquipmentHauleds to update
     */
    where?: EquipmentHauledWhereInput
    /**
     * Limit how many EquipmentHauleds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentHauledIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EquipmentHauled upsert
   */
  export type EquipmentHauledUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentHauled
     */
    select?: EquipmentHauledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentHauled
     */
    omit?: EquipmentHauledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentHauledInclude<ExtArgs> | null
    /**
     * The filter to search for the EquipmentHauled to update in case it exists.
     */
    where: EquipmentHauledWhereUniqueInput
    /**
     * In case the EquipmentHauled found by the `where` argument doesn't exist, create a new EquipmentHauled with this data.
     */
    create: XOR<EquipmentHauledCreateInput, EquipmentHauledUncheckedCreateInput>
    /**
     * In case the EquipmentHauled was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentHauledUpdateInput, EquipmentHauledUncheckedUpdateInput>
  }

  /**
   * EquipmentHauled delete
   */
  export type EquipmentHauledDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentHauled
     */
    select?: EquipmentHauledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentHauled
     */
    omit?: EquipmentHauledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentHauledInclude<ExtArgs> | null
    /**
     * Filter which EquipmentHauled to delete.
     */
    where: EquipmentHauledWhereUniqueInput
  }

  /**
   * EquipmentHauled deleteMany
   */
  export type EquipmentHauledDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EquipmentHauleds to delete
     */
    where?: EquipmentHauledWhereInput
    /**
     * Limit how many EquipmentHauleds to delete.
     */
    limit?: number
  }

  /**
   * EquipmentHauled.Equipment
   */
  export type EquipmentHauled$EquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
  }

  /**
   * EquipmentHauled.TruckingLog
   */
  export type EquipmentHauled$TruckingLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TruckingLog
     */
    select?: TruckingLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TruckingLog
     */
    omit?: TruckingLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TruckingLogInclude<ExtArgs> | null
    where?: TruckingLogWhereInput
  }

  /**
   * EquipmentHauled without action
   */
  export type EquipmentHauledDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentHauled
     */
    select?: EquipmentHauledSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EquipmentHauled
     */
    omit?: EquipmentHauledOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentHauledInclude<ExtArgs> | null
  }


  /**
   * Model TimeSheetChangeLog
   */

  export type AggregateTimeSheetChangeLog = {
    _count: TimeSheetChangeLogCountAggregateOutputType | null
    _avg: TimeSheetChangeLogAvgAggregateOutputType | null
    _sum: TimeSheetChangeLogSumAggregateOutputType | null
    _min: TimeSheetChangeLogMinAggregateOutputType | null
    _max: TimeSheetChangeLogMaxAggregateOutputType | null
  }

  export type TimeSheetChangeLogAvgAggregateOutputType = {
    timeSheetId: number | null
    numberOfChanges: number | null
  }

  export type TimeSheetChangeLogSumAggregateOutputType = {
    timeSheetId: number | null
    numberOfChanges: number | null
  }

  export type TimeSheetChangeLogMinAggregateOutputType = {
    id: string | null
    timeSheetId: number | null
    changedBy: string | null
    changedAt: Date | null
    changeReason: string | null
    wasStatusChange: boolean | null
    numberOfChanges: number | null
  }

  export type TimeSheetChangeLogMaxAggregateOutputType = {
    id: string | null
    timeSheetId: number | null
    changedBy: string | null
    changedAt: Date | null
    changeReason: string | null
    wasStatusChange: boolean | null
    numberOfChanges: number | null
  }

  export type TimeSheetChangeLogCountAggregateOutputType = {
    id: number
    timeSheetId: number
    changedBy: number
    changedAt: number
    changeReason: number
    changes: number
    wasStatusChange: number
    numberOfChanges: number
    _all: number
  }


  export type TimeSheetChangeLogAvgAggregateInputType = {
    timeSheetId?: true
    numberOfChanges?: true
  }

  export type TimeSheetChangeLogSumAggregateInputType = {
    timeSheetId?: true
    numberOfChanges?: true
  }

  export type TimeSheetChangeLogMinAggregateInputType = {
    id?: true
    timeSheetId?: true
    changedBy?: true
    changedAt?: true
    changeReason?: true
    wasStatusChange?: true
    numberOfChanges?: true
  }

  export type TimeSheetChangeLogMaxAggregateInputType = {
    id?: true
    timeSheetId?: true
    changedBy?: true
    changedAt?: true
    changeReason?: true
    wasStatusChange?: true
    numberOfChanges?: true
  }

  export type TimeSheetChangeLogCountAggregateInputType = {
    id?: true
    timeSheetId?: true
    changedBy?: true
    changedAt?: true
    changeReason?: true
    changes?: true
    wasStatusChange?: true
    numberOfChanges?: true
    _all?: true
  }

  export type TimeSheetChangeLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSheetChangeLog to aggregate.
     */
    where?: TimeSheetChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSheetChangeLogs to fetch.
     */
    orderBy?: TimeSheetChangeLogOrderByWithRelationInput | TimeSheetChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeSheetChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSheetChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSheetChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeSheetChangeLogs
    **/
    _count?: true | TimeSheetChangeLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeSheetChangeLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeSheetChangeLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeSheetChangeLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeSheetChangeLogMaxAggregateInputType
  }

  export type GetTimeSheetChangeLogAggregateType<T extends TimeSheetChangeLogAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeSheetChangeLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeSheetChangeLog[P]>
      : GetScalarType<T[P], AggregateTimeSheetChangeLog[P]>
  }




  export type TimeSheetChangeLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeSheetChangeLogWhereInput
    orderBy?: TimeSheetChangeLogOrderByWithAggregationInput | TimeSheetChangeLogOrderByWithAggregationInput[]
    by: TimeSheetChangeLogScalarFieldEnum[] | TimeSheetChangeLogScalarFieldEnum
    having?: TimeSheetChangeLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeSheetChangeLogCountAggregateInputType | true
    _avg?: TimeSheetChangeLogAvgAggregateInputType
    _sum?: TimeSheetChangeLogSumAggregateInputType
    _min?: TimeSheetChangeLogMinAggregateInputType
    _max?: TimeSheetChangeLogMaxAggregateInputType
  }

  export type TimeSheetChangeLogGroupByOutputType = {
    id: string
    timeSheetId: number
    changedBy: string
    changedAt: Date
    changeReason: string | null
    changes: JsonValue
    wasStatusChange: boolean
    numberOfChanges: number
    _count: TimeSheetChangeLogCountAggregateOutputType | null
    _avg: TimeSheetChangeLogAvgAggregateOutputType | null
    _sum: TimeSheetChangeLogSumAggregateOutputType | null
    _min: TimeSheetChangeLogMinAggregateOutputType | null
    _max: TimeSheetChangeLogMaxAggregateOutputType | null
  }

  type GetTimeSheetChangeLogGroupByPayload<T extends TimeSheetChangeLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeSheetChangeLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeSheetChangeLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeSheetChangeLogGroupByOutputType[P]>
            : GetScalarType<T[P], TimeSheetChangeLogGroupByOutputType[P]>
        }
      >
    >


  export type TimeSheetChangeLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timeSheetId?: boolean
    changedBy?: boolean
    changedAt?: boolean
    changeReason?: boolean
    changes?: boolean
    wasStatusChange?: boolean
    numberOfChanges?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSheetChangeLog"]>

  export type TimeSheetChangeLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timeSheetId?: boolean
    changedBy?: boolean
    changedAt?: boolean
    changeReason?: boolean
    changes?: boolean
    wasStatusChange?: boolean
    numberOfChanges?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSheetChangeLog"]>

  export type TimeSheetChangeLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timeSheetId?: boolean
    changedBy?: boolean
    changedAt?: boolean
    changeReason?: boolean
    changes?: boolean
    wasStatusChange?: boolean
    numberOfChanges?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeSheetChangeLog"]>

  export type TimeSheetChangeLogSelectScalar = {
    id?: boolean
    timeSheetId?: boolean
    changedBy?: boolean
    changedAt?: boolean
    changeReason?: boolean
    changes?: boolean
    wasStatusChange?: boolean
    numberOfChanges?: boolean
  }

  export type TimeSheetChangeLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timeSheetId" | "changedBy" | "changedAt" | "changeReason" | "changes" | "wasStatusChange" | "numberOfChanges", ExtArgs["result"]["timeSheetChangeLog"]>
  export type TimeSheetChangeLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }
  export type TimeSheetChangeLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }
  export type TimeSheetChangeLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    TimeSheet?: boolean | TimeSheetDefaultArgs<ExtArgs>
  }

  export type $TimeSheetChangeLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeSheetChangeLog"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      TimeSheet: Prisma.$TimeSheetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      timeSheetId: number
      changedBy: string
      changedAt: Date
      changeReason: string | null
      changes: Prisma.JsonValue
      wasStatusChange: boolean
      numberOfChanges: number
    }, ExtArgs["result"]["timeSheetChangeLog"]>
    composites: {}
  }

  type TimeSheetChangeLogGetPayload<S extends boolean | null | undefined | TimeSheetChangeLogDefaultArgs> = $Result.GetResult<Prisma.$TimeSheetChangeLogPayload, S>

  type TimeSheetChangeLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TimeSheetChangeLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TimeSheetChangeLogCountAggregateInputType | true
    }

  export interface TimeSheetChangeLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeSheetChangeLog'], meta: { name: 'TimeSheetChangeLog' } }
    /**
     * Find zero or one TimeSheetChangeLog that matches the filter.
     * @param {TimeSheetChangeLogFindUniqueArgs} args - Arguments to find a TimeSheetChangeLog
     * @example
     * // Get one TimeSheetChangeLog
     * const timeSheetChangeLog = await prisma.timeSheetChangeLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeSheetChangeLogFindUniqueArgs>(args: SelectSubset<T, TimeSheetChangeLogFindUniqueArgs<ExtArgs>>): Prisma__TimeSheetChangeLogClient<$Result.GetResult<Prisma.$TimeSheetChangeLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TimeSheetChangeLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TimeSheetChangeLogFindUniqueOrThrowArgs} args - Arguments to find a TimeSheetChangeLog
     * @example
     * // Get one TimeSheetChangeLog
     * const timeSheetChangeLog = await prisma.timeSheetChangeLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeSheetChangeLogFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeSheetChangeLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeSheetChangeLogClient<$Result.GetResult<Prisma.$TimeSheetChangeLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeSheetChangeLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSheetChangeLogFindFirstArgs} args - Arguments to find a TimeSheetChangeLog
     * @example
     * // Get one TimeSheetChangeLog
     * const timeSheetChangeLog = await prisma.timeSheetChangeLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeSheetChangeLogFindFirstArgs>(args?: SelectSubset<T, TimeSheetChangeLogFindFirstArgs<ExtArgs>>): Prisma__TimeSheetChangeLogClient<$Result.GetResult<Prisma.$TimeSheetChangeLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TimeSheetChangeLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSheetChangeLogFindFirstOrThrowArgs} args - Arguments to find a TimeSheetChangeLog
     * @example
     * // Get one TimeSheetChangeLog
     * const timeSheetChangeLog = await prisma.timeSheetChangeLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeSheetChangeLogFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeSheetChangeLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeSheetChangeLogClient<$Result.GetResult<Prisma.$TimeSheetChangeLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TimeSheetChangeLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSheetChangeLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeSheetChangeLogs
     * const timeSheetChangeLogs = await prisma.timeSheetChangeLog.findMany()
     * 
     * // Get first 10 TimeSheetChangeLogs
     * const timeSheetChangeLogs = await prisma.timeSheetChangeLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeSheetChangeLogWithIdOnly = await prisma.timeSheetChangeLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeSheetChangeLogFindManyArgs>(args?: SelectSubset<T, TimeSheetChangeLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSheetChangeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TimeSheetChangeLog.
     * @param {TimeSheetChangeLogCreateArgs} args - Arguments to create a TimeSheetChangeLog.
     * @example
     * // Create one TimeSheetChangeLog
     * const TimeSheetChangeLog = await prisma.timeSheetChangeLog.create({
     *   data: {
     *     // ... data to create a TimeSheetChangeLog
     *   }
     * })
     * 
     */
    create<T extends TimeSheetChangeLogCreateArgs>(args: SelectSubset<T, TimeSheetChangeLogCreateArgs<ExtArgs>>): Prisma__TimeSheetChangeLogClient<$Result.GetResult<Prisma.$TimeSheetChangeLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TimeSheetChangeLogs.
     * @param {TimeSheetChangeLogCreateManyArgs} args - Arguments to create many TimeSheetChangeLogs.
     * @example
     * // Create many TimeSheetChangeLogs
     * const timeSheetChangeLog = await prisma.timeSheetChangeLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeSheetChangeLogCreateManyArgs>(args?: SelectSubset<T, TimeSheetChangeLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeSheetChangeLogs and returns the data saved in the database.
     * @param {TimeSheetChangeLogCreateManyAndReturnArgs} args - Arguments to create many TimeSheetChangeLogs.
     * @example
     * // Create many TimeSheetChangeLogs
     * const timeSheetChangeLog = await prisma.timeSheetChangeLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeSheetChangeLogs and only return the `id`
     * const timeSheetChangeLogWithIdOnly = await prisma.timeSheetChangeLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeSheetChangeLogCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeSheetChangeLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSheetChangeLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TimeSheetChangeLog.
     * @param {TimeSheetChangeLogDeleteArgs} args - Arguments to delete one TimeSheetChangeLog.
     * @example
     * // Delete one TimeSheetChangeLog
     * const TimeSheetChangeLog = await prisma.timeSheetChangeLog.delete({
     *   where: {
     *     // ... filter to delete one TimeSheetChangeLog
     *   }
     * })
     * 
     */
    delete<T extends TimeSheetChangeLogDeleteArgs>(args: SelectSubset<T, TimeSheetChangeLogDeleteArgs<ExtArgs>>): Prisma__TimeSheetChangeLogClient<$Result.GetResult<Prisma.$TimeSheetChangeLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TimeSheetChangeLog.
     * @param {TimeSheetChangeLogUpdateArgs} args - Arguments to update one TimeSheetChangeLog.
     * @example
     * // Update one TimeSheetChangeLog
     * const timeSheetChangeLog = await prisma.timeSheetChangeLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeSheetChangeLogUpdateArgs>(args: SelectSubset<T, TimeSheetChangeLogUpdateArgs<ExtArgs>>): Prisma__TimeSheetChangeLogClient<$Result.GetResult<Prisma.$TimeSheetChangeLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TimeSheetChangeLogs.
     * @param {TimeSheetChangeLogDeleteManyArgs} args - Arguments to filter TimeSheetChangeLogs to delete.
     * @example
     * // Delete a few TimeSheetChangeLogs
     * const { count } = await prisma.timeSheetChangeLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeSheetChangeLogDeleteManyArgs>(args?: SelectSubset<T, TimeSheetChangeLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSheetChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSheetChangeLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeSheetChangeLogs
     * const timeSheetChangeLog = await prisma.timeSheetChangeLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeSheetChangeLogUpdateManyArgs>(args: SelectSubset<T, TimeSheetChangeLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeSheetChangeLogs and returns the data updated in the database.
     * @param {TimeSheetChangeLogUpdateManyAndReturnArgs} args - Arguments to update many TimeSheetChangeLogs.
     * @example
     * // Update many TimeSheetChangeLogs
     * const timeSheetChangeLog = await prisma.timeSheetChangeLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TimeSheetChangeLogs and only return the `id`
     * const timeSheetChangeLogWithIdOnly = await prisma.timeSheetChangeLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TimeSheetChangeLogUpdateManyAndReturnArgs>(args: SelectSubset<T, TimeSheetChangeLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSheetChangeLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TimeSheetChangeLog.
     * @param {TimeSheetChangeLogUpsertArgs} args - Arguments to update or create a TimeSheetChangeLog.
     * @example
     * // Update or create a TimeSheetChangeLog
     * const timeSheetChangeLog = await prisma.timeSheetChangeLog.upsert({
     *   create: {
     *     // ... data to create a TimeSheetChangeLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeSheetChangeLog we want to update
     *   }
     * })
     */
    upsert<T extends TimeSheetChangeLogUpsertArgs>(args: SelectSubset<T, TimeSheetChangeLogUpsertArgs<ExtArgs>>): Prisma__TimeSheetChangeLogClient<$Result.GetResult<Prisma.$TimeSheetChangeLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TimeSheetChangeLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSheetChangeLogCountArgs} args - Arguments to filter TimeSheetChangeLogs to count.
     * @example
     * // Count the number of TimeSheetChangeLogs
     * const count = await prisma.timeSheetChangeLog.count({
     *   where: {
     *     // ... the filter for the TimeSheetChangeLogs we want to count
     *   }
     * })
    **/
    count<T extends TimeSheetChangeLogCountArgs>(
      args?: Subset<T, TimeSheetChangeLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeSheetChangeLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeSheetChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSheetChangeLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeSheetChangeLogAggregateArgs>(args: Subset<T, TimeSheetChangeLogAggregateArgs>): Prisma.PrismaPromise<GetTimeSheetChangeLogAggregateType<T>>

    /**
     * Group by TimeSheetChangeLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeSheetChangeLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeSheetChangeLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeSheetChangeLogGroupByArgs['orderBy'] }
        : { orderBy?: TimeSheetChangeLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeSheetChangeLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeSheetChangeLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeSheetChangeLog model
   */
  readonly fields: TimeSheetChangeLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeSheetChangeLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeSheetChangeLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    TimeSheet<T extends TimeSheetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TimeSheetDefaultArgs<ExtArgs>>): Prisma__TimeSheetClient<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeSheetChangeLog model
   */
  interface TimeSheetChangeLogFieldRefs {
    readonly id: FieldRef<"TimeSheetChangeLog", 'String'>
    readonly timeSheetId: FieldRef<"TimeSheetChangeLog", 'Int'>
    readonly changedBy: FieldRef<"TimeSheetChangeLog", 'String'>
    readonly changedAt: FieldRef<"TimeSheetChangeLog", 'DateTime'>
    readonly changeReason: FieldRef<"TimeSheetChangeLog", 'String'>
    readonly changes: FieldRef<"TimeSheetChangeLog", 'Json'>
    readonly wasStatusChange: FieldRef<"TimeSheetChangeLog", 'Boolean'>
    readonly numberOfChanges: FieldRef<"TimeSheetChangeLog", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TimeSheetChangeLog findUnique
   */
  export type TimeSheetChangeLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheetChangeLog
     */
    select?: TimeSheetChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheetChangeLog
     */
    omit?: TimeSheetChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeSheetChangeLog to fetch.
     */
    where: TimeSheetChangeLogWhereUniqueInput
  }

  /**
   * TimeSheetChangeLog findUniqueOrThrow
   */
  export type TimeSheetChangeLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheetChangeLog
     */
    select?: TimeSheetChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheetChangeLog
     */
    omit?: TimeSheetChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeSheetChangeLog to fetch.
     */
    where: TimeSheetChangeLogWhereUniqueInput
  }

  /**
   * TimeSheetChangeLog findFirst
   */
  export type TimeSheetChangeLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheetChangeLog
     */
    select?: TimeSheetChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheetChangeLog
     */
    omit?: TimeSheetChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeSheetChangeLog to fetch.
     */
    where?: TimeSheetChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSheetChangeLogs to fetch.
     */
    orderBy?: TimeSheetChangeLogOrderByWithRelationInput | TimeSheetChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSheetChangeLogs.
     */
    cursor?: TimeSheetChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSheetChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSheetChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSheetChangeLogs.
     */
    distinct?: TimeSheetChangeLogScalarFieldEnum | TimeSheetChangeLogScalarFieldEnum[]
  }

  /**
   * TimeSheetChangeLog findFirstOrThrow
   */
  export type TimeSheetChangeLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheetChangeLog
     */
    select?: TimeSheetChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheetChangeLog
     */
    omit?: TimeSheetChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeSheetChangeLog to fetch.
     */
    where?: TimeSheetChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSheetChangeLogs to fetch.
     */
    orderBy?: TimeSheetChangeLogOrderByWithRelationInput | TimeSheetChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeSheetChangeLogs.
     */
    cursor?: TimeSheetChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSheetChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSheetChangeLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeSheetChangeLogs.
     */
    distinct?: TimeSheetChangeLogScalarFieldEnum | TimeSheetChangeLogScalarFieldEnum[]
  }

  /**
   * TimeSheetChangeLog findMany
   */
  export type TimeSheetChangeLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheetChangeLog
     */
    select?: TimeSheetChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheetChangeLog
     */
    omit?: TimeSheetChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetChangeLogInclude<ExtArgs> | null
    /**
     * Filter, which TimeSheetChangeLogs to fetch.
     */
    where?: TimeSheetChangeLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeSheetChangeLogs to fetch.
     */
    orderBy?: TimeSheetChangeLogOrderByWithRelationInput | TimeSheetChangeLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeSheetChangeLogs.
     */
    cursor?: TimeSheetChangeLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeSheetChangeLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeSheetChangeLogs.
     */
    skip?: number
    distinct?: TimeSheetChangeLogScalarFieldEnum | TimeSheetChangeLogScalarFieldEnum[]
  }

  /**
   * TimeSheetChangeLog create
   */
  export type TimeSheetChangeLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheetChangeLog
     */
    select?: TimeSheetChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheetChangeLog
     */
    omit?: TimeSheetChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeSheetChangeLog.
     */
    data: XOR<TimeSheetChangeLogCreateInput, TimeSheetChangeLogUncheckedCreateInput>
  }

  /**
   * TimeSheetChangeLog createMany
   */
  export type TimeSheetChangeLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeSheetChangeLogs.
     */
    data: TimeSheetChangeLogCreateManyInput | TimeSheetChangeLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeSheetChangeLog createManyAndReturn
   */
  export type TimeSheetChangeLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheetChangeLog
     */
    select?: TimeSheetChangeLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheetChangeLog
     */
    omit?: TimeSheetChangeLogOmit<ExtArgs> | null
    /**
     * The data used to create many TimeSheetChangeLogs.
     */
    data: TimeSheetChangeLogCreateManyInput | TimeSheetChangeLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetChangeLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeSheetChangeLog update
   */
  export type TimeSheetChangeLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheetChangeLog
     */
    select?: TimeSheetChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheetChangeLog
     */
    omit?: TimeSheetChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetChangeLogInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeSheetChangeLog.
     */
    data: XOR<TimeSheetChangeLogUpdateInput, TimeSheetChangeLogUncheckedUpdateInput>
    /**
     * Choose, which TimeSheetChangeLog to update.
     */
    where: TimeSheetChangeLogWhereUniqueInput
  }

  /**
   * TimeSheetChangeLog updateMany
   */
  export type TimeSheetChangeLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeSheetChangeLogs.
     */
    data: XOR<TimeSheetChangeLogUpdateManyMutationInput, TimeSheetChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which TimeSheetChangeLogs to update
     */
    where?: TimeSheetChangeLogWhereInput
    /**
     * Limit how many TimeSheetChangeLogs to update.
     */
    limit?: number
  }

  /**
   * TimeSheetChangeLog updateManyAndReturn
   */
  export type TimeSheetChangeLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheetChangeLog
     */
    select?: TimeSheetChangeLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheetChangeLog
     */
    omit?: TimeSheetChangeLogOmit<ExtArgs> | null
    /**
     * The data used to update TimeSheetChangeLogs.
     */
    data: XOR<TimeSheetChangeLogUpdateManyMutationInput, TimeSheetChangeLogUncheckedUpdateManyInput>
    /**
     * Filter which TimeSheetChangeLogs to update
     */
    where?: TimeSheetChangeLogWhereInput
    /**
     * Limit how many TimeSheetChangeLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetChangeLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeSheetChangeLog upsert
   */
  export type TimeSheetChangeLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheetChangeLog
     */
    select?: TimeSheetChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheetChangeLog
     */
    omit?: TimeSheetChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetChangeLogInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeSheetChangeLog to update in case it exists.
     */
    where: TimeSheetChangeLogWhereUniqueInput
    /**
     * In case the TimeSheetChangeLog found by the `where` argument doesn't exist, create a new TimeSheetChangeLog with this data.
     */
    create: XOR<TimeSheetChangeLogCreateInput, TimeSheetChangeLogUncheckedCreateInput>
    /**
     * In case the TimeSheetChangeLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeSheetChangeLogUpdateInput, TimeSheetChangeLogUncheckedUpdateInput>
  }

  /**
   * TimeSheetChangeLog delete
   */
  export type TimeSheetChangeLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheetChangeLog
     */
    select?: TimeSheetChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheetChangeLog
     */
    omit?: TimeSheetChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetChangeLogInclude<ExtArgs> | null
    /**
     * Filter which TimeSheetChangeLog to delete.
     */
    where: TimeSheetChangeLogWhereUniqueInput
  }

  /**
   * TimeSheetChangeLog deleteMany
   */
  export type TimeSheetChangeLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeSheetChangeLogs to delete
     */
    where?: TimeSheetChangeLogWhereInput
    /**
     * Limit how many TimeSheetChangeLogs to delete.
     */
    limit?: number
  }

  /**
   * TimeSheetChangeLog without action
   */
  export type TimeSheetChangeLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheetChangeLog
     */
    select?: TimeSheetChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheetChangeLog
     */
    omit?: TimeSheetChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetChangeLogInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    email: string | null
    password: string | null
    signature: string | null
    DOB: Date | null
    truckView: boolean | null
    tascoView: boolean | null
    laborView: boolean | null
    mechanicView: boolean | null
    permission: $Enums.Permission | null
    image: string | null
    startDate: Date | null
    terminationDate: Date | null
    accountSetup: boolean | null
    clockedIn: boolean | null
    companyId: string | null
    passwordResetTokenId: string | null
    workTypeId: string | null
    middleName: string | null
    secondLastName: string | null
    lastSeen: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    email: string | null
    password: string | null
    signature: string | null
    DOB: Date | null
    truckView: boolean | null
    tascoView: boolean | null
    laborView: boolean | null
    mechanicView: boolean | null
    permission: $Enums.Permission | null
    image: string | null
    startDate: Date | null
    terminationDate: Date | null
    accountSetup: boolean | null
    clockedIn: boolean | null
    companyId: string | null
    passwordResetTokenId: string | null
    workTypeId: string | null
    middleName: string | null
    secondLastName: string | null
    lastSeen: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    username: number
    email: number
    password: number
    signature: number
    DOB: number
    truckView: number
    tascoView: number
    laborView: number
    mechanicView: number
    permission: number
    image: number
    startDate: number
    terminationDate: number
    accountSetup: number
    clockedIn: number
    companyId: number
    passwordResetTokenId: number
    workTypeId: number
    middleName: number
    secondLastName: number
    lastSeen: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    email?: true
    password?: true
    signature?: true
    DOB?: true
    truckView?: true
    tascoView?: true
    laborView?: true
    mechanicView?: true
    permission?: true
    image?: true
    startDate?: true
    terminationDate?: true
    accountSetup?: true
    clockedIn?: true
    companyId?: true
    passwordResetTokenId?: true
    workTypeId?: true
    middleName?: true
    secondLastName?: true
    lastSeen?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    email?: true
    password?: true
    signature?: true
    DOB?: true
    truckView?: true
    tascoView?: true
    laborView?: true
    mechanicView?: true
    permission?: true
    image?: true
    startDate?: true
    terminationDate?: true
    accountSetup?: true
    clockedIn?: true
    companyId?: true
    passwordResetTokenId?: true
    workTypeId?: true
    middleName?: true
    secondLastName?: true
    lastSeen?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    username?: true
    email?: true
    password?: true
    signature?: true
    DOB?: true
    truckView?: true
    tascoView?: true
    laborView?: true
    mechanicView?: true
    permission?: true
    image?: true
    startDate?: true
    terminationDate?: true
    accountSetup?: true
    clockedIn?: true
    companyId?: true
    passwordResetTokenId?: true
    workTypeId?: true
    middleName?: true
    secondLastName?: true
    lastSeen?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    username: string
    email: string | null
    password: string
    signature: string | null
    DOB: Date | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission: $Enums.Permission
    image: string | null
    startDate: Date | null
    terminationDate: Date | null
    accountSetup: boolean
    clockedIn: boolean
    companyId: string
    passwordResetTokenId: string | null
    workTypeId: string | null
    middleName: string | null
    secondLastName: string | null
    lastSeen: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    signature?: boolean
    DOB?: boolean
    truckView?: boolean
    tascoView?: boolean
    laborView?: boolean
    mechanicView?: boolean
    permission?: boolean
    image?: boolean
    startDate?: boolean
    terminationDate?: boolean
    accountSetup?: boolean
    clockedIn?: boolean
    companyId?: boolean
    passwordResetTokenId?: boolean
    workTypeId?: boolean
    middleName?: boolean
    secondLastName?: boolean
    lastSeen?: boolean
    accountSetupToken?: boolean | User$accountSetupTokenArgs<ExtArgs>
    Contact?: boolean | User$ContactArgs<ExtArgs>
    Equipment?: boolean | User$EquipmentArgs<ExtArgs>
    FCMToken?: boolean | User$FCMTokenArgs<ExtArgs>
    FormApprovals?: boolean | User$FormApprovalsArgs<ExtArgs>
    FormSubmissions?: boolean | User$FormSubmissionsArgs<ExtArgs>
    Jobsite?: boolean | User$JobsiteArgs<ExtArgs>
    MaintenanceLogs?: boolean | User$MaintenanceLogsArgs<ExtArgs>
    NotificationRead?: boolean | User$NotificationReadArgs<ExtArgs>
    NotificationResponse?: boolean | User$NotificationResponseArgs<ExtArgs>
    PasswordResetTokens?: boolean | User$PasswordResetTokensArgs<ExtArgs>
    TimeSheets?: boolean | User$TimeSheetsArgs<ExtArgs>
    TimeSheetChanges?: boolean | User$TimeSheetChangesArgs<ExtArgs>
    topicSubscriptions?: boolean | User$topicSubscriptionsArgs<ExtArgs>
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
    UserSettings?: boolean | User$UserSettingsArgs<ExtArgs>
    Crews?: boolean | User$CrewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    signature?: boolean
    DOB?: boolean
    truckView?: boolean
    tascoView?: boolean
    laborView?: boolean
    mechanicView?: boolean
    permission?: boolean
    image?: boolean
    startDate?: boolean
    terminationDate?: boolean
    accountSetup?: boolean
    clockedIn?: boolean
    companyId?: boolean
    passwordResetTokenId?: boolean
    workTypeId?: boolean
    middleName?: boolean
    secondLastName?: boolean
    lastSeen?: boolean
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    signature?: boolean
    DOB?: boolean
    truckView?: boolean
    tascoView?: boolean
    laborView?: boolean
    mechanicView?: boolean
    permission?: boolean
    image?: boolean
    startDate?: boolean
    terminationDate?: boolean
    accountSetup?: boolean
    clockedIn?: boolean
    companyId?: boolean
    passwordResetTokenId?: boolean
    workTypeId?: boolean
    middleName?: boolean
    secondLastName?: boolean
    lastSeen?: boolean
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    signature?: boolean
    DOB?: boolean
    truckView?: boolean
    tascoView?: boolean
    laborView?: boolean
    mechanicView?: boolean
    permission?: boolean
    image?: boolean
    startDate?: boolean
    terminationDate?: boolean
    accountSetup?: boolean
    clockedIn?: boolean
    companyId?: boolean
    passwordResetTokenId?: boolean
    workTypeId?: boolean
    middleName?: boolean
    secondLastName?: boolean
    lastSeen?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstName" | "lastName" | "username" | "email" | "password" | "signature" | "DOB" | "truckView" | "tascoView" | "laborView" | "mechanicView" | "permission" | "image" | "startDate" | "terminationDate" | "accountSetup" | "clockedIn" | "companyId" | "passwordResetTokenId" | "workTypeId" | "middleName" | "secondLastName" | "lastSeen", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountSetupToken?: boolean | User$accountSetupTokenArgs<ExtArgs>
    Contact?: boolean | User$ContactArgs<ExtArgs>
    Equipment?: boolean | User$EquipmentArgs<ExtArgs>
    FCMToken?: boolean | User$FCMTokenArgs<ExtArgs>
    FormApprovals?: boolean | User$FormApprovalsArgs<ExtArgs>
    FormSubmissions?: boolean | User$FormSubmissionsArgs<ExtArgs>
    Jobsite?: boolean | User$JobsiteArgs<ExtArgs>
    MaintenanceLogs?: boolean | User$MaintenanceLogsArgs<ExtArgs>
    NotificationRead?: boolean | User$NotificationReadArgs<ExtArgs>
    NotificationResponse?: boolean | User$NotificationResponseArgs<ExtArgs>
    PasswordResetTokens?: boolean | User$PasswordResetTokensArgs<ExtArgs>
    TimeSheets?: boolean | User$TimeSheetsArgs<ExtArgs>
    TimeSheetChanges?: boolean | User$TimeSheetChangesArgs<ExtArgs>
    topicSubscriptions?: boolean | User$topicSubscriptionsArgs<ExtArgs>
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
    UserSettings?: boolean | User$UserSettingsArgs<ExtArgs>
    Crews?: boolean | User$CrewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accountSetupToken: Prisma.$AccountSetupTokenPayload<ExtArgs> | null
      Contact: Prisma.$ContactsPayload<ExtArgs> | null
      Equipment: Prisma.$EquipmentPayload<ExtArgs>[]
      FCMToken: Prisma.$FCMTokenPayload<ExtArgs>[]
      FormApprovals: Prisma.$FormApprovalPayload<ExtArgs>[]
      FormSubmissions: Prisma.$FormSubmissionPayload<ExtArgs>[]
      Jobsite: Prisma.$JobsitePayload<ExtArgs>[]
      MaintenanceLogs: Prisma.$MaintenanceLogPayload<ExtArgs>[]
      NotificationRead: Prisma.$NotificationReadPayload<ExtArgs>[]
      NotificationResponse: Prisma.$NotificationResponsePayload<ExtArgs>[]
      PasswordResetTokens: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
      TimeSheets: Prisma.$TimeSheetPayload<ExtArgs>[]
      TimeSheetChanges: Prisma.$TimeSheetChangeLogPayload<ExtArgs>[]
      topicSubscriptions: Prisma.$TopicSubscriptionPayload<ExtArgs>[]
      Company: Prisma.$CompanyPayload<ExtArgs>
      UserSettings: Prisma.$UserSettingsPayload<ExtArgs> | null
      Crews: Prisma.$CrewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstName: string
      lastName: string
      username: string
      email: string | null
      password: string
      signature: string | null
      DOB: Date | null
      truckView: boolean
      tascoView: boolean
      laborView: boolean
      mechanicView: boolean
      permission: $Enums.Permission
      image: string | null
      startDate: Date | null
      terminationDate: Date | null
      accountSetup: boolean
      clockedIn: boolean
      companyId: string
      passwordResetTokenId: string | null
      workTypeId: string | null
      middleName: string | null
      secondLastName: string | null
      lastSeen: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accountSetupToken<T extends User$accountSetupTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$accountSetupTokenArgs<ExtArgs>>): Prisma__AccountSetupTokenClient<$Result.GetResult<Prisma.$AccountSetupTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Contact<T extends User$ContactArgs<ExtArgs> = {}>(args?: Subset<T, User$ContactArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Equipment<T extends User$EquipmentArgs<ExtArgs> = {}>(args?: Subset<T, User$EquipmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FCMToken<T extends User$FCMTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$FCMTokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FCMTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FormApprovals<T extends User$FormApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$FormApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    FormSubmissions<T extends User$FormSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$FormSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Jobsite<T extends User$JobsiteArgs<ExtArgs> = {}>(args?: Subset<T, User$JobsiteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MaintenanceLogs<T extends User$MaintenanceLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$MaintenanceLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    NotificationRead<T extends User$NotificationReadArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationReadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    NotificationResponse<T extends User$NotificationResponseArgs<ExtArgs> = {}>(args?: Subset<T, User$NotificationResponseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    PasswordResetTokens<T extends User$PasswordResetTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$PasswordResetTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TimeSheets<T extends User$TimeSheetsArgs<ExtArgs> = {}>(args?: Subset<T, User$TimeSheetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSheetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TimeSheetChanges<T extends User$TimeSheetChangesArgs<ExtArgs> = {}>(args?: Subset<T, User$TimeSheetChangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeSheetChangeLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    topicSubscriptions<T extends User$topicSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, User$topicSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    UserSettings<T extends User$UserSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$UserSettingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Crews<T extends User$CrewsArgs<ExtArgs> = {}>(args?: Subset<T, User$CrewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CrewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly signature: FieldRef<"User", 'String'>
    readonly DOB: FieldRef<"User", 'DateTime'>
    readonly truckView: FieldRef<"User", 'Boolean'>
    readonly tascoView: FieldRef<"User", 'Boolean'>
    readonly laborView: FieldRef<"User", 'Boolean'>
    readonly mechanicView: FieldRef<"User", 'Boolean'>
    readonly permission: FieldRef<"User", 'Permission'>
    readonly image: FieldRef<"User", 'String'>
    readonly startDate: FieldRef<"User", 'DateTime'>
    readonly terminationDate: FieldRef<"User", 'DateTime'>
    readonly accountSetup: FieldRef<"User", 'Boolean'>
    readonly clockedIn: FieldRef<"User", 'Boolean'>
    readonly companyId: FieldRef<"User", 'String'>
    readonly passwordResetTokenId: FieldRef<"User", 'String'>
    readonly workTypeId: FieldRef<"User", 'String'>
    readonly middleName: FieldRef<"User", 'String'>
    readonly secondLastName: FieldRef<"User", 'String'>
    readonly lastSeen: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accountSetupToken
   */
  export type User$accountSetupTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountSetupToken
     */
    select?: AccountSetupTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountSetupToken
     */
    omit?: AccountSetupTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountSetupTokenInclude<ExtArgs> | null
    where?: AccountSetupTokenWhereInput
  }

  /**
   * User.Contact
   */
  export type User$ContactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    where?: ContactsWhereInput
  }

  /**
   * User.Equipment
   */
  export type User$EquipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * User.FCMToken
   */
  export type User$FCMTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FCMToken
     */
    select?: FCMTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FCMToken
     */
    omit?: FCMTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FCMTokenInclude<ExtArgs> | null
    where?: FCMTokenWhereInput
    orderBy?: FCMTokenOrderByWithRelationInput | FCMTokenOrderByWithRelationInput[]
    cursor?: FCMTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FCMTokenScalarFieldEnum | FCMTokenScalarFieldEnum[]
  }

  /**
   * User.FormApprovals
   */
  export type User$FormApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormApproval
     */
    select?: FormApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormApproval
     */
    omit?: FormApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormApprovalInclude<ExtArgs> | null
    where?: FormApprovalWhereInput
    orderBy?: FormApprovalOrderByWithRelationInput | FormApprovalOrderByWithRelationInput[]
    cursor?: FormApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormApprovalScalarFieldEnum | FormApprovalScalarFieldEnum[]
  }

  /**
   * User.FormSubmissions
   */
  export type User$FormSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormSubmission
     */
    select?: FormSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormSubmission
     */
    omit?: FormSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormSubmissionInclude<ExtArgs> | null
    where?: FormSubmissionWhereInput
    orderBy?: FormSubmissionOrderByWithRelationInput | FormSubmissionOrderByWithRelationInput[]
    cursor?: FormSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormSubmissionScalarFieldEnum | FormSubmissionScalarFieldEnum[]
  }

  /**
   * User.Jobsite
   */
  export type User$JobsiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobsite
     */
    select?: JobsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobsite
     */
    omit?: JobsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsiteInclude<ExtArgs> | null
    where?: JobsiteWhereInput
    orderBy?: JobsiteOrderByWithRelationInput | JobsiteOrderByWithRelationInput[]
    cursor?: JobsiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsiteScalarFieldEnum | JobsiteScalarFieldEnum[]
  }

  /**
   * User.MaintenanceLogs
   */
  export type User$MaintenanceLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceLog
     */
    select?: MaintenanceLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceLog
     */
    omit?: MaintenanceLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceLogInclude<ExtArgs> | null
    where?: MaintenanceLogWhereInput
    orderBy?: MaintenanceLogOrderByWithRelationInput | MaintenanceLogOrderByWithRelationInput[]
    cursor?: MaintenanceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceLogScalarFieldEnum | MaintenanceLogScalarFieldEnum[]
  }

  /**
   * User.NotificationRead
   */
  export type User$NotificationReadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    where?: NotificationReadWhereInput
    orderBy?: NotificationReadOrderByWithRelationInput | NotificationReadOrderByWithRelationInput[]
    cursor?: NotificationReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationReadScalarFieldEnum | NotificationReadScalarFieldEnum[]
  }

  /**
   * User.NotificationResponse
   */
  export type User$NotificationResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationResponse
     */
    select?: NotificationResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationResponse
     */
    omit?: NotificationResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationResponseInclude<ExtArgs> | null
    where?: NotificationResponseWhereInput
    orderBy?: NotificationResponseOrderByWithRelationInput | NotificationResponseOrderByWithRelationInput[]
    cursor?: NotificationResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationResponseScalarFieldEnum | NotificationResponseScalarFieldEnum[]
  }

  /**
   * User.PasswordResetTokens
   */
  export type User$PasswordResetTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User.TimeSheets
   */
  export type User$TimeSheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheet
     */
    select?: TimeSheetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheet
     */
    omit?: TimeSheetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetInclude<ExtArgs> | null
    where?: TimeSheetWhereInput
    orderBy?: TimeSheetOrderByWithRelationInput | TimeSheetOrderByWithRelationInput[]
    cursor?: TimeSheetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeSheetScalarFieldEnum | TimeSheetScalarFieldEnum[]
  }

  /**
   * User.TimeSheetChanges
   */
  export type User$TimeSheetChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeSheetChangeLog
     */
    select?: TimeSheetChangeLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TimeSheetChangeLog
     */
    omit?: TimeSheetChangeLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeSheetChangeLogInclude<ExtArgs> | null
    where?: TimeSheetChangeLogWhereInput
    orderBy?: TimeSheetChangeLogOrderByWithRelationInput | TimeSheetChangeLogOrderByWithRelationInput[]
    cursor?: TimeSheetChangeLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeSheetChangeLogScalarFieldEnum | TimeSheetChangeLogScalarFieldEnum[]
  }

  /**
   * User.topicSubscriptions
   */
  export type User$topicSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSubscription
     */
    select?: TopicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSubscription
     */
    omit?: TopicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicSubscriptionInclude<ExtArgs> | null
    where?: TopicSubscriptionWhereInput
    orderBy?: TopicSubscriptionOrderByWithRelationInput | TopicSubscriptionOrderByWithRelationInput[]
    cursor?: TopicSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TopicSubscriptionScalarFieldEnum | TopicSubscriptionScalarFieldEnum[]
  }

  /**
   * User.UserSettings
   */
  export type User$UserSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User.Crews
   */
  export type User$CrewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Crew
     */
    select?: CrewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Crew
     */
    omit?: CrewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CrewInclude<ExtArgs> | null
    where?: CrewWhereInput
    orderBy?: CrewOrderByWithRelationInput | CrewOrderByWithRelationInput[]
    cursor?: CrewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CrewScalarFieldEnum | CrewScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    language: string | null
    generalReminders: boolean | null
    personalReminders: boolean | null
    cameraAccess: boolean | null
    locationAccess: boolean | null
    cookiesAccess: boolean | null
    createdAt: Date | null
    lastUpdated: Date | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    language: string | null
    generalReminders: boolean | null
    personalReminders: boolean | null
    cameraAccess: boolean | null
    locationAccess: boolean | null
    cookiesAccess: boolean | null
    createdAt: Date | null
    lastUpdated: Date | null
  }

  export type UserSettingsCountAggregateOutputType = {
    id: number
    userId: number
    language: number
    generalReminders: number
    personalReminders: number
    cameraAccess: number
    locationAccess: number
    cookiesAccess: number
    createdAt: number
    lastUpdated: number
    _all: number
  }


  export type UserSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    language?: true
    generalReminders?: true
    personalReminders?: true
    cameraAccess?: true
    locationAccess?: true
    cookiesAccess?: true
    createdAt?: true
    lastUpdated?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    language?: true
    generalReminders?: true
    personalReminders?: true
    cameraAccess?: true
    locationAccess?: true
    cookiesAccess?: true
    createdAt?: true
    lastUpdated?: true
  }

  export type UserSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    language?: true
    generalReminders?: true
    personalReminders?: true
    cameraAccess?: true
    locationAccess?: true
    cookiesAccess?: true
    createdAt?: true
    lastUpdated?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    id: string
    userId: string
    language: string
    generalReminders: boolean
    personalReminders: boolean
    cameraAccess: boolean
    locationAccess: boolean
    cookiesAccess: boolean
    createdAt: Date
    lastUpdated: Date
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    language?: boolean
    generalReminders?: boolean
    personalReminders?: boolean
    cameraAccess?: boolean
    locationAccess?: boolean
    cookiesAccess?: boolean
    createdAt?: boolean
    lastUpdated?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    language?: boolean
    generalReminders?: boolean
    personalReminders?: boolean
    cameraAccess?: boolean
    locationAccess?: boolean
    cookiesAccess?: boolean
    createdAt?: boolean
    lastUpdated?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    language?: boolean
    generalReminders?: boolean
    personalReminders?: boolean
    cameraAccess?: boolean
    locationAccess?: boolean
    cookiesAccess?: boolean
    createdAt?: boolean
    lastUpdated?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    language?: boolean
    generalReminders?: boolean
    personalReminders?: boolean
    cameraAccess?: boolean
    locationAccess?: boolean
    cookiesAccess?: boolean
    createdAt?: boolean
    lastUpdated?: boolean
  }

  export type UserSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "language" | "generalReminders" | "personalReminders" | "cameraAccess" | "locationAccess" | "cookiesAccess" | "createdAt" | "lastUpdated", ExtArgs["result"]["userSettings"]>
  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      language: string
      generalReminders: boolean
      personalReminders: boolean
      cameraAccess: boolean
      locationAccess: boolean
      cookiesAccess: boolean
      createdAt: Date
      lastUpdated: Date
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingsCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings and returns the data updated in the database.
     * @param {UserSettingsUpdateManyAndReturnArgs} args - Arguments to update many UserSettings.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */
  interface UserSettingsFieldRefs {
    readonly id: FieldRef<"UserSettings", 'String'>
    readonly userId: FieldRef<"UserSettings", 'String'>
    readonly language: FieldRef<"UserSettings", 'String'>
    readonly generalReminders: FieldRef<"UserSettings", 'Boolean'>
    readonly personalReminders: FieldRef<"UserSettings", 'Boolean'>
    readonly cameraAccess: FieldRef<"UserSettings", 'Boolean'>
    readonly locationAccess: FieldRef<"UserSettings", 'Boolean'>
    readonly cookiesAccess: FieldRef<"UserSettings", 'Boolean'>
    readonly createdAt: FieldRef<"UserSettings", 'DateTime'>
    readonly lastUpdated: FieldRef<"UserSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSettings createManyAndReturn
   */
  export type UserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
  }

  /**
   * UserSettings updateManyAndReturn
   */
  export type UserSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to delete.
     */
    limit?: number
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model Contacts
   */

  export type AggregateContacts = {
    _count: ContactsCountAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  export type ContactsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    phoneNumber: string | null
    emergencyContact: string | null
    emergencyContactNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    phoneNumber: string | null
    emergencyContact: string | null
    emergencyContactNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactsCountAggregateOutputType = {
    id: number
    userId: number
    phoneNumber: number
    emergencyContact: number
    emergencyContactNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactsMinAggregateInputType = {
    id?: true
    userId?: true
    phoneNumber?: true
    emergencyContact?: true
    emergencyContactNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactsMaxAggregateInputType = {
    id?: true
    userId?: true
    phoneNumber?: true
    emergencyContact?: true
    emergencyContactNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactsCountAggregateInputType = {
    id?: true
    userId?: true
    phoneNumber?: true
    emergencyContact?: true
    emergencyContactNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to aggregate.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactsMaxAggregateInputType
  }

  export type GetContactsAggregateType<T extends ContactsAggregateArgs> = {
        [P in keyof T & keyof AggregateContacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContacts[P]>
      : GetScalarType<T[P], AggregateContacts[P]>
  }




  export type ContactsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactsWhereInput
    orderBy?: ContactsOrderByWithAggregationInput | ContactsOrderByWithAggregationInput[]
    by: ContactsScalarFieldEnum[] | ContactsScalarFieldEnum
    having?: ContactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactsCountAggregateInputType | true
    _min?: ContactsMinAggregateInputType
    _max?: ContactsMaxAggregateInputType
  }

  export type ContactsGroupByOutputType = {
    id: string
    userId: string
    phoneNumber: string | null
    emergencyContact: string | null
    emergencyContactNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: ContactsCountAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  type GetContactsGroupByPayload<T extends ContactsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactsGroupByOutputType[P]>
        }
      >
    >


  export type ContactsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    emergencyContact?: boolean
    emergencyContactNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contacts"]>

  export type ContactsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    emergencyContact?: boolean
    emergencyContactNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contacts"]>

  export type ContactsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    emergencyContact?: boolean
    emergencyContactNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contacts"]>

  export type ContactsSelectScalar = {
    id?: boolean
    userId?: boolean
    phoneNumber?: boolean
    emergencyContact?: boolean
    emergencyContactNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "phoneNumber" | "emergencyContact" | "emergencyContactNumber" | "createdAt" | "updatedAt", ExtArgs["result"]["contacts"]>
  export type ContactsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContactsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContactsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContactsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contacts"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      phoneNumber: string | null
      emergencyContact: string | null
      emergencyContactNumber: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contacts"]>
    composites: {}
  }

  type ContactsGetPayload<S extends boolean | null | undefined | ContactsDefaultArgs> = $Result.GetResult<Prisma.$ContactsPayload, S>

  type ContactsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactsCountAggregateInputType | true
    }

  export interface ContactsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contacts'], meta: { name: 'Contacts' } }
    /**
     * Find zero or one Contacts that matches the filter.
     * @param {ContactsFindUniqueArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactsFindUniqueArgs>(args: SelectSubset<T, ContactsFindUniqueArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contacts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactsFindUniqueOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactsFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsFindFirstArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactsFindFirstArgs>(args?: SelectSubset<T, ContactsFindFirstArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contacts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsFindFirstOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactsFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contacts.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contacts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactsWithIdOnly = await prisma.contacts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactsFindManyArgs>(args?: SelectSubset<T, ContactsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contacts.
     * @param {ContactsCreateArgs} args - Arguments to create a Contacts.
     * @example
     * // Create one Contacts
     * const Contacts = await prisma.contacts.create({
     *   data: {
     *     // ... data to create a Contacts
     *   }
     * })
     * 
     */
    create<T extends ContactsCreateArgs>(args: SelectSubset<T, ContactsCreateArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactsCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contacts = await prisma.contacts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactsCreateManyArgs>(args?: SelectSubset<T, ContactsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactsCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contacts = await prisma.contacts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactsWithIdOnly = await prisma.contacts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactsCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contacts.
     * @param {ContactsDeleteArgs} args - Arguments to delete one Contacts.
     * @example
     * // Delete one Contacts
     * const Contacts = await prisma.contacts.delete({
     *   where: {
     *     // ... filter to delete one Contacts
     *   }
     * })
     * 
     */
    delete<T extends ContactsDeleteArgs>(args: SelectSubset<T, ContactsDeleteArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contacts.
     * @param {ContactsUpdateArgs} args - Arguments to update one Contacts.
     * @example
     * // Update one Contacts
     * const contacts = await prisma.contacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactsUpdateArgs>(args: SelectSubset<T, ContactsUpdateArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactsDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactsDeleteManyArgs>(args?: SelectSubset<T, ContactsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contacts = await prisma.contacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactsUpdateManyArgs>(args: SelectSubset<T, ContactsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactsUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contacts = await prisma.contacts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactsWithIdOnly = await prisma.contacts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactsUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contacts.
     * @param {ContactsUpsertArgs} args - Arguments to update or create a Contacts.
     * @example
     * // Update or create a Contacts
     * const contacts = await prisma.contacts.upsert({
     *   create: {
     *     // ... data to create a Contacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contacts we want to update
     *   }
     * })
     */
    upsert<T extends ContactsUpsertArgs>(args: SelectSubset<T, ContactsUpsertArgs<ExtArgs>>): Prisma__ContactsClient<$Result.GetResult<Prisma.$ContactsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contacts.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactsCountArgs>(
      args?: Subset<T, ContactsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactsAggregateArgs>(args: Subset<T, ContactsAggregateArgs>): Prisma.PrismaPromise<GetContactsAggregateType<T>>

    /**
     * Group by Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactsGroupByArgs['orderBy'] }
        : { orderBy?: ContactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contacts model
   */
  readonly fields: ContactsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contacts model
   */
  interface ContactsFieldRefs {
    readonly id: FieldRef<"Contacts", 'String'>
    readonly userId: FieldRef<"Contacts", 'String'>
    readonly phoneNumber: FieldRef<"Contacts", 'String'>
    readonly emergencyContact: FieldRef<"Contacts", 'String'>
    readonly emergencyContactNumber: FieldRef<"Contacts", 'String'>
    readonly createdAt: FieldRef<"Contacts", 'DateTime'>
    readonly updatedAt: FieldRef<"Contacts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contacts findUnique
   */
  export type ContactsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where: ContactsWhereUniqueInput
  }

  /**
   * Contacts findUniqueOrThrow
   */
  export type ContactsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where: ContactsWhereUniqueInput
  }

  /**
   * Contacts findFirst
   */
  export type ContactsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * Contacts findFirstOrThrow
   */
  export type ContactsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * Contacts findMany
   */
  export type ContactsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactsOrderByWithRelationInput | ContactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * Contacts create
   */
  export type ContactsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * The data needed to create a Contacts.
     */
    data: XOR<ContactsCreateInput, ContactsUncheckedCreateInput>
  }

  /**
   * Contacts createMany
   */
  export type ContactsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactsCreateManyInput | ContactsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contacts createManyAndReturn
   */
  export type ContactsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactsCreateManyInput | ContactsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contacts update
   */
  export type ContactsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * The data needed to update a Contacts.
     */
    data: XOR<ContactsUpdateInput, ContactsUncheckedUpdateInput>
    /**
     * Choose, which Contacts to update.
     */
    where: ContactsWhereUniqueInput
  }

  /**
   * Contacts updateMany
   */
  export type ContactsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactsUpdateManyMutationInput, ContactsUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactsWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contacts updateManyAndReturn
   */
  export type ContactsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactsUpdateManyMutationInput, ContactsUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactsWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contacts upsert
   */
  export type ContactsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * The filter to search for the Contacts to update in case it exists.
     */
    where: ContactsWhereUniqueInput
    /**
     * In case the Contacts found by the `where` argument doesn't exist, create a new Contacts with this data.
     */
    create: XOR<ContactsCreateInput, ContactsUncheckedCreateInput>
    /**
     * In case the Contacts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactsUpdateInput, ContactsUncheckedUpdateInput>
  }

  /**
   * Contacts delete
   */
  export type ContactsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
    /**
     * Filter which Contacts to delete.
     */
    where: ContactsWhereUniqueInput
  }

  /**
   * Contacts deleteMany
   */
  export type ContactsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactsWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contacts without action
   */
  export type ContactsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contacts
     */
    select?: ContactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contacts
     */
    omit?: ContactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactsInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expiration: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expiration: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expiration: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expiration?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expiration?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expiration?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expiration: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expiration?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expiration?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expiration?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expiration?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "token" | "expiration", ExtArgs["result"]["passwordResetToken"]>
  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expiration: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly email: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expiration: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model AccountSetupToken
   */

  export type AggregateAccountSetupToken = {
    _count: AccountSetupTokenCountAggregateOutputType | null
    _min: AccountSetupTokenMinAggregateOutputType | null
    _max: AccountSetupTokenMaxAggregateOutputType | null
  }

  export type AccountSetupTokenMinAggregateOutputType = {
    id: string | null
    code: string | null
    userId: string | null
    expiresAt: Date | null
    used: boolean | null
  }

  export type AccountSetupTokenMaxAggregateOutputType = {
    id: string | null
    code: string | null
    userId: string | null
    expiresAt: Date | null
    used: boolean | null
  }

  export type AccountSetupTokenCountAggregateOutputType = {
    id: number
    code: number
    userId: number
    expiresAt: number
    used: number
    _all: number
  }


  export type AccountSetupTokenMinAggregateInputType = {
    id?: true
    code?: true
    userId?: true
    expiresAt?: true
    used?: true
  }

  export type AccountSetupTokenMaxAggregateInputType = {
    id?: true
    code?: true
    userId?: true
    expiresAt?: true
    used?: true
  }

  export type AccountSetupTokenCountAggregateInputType = {
    id?: true
    code?: true
    userId?: true
    expiresAt?: true
    used?: true
    _all?: true
  }

  export type AccountSetupTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountSetupToken to aggregate.
     */
    where?: AccountSetupTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountSetupTokens to fetch.
     */
    orderBy?: AccountSetupTokenOrderByWithRelationInput | AccountSetupTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountSetupTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountSetupTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountSetupTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountSetupTokens
    **/
    _count?: true | AccountSetupTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountSetupTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountSetupTokenMaxAggregateInputType
  }

  export type GetAccountSetupTokenAggregateType<T extends AccountSetupTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountSetupToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountSetupToken[P]>
      : GetScalarType<T[P], AggregateAccountSetupToken[P]>
  }




  export type AccountSetupTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountSetupTokenWhereInput
    orderBy?: AccountSetupTokenOrderByWithAggregationInput | AccountSetupTokenOrderByWithAggregationInput[]
    by: AccountSetupTokenScalarFieldEnum[] | AccountSetupTokenScalarFieldEnum
    having?: AccountSetupTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountSetupTokenCountAggregateInputType | true
    _min?: AccountSetupTokenMinAggregateInputType
    _max?: AccountSetupTokenMaxAggregateInputType
  }

  export type AccountSetupTokenGroupByOutputType = {
    id: string
    code: string
    userId: string
    expiresAt: Date
    used: boolean
    _count: AccountSetupTokenCountAggregateOutputType | null
    _min: AccountSetupTokenMinAggregateOutputType | null
    _max: AccountSetupTokenMaxAggregateOutputType | null
  }

  type GetAccountSetupTokenGroupByPayload<T extends AccountSetupTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountSetupTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountSetupTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountSetupTokenGroupByOutputType[P]>
            : GetScalarType<T[P], AccountSetupTokenGroupByOutputType[P]>
        }
      >
    >


  export type AccountSetupTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    userId?: boolean
    expiresAt?: boolean
    used?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountSetupToken"]>

  export type AccountSetupTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    userId?: boolean
    expiresAt?: boolean
    used?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountSetupToken"]>

  export type AccountSetupTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    userId?: boolean
    expiresAt?: boolean
    used?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountSetupToken"]>

  export type AccountSetupTokenSelectScalar = {
    id?: boolean
    code?: boolean
    userId?: boolean
    expiresAt?: boolean
    used?: boolean
  }

  export type AccountSetupTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "userId" | "expiresAt" | "used", ExtArgs["result"]["accountSetupToken"]>
  export type AccountSetupTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountSetupTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountSetupTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountSetupTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountSetupToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      userId: string
      expiresAt: Date
      used: boolean
    }, ExtArgs["result"]["accountSetupToken"]>
    composites: {}
  }

  type AccountSetupTokenGetPayload<S extends boolean | null | undefined | AccountSetupTokenDefaultArgs> = $Result.GetResult<Prisma.$AccountSetupTokenPayload, S>

  type AccountSetupTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountSetupTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountSetupTokenCountAggregateInputType | true
    }

  export interface AccountSetupTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountSetupToken'], meta: { name: 'AccountSetupToken' } }
    /**
     * Find zero or one AccountSetupToken that matches the filter.
     * @param {AccountSetupTokenFindUniqueArgs} args - Arguments to find a AccountSetupToken
     * @example
     * // Get one AccountSetupToken
     * const accountSetupToken = await prisma.accountSetupToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountSetupTokenFindUniqueArgs>(args: SelectSubset<T, AccountSetupTokenFindUniqueArgs<ExtArgs>>): Prisma__AccountSetupTokenClient<$Result.GetResult<Prisma.$AccountSetupTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccountSetupToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountSetupTokenFindUniqueOrThrowArgs} args - Arguments to find a AccountSetupToken
     * @example
     * // Get one AccountSetupToken
     * const accountSetupToken = await prisma.accountSetupToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountSetupTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountSetupTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountSetupTokenClient<$Result.GetResult<Prisma.$AccountSetupTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountSetupToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountSetupTokenFindFirstArgs} args - Arguments to find a AccountSetupToken
     * @example
     * // Get one AccountSetupToken
     * const accountSetupToken = await prisma.accountSetupToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountSetupTokenFindFirstArgs>(args?: SelectSubset<T, AccountSetupTokenFindFirstArgs<ExtArgs>>): Prisma__AccountSetupTokenClient<$Result.GetResult<Prisma.$AccountSetupTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountSetupToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountSetupTokenFindFirstOrThrowArgs} args - Arguments to find a AccountSetupToken
     * @example
     * // Get one AccountSetupToken
     * const accountSetupToken = await prisma.accountSetupToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountSetupTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountSetupTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountSetupTokenClient<$Result.GetResult<Prisma.$AccountSetupTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccountSetupTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountSetupTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountSetupTokens
     * const accountSetupTokens = await prisma.accountSetupToken.findMany()
     * 
     * // Get first 10 AccountSetupTokens
     * const accountSetupTokens = await prisma.accountSetupToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountSetupTokenWithIdOnly = await prisma.accountSetupToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountSetupTokenFindManyArgs>(args?: SelectSubset<T, AccountSetupTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountSetupTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccountSetupToken.
     * @param {AccountSetupTokenCreateArgs} args - Arguments to create a AccountSetupToken.
     * @example
     * // Create one AccountSetupToken
     * const AccountSetupToken = await prisma.accountSetupToken.create({
     *   data: {
     *     // ... data to create a AccountSetupToken
     *   }
     * })
     * 
     */
    create<T extends AccountSetupTokenCreateArgs>(args: SelectSubset<T, AccountSetupTokenCreateArgs<ExtArgs>>): Prisma__AccountSetupTokenClient<$Result.GetResult<Prisma.$AccountSetupTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccountSetupTokens.
     * @param {AccountSetupTokenCreateManyArgs} args - Arguments to create many AccountSetupTokens.
     * @example
     * // Create many AccountSetupTokens
     * const accountSetupToken = await prisma.accountSetupToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountSetupTokenCreateManyArgs>(args?: SelectSubset<T, AccountSetupTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccountSetupTokens and returns the data saved in the database.
     * @param {AccountSetupTokenCreateManyAndReturnArgs} args - Arguments to create many AccountSetupTokens.
     * @example
     * // Create many AccountSetupTokens
     * const accountSetupToken = await prisma.accountSetupToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccountSetupTokens and only return the `id`
     * const accountSetupTokenWithIdOnly = await prisma.accountSetupToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountSetupTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountSetupTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountSetupTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccountSetupToken.
     * @param {AccountSetupTokenDeleteArgs} args - Arguments to delete one AccountSetupToken.
     * @example
     * // Delete one AccountSetupToken
     * const AccountSetupToken = await prisma.accountSetupToken.delete({
     *   where: {
     *     // ... filter to delete one AccountSetupToken
     *   }
     * })
     * 
     */
    delete<T extends AccountSetupTokenDeleteArgs>(args: SelectSubset<T, AccountSetupTokenDeleteArgs<ExtArgs>>): Prisma__AccountSetupTokenClient<$Result.GetResult<Prisma.$AccountSetupTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccountSetupToken.
     * @param {AccountSetupTokenUpdateArgs} args - Arguments to update one AccountSetupToken.
     * @example
     * // Update one AccountSetupToken
     * const accountSetupToken = await prisma.accountSetupToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountSetupTokenUpdateArgs>(args: SelectSubset<T, AccountSetupTokenUpdateArgs<ExtArgs>>): Prisma__AccountSetupTokenClient<$Result.GetResult<Prisma.$AccountSetupTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccountSetupTokens.
     * @param {AccountSetupTokenDeleteManyArgs} args - Arguments to filter AccountSetupTokens to delete.
     * @example
     * // Delete a few AccountSetupTokens
     * const { count } = await prisma.accountSetupToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountSetupTokenDeleteManyArgs>(args?: SelectSubset<T, AccountSetupTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountSetupTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountSetupTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountSetupTokens
     * const accountSetupToken = await prisma.accountSetupToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountSetupTokenUpdateManyArgs>(args: SelectSubset<T, AccountSetupTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountSetupTokens and returns the data updated in the database.
     * @param {AccountSetupTokenUpdateManyAndReturnArgs} args - Arguments to update many AccountSetupTokens.
     * @example
     * // Update many AccountSetupTokens
     * const accountSetupToken = await prisma.accountSetupToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccountSetupTokens and only return the `id`
     * const accountSetupTokenWithIdOnly = await prisma.accountSetupToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountSetupTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountSetupTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountSetupTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccountSetupToken.
     * @param {AccountSetupTokenUpsertArgs} args - Arguments to update or create a AccountSetupToken.
     * @example
     * // Update or create a AccountSetupToken
     * const accountSetupToken = await prisma.accountSetupToken.upsert({
     *   create: {
     *     // ... data to create a AccountSetupToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountSetupToken we want to update
     *   }
     * })
     */
    upsert<T extends AccountSetupTokenUpsertArgs>(args: SelectSubset<T, AccountSetupTokenUpsertArgs<ExtArgs>>): Prisma__AccountSetupTokenClient<$Result.GetResult<Prisma.$AccountSetupTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccountSetupTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountSetupTokenCountArgs} args - Arguments to filter AccountSetupTokens to count.
     * @example
     * // Count the number of AccountSetupTokens
     * const count = await prisma.accountSetupToken.count({
     *   where: {
     *     // ... the filter for the AccountSetupTokens we want to count
     *   }
     * })
    **/
    count<T extends AccountSetupTokenCountArgs>(
      args?: Subset<T, AccountSetupTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountSetupTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountSetupToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountSetupTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountSetupTokenAggregateArgs>(args: Subset<T, AccountSetupTokenAggregateArgs>): Prisma.PrismaPromise<GetAccountSetupTokenAggregateType<T>>

    /**
     * Group by AccountSetupToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountSetupTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountSetupTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountSetupTokenGroupByArgs['orderBy'] }
        : { orderBy?: AccountSetupTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountSetupTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountSetupTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountSetupToken model
   */
  readonly fields: AccountSetupTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountSetupToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountSetupTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountSetupToken model
   */
  interface AccountSetupTokenFieldRefs {
    readonly id: FieldRef<"AccountSetupToken", 'String'>
    readonly code: FieldRef<"AccountSetupToken", 'String'>
    readonly userId: FieldRef<"AccountSetupToken", 'String'>
    readonly expiresAt: FieldRef<"AccountSetupToken", 'DateTime'>
    readonly used: FieldRef<"AccountSetupToken", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * AccountSetupToken findUnique
   */
  export type AccountSetupTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountSetupToken
     */
    select?: AccountSetupTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountSetupToken
     */
    omit?: AccountSetupTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountSetupTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccountSetupToken to fetch.
     */
    where: AccountSetupTokenWhereUniqueInput
  }

  /**
   * AccountSetupToken findUniqueOrThrow
   */
  export type AccountSetupTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountSetupToken
     */
    select?: AccountSetupTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountSetupToken
     */
    omit?: AccountSetupTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountSetupTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccountSetupToken to fetch.
     */
    where: AccountSetupTokenWhereUniqueInput
  }

  /**
   * AccountSetupToken findFirst
   */
  export type AccountSetupTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountSetupToken
     */
    select?: AccountSetupTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountSetupToken
     */
    omit?: AccountSetupTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountSetupTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccountSetupToken to fetch.
     */
    where?: AccountSetupTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountSetupTokens to fetch.
     */
    orderBy?: AccountSetupTokenOrderByWithRelationInput | AccountSetupTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountSetupTokens.
     */
    cursor?: AccountSetupTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountSetupTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountSetupTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountSetupTokens.
     */
    distinct?: AccountSetupTokenScalarFieldEnum | AccountSetupTokenScalarFieldEnum[]
  }

  /**
   * AccountSetupToken findFirstOrThrow
   */
  export type AccountSetupTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountSetupToken
     */
    select?: AccountSetupTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountSetupToken
     */
    omit?: AccountSetupTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountSetupTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccountSetupToken to fetch.
     */
    where?: AccountSetupTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountSetupTokens to fetch.
     */
    orderBy?: AccountSetupTokenOrderByWithRelationInput | AccountSetupTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountSetupTokens.
     */
    cursor?: AccountSetupTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountSetupTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountSetupTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountSetupTokens.
     */
    distinct?: AccountSetupTokenScalarFieldEnum | AccountSetupTokenScalarFieldEnum[]
  }

  /**
   * AccountSetupToken findMany
   */
  export type AccountSetupTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountSetupToken
     */
    select?: AccountSetupTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountSetupToken
     */
    omit?: AccountSetupTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountSetupTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccountSetupTokens to fetch.
     */
    where?: AccountSetupTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountSetupTokens to fetch.
     */
    orderBy?: AccountSetupTokenOrderByWithRelationInput | AccountSetupTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountSetupTokens.
     */
    cursor?: AccountSetupTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountSetupTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountSetupTokens.
     */
    skip?: number
    distinct?: AccountSetupTokenScalarFieldEnum | AccountSetupTokenScalarFieldEnum[]
  }

  /**
   * AccountSetupToken create
   */
  export type AccountSetupTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountSetupToken
     */
    select?: AccountSetupTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountSetupToken
     */
    omit?: AccountSetupTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountSetupTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountSetupToken.
     */
    data: XOR<AccountSetupTokenCreateInput, AccountSetupTokenUncheckedCreateInput>
  }

  /**
   * AccountSetupToken createMany
   */
  export type AccountSetupTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountSetupTokens.
     */
    data: AccountSetupTokenCreateManyInput | AccountSetupTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountSetupToken createManyAndReturn
   */
  export type AccountSetupTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountSetupToken
     */
    select?: AccountSetupTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccountSetupToken
     */
    omit?: AccountSetupTokenOmit<ExtArgs> | null
    /**
     * The data used to create many AccountSetupTokens.
     */
    data: AccountSetupTokenCreateManyInput | AccountSetupTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountSetupTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountSetupToken update
   */
  export type AccountSetupTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountSetupToken
     */
    select?: AccountSetupTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountSetupToken
     */
    omit?: AccountSetupTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountSetupTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountSetupToken.
     */
    data: XOR<AccountSetupTokenUpdateInput, AccountSetupTokenUncheckedUpdateInput>
    /**
     * Choose, which AccountSetupToken to update.
     */
    where: AccountSetupTokenWhereUniqueInput
  }

  /**
   * AccountSetupToken updateMany
   */
  export type AccountSetupTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountSetupTokens.
     */
    data: XOR<AccountSetupTokenUpdateManyMutationInput, AccountSetupTokenUncheckedUpdateManyInput>
    /**
     * Filter which AccountSetupTokens to update
     */
    where?: AccountSetupTokenWhereInput
    /**
     * Limit how many AccountSetupTokens to update.
     */
    limit?: number
  }

  /**
   * AccountSetupToken updateManyAndReturn
   */
  export type AccountSetupTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountSetupToken
     */
    select?: AccountSetupTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccountSetupToken
     */
    omit?: AccountSetupTokenOmit<ExtArgs> | null
    /**
     * The data used to update AccountSetupTokens.
     */
    data: XOR<AccountSetupTokenUpdateManyMutationInput, AccountSetupTokenUncheckedUpdateManyInput>
    /**
     * Filter which AccountSetupTokens to update
     */
    where?: AccountSetupTokenWhereInput
    /**
     * Limit how many AccountSetupTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountSetupTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountSetupToken upsert
   */
  export type AccountSetupTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountSetupToken
     */
    select?: AccountSetupTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountSetupToken
     */
    omit?: AccountSetupTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountSetupTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountSetupToken to update in case it exists.
     */
    where: AccountSetupTokenWhereUniqueInput
    /**
     * In case the AccountSetupToken found by the `where` argument doesn't exist, create a new AccountSetupToken with this data.
     */
    create: XOR<AccountSetupTokenCreateInput, AccountSetupTokenUncheckedCreateInput>
    /**
     * In case the AccountSetupToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountSetupTokenUpdateInput, AccountSetupTokenUncheckedUpdateInput>
  }

  /**
   * AccountSetupToken delete
   */
  export type AccountSetupTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountSetupToken
     */
    select?: AccountSetupTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountSetupToken
     */
    omit?: AccountSetupTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountSetupTokenInclude<ExtArgs> | null
    /**
     * Filter which AccountSetupToken to delete.
     */
    where: AccountSetupTokenWhereUniqueInput
  }

  /**
   * AccountSetupToken deleteMany
   */
  export type AccountSetupTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountSetupTokens to delete
     */
    where?: AccountSetupTokenWhereInput
    /**
     * Limit how many AccountSetupTokens to delete.
     */
    limit?: number
  }

  /**
   * AccountSetupToken without action
   */
  export type AccountSetupTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountSetupToken
     */
    select?: AccountSetupTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountSetupToken
     */
    omit?: AccountSetupTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountSetupTokenInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    street: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    street: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    country: string | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    street: number
    city: number
    state: number
    zipCode: number
    country: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    street?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    street?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    street?: true
    city?: true
    state?: true
    zipCode?: true
    country?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: string
    street: string
    city: string
    state: string
    zipCode: string
    country: string
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
    Company?: boolean | Address$CompanyArgs<ExtArgs>
    Jobsite?: boolean | Address$JobsiteArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    country?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "street" | "city" | "state" | "zipCode" | "country", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Company?: boolean | Address$CompanyArgs<ExtArgs>
    Jobsite?: boolean | Address$JobsiteArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      Company: Prisma.$CompanyPayload<ExtArgs>[]
      Jobsite: Prisma.$JobsitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      street: string
      city: string
      state: string
      zipCode: string
      country: string
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Company<T extends Address$CompanyArgs<ExtArgs> = {}>(args?: Subset<T, Address$CompanyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Jobsite<T extends Address$JobsiteArgs<ExtArgs> = {}>(args?: Subset<T, Address$JobsiteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'String'>
    readonly street: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly state: FieldRef<"Address", 'String'>
    readonly zipCode: FieldRef<"Address", 'String'>
    readonly country: FieldRef<"Address", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address.Company
   */
  export type Address$CompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    cursor?: CompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Address.Jobsite
   */
  export type Address$JobsiteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobsite
     */
    select?: JobsiteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Jobsite
     */
    omit?: JobsiteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsiteInclude<ExtArgs> | null
    where?: JobsiteWhereInput
    orderBy?: JobsiteOrderByWithRelationInput | JobsiteOrderByWithRelationInput[]
    cursor?: JobsiteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsiteScalarFieldEnum | JobsiteScalarFieldEnum[]
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model FCMToken
   */

  export type AggregateFCMToken = {
    _count: FCMTokenCountAggregateOutputType | null
    _min: FCMTokenMinAggregateOutputType | null
    _max: FCMTokenMaxAggregateOutputType | null
  }

  export type FCMTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    platform: string | null
    lastUsedAt: Date | null
    isValid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FCMTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    platform: string | null
    lastUsedAt: Date | null
    isValid: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FCMTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    platform: number
    lastUsedAt: number
    isValid: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FCMTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    platform?: true
    lastUsedAt?: true
    isValid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FCMTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    platform?: true
    lastUsedAt?: true
    isValid?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FCMTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    platform?: true
    lastUsedAt?: true
    isValid?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FCMTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FCMToken to aggregate.
     */
    where?: FCMTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FCMTokens to fetch.
     */
    orderBy?: FCMTokenOrderByWithRelationInput | FCMTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FCMTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FCMTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FCMTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FCMTokens
    **/
    _count?: true | FCMTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FCMTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FCMTokenMaxAggregateInputType
  }

  export type GetFCMTokenAggregateType<T extends FCMTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateFCMToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFCMToken[P]>
      : GetScalarType<T[P], AggregateFCMToken[P]>
  }




  export type FCMTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FCMTokenWhereInput
    orderBy?: FCMTokenOrderByWithAggregationInput | FCMTokenOrderByWithAggregationInput[]
    by: FCMTokenScalarFieldEnum[] | FCMTokenScalarFieldEnum
    having?: FCMTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FCMTokenCountAggregateInputType | true
    _min?: FCMTokenMinAggregateInputType
    _max?: FCMTokenMaxAggregateInputType
  }

  export type FCMTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    platform: string | null
    lastUsedAt: Date | null
    isValid: boolean
    createdAt: Date
    updatedAt: Date
    _count: FCMTokenCountAggregateOutputType | null
    _min: FCMTokenMinAggregateOutputType | null
    _max: FCMTokenMaxAggregateOutputType | null
  }

  type GetFCMTokenGroupByPayload<T extends FCMTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FCMTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FCMTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FCMTokenGroupByOutputType[P]>
            : GetScalarType<T[P], FCMTokenGroupByOutputType[P]>
        }
      >
    >


  export type FCMTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    platform?: boolean
    lastUsedAt?: boolean
    isValid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fCMToken"]>

  export type FCMTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    platform?: boolean
    lastUsedAt?: boolean
    isValid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fCMToken"]>

  export type FCMTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    platform?: boolean
    lastUsedAt?: boolean
    isValid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fCMToken"]>

  export type FCMTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    platform?: boolean
    lastUsedAt?: boolean
    isValid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FCMTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "platform" | "lastUsedAt" | "isValid" | "createdAt" | "updatedAt", ExtArgs["result"]["fCMToken"]>
  export type FCMTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FCMTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FCMTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FCMTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FCMToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      platform: string | null
      lastUsedAt: Date | null
      isValid: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fCMToken"]>
    composites: {}
  }

  type FCMTokenGetPayload<S extends boolean | null | undefined | FCMTokenDefaultArgs> = $Result.GetResult<Prisma.$FCMTokenPayload, S>

  type FCMTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FCMTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FCMTokenCountAggregateInputType | true
    }

  export interface FCMTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FCMToken'], meta: { name: 'FCMToken' } }
    /**
     * Find zero or one FCMToken that matches the filter.
     * @param {FCMTokenFindUniqueArgs} args - Arguments to find a FCMToken
     * @example
     * // Get one FCMToken
     * const fCMToken = await prisma.fCMToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FCMTokenFindUniqueArgs>(args: SelectSubset<T, FCMTokenFindUniqueArgs<ExtArgs>>): Prisma__FCMTokenClient<$Result.GetResult<Prisma.$FCMTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FCMToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FCMTokenFindUniqueOrThrowArgs} args - Arguments to find a FCMToken
     * @example
     * // Get one FCMToken
     * const fCMToken = await prisma.fCMToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FCMTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, FCMTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FCMTokenClient<$Result.GetResult<Prisma.$FCMTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FCMToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FCMTokenFindFirstArgs} args - Arguments to find a FCMToken
     * @example
     * // Get one FCMToken
     * const fCMToken = await prisma.fCMToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FCMTokenFindFirstArgs>(args?: SelectSubset<T, FCMTokenFindFirstArgs<ExtArgs>>): Prisma__FCMTokenClient<$Result.GetResult<Prisma.$FCMTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FCMToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FCMTokenFindFirstOrThrowArgs} args - Arguments to find a FCMToken
     * @example
     * // Get one FCMToken
     * const fCMToken = await prisma.fCMToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FCMTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, FCMTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__FCMTokenClient<$Result.GetResult<Prisma.$FCMTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FCMTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FCMTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FCMTokens
     * const fCMTokens = await prisma.fCMToken.findMany()
     * 
     * // Get first 10 FCMTokens
     * const fCMTokens = await prisma.fCMToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fCMTokenWithIdOnly = await prisma.fCMToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FCMTokenFindManyArgs>(args?: SelectSubset<T, FCMTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FCMTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FCMToken.
     * @param {FCMTokenCreateArgs} args - Arguments to create a FCMToken.
     * @example
     * // Create one FCMToken
     * const FCMToken = await prisma.fCMToken.create({
     *   data: {
     *     // ... data to create a FCMToken
     *   }
     * })
     * 
     */
    create<T extends FCMTokenCreateArgs>(args: SelectSubset<T, FCMTokenCreateArgs<ExtArgs>>): Prisma__FCMTokenClient<$Result.GetResult<Prisma.$FCMTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FCMTokens.
     * @param {FCMTokenCreateManyArgs} args - Arguments to create many FCMTokens.
     * @example
     * // Create many FCMTokens
     * const fCMToken = await prisma.fCMToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FCMTokenCreateManyArgs>(args?: SelectSubset<T, FCMTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FCMTokens and returns the data saved in the database.
     * @param {FCMTokenCreateManyAndReturnArgs} args - Arguments to create many FCMTokens.
     * @example
     * // Create many FCMTokens
     * const fCMToken = await prisma.fCMToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FCMTokens and only return the `id`
     * const fCMTokenWithIdOnly = await prisma.fCMToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FCMTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, FCMTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FCMTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FCMToken.
     * @param {FCMTokenDeleteArgs} args - Arguments to delete one FCMToken.
     * @example
     * // Delete one FCMToken
     * const FCMToken = await prisma.fCMToken.delete({
     *   where: {
     *     // ... filter to delete one FCMToken
     *   }
     * })
     * 
     */
    delete<T extends FCMTokenDeleteArgs>(args: SelectSubset<T, FCMTokenDeleteArgs<ExtArgs>>): Prisma__FCMTokenClient<$Result.GetResult<Prisma.$FCMTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FCMToken.
     * @param {FCMTokenUpdateArgs} args - Arguments to update one FCMToken.
     * @example
     * // Update one FCMToken
     * const fCMToken = await prisma.fCMToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FCMTokenUpdateArgs>(args: SelectSubset<T, FCMTokenUpdateArgs<ExtArgs>>): Prisma__FCMTokenClient<$Result.GetResult<Prisma.$FCMTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FCMTokens.
     * @param {FCMTokenDeleteManyArgs} args - Arguments to filter FCMTokens to delete.
     * @example
     * // Delete a few FCMTokens
     * const { count } = await prisma.fCMToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FCMTokenDeleteManyArgs>(args?: SelectSubset<T, FCMTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FCMTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FCMTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FCMTokens
     * const fCMToken = await prisma.fCMToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FCMTokenUpdateManyArgs>(args: SelectSubset<T, FCMTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FCMTokens and returns the data updated in the database.
     * @param {FCMTokenUpdateManyAndReturnArgs} args - Arguments to update many FCMTokens.
     * @example
     * // Update many FCMTokens
     * const fCMToken = await prisma.fCMToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FCMTokens and only return the `id`
     * const fCMTokenWithIdOnly = await prisma.fCMToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FCMTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, FCMTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FCMTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FCMToken.
     * @param {FCMTokenUpsertArgs} args - Arguments to update or create a FCMToken.
     * @example
     * // Update or create a FCMToken
     * const fCMToken = await prisma.fCMToken.upsert({
     *   create: {
     *     // ... data to create a FCMToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FCMToken we want to update
     *   }
     * })
     */
    upsert<T extends FCMTokenUpsertArgs>(args: SelectSubset<T, FCMTokenUpsertArgs<ExtArgs>>): Prisma__FCMTokenClient<$Result.GetResult<Prisma.$FCMTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FCMTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FCMTokenCountArgs} args - Arguments to filter FCMTokens to count.
     * @example
     * // Count the number of FCMTokens
     * const count = await prisma.fCMToken.count({
     *   where: {
     *     // ... the filter for the FCMTokens we want to count
     *   }
     * })
    **/
    count<T extends FCMTokenCountArgs>(
      args?: Subset<T, FCMTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FCMTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FCMToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FCMTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FCMTokenAggregateArgs>(args: Subset<T, FCMTokenAggregateArgs>): Prisma.PrismaPromise<GetFCMTokenAggregateType<T>>

    /**
     * Group by FCMToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FCMTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FCMTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FCMTokenGroupByArgs['orderBy'] }
        : { orderBy?: FCMTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FCMTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFCMTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FCMToken model
   */
  readonly fields: FCMTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FCMToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FCMTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FCMToken model
   */
  interface FCMTokenFieldRefs {
    readonly id: FieldRef<"FCMToken", 'String'>
    readonly token: FieldRef<"FCMToken", 'String'>
    readonly userId: FieldRef<"FCMToken", 'String'>
    readonly platform: FieldRef<"FCMToken", 'String'>
    readonly lastUsedAt: FieldRef<"FCMToken", 'DateTime'>
    readonly isValid: FieldRef<"FCMToken", 'Boolean'>
    readonly createdAt: FieldRef<"FCMToken", 'DateTime'>
    readonly updatedAt: FieldRef<"FCMToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FCMToken findUnique
   */
  export type FCMTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FCMToken
     */
    select?: FCMTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FCMToken
     */
    omit?: FCMTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FCMTokenInclude<ExtArgs> | null
    /**
     * Filter, which FCMToken to fetch.
     */
    where: FCMTokenWhereUniqueInput
  }

  /**
   * FCMToken findUniqueOrThrow
   */
  export type FCMTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FCMToken
     */
    select?: FCMTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FCMToken
     */
    omit?: FCMTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FCMTokenInclude<ExtArgs> | null
    /**
     * Filter, which FCMToken to fetch.
     */
    where: FCMTokenWhereUniqueInput
  }

  /**
   * FCMToken findFirst
   */
  export type FCMTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FCMToken
     */
    select?: FCMTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FCMToken
     */
    omit?: FCMTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FCMTokenInclude<ExtArgs> | null
    /**
     * Filter, which FCMToken to fetch.
     */
    where?: FCMTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FCMTokens to fetch.
     */
    orderBy?: FCMTokenOrderByWithRelationInput | FCMTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FCMTokens.
     */
    cursor?: FCMTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FCMTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FCMTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FCMTokens.
     */
    distinct?: FCMTokenScalarFieldEnum | FCMTokenScalarFieldEnum[]
  }

  /**
   * FCMToken findFirstOrThrow
   */
  export type FCMTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FCMToken
     */
    select?: FCMTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FCMToken
     */
    omit?: FCMTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FCMTokenInclude<ExtArgs> | null
    /**
     * Filter, which FCMToken to fetch.
     */
    where?: FCMTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FCMTokens to fetch.
     */
    orderBy?: FCMTokenOrderByWithRelationInput | FCMTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FCMTokens.
     */
    cursor?: FCMTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FCMTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FCMTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FCMTokens.
     */
    distinct?: FCMTokenScalarFieldEnum | FCMTokenScalarFieldEnum[]
  }

  /**
   * FCMToken findMany
   */
  export type FCMTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FCMToken
     */
    select?: FCMTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FCMToken
     */
    omit?: FCMTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FCMTokenInclude<ExtArgs> | null
    /**
     * Filter, which FCMTokens to fetch.
     */
    where?: FCMTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FCMTokens to fetch.
     */
    orderBy?: FCMTokenOrderByWithRelationInput | FCMTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FCMTokens.
     */
    cursor?: FCMTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FCMTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FCMTokens.
     */
    skip?: number
    distinct?: FCMTokenScalarFieldEnum | FCMTokenScalarFieldEnum[]
  }

  /**
   * FCMToken create
   */
  export type FCMTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FCMToken
     */
    select?: FCMTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FCMToken
     */
    omit?: FCMTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FCMTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a FCMToken.
     */
    data: XOR<FCMTokenCreateInput, FCMTokenUncheckedCreateInput>
  }

  /**
   * FCMToken createMany
   */
  export type FCMTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FCMTokens.
     */
    data: FCMTokenCreateManyInput | FCMTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FCMToken createManyAndReturn
   */
  export type FCMTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FCMToken
     */
    select?: FCMTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FCMToken
     */
    omit?: FCMTokenOmit<ExtArgs> | null
    /**
     * The data used to create many FCMTokens.
     */
    data: FCMTokenCreateManyInput | FCMTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FCMTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FCMToken update
   */
  export type FCMTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FCMToken
     */
    select?: FCMTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FCMToken
     */
    omit?: FCMTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FCMTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a FCMToken.
     */
    data: XOR<FCMTokenUpdateInput, FCMTokenUncheckedUpdateInput>
    /**
     * Choose, which FCMToken to update.
     */
    where: FCMTokenWhereUniqueInput
  }

  /**
   * FCMToken updateMany
   */
  export type FCMTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FCMTokens.
     */
    data: XOR<FCMTokenUpdateManyMutationInput, FCMTokenUncheckedUpdateManyInput>
    /**
     * Filter which FCMTokens to update
     */
    where?: FCMTokenWhereInput
    /**
     * Limit how many FCMTokens to update.
     */
    limit?: number
  }

  /**
   * FCMToken updateManyAndReturn
   */
  export type FCMTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FCMToken
     */
    select?: FCMTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FCMToken
     */
    omit?: FCMTokenOmit<ExtArgs> | null
    /**
     * The data used to update FCMTokens.
     */
    data: XOR<FCMTokenUpdateManyMutationInput, FCMTokenUncheckedUpdateManyInput>
    /**
     * Filter which FCMTokens to update
     */
    where?: FCMTokenWhereInput
    /**
     * Limit how many FCMTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FCMTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FCMToken upsert
   */
  export type FCMTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FCMToken
     */
    select?: FCMTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FCMToken
     */
    omit?: FCMTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FCMTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the FCMToken to update in case it exists.
     */
    where: FCMTokenWhereUniqueInput
    /**
     * In case the FCMToken found by the `where` argument doesn't exist, create a new FCMToken with this data.
     */
    create: XOR<FCMTokenCreateInput, FCMTokenUncheckedCreateInput>
    /**
     * In case the FCMToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FCMTokenUpdateInput, FCMTokenUncheckedUpdateInput>
  }

  /**
   * FCMToken delete
   */
  export type FCMTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FCMToken
     */
    select?: FCMTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FCMToken
     */
    omit?: FCMTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FCMTokenInclude<ExtArgs> | null
    /**
     * Filter which FCMToken to delete.
     */
    where: FCMTokenWhereUniqueInput
  }

  /**
   * FCMToken deleteMany
   */
  export type FCMTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FCMTokens to delete
     */
    where?: FCMTokenWhereInput
    /**
     * Limit how many FCMTokens to delete.
     */
    limit?: number
  }

  /**
   * FCMToken without action
   */
  export type FCMTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FCMToken
     */
    select?: FCMTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FCMToken
     */
    omit?: FCMTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FCMTokenInclude<ExtArgs> | null
  }


  /**
   * Model TopicSubscription
   */

  export type AggregateTopicSubscription = {
    _count: TopicSubscriptionCountAggregateOutputType | null
    _min: TopicSubscriptionMinAggregateOutputType | null
    _max: TopicSubscriptionMaxAggregateOutputType | null
  }

  export type TopicSubscriptionMinAggregateOutputType = {
    id: string | null
    topic: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type TopicSubscriptionMaxAggregateOutputType = {
    id: string | null
    topic: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type TopicSubscriptionCountAggregateOutputType = {
    id: number
    topic: number
    createdAt: number
    userId: number
    _all: number
  }


  export type TopicSubscriptionMinAggregateInputType = {
    id?: true
    topic?: true
    createdAt?: true
    userId?: true
  }

  export type TopicSubscriptionMaxAggregateInputType = {
    id?: true
    topic?: true
    createdAt?: true
    userId?: true
  }

  export type TopicSubscriptionCountAggregateInputType = {
    id?: true
    topic?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type TopicSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TopicSubscription to aggregate.
     */
    where?: TopicSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicSubscriptions to fetch.
     */
    orderBy?: TopicSubscriptionOrderByWithRelationInput | TopicSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TopicSubscriptions
    **/
    _count?: true | TopicSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicSubscriptionMaxAggregateInputType
  }

  export type GetTopicSubscriptionAggregateType<T extends TopicSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateTopicSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopicSubscription[P]>
      : GetScalarType<T[P], AggregateTopicSubscription[P]>
  }




  export type TopicSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicSubscriptionWhereInput
    orderBy?: TopicSubscriptionOrderByWithAggregationInput | TopicSubscriptionOrderByWithAggregationInput[]
    by: TopicSubscriptionScalarFieldEnum[] | TopicSubscriptionScalarFieldEnum
    having?: TopicSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicSubscriptionCountAggregateInputType | true
    _min?: TopicSubscriptionMinAggregateInputType
    _max?: TopicSubscriptionMaxAggregateInputType
  }

  export type TopicSubscriptionGroupByOutputType = {
    id: string
    topic: string
    createdAt: Date
    userId: string
    _count: TopicSubscriptionCountAggregateOutputType | null
    _min: TopicSubscriptionMinAggregateOutputType | null
    _max: TopicSubscriptionMaxAggregateOutputType | null
  }

  type GetTopicSubscriptionGroupByPayload<T extends TopicSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], TopicSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type TopicSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topicSubscription"]>

  export type TopicSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topicSubscription"]>

  export type TopicSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topic?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topicSubscription"]>

  export type TopicSubscriptionSelectScalar = {
    id?: boolean
    topic?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type TopicSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "topic" | "createdAt" | "userId", ExtArgs["result"]["topicSubscription"]>
  export type TopicSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TopicSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TopicSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TopicSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TopicSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      topic: string
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["topicSubscription"]>
    composites: {}
  }

  type TopicSubscriptionGetPayload<S extends boolean | null | undefined | TopicSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$TopicSubscriptionPayload, S>

  type TopicSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TopicSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TopicSubscriptionCountAggregateInputType | true
    }

  export interface TopicSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TopicSubscription'], meta: { name: 'TopicSubscription' } }
    /**
     * Find zero or one TopicSubscription that matches the filter.
     * @param {TopicSubscriptionFindUniqueArgs} args - Arguments to find a TopicSubscription
     * @example
     * // Get one TopicSubscription
     * const topicSubscription = await prisma.topicSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicSubscriptionFindUniqueArgs>(args: SelectSubset<T, TopicSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__TopicSubscriptionClient<$Result.GetResult<Prisma.$TopicSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TopicSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a TopicSubscription
     * @example
     * // Get one TopicSubscription
     * const topicSubscription = await prisma.topicSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicSubscriptionClient<$Result.GetResult<Prisma.$TopicSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TopicSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicSubscriptionFindFirstArgs} args - Arguments to find a TopicSubscription
     * @example
     * // Get one TopicSubscription
     * const topicSubscription = await prisma.topicSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicSubscriptionFindFirstArgs>(args?: SelectSubset<T, TopicSubscriptionFindFirstArgs<ExtArgs>>): Prisma__TopicSubscriptionClient<$Result.GetResult<Prisma.$TopicSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TopicSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicSubscriptionFindFirstOrThrowArgs} args - Arguments to find a TopicSubscription
     * @example
     * // Get one TopicSubscription
     * const topicSubscription = await prisma.topicSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicSubscriptionClient<$Result.GetResult<Prisma.$TopicSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TopicSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TopicSubscriptions
     * const topicSubscriptions = await prisma.topicSubscription.findMany()
     * 
     * // Get first 10 TopicSubscriptions
     * const topicSubscriptions = await prisma.topicSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicSubscriptionWithIdOnly = await prisma.topicSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicSubscriptionFindManyArgs>(args?: SelectSubset<T, TopicSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TopicSubscription.
     * @param {TopicSubscriptionCreateArgs} args - Arguments to create a TopicSubscription.
     * @example
     * // Create one TopicSubscription
     * const TopicSubscription = await prisma.topicSubscription.create({
     *   data: {
     *     // ... data to create a TopicSubscription
     *   }
     * })
     * 
     */
    create<T extends TopicSubscriptionCreateArgs>(args: SelectSubset<T, TopicSubscriptionCreateArgs<ExtArgs>>): Prisma__TopicSubscriptionClient<$Result.GetResult<Prisma.$TopicSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TopicSubscriptions.
     * @param {TopicSubscriptionCreateManyArgs} args - Arguments to create many TopicSubscriptions.
     * @example
     * // Create many TopicSubscriptions
     * const topicSubscription = await prisma.topicSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicSubscriptionCreateManyArgs>(args?: SelectSubset<T, TopicSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TopicSubscriptions and returns the data saved in the database.
     * @param {TopicSubscriptionCreateManyAndReturnArgs} args - Arguments to create many TopicSubscriptions.
     * @example
     * // Create many TopicSubscriptions
     * const topicSubscription = await prisma.topicSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TopicSubscriptions and only return the `id`
     * const topicSubscriptionWithIdOnly = await prisma.topicSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TopicSubscription.
     * @param {TopicSubscriptionDeleteArgs} args - Arguments to delete one TopicSubscription.
     * @example
     * // Delete one TopicSubscription
     * const TopicSubscription = await prisma.topicSubscription.delete({
     *   where: {
     *     // ... filter to delete one TopicSubscription
     *   }
     * })
     * 
     */
    delete<T extends TopicSubscriptionDeleteArgs>(args: SelectSubset<T, TopicSubscriptionDeleteArgs<ExtArgs>>): Prisma__TopicSubscriptionClient<$Result.GetResult<Prisma.$TopicSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TopicSubscription.
     * @param {TopicSubscriptionUpdateArgs} args - Arguments to update one TopicSubscription.
     * @example
     * // Update one TopicSubscription
     * const topicSubscription = await prisma.topicSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicSubscriptionUpdateArgs>(args: SelectSubset<T, TopicSubscriptionUpdateArgs<ExtArgs>>): Prisma__TopicSubscriptionClient<$Result.GetResult<Prisma.$TopicSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TopicSubscriptions.
     * @param {TopicSubscriptionDeleteManyArgs} args - Arguments to filter TopicSubscriptions to delete.
     * @example
     * // Delete a few TopicSubscriptions
     * const { count } = await prisma.topicSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicSubscriptionDeleteManyArgs>(args?: SelectSubset<T, TopicSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TopicSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TopicSubscriptions
     * const topicSubscription = await prisma.topicSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicSubscriptionUpdateManyArgs>(args: SelectSubset<T, TopicSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TopicSubscriptions and returns the data updated in the database.
     * @param {TopicSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many TopicSubscriptions.
     * @example
     * // Update many TopicSubscriptions
     * const topicSubscription = await prisma.topicSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TopicSubscriptions and only return the `id`
     * const topicSubscriptionWithIdOnly = await prisma.topicSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TopicSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, TopicSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TopicSubscription.
     * @param {TopicSubscriptionUpsertArgs} args - Arguments to update or create a TopicSubscription.
     * @example
     * // Update or create a TopicSubscription
     * const topicSubscription = await prisma.topicSubscription.upsert({
     *   create: {
     *     // ... data to create a TopicSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TopicSubscription we want to update
     *   }
     * })
     */
    upsert<T extends TopicSubscriptionUpsertArgs>(args: SelectSubset<T, TopicSubscriptionUpsertArgs<ExtArgs>>): Prisma__TopicSubscriptionClient<$Result.GetResult<Prisma.$TopicSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TopicSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicSubscriptionCountArgs} args - Arguments to filter TopicSubscriptions to count.
     * @example
     * // Count the number of TopicSubscriptions
     * const count = await prisma.topicSubscription.count({
     *   where: {
     *     // ... the filter for the TopicSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends TopicSubscriptionCountArgs>(
      args?: Subset<T, TopicSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TopicSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicSubscriptionAggregateArgs>(args: Subset<T, TopicSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetTopicSubscriptionAggregateType<T>>

    /**
     * Group by TopicSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: TopicSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TopicSubscription model
   */
  readonly fields: TopicSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TopicSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TopicSubscription model
   */
  interface TopicSubscriptionFieldRefs {
    readonly id: FieldRef<"TopicSubscription", 'String'>
    readonly topic: FieldRef<"TopicSubscription", 'String'>
    readonly createdAt: FieldRef<"TopicSubscription", 'DateTime'>
    readonly userId: FieldRef<"TopicSubscription", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TopicSubscription findUnique
   */
  export type TopicSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSubscription
     */
    select?: TopicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSubscription
     */
    omit?: TopicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which TopicSubscription to fetch.
     */
    where: TopicSubscriptionWhereUniqueInput
  }

  /**
   * TopicSubscription findUniqueOrThrow
   */
  export type TopicSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSubscription
     */
    select?: TopicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSubscription
     */
    omit?: TopicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which TopicSubscription to fetch.
     */
    where: TopicSubscriptionWhereUniqueInput
  }

  /**
   * TopicSubscription findFirst
   */
  export type TopicSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSubscription
     */
    select?: TopicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSubscription
     */
    omit?: TopicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which TopicSubscription to fetch.
     */
    where?: TopicSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicSubscriptions to fetch.
     */
    orderBy?: TopicSubscriptionOrderByWithRelationInput | TopicSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopicSubscriptions.
     */
    cursor?: TopicSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopicSubscriptions.
     */
    distinct?: TopicSubscriptionScalarFieldEnum | TopicSubscriptionScalarFieldEnum[]
  }

  /**
   * TopicSubscription findFirstOrThrow
   */
  export type TopicSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSubscription
     */
    select?: TopicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSubscription
     */
    omit?: TopicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which TopicSubscription to fetch.
     */
    where?: TopicSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicSubscriptions to fetch.
     */
    orderBy?: TopicSubscriptionOrderByWithRelationInput | TopicSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TopicSubscriptions.
     */
    cursor?: TopicSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TopicSubscriptions.
     */
    distinct?: TopicSubscriptionScalarFieldEnum | TopicSubscriptionScalarFieldEnum[]
  }

  /**
   * TopicSubscription findMany
   */
  export type TopicSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSubscription
     */
    select?: TopicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSubscription
     */
    omit?: TopicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which TopicSubscriptions to fetch.
     */
    where?: TopicSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TopicSubscriptions to fetch.
     */
    orderBy?: TopicSubscriptionOrderByWithRelationInput | TopicSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TopicSubscriptions.
     */
    cursor?: TopicSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TopicSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TopicSubscriptions.
     */
    skip?: number
    distinct?: TopicSubscriptionScalarFieldEnum | TopicSubscriptionScalarFieldEnum[]
  }

  /**
   * TopicSubscription create
   */
  export type TopicSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSubscription
     */
    select?: TopicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSubscription
     */
    omit?: TopicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a TopicSubscription.
     */
    data: XOR<TopicSubscriptionCreateInput, TopicSubscriptionUncheckedCreateInput>
  }

  /**
   * TopicSubscription createMany
   */
  export type TopicSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TopicSubscriptions.
     */
    data: TopicSubscriptionCreateManyInput | TopicSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TopicSubscription createManyAndReturn
   */
  export type TopicSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSubscription
     */
    select?: TopicSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSubscription
     */
    omit?: TopicSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many TopicSubscriptions.
     */
    data: TopicSubscriptionCreateManyInput | TopicSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TopicSubscription update
   */
  export type TopicSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSubscription
     */
    select?: TopicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSubscription
     */
    omit?: TopicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a TopicSubscription.
     */
    data: XOR<TopicSubscriptionUpdateInput, TopicSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which TopicSubscription to update.
     */
    where: TopicSubscriptionWhereUniqueInput
  }

  /**
   * TopicSubscription updateMany
   */
  export type TopicSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TopicSubscriptions.
     */
    data: XOR<TopicSubscriptionUpdateManyMutationInput, TopicSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which TopicSubscriptions to update
     */
    where?: TopicSubscriptionWhereInput
    /**
     * Limit how many TopicSubscriptions to update.
     */
    limit?: number
  }

  /**
   * TopicSubscription updateManyAndReturn
   */
  export type TopicSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSubscription
     */
    select?: TopicSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSubscription
     */
    omit?: TopicSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update TopicSubscriptions.
     */
    data: XOR<TopicSubscriptionUpdateManyMutationInput, TopicSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which TopicSubscriptions to update
     */
    where?: TopicSubscriptionWhereInput
    /**
     * Limit how many TopicSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TopicSubscription upsert
   */
  export type TopicSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSubscription
     */
    select?: TopicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSubscription
     */
    omit?: TopicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the TopicSubscription to update in case it exists.
     */
    where: TopicSubscriptionWhereUniqueInput
    /**
     * In case the TopicSubscription found by the `where` argument doesn't exist, create a new TopicSubscription with this data.
     */
    create: XOR<TopicSubscriptionCreateInput, TopicSubscriptionUncheckedCreateInput>
    /**
     * In case the TopicSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicSubscriptionUpdateInput, TopicSubscriptionUncheckedUpdateInput>
  }

  /**
   * TopicSubscription delete
   */
  export type TopicSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSubscription
     */
    select?: TopicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSubscription
     */
    omit?: TopicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which TopicSubscription to delete.
     */
    where: TopicSubscriptionWhereUniqueInput
  }

  /**
   * TopicSubscription deleteMany
   */
  export type TopicSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TopicSubscriptions to delete
     */
    where?: TopicSubscriptionWhereInput
    /**
     * Limit how many TopicSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * TopicSubscription without action
   */
  export type TopicSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicSubscription
     */
    select?: TopicSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TopicSubscription
     */
    omit?: TopicSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    pushAttempts: number | null
    id: number | null
  }

  export type NotificationSumAggregateOutputType = {
    pushAttempts: number | null
    id: number | null
  }

  export type NotificationMinAggregateOutputType = {
    topic: string | null
    title: string | null
    body: string | null
    url: string | null
    createdAt: Date | null
    pushedAt: Date | null
    pushAttempts: number | null
    readAt: Date | null
    id: number | null
    referenceId: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    topic: string | null
    title: string | null
    body: string | null
    url: string | null
    createdAt: Date | null
    pushedAt: Date | null
    pushAttempts: number | null
    readAt: Date | null
    id: number | null
    referenceId: string | null
  }

  export type NotificationCountAggregateOutputType = {
    topic: number
    title: number
    body: number
    url: number
    metadata: number
    createdAt: number
    pushedAt: number
    pushAttempts: number
    readAt: number
    id: number
    referenceId: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    pushAttempts?: true
    id?: true
  }

  export type NotificationSumAggregateInputType = {
    pushAttempts?: true
    id?: true
  }

  export type NotificationMinAggregateInputType = {
    topic?: true
    title?: true
    body?: true
    url?: true
    createdAt?: true
    pushedAt?: true
    pushAttempts?: true
    readAt?: true
    id?: true
    referenceId?: true
  }

  export type NotificationMaxAggregateInputType = {
    topic?: true
    title?: true
    body?: true
    url?: true
    createdAt?: true
    pushedAt?: true
    pushAttempts?: true
    readAt?: true
    id?: true
    referenceId?: true
  }

  export type NotificationCountAggregateInputType = {
    topic?: true
    title?: true
    body?: true
    url?: true
    metadata?: true
    createdAt?: true
    pushedAt?: true
    pushAttempts?: true
    readAt?: true
    id?: true
    referenceId?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    topic: string | null
    title: string
    body: string | null
    url: string | null
    metadata: JsonValue | null
    createdAt: Date
    pushedAt: Date | null
    pushAttempts: number
    readAt: Date | null
    id: number
    referenceId: string | null
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    topic?: boolean
    title?: boolean
    body?: boolean
    url?: boolean
    metadata?: boolean
    createdAt?: boolean
    pushedAt?: boolean
    pushAttempts?: boolean
    readAt?: boolean
    id?: boolean
    referenceId?: boolean
    Reads?: boolean | Notification$ReadsArgs<ExtArgs>
    Response?: boolean | Notification$ResponseArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    topic?: boolean
    title?: boolean
    body?: boolean
    url?: boolean
    metadata?: boolean
    createdAt?: boolean
    pushedAt?: boolean
    pushAttempts?: boolean
    readAt?: boolean
    id?: boolean
    referenceId?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    topic?: boolean
    title?: boolean
    body?: boolean
    url?: boolean
    metadata?: boolean
    createdAt?: boolean
    pushedAt?: boolean
    pushAttempts?: boolean
    readAt?: boolean
    id?: boolean
    referenceId?: boolean
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    topic?: boolean
    title?: boolean
    body?: boolean
    url?: boolean
    metadata?: boolean
    createdAt?: boolean
    pushedAt?: boolean
    pushAttempts?: boolean
    readAt?: boolean
    id?: boolean
    referenceId?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"topic" | "title" | "body" | "url" | "metadata" | "createdAt" | "pushedAt" | "pushAttempts" | "readAt" | "id" | "referenceId", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Reads?: boolean | Notification$ReadsArgs<ExtArgs>
    Response?: boolean | Notification$ResponseArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      Reads: Prisma.$NotificationReadPayload<ExtArgs>[]
      Response: Prisma.$NotificationResponsePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      topic: string | null
      title: string
      body: string | null
      url: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      pushedAt: Date | null
      pushAttempts: number
      readAt: Date | null
      id: number
      referenceId: string | null
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `topic`
     * const notificationWithTopicOnly = await prisma.notification.findMany({ select: { topic: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `topic`
     * const notificationWithTopicOnly = await prisma.notification.createManyAndReturn({
     *   select: { topic: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `topic`
     * const notificationWithTopicOnly = await prisma.notification.updateManyAndReturn({
     *   select: { topic: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Reads<T extends Notification$ReadsArgs<ExtArgs> = {}>(args?: Subset<T, Notification$ReadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Response<T extends Notification$ResponseArgs<ExtArgs> = {}>(args?: Subset<T, Notification$ResponseArgs<ExtArgs>>): Prisma__NotificationResponseClient<$Result.GetResult<Prisma.$NotificationResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly topic: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly url: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly pushedAt: FieldRef<"Notification", 'DateTime'>
    readonly pushAttempts: FieldRef<"Notification", 'Int'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly id: FieldRef<"Notification", 'Int'>
    readonly referenceId: FieldRef<"Notification", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.Reads
   */
  export type Notification$ReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    where?: NotificationReadWhereInput
    orderBy?: NotificationReadOrderByWithRelationInput | NotificationReadOrderByWithRelationInput[]
    cursor?: NotificationReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationReadScalarFieldEnum | NotificationReadScalarFieldEnum[]
  }

  /**
   * Notification.Response
   */
  export type Notification$ResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationResponse
     */
    select?: NotificationResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationResponse
     */
    omit?: NotificationResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationResponseInclude<ExtArgs> | null
    where?: NotificationResponseWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationResponse
   */

  export type AggregateNotificationResponse = {
    _count: NotificationResponseCountAggregateOutputType | null
    _avg: NotificationResponseAvgAggregateOutputType | null
    _sum: NotificationResponseSumAggregateOutputType | null
    _min: NotificationResponseMinAggregateOutputType | null
    _max: NotificationResponseMaxAggregateOutputType | null
  }

  export type NotificationResponseAvgAggregateOutputType = {
    id: number | null
    notificationId: number | null
  }

  export type NotificationResponseSumAggregateOutputType = {
    id: number | null
    notificationId: number | null
  }

  export type NotificationResponseMinAggregateOutputType = {
    id: number | null
    notificationId: number | null
    userId: string | null
    response: string | null
    respondedAt: Date | null
  }

  export type NotificationResponseMaxAggregateOutputType = {
    id: number | null
    notificationId: number | null
    userId: string | null
    response: string | null
    respondedAt: Date | null
  }

  export type NotificationResponseCountAggregateOutputType = {
    id: number
    notificationId: number
    userId: number
    response: number
    respondedAt: number
    _all: number
  }


  export type NotificationResponseAvgAggregateInputType = {
    id?: true
    notificationId?: true
  }

  export type NotificationResponseSumAggregateInputType = {
    id?: true
    notificationId?: true
  }

  export type NotificationResponseMinAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    response?: true
    respondedAt?: true
  }

  export type NotificationResponseMaxAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    response?: true
    respondedAt?: true
  }

  export type NotificationResponseCountAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    response?: true
    respondedAt?: true
    _all?: true
  }

  export type NotificationResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationResponse to aggregate.
     */
    where?: NotificationResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationResponses to fetch.
     */
    orderBy?: NotificationResponseOrderByWithRelationInput | NotificationResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationResponses
    **/
    _count?: true | NotificationResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationResponseMaxAggregateInputType
  }

  export type GetNotificationResponseAggregateType<T extends NotificationResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationResponse[P]>
      : GetScalarType<T[P], AggregateNotificationResponse[P]>
  }




  export type NotificationResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationResponseWhereInput
    orderBy?: NotificationResponseOrderByWithAggregationInput | NotificationResponseOrderByWithAggregationInput[]
    by: NotificationResponseScalarFieldEnum[] | NotificationResponseScalarFieldEnum
    having?: NotificationResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationResponseCountAggregateInputType | true
    _avg?: NotificationResponseAvgAggregateInputType
    _sum?: NotificationResponseSumAggregateInputType
    _min?: NotificationResponseMinAggregateInputType
    _max?: NotificationResponseMaxAggregateInputType
  }

  export type NotificationResponseGroupByOutputType = {
    id: number
    notificationId: number
    userId: string
    response: string | null
    respondedAt: Date
    _count: NotificationResponseCountAggregateOutputType | null
    _avg: NotificationResponseAvgAggregateOutputType | null
    _sum: NotificationResponseSumAggregateOutputType | null
    _min: NotificationResponseMinAggregateOutputType | null
    _max: NotificationResponseMaxAggregateOutputType | null
  }

  type GetNotificationResponseGroupByPayload<T extends NotificationResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationResponseGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationResponseGroupByOutputType[P]>
        }
      >
    >


  export type NotificationResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    response?: boolean
    respondedAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationResponse"]>

  export type NotificationResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    response?: boolean
    respondedAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationResponse"]>

  export type NotificationResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    response?: boolean
    respondedAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationResponse"]>

  export type NotificationResponseSelectScalar = {
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    response?: boolean
    respondedAt?: boolean
  }

  export type NotificationResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "notificationId" | "userId" | "response" | "respondedAt", ExtArgs["result"]["notificationResponse"]>
  export type NotificationResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationResponse"
    objects: {
      notification: Prisma.$NotificationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      notificationId: number
      userId: string
      response: string | null
      respondedAt: Date
    }, ExtArgs["result"]["notificationResponse"]>
    composites: {}
  }

  type NotificationResponseGetPayload<S extends boolean | null | undefined | NotificationResponseDefaultArgs> = $Result.GetResult<Prisma.$NotificationResponsePayload, S>

  type NotificationResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationResponseCountAggregateInputType | true
    }

  export interface NotificationResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationResponse'], meta: { name: 'NotificationResponse' } }
    /**
     * Find zero or one NotificationResponse that matches the filter.
     * @param {NotificationResponseFindUniqueArgs} args - Arguments to find a NotificationResponse
     * @example
     * // Get one NotificationResponse
     * const notificationResponse = await prisma.notificationResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationResponseFindUniqueArgs>(args: SelectSubset<T, NotificationResponseFindUniqueArgs<ExtArgs>>): Prisma__NotificationResponseClient<$Result.GetResult<Prisma.$NotificationResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationResponseFindUniqueOrThrowArgs} args - Arguments to find a NotificationResponse
     * @example
     * // Get one NotificationResponse
     * const notificationResponse = await prisma.notificationResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationResponseClient<$Result.GetResult<Prisma.$NotificationResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationResponseFindFirstArgs} args - Arguments to find a NotificationResponse
     * @example
     * // Get one NotificationResponse
     * const notificationResponse = await prisma.notificationResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationResponseFindFirstArgs>(args?: SelectSubset<T, NotificationResponseFindFirstArgs<ExtArgs>>): Prisma__NotificationResponseClient<$Result.GetResult<Prisma.$NotificationResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationResponseFindFirstOrThrowArgs} args - Arguments to find a NotificationResponse
     * @example
     * // Get one NotificationResponse
     * const notificationResponse = await prisma.notificationResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationResponseClient<$Result.GetResult<Prisma.$NotificationResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationResponses
     * const notificationResponses = await prisma.notificationResponse.findMany()
     * 
     * // Get first 10 NotificationResponses
     * const notificationResponses = await prisma.notificationResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationResponseWithIdOnly = await prisma.notificationResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationResponseFindManyArgs>(args?: SelectSubset<T, NotificationResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationResponse.
     * @param {NotificationResponseCreateArgs} args - Arguments to create a NotificationResponse.
     * @example
     * // Create one NotificationResponse
     * const NotificationResponse = await prisma.notificationResponse.create({
     *   data: {
     *     // ... data to create a NotificationResponse
     *   }
     * })
     * 
     */
    create<T extends NotificationResponseCreateArgs>(args: SelectSubset<T, NotificationResponseCreateArgs<ExtArgs>>): Prisma__NotificationResponseClient<$Result.GetResult<Prisma.$NotificationResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationResponses.
     * @param {NotificationResponseCreateManyArgs} args - Arguments to create many NotificationResponses.
     * @example
     * // Create many NotificationResponses
     * const notificationResponse = await prisma.notificationResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationResponseCreateManyArgs>(args?: SelectSubset<T, NotificationResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationResponses and returns the data saved in the database.
     * @param {NotificationResponseCreateManyAndReturnArgs} args - Arguments to create many NotificationResponses.
     * @example
     * // Create many NotificationResponses
     * const notificationResponse = await prisma.notificationResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationResponses and only return the `id`
     * const notificationResponseWithIdOnly = await prisma.notificationResponse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationResponse.
     * @param {NotificationResponseDeleteArgs} args - Arguments to delete one NotificationResponse.
     * @example
     * // Delete one NotificationResponse
     * const NotificationResponse = await prisma.notificationResponse.delete({
     *   where: {
     *     // ... filter to delete one NotificationResponse
     *   }
     * })
     * 
     */
    delete<T extends NotificationResponseDeleteArgs>(args: SelectSubset<T, NotificationResponseDeleteArgs<ExtArgs>>): Prisma__NotificationResponseClient<$Result.GetResult<Prisma.$NotificationResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationResponse.
     * @param {NotificationResponseUpdateArgs} args - Arguments to update one NotificationResponse.
     * @example
     * // Update one NotificationResponse
     * const notificationResponse = await prisma.notificationResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationResponseUpdateArgs>(args: SelectSubset<T, NotificationResponseUpdateArgs<ExtArgs>>): Prisma__NotificationResponseClient<$Result.GetResult<Prisma.$NotificationResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationResponses.
     * @param {NotificationResponseDeleteManyArgs} args - Arguments to filter NotificationResponses to delete.
     * @example
     * // Delete a few NotificationResponses
     * const { count } = await prisma.notificationResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationResponseDeleteManyArgs>(args?: SelectSubset<T, NotificationResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationResponses
     * const notificationResponse = await prisma.notificationResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationResponseUpdateManyArgs>(args: SelectSubset<T, NotificationResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationResponses and returns the data updated in the database.
     * @param {NotificationResponseUpdateManyAndReturnArgs} args - Arguments to update many NotificationResponses.
     * @example
     * // Update many NotificationResponses
     * const notificationResponse = await prisma.notificationResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationResponses and only return the `id`
     * const notificationResponseWithIdOnly = await prisma.notificationResponse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationResponse.
     * @param {NotificationResponseUpsertArgs} args - Arguments to update or create a NotificationResponse.
     * @example
     * // Update or create a NotificationResponse
     * const notificationResponse = await prisma.notificationResponse.upsert({
     *   create: {
     *     // ... data to create a NotificationResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationResponse we want to update
     *   }
     * })
     */
    upsert<T extends NotificationResponseUpsertArgs>(args: SelectSubset<T, NotificationResponseUpsertArgs<ExtArgs>>): Prisma__NotificationResponseClient<$Result.GetResult<Prisma.$NotificationResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationResponseCountArgs} args - Arguments to filter NotificationResponses to count.
     * @example
     * // Count the number of NotificationResponses
     * const count = await prisma.notificationResponse.count({
     *   where: {
     *     // ... the filter for the NotificationResponses we want to count
     *   }
     * })
    **/
    count<T extends NotificationResponseCountArgs>(
      args?: Subset<T, NotificationResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationResponseAggregateArgs>(args: Subset<T, NotificationResponseAggregateArgs>): Prisma.PrismaPromise<GetNotificationResponseAggregateType<T>>

    /**
     * Group by NotificationResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationResponseGroupByArgs['orderBy'] }
        : { orderBy?: NotificationResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationResponse model
   */
  readonly fields: NotificationResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notification<T extends NotificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationDefaultArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationResponse model
   */
  interface NotificationResponseFieldRefs {
    readonly id: FieldRef<"NotificationResponse", 'Int'>
    readonly notificationId: FieldRef<"NotificationResponse", 'Int'>
    readonly userId: FieldRef<"NotificationResponse", 'String'>
    readonly response: FieldRef<"NotificationResponse", 'String'>
    readonly respondedAt: FieldRef<"NotificationResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationResponse findUnique
   */
  export type NotificationResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationResponse
     */
    select?: NotificationResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationResponse
     */
    omit?: NotificationResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationResponseInclude<ExtArgs> | null
    /**
     * Filter, which NotificationResponse to fetch.
     */
    where: NotificationResponseWhereUniqueInput
  }

  /**
   * NotificationResponse findUniqueOrThrow
   */
  export type NotificationResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationResponse
     */
    select?: NotificationResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationResponse
     */
    omit?: NotificationResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationResponseInclude<ExtArgs> | null
    /**
     * Filter, which NotificationResponse to fetch.
     */
    where: NotificationResponseWhereUniqueInput
  }

  /**
   * NotificationResponse findFirst
   */
  export type NotificationResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationResponse
     */
    select?: NotificationResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationResponse
     */
    omit?: NotificationResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationResponseInclude<ExtArgs> | null
    /**
     * Filter, which NotificationResponse to fetch.
     */
    where?: NotificationResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationResponses to fetch.
     */
    orderBy?: NotificationResponseOrderByWithRelationInput | NotificationResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationResponses.
     */
    cursor?: NotificationResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationResponses.
     */
    distinct?: NotificationResponseScalarFieldEnum | NotificationResponseScalarFieldEnum[]
  }

  /**
   * NotificationResponse findFirstOrThrow
   */
  export type NotificationResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationResponse
     */
    select?: NotificationResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationResponse
     */
    omit?: NotificationResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationResponseInclude<ExtArgs> | null
    /**
     * Filter, which NotificationResponse to fetch.
     */
    where?: NotificationResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationResponses to fetch.
     */
    orderBy?: NotificationResponseOrderByWithRelationInput | NotificationResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationResponses.
     */
    cursor?: NotificationResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationResponses.
     */
    distinct?: NotificationResponseScalarFieldEnum | NotificationResponseScalarFieldEnum[]
  }

  /**
   * NotificationResponse findMany
   */
  export type NotificationResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationResponse
     */
    select?: NotificationResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationResponse
     */
    omit?: NotificationResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationResponseInclude<ExtArgs> | null
    /**
     * Filter, which NotificationResponses to fetch.
     */
    where?: NotificationResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationResponses to fetch.
     */
    orderBy?: NotificationResponseOrderByWithRelationInput | NotificationResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationResponses.
     */
    cursor?: NotificationResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationResponses.
     */
    skip?: number
    distinct?: NotificationResponseScalarFieldEnum | NotificationResponseScalarFieldEnum[]
  }

  /**
   * NotificationResponse create
   */
  export type NotificationResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationResponse
     */
    select?: NotificationResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationResponse
     */
    omit?: NotificationResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationResponse.
     */
    data: XOR<NotificationResponseCreateInput, NotificationResponseUncheckedCreateInput>
  }

  /**
   * NotificationResponse createMany
   */
  export type NotificationResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationResponses.
     */
    data: NotificationResponseCreateManyInput | NotificationResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationResponse createManyAndReturn
   */
  export type NotificationResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationResponse
     */
    select?: NotificationResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationResponse
     */
    omit?: NotificationResponseOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationResponses.
     */
    data: NotificationResponseCreateManyInput | NotificationResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationResponse update
   */
  export type NotificationResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationResponse
     */
    select?: NotificationResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationResponse
     */
    omit?: NotificationResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationResponse.
     */
    data: XOR<NotificationResponseUpdateInput, NotificationResponseUncheckedUpdateInput>
    /**
     * Choose, which NotificationResponse to update.
     */
    where: NotificationResponseWhereUniqueInput
  }

  /**
   * NotificationResponse updateMany
   */
  export type NotificationResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationResponses.
     */
    data: XOR<NotificationResponseUpdateManyMutationInput, NotificationResponseUncheckedUpdateManyInput>
    /**
     * Filter which NotificationResponses to update
     */
    where?: NotificationResponseWhereInput
    /**
     * Limit how many NotificationResponses to update.
     */
    limit?: number
  }

  /**
   * NotificationResponse updateManyAndReturn
   */
  export type NotificationResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationResponse
     */
    select?: NotificationResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationResponse
     */
    omit?: NotificationResponseOmit<ExtArgs> | null
    /**
     * The data used to update NotificationResponses.
     */
    data: XOR<NotificationResponseUpdateManyMutationInput, NotificationResponseUncheckedUpdateManyInput>
    /**
     * Filter which NotificationResponses to update
     */
    where?: NotificationResponseWhereInput
    /**
     * Limit how many NotificationResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationResponse upsert
   */
  export type NotificationResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationResponse
     */
    select?: NotificationResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationResponse
     */
    omit?: NotificationResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationResponse to update in case it exists.
     */
    where: NotificationResponseWhereUniqueInput
    /**
     * In case the NotificationResponse found by the `where` argument doesn't exist, create a new NotificationResponse with this data.
     */
    create: XOR<NotificationResponseCreateInput, NotificationResponseUncheckedCreateInput>
    /**
     * In case the NotificationResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationResponseUpdateInput, NotificationResponseUncheckedUpdateInput>
  }

  /**
   * NotificationResponse delete
   */
  export type NotificationResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationResponse
     */
    select?: NotificationResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationResponse
     */
    omit?: NotificationResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationResponseInclude<ExtArgs> | null
    /**
     * Filter which NotificationResponse to delete.
     */
    where: NotificationResponseWhereUniqueInput
  }

  /**
   * NotificationResponse deleteMany
   */
  export type NotificationResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationResponses to delete
     */
    where?: NotificationResponseWhereInput
    /**
     * Limit how many NotificationResponses to delete.
     */
    limit?: number
  }

  /**
   * NotificationResponse without action
   */
  export type NotificationResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationResponse
     */
    select?: NotificationResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationResponse
     */
    omit?: NotificationResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationResponseInclude<ExtArgs> | null
  }


  /**
   * Model NotificationRead
   */

  export type AggregateNotificationRead = {
    _count: NotificationReadCountAggregateOutputType | null
    _avg: NotificationReadAvgAggregateOutputType | null
    _sum: NotificationReadSumAggregateOutputType | null
    _min: NotificationReadMinAggregateOutputType | null
    _max: NotificationReadMaxAggregateOutputType | null
  }

  export type NotificationReadAvgAggregateOutputType = {
    id: number | null
    notificationId: number | null
  }

  export type NotificationReadSumAggregateOutputType = {
    id: number | null
    notificationId: number | null
  }

  export type NotificationReadMinAggregateOutputType = {
    id: number | null
    notificationId: number | null
    userId: string | null
    readAt: Date | null
  }

  export type NotificationReadMaxAggregateOutputType = {
    id: number | null
    notificationId: number | null
    userId: string | null
    readAt: Date | null
  }

  export type NotificationReadCountAggregateOutputType = {
    id: number
    notificationId: number
    userId: number
    readAt: number
    _all: number
  }


  export type NotificationReadAvgAggregateInputType = {
    id?: true
    notificationId?: true
  }

  export type NotificationReadSumAggregateInputType = {
    id?: true
    notificationId?: true
  }

  export type NotificationReadMinAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    readAt?: true
  }

  export type NotificationReadMaxAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    readAt?: true
  }

  export type NotificationReadCountAggregateInputType = {
    id?: true
    notificationId?: true
    userId?: true
    readAt?: true
    _all?: true
  }

  export type NotificationReadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationRead to aggregate.
     */
    where?: NotificationReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationReads to fetch.
     */
    orderBy?: NotificationReadOrderByWithRelationInput | NotificationReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationReads
    **/
    _count?: true | NotificationReadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationReadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationReadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationReadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationReadMaxAggregateInputType
  }

  export type GetNotificationReadAggregateType<T extends NotificationReadAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationRead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationRead[P]>
      : GetScalarType<T[P], AggregateNotificationRead[P]>
  }




  export type NotificationReadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationReadWhereInput
    orderBy?: NotificationReadOrderByWithAggregationInput | NotificationReadOrderByWithAggregationInput[]
    by: NotificationReadScalarFieldEnum[] | NotificationReadScalarFieldEnum
    having?: NotificationReadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationReadCountAggregateInputType | true
    _avg?: NotificationReadAvgAggregateInputType
    _sum?: NotificationReadSumAggregateInputType
    _min?: NotificationReadMinAggregateInputType
    _max?: NotificationReadMaxAggregateInputType
  }

  export type NotificationReadGroupByOutputType = {
    id: number
    notificationId: number
    userId: string
    readAt: Date
    _count: NotificationReadCountAggregateOutputType | null
    _avg: NotificationReadAvgAggregateOutputType | null
    _sum: NotificationReadSumAggregateOutputType | null
    _min: NotificationReadMinAggregateOutputType | null
    _max: NotificationReadMaxAggregateOutputType | null
  }

  type GetNotificationReadGroupByPayload<T extends NotificationReadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationReadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationReadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationReadGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationReadGroupByOutputType[P]>
        }
      >
    >


  export type NotificationReadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    readAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRead"]>

  export type NotificationReadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    readAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRead"]>

  export type NotificationReadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    readAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRead"]>

  export type NotificationReadSelectScalar = {
    id?: boolean
    notificationId?: boolean
    userId?: boolean
    readAt?: boolean
  }

  export type NotificationReadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "notificationId" | "userId" | "readAt", ExtArgs["result"]["notificationRead"]>
  export type NotificationReadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationReadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationReadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationReadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationRead"
    objects: {
      notification: Prisma.$NotificationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      notificationId: number
      userId: string
      readAt: Date
    }, ExtArgs["result"]["notificationRead"]>
    composites: {}
  }

  type NotificationReadGetPayload<S extends boolean | null | undefined | NotificationReadDefaultArgs> = $Result.GetResult<Prisma.$NotificationReadPayload, S>

  type NotificationReadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationReadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationReadCountAggregateInputType | true
    }

  export interface NotificationReadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationRead'], meta: { name: 'NotificationRead' } }
    /**
     * Find zero or one NotificationRead that matches the filter.
     * @param {NotificationReadFindUniqueArgs} args - Arguments to find a NotificationRead
     * @example
     * // Get one NotificationRead
     * const notificationRead = await prisma.notificationRead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationReadFindUniqueArgs>(args: SelectSubset<T, NotificationReadFindUniqueArgs<ExtArgs>>): Prisma__NotificationReadClient<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationRead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationReadFindUniqueOrThrowArgs} args - Arguments to find a NotificationRead
     * @example
     * // Get one NotificationRead
     * const notificationRead = await prisma.notificationRead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationReadFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationReadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationReadClient<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationRead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReadFindFirstArgs} args - Arguments to find a NotificationRead
     * @example
     * // Get one NotificationRead
     * const notificationRead = await prisma.notificationRead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationReadFindFirstArgs>(args?: SelectSubset<T, NotificationReadFindFirstArgs<ExtArgs>>): Prisma__NotificationReadClient<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationRead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReadFindFirstOrThrowArgs} args - Arguments to find a NotificationRead
     * @example
     * // Get one NotificationRead
     * const notificationRead = await prisma.notificationRead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationReadFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationReadFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationReadClient<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationReads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationReads
     * const notificationReads = await prisma.notificationRead.findMany()
     * 
     * // Get first 10 NotificationReads
     * const notificationReads = await prisma.notificationRead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationReadWithIdOnly = await prisma.notificationRead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationReadFindManyArgs>(args?: SelectSubset<T, NotificationReadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationRead.
     * @param {NotificationReadCreateArgs} args - Arguments to create a NotificationRead.
     * @example
     * // Create one NotificationRead
     * const NotificationRead = await prisma.notificationRead.create({
     *   data: {
     *     // ... data to create a NotificationRead
     *   }
     * })
     * 
     */
    create<T extends NotificationReadCreateArgs>(args: SelectSubset<T, NotificationReadCreateArgs<ExtArgs>>): Prisma__NotificationReadClient<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationReads.
     * @param {NotificationReadCreateManyArgs} args - Arguments to create many NotificationReads.
     * @example
     * // Create many NotificationReads
     * const notificationRead = await prisma.notificationRead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationReadCreateManyArgs>(args?: SelectSubset<T, NotificationReadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationReads and returns the data saved in the database.
     * @param {NotificationReadCreateManyAndReturnArgs} args - Arguments to create many NotificationReads.
     * @example
     * // Create many NotificationReads
     * const notificationRead = await prisma.notificationRead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationReads and only return the `id`
     * const notificationReadWithIdOnly = await prisma.notificationRead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationReadCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationReadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationRead.
     * @param {NotificationReadDeleteArgs} args - Arguments to delete one NotificationRead.
     * @example
     * // Delete one NotificationRead
     * const NotificationRead = await prisma.notificationRead.delete({
     *   where: {
     *     // ... filter to delete one NotificationRead
     *   }
     * })
     * 
     */
    delete<T extends NotificationReadDeleteArgs>(args: SelectSubset<T, NotificationReadDeleteArgs<ExtArgs>>): Prisma__NotificationReadClient<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationRead.
     * @param {NotificationReadUpdateArgs} args - Arguments to update one NotificationRead.
     * @example
     * // Update one NotificationRead
     * const notificationRead = await prisma.notificationRead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationReadUpdateArgs>(args: SelectSubset<T, NotificationReadUpdateArgs<ExtArgs>>): Prisma__NotificationReadClient<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationReads.
     * @param {NotificationReadDeleteManyArgs} args - Arguments to filter NotificationReads to delete.
     * @example
     * // Delete a few NotificationReads
     * const { count } = await prisma.notificationRead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationReadDeleteManyArgs>(args?: SelectSubset<T, NotificationReadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationReads
     * const notificationRead = await prisma.notificationRead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationReadUpdateManyArgs>(args: SelectSubset<T, NotificationReadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationReads and returns the data updated in the database.
     * @param {NotificationReadUpdateManyAndReturnArgs} args - Arguments to update many NotificationReads.
     * @example
     * // Update many NotificationReads
     * const notificationRead = await prisma.notificationRead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationReads and only return the `id`
     * const notificationReadWithIdOnly = await prisma.notificationRead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationReadUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationReadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationRead.
     * @param {NotificationReadUpsertArgs} args - Arguments to update or create a NotificationRead.
     * @example
     * // Update or create a NotificationRead
     * const notificationRead = await prisma.notificationRead.upsert({
     *   create: {
     *     // ... data to create a NotificationRead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationRead we want to update
     *   }
     * })
     */
    upsert<T extends NotificationReadUpsertArgs>(args: SelectSubset<T, NotificationReadUpsertArgs<ExtArgs>>): Prisma__NotificationReadClient<$Result.GetResult<Prisma.$NotificationReadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReadCountArgs} args - Arguments to filter NotificationReads to count.
     * @example
     * // Count the number of NotificationReads
     * const count = await prisma.notificationRead.count({
     *   where: {
     *     // ... the filter for the NotificationReads we want to count
     *   }
     * })
    **/
    count<T extends NotificationReadCountArgs>(
      args?: Subset<T, NotificationReadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationReadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationReadAggregateArgs>(args: Subset<T, NotificationReadAggregateArgs>): Prisma.PrismaPromise<GetNotificationReadAggregateType<T>>

    /**
     * Group by NotificationRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationReadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationReadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationReadGroupByArgs['orderBy'] }
        : { orderBy?: NotificationReadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationReadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationReadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationRead model
   */
  readonly fields: NotificationReadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationRead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationReadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notification<T extends NotificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationDefaultArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationRead model
   */
  interface NotificationReadFieldRefs {
    readonly id: FieldRef<"NotificationRead", 'Int'>
    readonly notificationId: FieldRef<"NotificationRead", 'Int'>
    readonly userId: FieldRef<"NotificationRead", 'String'>
    readonly readAt: FieldRef<"NotificationRead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationRead findUnique
   */
  export type NotificationReadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRead to fetch.
     */
    where: NotificationReadWhereUniqueInput
  }

  /**
   * NotificationRead findUniqueOrThrow
   */
  export type NotificationReadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRead to fetch.
     */
    where: NotificationReadWhereUniqueInput
  }

  /**
   * NotificationRead findFirst
   */
  export type NotificationReadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRead to fetch.
     */
    where?: NotificationReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationReads to fetch.
     */
    orderBy?: NotificationReadOrderByWithRelationInput | NotificationReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationReads.
     */
    cursor?: NotificationReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationReads.
     */
    distinct?: NotificationReadScalarFieldEnum | NotificationReadScalarFieldEnum[]
  }

  /**
   * NotificationRead findFirstOrThrow
   */
  export type NotificationReadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRead to fetch.
     */
    where?: NotificationReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationReads to fetch.
     */
    orderBy?: NotificationReadOrderByWithRelationInput | NotificationReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationReads.
     */
    cursor?: NotificationReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationReads.
     */
    distinct?: NotificationReadScalarFieldEnum | NotificationReadScalarFieldEnum[]
  }

  /**
   * NotificationRead findMany
   */
  export type NotificationReadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * Filter, which NotificationReads to fetch.
     */
    where?: NotificationReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationReads to fetch.
     */
    orderBy?: NotificationReadOrderByWithRelationInput | NotificationReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationReads.
     */
    cursor?: NotificationReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationReads.
     */
    skip?: number
    distinct?: NotificationReadScalarFieldEnum | NotificationReadScalarFieldEnum[]
  }

  /**
   * NotificationRead create
   */
  export type NotificationReadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationRead.
     */
    data: XOR<NotificationReadCreateInput, NotificationReadUncheckedCreateInput>
  }

  /**
   * NotificationRead createMany
   */
  export type NotificationReadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationReads.
     */
    data: NotificationReadCreateManyInput | NotificationReadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationRead createManyAndReturn
   */
  export type NotificationReadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationReads.
     */
    data: NotificationReadCreateManyInput | NotificationReadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationRead update
   */
  export type NotificationReadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationRead.
     */
    data: XOR<NotificationReadUpdateInput, NotificationReadUncheckedUpdateInput>
    /**
     * Choose, which NotificationRead to update.
     */
    where: NotificationReadWhereUniqueInput
  }

  /**
   * NotificationRead updateMany
   */
  export type NotificationReadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationReads.
     */
    data: XOR<NotificationReadUpdateManyMutationInput, NotificationReadUncheckedUpdateManyInput>
    /**
     * Filter which NotificationReads to update
     */
    where?: NotificationReadWhereInput
    /**
     * Limit how many NotificationReads to update.
     */
    limit?: number
  }

  /**
   * NotificationRead updateManyAndReturn
   */
  export type NotificationReadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * The data used to update NotificationReads.
     */
    data: XOR<NotificationReadUpdateManyMutationInput, NotificationReadUncheckedUpdateManyInput>
    /**
     * Filter which NotificationReads to update
     */
    where?: NotificationReadWhereInput
    /**
     * Limit how many NotificationReads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationRead upsert
   */
  export type NotificationReadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationRead to update in case it exists.
     */
    where: NotificationReadWhereUniqueInput
    /**
     * In case the NotificationRead found by the `where` argument doesn't exist, create a new NotificationRead with this data.
     */
    create: XOR<NotificationReadCreateInput, NotificationReadUncheckedCreateInput>
    /**
     * In case the NotificationRead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationReadUpdateInput, NotificationReadUncheckedUpdateInput>
  }

  /**
   * NotificationRead delete
   */
  export type NotificationReadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
    /**
     * Filter which NotificationRead to delete.
     */
    where: NotificationReadWhereUniqueInput
  }

  /**
   * NotificationRead deleteMany
   */
  export type NotificationReadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationReads to delete
     */
    where?: NotificationReadWhereInput
    /**
     * Limit how many NotificationReads to delete.
     */
    limit?: number
  }

  /**
   * NotificationRead without action
   */
  export type NotificationReadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRead
     */
    select?: NotificationReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRead
     */
    omit?: NotificationReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationReadInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    addressId: 'addressId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    SubscriptionDate: 'SubscriptionDate'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const CostCodeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    code: 'code'
  };

  export type CostCodeScalarFieldEnum = (typeof CostCodeScalarFieldEnum)[keyof typeof CostCodeScalarFieldEnum]


  export const CCTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type CCTagScalarFieldEnum = (typeof CCTagScalarFieldEnum)[keyof typeof CCTagScalarFieldEnum]


  export const CrewScalarFieldEnum: {
    id: 'id',
    name: 'name',
    leadId: 'leadId',
    crewType: 'crewType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CrewScalarFieldEnum = (typeof CrewScalarFieldEnum)[keyof typeof CrewScalarFieldEnum]


  export const PdfDocumentScalarFieldEnum: {
    id: 'id',
    qrId: 'qrId',
    fileName: 'fileName',
    description: 'description',
    fileData: 'fileData',
    contentType: 'contentType',
    size: 'size',
    isActive: 'isActive',
    createdAt: 'createdAt',
    uploadDate: 'uploadDate'
  };

  export type PdfDocumentScalarFieldEnum = (typeof PdfDocumentScalarFieldEnum)[keyof typeof PdfDocumentScalarFieldEnum]


  export const DocumentTagScalarFieldEnum: {
    id: 'id',
    tagName: 'tagName'
  };

  export type DocumentTagScalarFieldEnum = (typeof DocumentTagScalarFieldEnum)[keyof typeof DocumentTagScalarFieldEnum]


  export const EquipmentScalarFieldEnum: {
    id: 'id',
    qrId: 'qrId',
    name: 'name',
    description: 'description',
    creationReason: 'creationReason',
    equipmentTag: 'equipmentTag',
    state: 'state',
    approvalStatus: 'approvalStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    overWeight: 'overWeight',
    currentWeight: 'currentWeight',
    createdById: 'createdById',
    createdVia: 'createdVia',
    acquiredDate: 'acquiredDate',
    code: 'code',
    color: 'color',
    licensePlate: 'licensePlate',
    licenseState: 'licenseState',
    make: 'make',
    memo: 'memo',
    model: 'model',
    ownershipType: 'ownershipType',
    registrationExpiration: 'registrationExpiration',
    serialNumber: 'serialNumber',
    year: 'year',
    acquiredCondition: 'acquiredCondition',
    status: 'status'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const EmployeeEquipmentLogScalarFieldEnum: {
    id: 'id',
    equipmentId: 'equipmentId',
    maintenanceId: 'maintenanceId',
    startTime: 'startTime',
    endTime: 'endTime',
    comment: 'comment',
    timeSheetId: 'timeSheetId',
    rental: 'rental'
  };

  export type EmployeeEquipmentLogScalarFieldEnum = (typeof EmployeeEquipmentLogScalarFieldEnum)[keyof typeof EmployeeEquipmentLogScalarFieldEnum]


  export const FormTemplateScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isSignatureRequired: 'isSignatureRequired',
    description: 'description',
    isActive: 'isActive',
    formType: 'formType',
    isApprovalRequired: 'isApprovalRequired'
  };

  export type FormTemplateScalarFieldEnum = (typeof FormTemplateScalarFieldEnum)[keyof typeof FormTemplateScalarFieldEnum]


  export const FormGroupingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    order: 'order'
  };

  export type FormGroupingScalarFieldEnum = (typeof FormGroupingScalarFieldEnum)[keyof typeof FormGroupingScalarFieldEnum]


  export const FormFieldScalarFieldEnum: {
    id: 'id',
    formGroupingId: 'formGroupingId',
    label: 'label',
    type: 'type',
    required: 'required',
    order: 'order',
    placeholder: 'placeholder',
    maxLength: 'maxLength',
    content: 'content',
    filter: 'filter',
    minLength: 'minLength',
    multiple: 'multiple'
  };

  export type FormFieldScalarFieldEnum = (typeof FormFieldScalarFieldEnum)[keyof typeof FormFieldScalarFieldEnum]


  export const FormFieldOptionScalarFieldEnum: {
    id: 'id',
    fieldId: 'fieldId',
    value: 'value'
  };

  export type FormFieldOptionScalarFieldEnum = (typeof FormFieldOptionScalarFieldEnum)[keyof typeof FormFieldOptionScalarFieldEnum]


  export const FormSubmissionScalarFieldEnum: {
    title: 'title',
    formTemplateId: 'formTemplateId',
    userId: 'userId',
    formType: 'formType',
    data: 'data',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    submittedAt: 'submittedAt',
    status: 'status',
    id: 'id'
  };

  export type FormSubmissionScalarFieldEnum = (typeof FormSubmissionScalarFieldEnum)[keyof typeof FormSubmissionScalarFieldEnum]


  export const FormApprovalScalarFieldEnum: {
    id: 'id',
    signedBy: 'signedBy',
    submittedAt: 'submittedAt',
    updatedAt: 'updatedAt',
    signature: 'signature',
    comment: 'comment',
    formSubmissionId: 'formSubmissionId'
  };

  export type FormApprovalScalarFieldEnum = (typeof FormApprovalScalarFieldEnum)[keyof typeof FormApprovalScalarFieldEnum]


  export const JobsiteScalarFieldEnum: {
    id: 'id',
    qrId: 'qrId',
    name: 'name',
    description: 'description',
    creationReason: 'creationReason',
    approvalStatus: 'approvalStatus',
    addressId: 'addressId',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    archiveDate: 'archiveDate',
    createdById: 'createdById',
    createdVia: 'createdVia',
    code: 'code',
    latitude: 'latitude',
    longitude: 'longitude',
    radiusMeters: 'radiusMeters',
    status: 'status'
  };

  export type JobsiteScalarFieldEnum = (typeof JobsiteScalarFieldEnum)[keyof typeof JobsiteScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    name: 'name',
    description: 'description',
    companyId: 'companyId',
    createdAt: 'createdAt',
    createdBy: 'createdBy',
    updatedAt: 'updatedAt',
    parameters: 'parameters',
    visibility: 'visibility',
    tags: 'tags',
    id: 'id'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const ReportRunScalarFieldEnum: {
    id: 'id',
    runAt: 'runAt',
    status: 'status',
    results: 'results',
    duration: 'duration',
    startDate: 'startDate',
    endDate: 'endDate',
    customParams: 'customParams',
    exportFormats: 'exportFormats',
    lastExportedAt: 'lastExportedAt',
    reportId: 'reportId'
  };

  export type ReportRunScalarFieldEnum = (typeof ReportRunScalarFieldEnum)[keyof typeof ReportRunScalarFieldEnum]


  export const TimeSheetScalarFieldEnum: {
    date: 'date',
    userId: 'userId',
    jobsiteId: 'jobsiteId',
    costcode: 'costcode',
    nu: 'nu',
    Fp: 'Fp',
    startTime: 'startTime',
    endTime: 'endTime',
    comment: 'comment',
    statusComment: 'statusComment',
    location: 'location',
    status: 'status',
    workType: 'workType',
    editedByUserId: 'editedByUserId',
    newTimeSheetId: 'newTimeSheetId',
    createdByAdmin: 'createdByAdmin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clockInLat: 'clockInLat',
    clockInLng: 'clockInLng',
    clockOutLat: 'clockOutLat',
    clockOutLng: 'clockOutLng',
    withinFenceIn: 'withinFenceIn',
    withinFenceOut: 'withinFenceOut',
    wasInjured: 'wasInjured',
    id: 'id'
  };

  export type TimeSheetScalarFieldEnum = (typeof TimeSheetScalarFieldEnum)[keyof typeof TimeSheetScalarFieldEnum]


  export const MechanicProjectsScalarFieldEnum: {
    id: 'id',
    timeSheetId: 'timeSheetId',
    hours: 'hours',
    equipmentId: 'equipmentId',
    description: 'description'
  };

  export type MechanicProjectsScalarFieldEnum = (typeof MechanicProjectsScalarFieldEnum)[keyof typeof MechanicProjectsScalarFieldEnum]


  export const MaintenanceLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    maintenanceId: 'maintenanceId',
    startTime: 'startTime',
    endTime: 'endTime',
    comment: 'comment',
    timeSheetId: 'timeSheetId'
  };

  export type MaintenanceLogScalarFieldEnum = (typeof MaintenanceLogScalarFieldEnum)[keyof typeof MaintenanceLogScalarFieldEnum]


  export const MaintenanceScalarFieldEnum: {
    id: 'id',
    equipmentId: 'equipmentId',
    equipmentIssue: 'equipmentIssue',
    employeeEquipmentLogId: 'employeeEquipmentLogId',
    additionalInfo: 'additionalInfo',
    location: 'location',
    problemDiagnosis: 'problemDiagnosis',
    solution: 'solution',
    totalHoursLaboured: 'totalHoursLaboured',
    createdAt: 'createdAt',
    priority: 'priority',
    delay: 'delay',
    delayReasoning: 'delayReasoning',
    repaired: 'repaired',
    selected: 'selected',
    hasBeenDelayed: 'hasBeenDelayed',
    createdBy: 'createdBy'
  };

  export type MaintenanceScalarFieldEnum = (typeof MaintenanceScalarFieldEnum)[keyof typeof MaintenanceScalarFieldEnum]


  export const TascoLogScalarFieldEnum: {
    id: 'id',
    shiftType: 'shiftType',
    equipmentId: 'equipmentId',
    laborType: 'laborType',
    materialType: 'materialType',
    LoadQuantity: 'LoadQuantity',
    screenType: 'screenType',
    timeSheetId: 'timeSheetId'
  };

  export type TascoLogScalarFieldEnum = (typeof TascoLogScalarFieldEnum)[keyof typeof TascoLogScalarFieldEnum]


  export const TascoFLoadsScalarFieldEnum: {
    id: 'id',
    tascoLogId: 'tascoLogId',
    weight: 'weight',
    screenType: 'screenType'
  };

  export type TascoFLoadsScalarFieldEnum = (typeof TascoFLoadsScalarFieldEnum)[keyof typeof TascoFLoadsScalarFieldEnum]


  export const TascoMaterialTypesScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type TascoMaterialTypesScalarFieldEnum = (typeof TascoMaterialTypesScalarFieldEnum)[keyof typeof TascoMaterialTypesScalarFieldEnum]


  export const TruckingLogScalarFieldEnum: {
    id: 'id',
    laborType: 'laborType',
    taskName: 'taskName',
    equipmentId: 'equipmentId',
    startingMileage: 'startingMileage',
    endingMileage: 'endingMileage',
    truckLaborLogId: 'truckLaborLogId',
    trailerNumber: 'trailerNumber',
    truckNumber: 'truckNumber',
    timeSheetId: 'timeSheetId'
  };

  export type TruckingLogScalarFieldEnum = (typeof TruckingLogScalarFieldEnum)[keyof typeof TruckingLogScalarFieldEnum]


  export const StateMileageScalarFieldEnum: {
    id: 'id',
    truckingLogId: 'truckingLogId',
    state: 'state',
    stateLineMileage: 'stateLineMileage'
  };

  export type StateMileageScalarFieldEnum = (typeof StateMileageScalarFieldEnum)[keyof typeof StateMileageScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    truckingLogId: 'truckingLogId',
    LocationOfMaterial: 'LocationOfMaterial',
    name: 'name',
    quantity: 'quantity',
    materialWeight: 'materialWeight',
    loadType: 'loadType',
    createdAt: 'createdAt',
    unit: 'unit'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const RefuelLogScalarFieldEnum: {
    id: 'id',
    employeeEquipmentLogId: 'employeeEquipmentLogId',
    truckingLogId: 'truckingLogId',
    tascoLogId: 'tascoLogId',
    gallonsRefueled: 'gallonsRefueled',
    milesAtFueling: 'milesAtFueling'
  };

  export type RefuelLogScalarFieldEnum = (typeof RefuelLogScalarFieldEnum)[keyof typeof RefuelLogScalarFieldEnum]


  export const EquipmentHauledScalarFieldEnum: {
    id: 'id',
    truckingLogId: 'truckingLogId',
    equipmentId: 'equipmentId',
    createdAt: 'createdAt',
    endMileage: 'endMileage',
    startMileage: 'startMileage',
    destination: 'destination',
    source: 'source'
  };

  export type EquipmentHauledScalarFieldEnum = (typeof EquipmentHauledScalarFieldEnum)[keyof typeof EquipmentHauledScalarFieldEnum]


  export const TimeSheetChangeLogScalarFieldEnum: {
    id: 'id',
    timeSheetId: 'timeSheetId',
    changedBy: 'changedBy',
    changedAt: 'changedAt',
    changeReason: 'changeReason',
    changes: 'changes',
    wasStatusChange: 'wasStatusChange',
    numberOfChanges: 'numberOfChanges'
  };

  export type TimeSheetChangeLogScalarFieldEnum = (typeof TimeSheetChangeLogScalarFieldEnum)[keyof typeof TimeSheetChangeLogScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    username: 'username',
    email: 'email',
    password: 'password',
    signature: 'signature',
    DOB: 'DOB',
    truckView: 'truckView',
    tascoView: 'tascoView',
    laborView: 'laborView',
    mechanicView: 'mechanicView',
    permission: 'permission',
    image: 'image',
    startDate: 'startDate',
    terminationDate: 'terminationDate',
    accountSetup: 'accountSetup',
    clockedIn: 'clockedIn',
    companyId: 'companyId',
    passwordResetTokenId: 'passwordResetTokenId',
    workTypeId: 'workTypeId',
    middleName: 'middleName',
    secondLastName: 'secondLastName',
    lastSeen: 'lastSeen'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    language: 'language',
    generalReminders: 'generalReminders',
    personalReminders: 'personalReminders',
    cameraAccess: 'cameraAccess',
    locationAccess: 'locationAccess',
    cookiesAccess: 'cookiesAccess',
    createdAt: 'createdAt',
    lastUpdated: 'lastUpdated'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const ContactsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    phoneNumber: 'phoneNumber',
    emergencyContact: 'emergencyContact',
    emergencyContactNumber: 'emergencyContactNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactsScalarFieldEnum = (typeof ContactsScalarFieldEnum)[keyof typeof ContactsScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expiration: 'expiration'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const AccountSetupTokenScalarFieldEnum: {
    id: 'id',
    code: 'code',
    userId: 'userId',
    expiresAt: 'expiresAt',
    used: 'used'
  };

  export type AccountSetupTokenScalarFieldEnum = (typeof AccountSetupTokenScalarFieldEnum)[keyof typeof AccountSetupTokenScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    street: 'street',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    country: 'country'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const FCMTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    platform: 'platform',
    lastUsedAt: 'lastUsedAt',
    isValid: 'isValid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FCMTokenScalarFieldEnum = (typeof FCMTokenScalarFieldEnum)[keyof typeof FCMTokenScalarFieldEnum]


  export const TopicSubscriptionScalarFieldEnum: {
    id: 'id',
    topic: 'topic',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type TopicSubscriptionScalarFieldEnum = (typeof TopicSubscriptionScalarFieldEnum)[keyof typeof TopicSubscriptionScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    topic: 'topic',
    title: 'title',
    body: 'body',
    url: 'url',
    metadata: 'metadata',
    createdAt: 'createdAt',
    pushedAt: 'pushedAt',
    pushAttempts: 'pushAttempts',
    readAt: 'readAt',
    id: 'id',
    referenceId: 'referenceId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationResponseScalarFieldEnum: {
    id: 'id',
    notificationId: 'notificationId',
    userId: 'userId',
    response: 'response',
    respondedAt: 'respondedAt'
  };

  export type NotificationResponseScalarFieldEnum = (typeof NotificationResponseScalarFieldEnum)[keyof typeof NotificationResponseScalarFieldEnum]


  export const NotificationReadScalarFieldEnum: {
    id: 'id',
    notificationId: 'notificationId',
    userId: 'userId',
    readAt: 'readAt'
  };

  export type NotificationReadScalarFieldEnum = (typeof NotificationReadScalarFieldEnum)[keyof typeof NotificationReadScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'WorkType'
   */
  export type EnumWorkTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkType'>
    


  /**
   * Reference to a field of type 'WorkType[]'
   */
  export type ListEnumWorkTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkType[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'EquipmentTags'
   */
  export type EnumEquipmentTagsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentTags'>
    


  /**
   * Reference to a field of type 'EquipmentTags[]'
   */
  export type ListEnumEquipmentTagsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentTags[]'>
    


  /**
   * Reference to a field of type 'EquipmentState'
   */
  export type EnumEquipmentStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentState'>
    


  /**
   * Reference to a field of type 'EquipmentState[]'
   */
  export type ListEnumEquipmentStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentState[]'>
    


  /**
   * Reference to a field of type 'ApprovalStatus'
   */
  export type EnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus'>
    


  /**
   * Reference to a field of type 'ApprovalStatus[]'
   */
  export type ListEnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CreatedVia'
   */
  export type EnumCreatedViaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreatedVia'>
    


  /**
   * Reference to a field of type 'CreatedVia[]'
   */
  export type ListEnumCreatedViaFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreatedVia[]'>
    


  /**
   * Reference to a field of type 'OwnershipType'
   */
  export type EnumOwnershipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OwnershipType'>
    


  /**
   * Reference to a field of type 'OwnershipType[]'
   */
  export type ListEnumOwnershipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OwnershipType[]'>
    


  /**
   * Reference to a field of type 'Condition'
   */
  export type EnumConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Condition'>
    


  /**
   * Reference to a field of type 'Condition[]'
   */
  export type ListEnumConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Condition[]'>
    


  /**
   * Reference to a field of type 'FormTemplateStatus'
   */
  export type EnumFormTemplateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormTemplateStatus'>
    


  /**
   * Reference to a field of type 'FormTemplateStatus[]'
   */
  export type ListEnumFormTemplateStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormTemplateStatus[]'>
    


  /**
   * Reference to a field of type 'FormTemplateCategory'
   */
  export type EnumFormTemplateCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormTemplateCategory'>
    


  /**
   * Reference to a field of type 'FormTemplateCategory[]'
   */
  export type ListEnumFormTemplateCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormTemplateCategory[]'>
    


  /**
   * Reference to a field of type 'FieldType'
   */
  export type EnumFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FieldType'>
    


  /**
   * Reference to a field of type 'FieldType[]'
   */
  export type ListEnumFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FieldType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'FormStatus'
   */
  export type EnumFormStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormStatus'>
    


  /**
   * Reference to a field of type 'FormStatus[]'
   */
  export type ListEnumFormStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormStatus[]'>
    


  /**
   * Reference to a field of type 'ReportVisibility'
   */
  export type EnumReportVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportVisibility'>
    


  /**
   * Reference to a field of type 'ReportVisibility[]'
   */
  export type ListEnumReportVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportVisibility[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'LoadType'
   */
  export type EnumLoadTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoadType'>
    


  /**
   * Reference to a field of type 'LoadType[]'
   */
  export type ListEnumLoadTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LoadType[]'>
    


  /**
   * Reference to a field of type 'materialUnit'
   */
  export type EnummaterialUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'materialUnit'>
    


  /**
   * Reference to a field of type 'materialUnit[]'
   */
  export type ListEnummaterialUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'materialUnit[]'>
    


  /**
   * Reference to a field of type 'Permission'
   */
  export type EnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Permission'>
    


  /**
   * Reference to a field of type 'Permission[]'
   */
  export type ListEnumPermissionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Permission[]'>
    
  /**
   * Deep Input Types
   */


  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    addressId?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    SubscriptionDate?: DateTimeFilter<"Company"> | Date | string
    Address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    FormTemplates?: FormTemplateListRelationFilter
    Reports?: ReportListRelationFilter
    Users?: UserListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    addressId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    SubscriptionDate?: SortOrder
    Address?: AddressOrderByWithRelationInput
    FormTemplates?: FormTemplateOrderByRelationAggregateInput
    Reports?: ReportOrderByRelationAggregateInput
    Users?: UserOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    addressId?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    SubscriptionDate?: DateTimeFilter<"Company"> | Date | string
    Address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    FormTemplates?: FormTemplateListRelationFilter
    Reports?: ReportListRelationFilter
    Users?: UserListRelationFilter
  }, "id">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    addressId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    SubscriptionDate?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    addressId?: StringNullableWithAggregatesFilter<"Company"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    SubscriptionDate?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type CostCodeWhereInput = {
    AND?: CostCodeWhereInput | CostCodeWhereInput[]
    OR?: CostCodeWhereInput[]
    NOT?: CostCodeWhereInput | CostCodeWhereInput[]
    id?: StringFilter<"CostCode"> | string
    name?: StringFilter<"CostCode"> | string
    isActive?: BoolFilter<"CostCode"> | boolean
    createdAt?: DateTimeFilter<"CostCode"> | Date | string
    updatedAt?: DateTimeFilter<"CostCode"> | Date | string
    code?: StringNullableFilter<"CostCode"> | string | null
    Timesheets?: TimeSheetListRelationFilter
    CCTags?: CCTagListRelationFilter
  }

  export type CostCodeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrderInput | SortOrder
    Timesheets?: TimeSheetOrderByRelationAggregateInput
    CCTags?: CCTagOrderByRelationAggregateInput
  }

  export type CostCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CostCodeWhereInput | CostCodeWhereInput[]
    OR?: CostCodeWhereInput[]
    NOT?: CostCodeWhereInput | CostCodeWhereInput[]
    isActive?: BoolFilter<"CostCode"> | boolean
    createdAt?: DateTimeFilter<"CostCode"> | Date | string
    updatedAt?: DateTimeFilter<"CostCode"> | Date | string
    code?: StringNullableFilter<"CostCode"> | string | null
    Timesheets?: TimeSheetListRelationFilter
    CCTags?: CCTagListRelationFilter
  }, "id" | "name">

  export type CostCodeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrderInput | SortOrder
    _count?: CostCodeCountOrderByAggregateInput
    _max?: CostCodeMaxOrderByAggregateInput
    _min?: CostCodeMinOrderByAggregateInput
  }

  export type CostCodeScalarWhereWithAggregatesInput = {
    AND?: CostCodeScalarWhereWithAggregatesInput | CostCodeScalarWhereWithAggregatesInput[]
    OR?: CostCodeScalarWhereWithAggregatesInput[]
    NOT?: CostCodeScalarWhereWithAggregatesInput | CostCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CostCode"> | string
    name?: StringWithAggregatesFilter<"CostCode"> | string
    isActive?: BoolWithAggregatesFilter<"CostCode"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CostCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CostCode"> | Date | string
    code?: StringNullableWithAggregatesFilter<"CostCode"> | string | null
  }

  export type CCTagWhereInput = {
    AND?: CCTagWhereInput | CCTagWhereInput[]
    OR?: CCTagWhereInput[]
    NOT?: CCTagWhereInput | CCTagWhereInput[]
    id?: StringFilter<"CCTag"> | string
    name?: StringFilter<"CCTag"> | string
    description?: StringNullableFilter<"CCTag"> | string | null
    CostCodes?: CostCodeListRelationFilter
    Jobsites?: JobsiteListRelationFilter
  }

  export type CCTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    CostCodes?: CostCodeOrderByRelationAggregateInput
    Jobsites?: JobsiteOrderByRelationAggregateInput
  }

  export type CCTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CCTagWhereInput | CCTagWhereInput[]
    OR?: CCTagWhereInput[]
    NOT?: CCTagWhereInput | CCTagWhereInput[]
    description?: StringNullableFilter<"CCTag"> | string | null
    CostCodes?: CostCodeListRelationFilter
    Jobsites?: JobsiteListRelationFilter
  }, "id" | "name">

  export type CCTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: CCTagCountOrderByAggregateInput
    _max?: CCTagMaxOrderByAggregateInput
    _min?: CCTagMinOrderByAggregateInput
  }

  export type CCTagScalarWhereWithAggregatesInput = {
    AND?: CCTagScalarWhereWithAggregatesInput | CCTagScalarWhereWithAggregatesInput[]
    OR?: CCTagScalarWhereWithAggregatesInput[]
    NOT?: CCTagScalarWhereWithAggregatesInput | CCTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CCTag"> | string
    name?: StringWithAggregatesFilter<"CCTag"> | string
    description?: StringNullableWithAggregatesFilter<"CCTag"> | string | null
  }

  export type CrewWhereInput = {
    AND?: CrewWhereInput | CrewWhereInput[]
    OR?: CrewWhereInput[]
    NOT?: CrewWhereInput | CrewWhereInput[]
    id?: StringFilter<"Crew"> | string
    name?: StringFilter<"Crew"> | string
    leadId?: StringFilter<"Crew"> | string
    crewType?: EnumWorkTypeFilter<"Crew"> | $Enums.WorkType
    createdAt?: DateTimeFilter<"Crew"> | Date | string
    updatedAt?: DateTimeFilter<"Crew"> | Date | string
    Users?: UserListRelationFilter
  }

  export type CrewOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    leadId?: SortOrder
    crewType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Users?: UserOrderByRelationAggregateInput
  }

  export type CrewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CrewWhereInput | CrewWhereInput[]
    OR?: CrewWhereInput[]
    NOT?: CrewWhereInput | CrewWhereInput[]
    name?: StringFilter<"Crew"> | string
    leadId?: StringFilter<"Crew"> | string
    crewType?: EnumWorkTypeFilter<"Crew"> | $Enums.WorkType
    createdAt?: DateTimeFilter<"Crew"> | Date | string
    updatedAt?: DateTimeFilter<"Crew"> | Date | string
    Users?: UserListRelationFilter
  }, "id">

  export type CrewOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    leadId?: SortOrder
    crewType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CrewCountOrderByAggregateInput
    _max?: CrewMaxOrderByAggregateInput
    _min?: CrewMinOrderByAggregateInput
  }

  export type CrewScalarWhereWithAggregatesInput = {
    AND?: CrewScalarWhereWithAggregatesInput | CrewScalarWhereWithAggregatesInput[]
    OR?: CrewScalarWhereWithAggregatesInput[]
    NOT?: CrewScalarWhereWithAggregatesInput | CrewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Crew"> | string
    name?: StringWithAggregatesFilter<"Crew"> | string
    leadId?: StringWithAggregatesFilter<"Crew"> | string
    crewType?: EnumWorkTypeWithAggregatesFilter<"Crew"> | $Enums.WorkType
    createdAt?: DateTimeWithAggregatesFilter<"Crew"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Crew"> | Date | string
  }

  export type PdfDocumentWhereInput = {
    AND?: PdfDocumentWhereInput | PdfDocumentWhereInput[]
    OR?: PdfDocumentWhereInput[]
    NOT?: PdfDocumentWhereInput | PdfDocumentWhereInput[]
    id?: StringFilter<"PdfDocument"> | string
    qrId?: StringFilter<"PdfDocument"> | string
    fileName?: StringFilter<"PdfDocument"> | string
    description?: StringNullableFilter<"PdfDocument"> | string | null
    fileData?: BytesFilter<"PdfDocument"> | Bytes
    contentType?: StringFilter<"PdfDocument"> | string
    size?: IntFilter<"PdfDocument"> | number
    isActive?: BoolFilter<"PdfDocument"> | boolean
    createdAt?: DateTimeFilter<"PdfDocument"> | Date | string
    uploadDate?: DateTimeFilter<"PdfDocument"> | Date | string
    DocumentTags?: DocumentTagListRelationFilter
  }

  export type PdfDocumentOrderByWithRelationInput = {
    id?: SortOrder
    qrId?: SortOrder
    fileName?: SortOrder
    description?: SortOrderInput | SortOrder
    fileData?: SortOrder
    contentType?: SortOrder
    size?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    uploadDate?: SortOrder
    DocumentTags?: DocumentTagOrderByRelationAggregateInput
  }

  export type PdfDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    qrId?: string
    AND?: PdfDocumentWhereInput | PdfDocumentWhereInput[]
    OR?: PdfDocumentWhereInput[]
    NOT?: PdfDocumentWhereInput | PdfDocumentWhereInput[]
    fileName?: StringFilter<"PdfDocument"> | string
    description?: StringNullableFilter<"PdfDocument"> | string | null
    fileData?: BytesFilter<"PdfDocument"> | Bytes
    contentType?: StringFilter<"PdfDocument"> | string
    size?: IntFilter<"PdfDocument"> | number
    isActive?: BoolFilter<"PdfDocument"> | boolean
    createdAt?: DateTimeFilter<"PdfDocument"> | Date | string
    uploadDate?: DateTimeFilter<"PdfDocument"> | Date | string
    DocumentTags?: DocumentTagListRelationFilter
  }, "id" | "qrId">

  export type PdfDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    qrId?: SortOrder
    fileName?: SortOrder
    description?: SortOrderInput | SortOrder
    fileData?: SortOrder
    contentType?: SortOrder
    size?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    uploadDate?: SortOrder
    _count?: PdfDocumentCountOrderByAggregateInput
    _avg?: PdfDocumentAvgOrderByAggregateInput
    _max?: PdfDocumentMaxOrderByAggregateInput
    _min?: PdfDocumentMinOrderByAggregateInput
    _sum?: PdfDocumentSumOrderByAggregateInput
  }

  export type PdfDocumentScalarWhereWithAggregatesInput = {
    AND?: PdfDocumentScalarWhereWithAggregatesInput | PdfDocumentScalarWhereWithAggregatesInput[]
    OR?: PdfDocumentScalarWhereWithAggregatesInput[]
    NOT?: PdfDocumentScalarWhereWithAggregatesInput | PdfDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PdfDocument"> | string
    qrId?: StringWithAggregatesFilter<"PdfDocument"> | string
    fileName?: StringWithAggregatesFilter<"PdfDocument"> | string
    description?: StringNullableWithAggregatesFilter<"PdfDocument"> | string | null
    fileData?: BytesWithAggregatesFilter<"PdfDocument"> | Bytes
    contentType?: StringWithAggregatesFilter<"PdfDocument"> | string
    size?: IntWithAggregatesFilter<"PdfDocument"> | number
    isActive?: BoolWithAggregatesFilter<"PdfDocument"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PdfDocument"> | Date | string
    uploadDate?: DateTimeWithAggregatesFilter<"PdfDocument"> | Date | string
  }

  export type DocumentTagWhereInput = {
    AND?: DocumentTagWhereInput | DocumentTagWhereInput[]
    OR?: DocumentTagWhereInput[]
    NOT?: DocumentTagWhereInput | DocumentTagWhereInput[]
    id?: StringFilter<"DocumentTag"> | string
    tagName?: StringFilter<"DocumentTag"> | string
    Equipment?: EquipmentListRelationFilter
    Documents?: PdfDocumentListRelationFilter
  }

  export type DocumentTagOrderByWithRelationInput = {
    id?: SortOrder
    tagName?: SortOrder
    Equipment?: EquipmentOrderByRelationAggregateInput
    Documents?: PdfDocumentOrderByRelationAggregateInput
  }

  export type DocumentTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentTagWhereInput | DocumentTagWhereInput[]
    OR?: DocumentTagWhereInput[]
    NOT?: DocumentTagWhereInput | DocumentTagWhereInput[]
    tagName?: StringFilter<"DocumentTag"> | string
    Equipment?: EquipmentListRelationFilter
    Documents?: PdfDocumentListRelationFilter
  }, "id">

  export type DocumentTagOrderByWithAggregationInput = {
    id?: SortOrder
    tagName?: SortOrder
    _count?: DocumentTagCountOrderByAggregateInput
    _max?: DocumentTagMaxOrderByAggregateInput
    _min?: DocumentTagMinOrderByAggregateInput
  }

  export type DocumentTagScalarWhereWithAggregatesInput = {
    AND?: DocumentTagScalarWhereWithAggregatesInput | DocumentTagScalarWhereWithAggregatesInput[]
    OR?: DocumentTagScalarWhereWithAggregatesInput[]
    NOT?: DocumentTagScalarWhereWithAggregatesInput | DocumentTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentTag"> | string
    tagName?: StringWithAggregatesFilter<"DocumentTag"> | string
  }

  export type EquipmentWhereInput = {
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    id?: StringFilter<"Equipment"> | string
    qrId?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    description?: StringNullableFilter<"Equipment"> | string | null
    creationReason?: StringNullableFilter<"Equipment"> | string | null
    equipmentTag?: EnumEquipmentTagsFilter<"Equipment"> | $Enums.EquipmentTags
    state?: EnumEquipmentStateFilter<"Equipment"> | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFilter<"Equipment"> | $Enums.ApprovalStatus
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    overWeight?: BoolNullableFilter<"Equipment"> | boolean | null
    currentWeight?: FloatNullableFilter<"Equipment"> | number | null
    createdById?: StringNullableFilter<"Equipment"> | string | null
    createdVia?: EnumCreatedViaFilter<"Equipment"> | $Enums.CreatedVia
    acquiredDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    code?: StringNullableFilter<"Equipment"> | string | null
    color?: StringNullableFilter<"Equipment"> | string | null
    licensePlate?: StringNullableFilter<"Equipment"> | string | null
    licenseState?: StringNullableFilter<"Equipment"> | string | null
    make?: StringNullableFilter<"Equipment"> | string | null
    memo?: StringNullableFilter<"Equipment"> | string | null
    model?: StringNullableFilter<"Equipment"> | string | null
    ownershipType?: EnumOwnershipTypeNullableFilter<"Equipment"> | $Enums.OwnershipType | null
    registrationExpiration?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    serialNumber?: StringNullableFilter<"Equipment"> | string | null
    year?: StringNullableFilter<"Equipment"> | string | null
    acquiredCondition?: EnumConditionNullableFilter<"Equipment"> | $Enums.Condition | null
    status?: EnumFormTemplateStatusFilter<"Equipment"> | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogListRelationFilter
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    EquipmentHauled?: EquipmentHauledListRelationFilter
    Maintenances?: MaintenanceListRelationFilter
    TascoLogs?: TascoLogListRelationFilter
    HauledInLogs?: TruckingLogListRelationFilter
    UsedAsTrailer?: TruckingLogListRelationFilter
    UsedAsTruck?: TruckingLogListRelationFilter
    Maintenance?: MechanicProjectsListRelationFilter
    DocumentTags?: DocumentTagListRelationFilter
  }

  export type EquipmentOrderByWithRelationInput = {
    id?: SortOrder
    qrId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    creationReason?: SortOrderInput | SortOrder
    equipmentTag?: SortOrder
    state?: SortOrder
    approvalStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    overWeight?: SortOrderInput | SortOrder
    currentWeight?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdVia?: SortOrder
    acquiredDate?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    licensePlate?: SortOrderInput | SortOrder
    licenseState?: SortOrderInput | SortOrder
    make?: SortOrderInput | SortOrder
    memo?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    ownershipType?: SortOrderInput | SortOrder
    registrationExpiration?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    acquiredCondition?: SortOrderInput | SortOrder
    status?: SortOrder
    EmployeeEquipmentLogs?: EmployeeEquipmentLogOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
    EquipmentHauled?: EquipmentHauledOrderByRelationAggregateInput
    Maintenances?: MaintenanceOrderByRelationAggregateInput
    TascoLogs?: TascoLogOrderByRelationAggregateInput
    HauledInLogs?: TruckingLogOrderByRelationAggregateInput
    UsedAsTrailer?: TruckingLogOrderByRelationAggregateInput
    UsedAsTruck?: TruckingLogOrderByRelationAggregateInput
    Maintenance?: mechanicProjectsOrderByRelationAggregateInput
    DocumentTags?: DocumentTagOrderByRelationAggregateInput
  }

  export type EquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    qrId?: string
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    name?: StringFilter<"Equipment"> | string
    description?: StringNullableFilter<"Equipment"> | string | null
    creationReason?: StringNullableFilter<"Equipment"> | string | null
    equipmentTag?: EnumEquipmentTagsFilter<"Equipment"> | $Enums.EquipmentTags
    state?: EnumEquipmentStateFilter<"Equipment"> | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFilter<"Equipment"> | $Enums.ApprovalStatus
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    overWeight?: BoolNullableFilter<"Equipment"> | boolean | null
    currentWeight?: FloatNullableFilter<"Equipment"> | number | null
    createdById?: StringNullableFilter<"Equipment"> | string | null
    createdVia?: EnumCreatedViaFilter<"Equipment"> | $Enums.CreatedVia
    acquiredDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    code?: StringNullableFilter<"Equipment"> | string | null
    color?: StringNullableFilter<"Equipment"> | string | null
    licensePlate?: StringNullableFilter<"Equipment"> | string | null
    licenseState?: StringNullableFilter<"Equipment"> | string | null
    make?: StringNullableFilter<"Equipment"> | string | null
    memo?: StringNullableFilter<"Equipment"> | string | null
    model?: StringNullableFilter<"Equipment"> | string | null
    ownershipType?: EnumOwnershipTypeNullableFilter<"Equipment"> | $Enums.OwnershipType | null
    registrationExpiration?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    serialNumber?: StringNullableFilter<"Equipment"> | string | null
    year?: StringNullableFilter<"Equipment"> | string | null
    acquiredCondition?: EnumConditionNullableFilter<"Equipment"> | $Enums.Condition | null
    status?: EnumFormTemplateStatusFilter<"Equipment"> | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogListRelationFilter
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    EquipmentHauled?: EquipmentHauledListRelationFilter
    Maintenances?: MaintenanceListRelationFilter
    TascoLogs?: TascoLogListRelationFilter
    HauledInLogs?: TruckingLogListRelationFilter
    UsedAsTrailer?: TruckingLogListRelationFilter
    UsedAsTruck?: TruckingLogListRelationFilter
    Maintenance?: MechanicProjectsListRelationFilter
    DocumentTags?: DocumentTagListRelationFilter
  }, "id" | "qrId">

  export type EquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    qrId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    creationReason?: SortOrderInput | SortOrder
    equipmentTag?: SortOrder
    state?: SortOrder
    approvalStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    overWeight?: SortOrderInput | SortOrder
    currentWeight?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdVia?: SortOrder
    acquiredDate?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    licensePlate?: SortOrderInput | SortOrder
    licenseState?: SortOrderInput | SortOrder
    make?: SortOrderInput | SortOrder
    memo?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    ownershipType?: SortOrderInput | SortOrder
    registrationExpiration?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    acquiredCondition?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: EquipmentCountOrderByAggregateInput
    _avg?: EquipmentAvgOrderByAggregateInput
    _max?: EquipmentMaxOrderByAggregateInput
    _min?: EquipmentMinOrderByAggregateInput
    _sum?: EquipmentSumOrderByAggregateInput
  }

  export type EquipmentScalarWhereWithAggregatesInput = {
    AND?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    OR?: EquipmentScalarWhereWithAggregatesInput[]
    NOT?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Equipment"> | string
    qrId?: StringWithAggregatesFilter<"Equipment"> | string
    name?: StringWithAggregatesFilter<"Equipment"> | string
    description?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    creationReason?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    equipmentTag?: EnumEquipmentTagsWithAggregatesFilter<"Equipment"> | $Enums.EquipmentTags
    state?: EnumEquipmentStateWithAggregatesFilter<"Equipment"> | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusWithAggregatesFilter<"Equipment"> | $Enums.ApprovalStatus
    createdAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
    overWeight?: BoolNullableWithAggregatesFilter<"Equipment"> | boolean | null
    currentWeight?: FloatNullableWithAggregatesFilter<"Equipment"> | number | null
    createdById?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    createdVia?: EnumCreatedViaWithAggregatesFilter<"Equipment"> | $Enums.CreatedVia
    acquiredDate?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    code?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    color?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    licensePlate?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    licenseState?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    make?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    memo?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    model?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    ownershipType?: EnumOwnershipTypeNullableWithAggregatesFilter<"Equipment"> | $Enums.OwnershipType | null
    registrationExpiration?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    serialNumber?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    year?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    acquiredCondition?: EnumConditionNullableWithAggregatesFilter<"Equipment"> | $Enums.Condition | null
    status?: EnumFormTemplateStatusWithAggregatesFilter<"Equipment"> | $Enums.FormTemplateStatus
  }

  export type EmployeeEquipmentLogWhereInput = {
    AND?: EmployeeEquipmentLogWhereInput | EmployeeEquipmentLogWhereInput[]
    OR?: EmployeeEquipmentLogWhereInput[]
    NOT?: EmployeeEquipmentLogWhereInput | EmployeeEquipmentLogWhereInput[]
    id?: StringFilter<"EmployeeEquipmentLog"> | string
    equipmentId?: StringNullableFilter<"EmployeeEquipmentLog"> | string | null
    maintenanceId?: StringNullableFilter<"EmployeeEquipmentLog"> | string | null
    startTime?: DateTimeFilter<"EmployeeEquipmentLog"> | Date | string
    endTime?: DateTimeNullableFilter<"EmployeeEquipmentLog"> | Date | string | null
    comment?: StringNullableFilter<"EmployeeEquipmentLog"> | string | null
    timeSheetId?: IntFilter<"EmployeeEquipmentLog"> | number
    rental?: BoolFilter<"EmployeeEquipmentLog"> | boolean
    Equipment?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
    Maintenance?: XOR<MaintenanceNullableScalarRelationFilter, MaintenanceWhereInput> | null
    TimeSheet?: XOR<TimeSheetScalarRelationFilter, TimeSheetWhereInput>
    RefuelLog?: XOR<RefuelLogNullableScalarRelationFilter, RefuelLogWhereInput> | null
  }

  export type EmployeeEquipmentLogOrderByWithRelationInput = {
    id?: SortOrder
    equipmentId?: SortOrderInput | SortOrder
    maintenanceId?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    timeSheetId?: SortOrder
    rental?: SortOrder
    Equipment?: EquipmentOrderByWithRelationInput
    Maintenance?: MaintenanceOrderByWithRelationInput
    TimeSheet?: TimeSheetOrderByWithRelationInput
    RefuelLog?: RefuelLogOrderByWithRelationInput
  }

  export type EmployeeEquipmentLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeeEquipmentLogWhereInput | EmployeeEquipmentLogWhereInput[]
    OR?: EmployeeEquipmentLogWhereInput[]
    NOT?: EmployeeEquipmentLogWhereInput | EmployeeEquipmentLogWhereInput[]
    equipmentId?: StringNullableFilter<"EmployeeEquipmentLog"> | string | null
    maintenanceId?: StringNullableFilter<"EmployeeEquipmentLog"> | string | null
    startTime?: DateTimeFilter<"EmployeeEquipmentLog"> | Date | string
    endTime?: DateTimeNullableFilter<"EmployeeEquipmentLog"> | Date | string | null
    comment?: StringNullableFilter<"EmployeeEquipmentLog"> | string | null
    timeSheetId?: IntFilter<"EmployeeEquipmentLog"> | number
    rental?: BoolFilter<"EmployeeEquipmentLog"> | boolean
    Equipment?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
    Maintenance?: XOR<MaintenanceNullableScalarRelationFilter, MaintenanceWhereInput> | null
    TimeSheet?: XOR<TimeSheetScalarRelationFilter, TimeSheetWhereInput>
    RefuelLog?: XOR<RefuelLogNullableScalarRelationFilter, RefuelLogWhereInput> | null
  }, "id">

  export type EmployeeEquipmentLogOrderByWithAggregationInput = {
    id?: SortOrder
    equipmentId?: SortOrderInput | SortOrder
    maintenanceId?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    timeSheetId?: SortOrder
    rental?: SortOrder
    _count?: EmployeeEquipmentLogCountOrderByAggregateInput
    _avg?: EmployeeEquipmentLogAvgOrderByAggregateInput
    _max?: EmployeeEquipmentLogMaxOrderByAggregateInput
    _min?: EmployeeEquipmentLogMinOrderByAggregateInput
    _sum?: EmployeeEquipmentLogSumOrderByAggregateInput
  }

  export type EmployeeEquipmentLogScalarWhereWithAggregatesInput = {
    AND?: EmployeeEquipmentLogScalarWhereWithAggregatesInput | EmployeeEquipmentLogScalarWhereWithAggregatesInput[]
    OR?: EmployeeEquipmentLogScalarWhereWithAggregatesInput[]
    NOT?: EmployeeEquipmentLogScalarWhereWithAggregatesInput | EmployeeEquipmentLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeEquipmentLog"> | string
    equipmentId?: StringNullableWithAggregatesFilter<"EmployeeEquipmentLog"> | string | null
    maintenanceId?: StringNullableWithAggregatesFilter<"EmployeeEquipmentLog"> | string | null
    startTime?: DateTimeWithAggregatesFilter<"EmployeeEquipmentLog"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"EmployeeEquipmentLog"> | Date | string | null
    comment?: StringNullableWithAggregatesFilter<"EmployeeEquipmentLog"> | string | null
    timeSheetId?: IntWithAggregatesFilter<"EmployeeEquipmentLog"> | number
    rental?: BoolWithAggregatesFilter<"EmployeeEquipmentLog"> | boolean
  }

  export type FormTemplateWhereInput = {
    AND?: FormTemplateWhereInput | FormTemplateWhereInput[]
    OR?: FormTemplateWhereInput[]
    NOT?: FormTemplateWhereInput | FormTemplateWhereInput[]
    id?: StringFilter<"FormTemplate"> | string
    companyId?: StringFilter<"FormTemplate"> | string
    name?: StringFilter<"FormTemplate"> | string
    createdAt?: DateTimeFilter<"FormTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"FormTemplate"> | Date | string
    isSignatureRequired?: BoolFilter<"FormTemplate"> | boolean
    description?: StringNullableFilter<"FormTemplate"> | string | null
    isActive?: EnumFormTemplateStatusFilter<"FormTemplate"> | $Enums.FormTemplateStatus
    formType?: EnumFormTemplateCategoryFilter<"FormTemplate"> | $Enums.FormTemplateCategory
    isApprovalRequired?: BoolFilter<"FormTemplate"> | boolean
    Submissions?: FormSubmissionListRelationFilter
    Company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    FormGrouping?: FormGroupingListRelationFilter
  }

  export type FormTemplateOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSignatureRequired?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    formType?: SortOrder
    isApprovalRequired?: SortOrder
    Submissions?: FormSubmissionOrderByRelationAggregateInput
    Company?: CompanyOrderByWithRelationInput
    FormGrouping?: FormGroupingOrderByRelationAggregateInput
  }

  export type FormTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormTemplateWhereInput | FormTemplateWhereInput[]
    OR?: FormTemplateWhereInput[]
    NOT?: FormTemplateWhereInput | FormTemplateWhereInput[]
    companyId?: StringFilter<"FormTemplate"> | string
    name?: StringFilter<"FormTemplate"> | string
    createdAt?: DateTimeFilter<"FormTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"FormTemplate"> | Date | string
    isSignatureRequired?: BoolFilter<"FormTemplate"> | boolean
    description?: StringNullableFilter<"FormTemplate"> | string | null
    isActive?: EnumFormTemplateStatusFilter<"FormTemplate"> | $Enums.FormTemplateStatus
    formType?: EnumFormTemplateCategoryFilter<"FormTemplate"> | $Enums.FormTemplateCategory
    isApprovalRequired?: BoolFilter<"FormTemplate"> | boolean
    Submissions?: FormSubmissionListRelationFilter
    Company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    FormGrouping?: FormGroupingListRelationFilter
  }, "id">

  export type FormTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSignatureRequired?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    formType?: SortOrder
    isApprovalRequired?: SortOrder
    _count?: FormTemplateCountOrderByAggregateInput
    _max?: FormTemplateMaxOrderByAggregateInput
    _min?: FormTemplateMinOrderByAggregateInput
  }

  export type FormTemplateScalarWhereWithAggregatesInput = {
    AND?: FormTemplateScalarWhereWithAggregatesInput | FormTemplateScalarWhereWithAggregatesInput[]
    OR?: FormTemplateScalarWhereWithAggregatesInput[]
    NOT?: FormTemplateScalarWhereWithAggregatesInput | FormTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormTemplate"> | string
    companyId?: StringWithAggregatesFilter<"FormTemplate"> | string
    name?: StringWithAggregatesFilter<"FormTemplate"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FormTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FormTemplate"> | Date | string
    isSignatureRequired?: BoolWithAggregatesFilter<"FormTemplate"> | boolean
    description?: StringNullableWithAggregatesFilter<"FormTemplate"> | string | null
    isActive?: EnumFormTemplateStatusWithAggregatesFilter<"FormTemplate"> | $Enums.FormTemplateStatus
    formType?: EnumFormTemplateCategoryWithAggregatesFilter<"FormTemplate"> | $Enums.FormTemplateCategory
    isApprovalRequired?: BoolWithAggregatesFilter<"FormTemplate"> | boolean
  }

  export type FormGroupingWhereInput = {
    AND?: FormGroupingWhereInput | FormGroupingWhereInput[]
    OR?: FormGroupingWhereInput[]
    NOT?: FormGroupingWhereInput | FormGroupingWhereInput[]
    id?: StringFilter<"FormGrouping"> | string
    title?: StringNullableFilter<"FormGrouping"> | string | null
    order?: IntFilter<"FormGrouping"> | number
    Fields?: FormFieldListRelationFilter
    FormTemplate?: FormTemplateListRelationFilter
  }

  export type FormGroupingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    order?: SortOrder
    Fields?: FormFieldOrderByRelationAggregateInput
    FormTemplate?: FormTemplateOrderByRelationAggregateInput
  }

  export type FormGroupingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormGroupingWhereInput | FormGroupingWhereInput[]
    OR?: FormGroupingWhereInput[]
    NOT?: FormGroupingWhereInput | FormGroupingWhereInput[]
    title?: StringNullableFilter<"FormGrouping"> | string | null
    order?: IntFilter<"FormGrouping"> | number
    Fields?: FormFieldListRelationFilter
    FormTemplate?: FormTemplateListRelationFilter
  }, "id">

  export type FormGroupingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    order?: SortOrder
    _count?: FormGroupingCountOrderByAggregateInput
    _avg?: FormGroupingAvgOrderByAggregateInput
    _max?: FormGroupingMaxOrderByAggregateInput
    _min?: FormGroupingMinOrderByAggregateInput
    _sum?: FormGroupingSumOrderByAggregateInput
  }

  export type FormGroupingScalarWhereWithAggregatesInput = {
    AND?: FormGroupingScalarWhereWithAggregatesInput | FormGroupingScalarWhereWithAggregatesInput[]
    OR?: FormGroupingScalarWhereWithAggregatesInput[]
    NOT?: FormGroupingScalarWhereWithAggregatesInput | FormGroupingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormGrouping"> | string
    title?: StringNullableWithAggregatesFilter<"FormGrouping"> | string | null
    order?: IntWithAggregatesFilter<"FormGrouping"> | number
  }

  export type FormFieldWhereInput = {
    AND?: FormFieldWhereInput | FormFieldWhereInput[]
    OR?: FormFieldWhereInput[]
    NOT?: FormFieldWhereInput | FormFieldWhereInput[]
    id?: StringFilter<"FormField"> | string
    formGroupingId?: StringFilter<"FormField"> | string
    label?: StringFilter<"FormField"> | string
    type?: EnumFieldTypeFilter<"FormField"> | $Enums.FieldType
    required?: BoolFilter<"FormField"> | boolean
    order?: IntFilter<"FormField"> | number
    placeholder?: StringNullableFilter<"FormField"> | string | null
    maxLength?: IntNullableFilter<"FormField"> | number | null
    content?: StringNullableFilter<"FormField"> | string | null
    filter?: StringNullableFilter<"FormField"> | string | null
    minLength?: IntNullableFilter<"FormField"> | number | null
    multiple?: BoolNullableFilter<"FormField"> | boolean | null
    FormGrouping?: XOR<FormGroupingScalarRelationFilter, FormGroupingWhereInput>
    Options?: FormFieldOptionListRelationFilter
  }

  export type FormFieldOrderByWithRelationInput = {
    id?: SortOrder
    formGroupingId?: SortOrder
    label?: SortOrder
    type?: SortOrder
    required?: SortOrder
    order?: SortOrder
    placeholder?: SortOrderInput | SortOrder
    maxLength?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    filter?: SortOrderInput | SortOrder
    minLength?: SortOrderInput | SortOrder
    multiple?: SortOrderInput | SortOrder
    FormGrouping?: FormGroupingOrderByWithRelationInput
    Options?: FormFieldOptionOrderByRelationAggregateInput
  }

  export type FormFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormFieldWhereInput | FormFieldWhereInput[]
    OR?: FormFieldWhereInput[]
    NOT?: FormFieldWhereInput | FormFieldWhereInput[]
    formGroupingId?: StringFilter<"FormField"> | string
    label?: StringFilter<"FormField"> | string
    type?: EnumFieldTypeFilter<"FormField"> | $Enums.FieldType
    required?: BoolFilter<"FormField"> | boolean
    order?: IntFilter<"FormField"> | number
    placeholder?: StringNullableFilter<"FormField"> | string | null
    maxLength?: IntNullableFilter<"FormField"> | number | null
    content?: StringNullableFilter<"FormField"> | string | null
    filter?: StringNullableFilter<"FormField"> | string | null
    minLength?: IntNullableFilter<"FormField"> | number | null
    multiple?: BoolNullableFilter<"FormField"> | boolean | null
    FormGrouping?: XOR<FormGroupingScalarRelationFilter, FormGroupingWhereInput>
    Options?: FormFieldOptionListRelationFilter
  }, "id">

  export type FormFieldOrderByWithAggregationInput = {
    id?: SortOrder
    formGroupingId?: SortOrder
    label?: SortOrder
    type?: SortOrder
    required?: SortOrder
    order?: SortOrder
    placeholder?: SortOrderInput | SortOrder
    maxLength?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    filter?: SortOrderInput | SortOrder
    minLength?: SortOrderInput | SortOrder
    multiple?: SortOrderInput | SortOrder
    _count?: FormFieldCountOrderByAggregateInput
    _avg?: FormFieldAvgOrderByAggregateInput
    _max?: FormFieldMaxOrderByAggregateInput
    _min?: FormFieldMinOrderByAggregateInput
    _sum?: FormFieldSumOrderByAggregateInput
  }

  export type FormFieldScalarWhereWithAggregatesInput = {
    AND?: FormFieldScalarWhereWithAggregatesInput | FormFieldScalarWhereWithAggregatesInput[]
    OR?: FormFieldScalarWhereWithAggregatesInput[]
    NOT?: FormFieldScalarWhereWithAggregatesInput | FormFieldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormField"> | string
    formGroupingId?: StringWithAggregatesFilter<"FormField"> | string
    label?: StringWithAggregatesFilter<"FormField"> | string
    type?: EnumFieldTypeWithAggregatesFilter<"FormField"> | $Enums.FieldType
    required?: BoolWithAggregatesFilter<"FormField"> | boolean
    order?: IntWithAggregatesFilter<"FormField"> | number
    placeholder?: StringNullableWithAggregatesFilter<"FormField"> | string | null
    maxLength?: IntNullableWithAggregatesFilter<"FormField"> | number | null
    content?: StringNullableWithAggregatesFilter<"FormField"> | string | null
    filter?: StringNullableWithAggregatesFilter<"FormField"> | string | null
    minLength?: IntNullableWithAggregatesFilter<"FormField"> | number | null
    multiple?: BoolNullableWithAggregatesFilter<"FormField"> | boolean | null
  }

  export type FormFieldOptionWhereInput = {
    AND?: FormFieldOptionWhereInput | FormFieldOptionWhereInput[]
    OR?: FormFieldOptionWhereInput[]
    NOT?: FormFieldOptionWhereInput | FormFieldOptionWhereInput[]
    id?: StringFilter<"FormFieldOption"> | string
    fieldId?: StringFilter<"FormFieldOption"> | string
    value?: StringFilter<"FormFieldOption"> | string
    Field?: XOR<FormFieldScalarRelationFilter, FormFieldWhereInput>
  }

  export type FormFieldOptionOrderByWithRelationInput = {
    id?: SortOrder
    fieldId?: SortOrder
    value?: SortOrder
    Field?: FormFieldOrderByWithRelationInput
  }

  export type FormFieldOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormFieldOptionWhereInput | FormFieldOptionWhereInput[]
    OR?: FormFieldOptionWhereInput[]
    NOT?: FormFieldOptionWhereInput | FormFieldOptionWhereInput[]
    fieldId?: StringFilter<"FormFieldOption"> | string
    value?: StringFilter<"FormFieldOption"> | string
    Field?: XOR<FormFieldScalarRelationFilter, FormFieldWhereInput>
  }, "id">

  export type FormFieldOptionOrderByWithAggregationInput = {
    id?: SortOrder
    fieldId?: SortOrder
    value?: SortOrder
    _count?: FormFieldOptionCountOrderByAggregateInput
    _max?: FormFieldOptionMaxOrderByAggregateInput
    _min?: FormFieldOptionMinOrderByAggregateInput
  }

  export type FormFieldOptionScalarWhereWithAggregatesInput = {
    AND?: FormFieldOptionScalarWhereWithAggregatesInput | FormFieldOptionScalarWhereWithAggregatesInput[]
    OR?: FormFieldOptionScalarWhereWithAggregatesInput[]
    NOT?: FormFieldOptionScalarWhereWithAggregatesInput | FormFieldOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormFieldOption"> | string
    fieldId?: StringWithAggregatesFilter<"FormFieldOption"> | string
    value?: StringWithAggregatesFilter<"FormFieldOption"> | string
  }

  export type FormSubmissionWhereInput = {
    AND?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    OR?: FormSubmissionWhereInput[]
    NOT?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    title?: StringNullableFilter<"FormSubmission"> | string | null
    formTemplateId?: StringFilter<"FormSubmission"> | string
    userId?: StringFilter<"FormSubmission"> | string
    formType?: StringNullableFilter<"FormSubmission"> | string | null
    data?: JsonNullableFilter<"FormSubmission">
    createdAt?: DateTimeFilter<"FormSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"FormSubmission"> | Date | string
    submittedAt?: DateTimeNullableFilter<"FormSubmission"> | Date | string | null
    status?: EnumFormStatusFilter<"FormSubmission"> | $Enums.FormStatus
    id?: IntFilter<"FormSubmission"> | number
    Approvals?: FormApprovalListRelationFilter
    FormTemplate?: XOR<FormTemplateScalarRelationFilter, FormTemplateWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FormSubmissionOrderByWithRelationInput = {
    title?: SortOrderInput | SortOrder
    formTemplateId?: SortOrder
    userId?: SortOrder
    formType?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    id?: SortOrder
    Approvals?: FormApprovalOrderByRelationAggregateInput
    FormTemplate?: FormTemplateOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type FormSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    OR?: FormSubmissionWhereInput[]
    NOT?: FormSubmissionWhereInput | FormSubmissionWhereInput[]
    title?: StringNullableFilter<"FormSubmission"> | string | null
    formTemplateId?: StringFilter<"FormSubmission"> | string
    userId?: StringFilter<"FormSubmission"> | string
    formType?: StringNullableFilter<"FormSubmission"> | string | null
    data?: JsonNullableFilter<"FormSubmission">
    createdAt?: DateTimeFilter<"FormSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"FormSubmission"> | Date | string
    submittedAt?: DateTimeNullableFilter<"FormSubmission"> | Date | string | null
    status?: EnumFormStatusFilter<"FormSubmission"> | $Enums.FormStatus
    Approvals?: FormApprovalListRelationFilter
    FormTemplate?: XOR<FormTemplateScalarRelationFilter, FormTemplateWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FormSubmissionOrderByWithAggregationInput = {
    title?: SortOrderInput | SortOrder
    formTemplateId?: SortOrder
    userId?: SortOrder
    formType?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    id?: SortOrder
    _count?: FormSubmissionCountOrderByAggregateInput
    _avg?: FormSubmissionAvgOrderByAggregateInput
    _max?: FormSubmissionMaxOrderByAggregateInput
    _min?: FormSubmissionMinOrderByAggregateInput
    _sum?: FormSubmissionSumOrderByAggregateInput
  }

  export type FormSubmissionScalarWhereWithAggregatesInput = {
    AND?: FormSubmissionScalarWhereWithAggregatesInput | FormSubmissionScalarWhereWithAggregatesInput[]
    OR?: FormSubmissionScalarWhereWithAggregatesInput[]
    NOT?: FormSubmissionScalarWhereWithAggregatesInput | FormSubmissionScalarWhereWithAggregatesInput[]
    title?: StringNullableWithAggregatesFilter<"FormSubmission"> | string | null
    formTemplateId?: StringWithAggregatesFilter<"FormSubmission"> | string
    userId?: StringWithAggregatesFilter<"FormSubmission"> | string
    formType?: StringNullableWithAggregatesFilter<"FormSubmission"> | string | null
    data?: JsonNullableWithAggregatesFilter<"FormSubmission">
    createdAt?: DateTimeWithAggregatesFilter<"FormSubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FormSubmission"> | Date | string
    submittedAt?: DateTimeNullableWithAggregatesFilter<"FormSubmission"> | Date | string | null
    status?: EnumFormStatusWithAggregatesFilter<"FormSubmission"> | $Enums.FormStatus
    id?: IntWithAggregatesFilter<"FormSubmission"> | number
  }

  export type FormApprovalWhereInput = {
    AND?: FormApprovalWhereInput | FormApprovalWhereInput[]
    OR?: FormApprovalWhereInput[]
    NOT?: FormApprovalWhereInput | FormApprovalWhereInput[]
    id?: StringFilter<"FormApproval"> | string
    signedBy?: StringNullableFilter<"FormApproval"> | string | null
    submittedAt?: DateTimeFilter<"FormApproval"> | Date | string
    updatedAt?: DateTimeFilter<"FormApproval"> | Date | string
    signature?: StringNullableFilter<"FormApproval"> | string | null
    comment?: StringNullableFilter<"FormApproval"> | string | null
    formSubmissionId?: IntFilter<"FormApproval"> | number
    FormSubmission?: XOR<FormSubmissionScalarRelationFilter, FormSubmissionWhereInput>
    Approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type FormApprovalOrderByWithRelationInput = {
    id?: SortOrder
    signedBy?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    signature?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    formSubmissionId?: SortOrder
    FormSubmission?: FormSubmissionOrderByWithRelationInput
    Approver?: UserOrderByWithRelationInput
  }

  export type FormApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FormApprovalWhereInput | FormApprovalWhereInput[]
    OR?: FormApprovalWhereInput[]
    NOT?: FormApprovalWhereInput | FormApprovalWhereInput[]
    signedBy?: StringNullableFilter<"FormApproval"> | string | null
    submittedAt?: DateTimeFilter<"FormApproval"> | Date | string
    updatedAt?: DateTimeFilter<"FormApproval"> | Date | string
    signature?: StringNullableFilter<"FormApproval"> | string | null
    comment?: StringNullableFilter<"FormApproval"> | string | null
    formSubmissionId?: IntFilter<"FormApproval"> | number
    FormSubmission?: XOR<FormSubmissionScalarRelationFilter, FormSubmissionWhereInput>
    Approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type FormApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    signedBy?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    signature?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    formSubmissionId?: SortOrder
    _count?: FormApprovalCountOrderByAggregateInput
    _avg?: FormApprovalAvgOrderByAggregateInput
    _max?: FormApprovalMaxOrderByAggregateInput
    _min?: FormApprovalMinOrderByAggregateInput
    _sum?: FormApprovalSumOrderByAggregateInput
  }

  export type FormApprovalScalarWhereWithAggregatesInput = {
    AND?: FormApprovalScalarWhereWithAggregatesInput | FormApprovalScalarWhereWithAggregatesInput[]
    OR?: FormApprovalScalarWhereWithAggregatesInput[]
    NOT?: FormApprovalScalarWhereWithAggregatesInput | FormApprovalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FormApproval"> | string
    signedBy?: StringNullableWithAggregatesFilter<"FormApproval"> | string | null
    submittedAt?: DateTimeWithAggregatesFilter<"FormApproval"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FormApproval"> | Date | string
    signature?: StringNullableWithAggregatesFilter<"FormApproval"> | string | null
    comment?: StringNullableWithAggregatesFilter<"FormApproval"> | string | null
    formSubmissionId?: IntWithAggregatesFilter<"FormApproval"> | number
  }

  export type JobsiteWhereInput = {
    AND?: JobsiteWhereInput | JobsiteWhereInput[]
    OR?: JobsiteWhereInput[]
    NOT?: JobsiteWhereInput | JobsiteWhereInput[]
    id?: StringFilter<"Jobsite"> | string
    qrId?: StringFilter<"Jobsite"> | string
    name?: StringFilter<"Jobsite"> | string
    description?: StringFilter<"Jobsite"> | string
    creationReason?: StringNullableFilter<"Jobsite"> | string | null
    approvalStatus?: EnumApprovalStatusFilter<"Jobsite"> | $Enums.ApprovalStatus
    addressId?: StringNullableFilter<"Jobsite"> | string | null
    comment?: StringNullableFilter<"Jobsite"> | string | null
    createdAt?: DateTimeFilter<"Jobsite"> | Date | string
    updatedAt?: DateTimeFilter<"Jobsite"> | Date | string
    archiveDate?: DateTimeNullableFilter<"Jobsite"> | Date | string | null
    createdById?: StringNullableFilter<"Jobsite"> | string | null
    createdVia?: EnumCreatedViaFilter<"Jobsite"> | $Enums.CreatedVia
    code?: StringNullableFilter<"Jobsite"> | string | null
    latitude?: FloatNullableFilter<"Jobsite"> | number | null
    longitude?: FloatNullableFilter<"Jobsite"> | number | null
    radiusMeters?: FloatNullableFilter<"Jobsite"> | number | null
    status?: EnumFormTemplateStatusFilter<"Jobsite"> | $Enums.FormTemplateStatus
    Address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    TimeSheets?: TimeSheetListRelationFilter
    CCTags?: CCTagListRelationFilter
  }

  export type JobsiteOrderByWithRelationInput = {
    id?: SortOrder
    qrId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creationReason?: SortOrderInput | SortOrder
    approvalStatus?: SortOrder
    addressId?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archiveDate?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdVia?: SortOrder
    code?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    radiusMeters?: SortOrderInput | SortOrder
    status?: SortOrder
    Address?: AddressOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    TimeSheets?: TimeSheetOrderByRelationAggregateInput
    CCTags?: CCTagOrderByRelationAggregateInput
  }

  export type JobsiteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    qrId?: string
    AND?: JobsiteWhereInput | JobsiteWhereInput[]
    OR?: JobsiteWhereInput[]
    NOT?: JobsiteWhereInput | JobsiteWhereInput[]
    name?: StringFilter<"Jobsite"> | string
    description?: StringFilter<"Jobsite"> | string
    creationReason?: StringNullableFilter<"Jobsite"> | string | null
    approvalStatus?: EnumApprovalStatusFilter<"Jobsite"> | $Enums.ApprovalStatus
    addressId?: StringNullableFilter<"Jobsite"> | string | null
    comment?: StringNullableFilter<"Jobsite"> | string | null
    createdAt?: DateTimeFilter<"Jobsite"> | Date | string
    updatedAt?: DateTimeFilter<"Jobsite"> | Date | string
    archiveDate?: DateTimeNullableFilter<"Jobsite"> | Date | string | null
    createdById?: StringNullableFilter<"Jobsite"> | string | null
    createdVia?: EnumCreatedViaFilter<"Jobsite"> | $Enums.CreatedVia
    code?: StringNullableFilter<"Jobsite"> | string | null
    latitude?: FloatNullableFilter<"Jobsite"> | number | null
    longitude?: FloatNullableFilter<"Jobsite"> | number | null
    radiusMeters?: FloatNullableFilter<"Jobsite"> | number | null
    status?: EnumFormTemplateStatusFilter<"Jobsite"> | $Enums.FormTemplateStatus
    Address?: XOR<AddressNullableScalarRelationFilter, AddressWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    TimeSheets?: TimeSheetListRelationFilter
    CCTags?: CCTagListRelationFilter
  }, "id" | "qrId">

  export type JobsiteOrderByWithAggregationInput = {
    id?: SortOrder
    qrId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creationReason?: SortOrderInput | SortOrder
    approvalStatus?: SortOrder
    addressId?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archiveDate?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdVia?: SortOrder
    code?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    radiusMeters?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: JobsiteCountOrderByAggregateInput
    _avg?: JobsiteAvgOrderByAggregateInput
    _max?: JobsiteMaxOrderByAggregateInput
    _min?: JobsiteMinOrderByAggregateInput
    _sum?: JobsiteSumOrderByAggregateInput
  }

  export type JobsiteScalarWhereWithAggregatesInput = {
    AND?: JobsiteScalarWhereWithAggregatesInput | JobsiteScalarWhereWithAggregatesInput[]
    OR?: JobsiteScalarWhereWithAggregatesInput[]
    NOT?: JobsiteScalarWhereWithAggregatesInput | JobsiteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Jobsite"> | string
    qrId?: StringWithAggregatesFilter<"Jobsite"> | string
    name?: StringWithAggregatesFilter<"Jobsite"> | string
    description?: StringWithAggregatesFilter<"Jobsite"> | string
    creationReason?: StringNullableWithAggregatesFilter<"Jobsite"> | string | null
    approvalStatus?: EnumApprovalStatusWithAggregatesFilter<"Jobsite"> | $Enums.ApprovalStatus
    addressId?: StringNullableWithAggregatesFilter<"Jobsite"> | string | null
    comment?: StringNullableWithAggregatesFilter<"Jobsite"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Jobsite"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Jobsite"> | Date | string
    archiveDate?: DateTimeNullableWithAggregatesFilter<"Jobsite"> | Date | string | null
    createdById?: StringNullableWithAggregatesFilter<"Jobsite"> | string | null
    createdVia?: EnumCreatedViaWithAggregatesFilter<"Jobsite"> | $Enums.CreatedVia
    code?: StringNullableWithAggregatesFilter<"Jobsite"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Jobsite"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Jobsite"> | number | null
    radiusMeters?: FloatNullableWithAggregatesFilter<"Jobsite"> | number | null
    status?: EnumFormTemplateStatusWithAggregatesFilter<"Jobsite"> | $Enums.FormTemplateStatus
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    name?: StringFilter<"Report"> | string
    description?: StringFilter<"Report"> | string
    companyId?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
    createdBy?: StringFilter<"Report"> | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    parameters?: JsonNullableFilter<"Report">
    visibility?: EnumReportVisibilityFilter<"Report"> | $Enums.ReportVisibility
    tags?: StringNullableListFilter<"Report">
    id?: IntFilter<"Report"> | number
    Company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    ReportRuns?: ReportRunListRelationFilter
  }

  export type ReportOrderByWithRelationInput = {
    name?: SortOrder
    description?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    parameters?: SortOrderInput | SortOrder
    visibility?: SortOrder
    tags?: SortOrder
    id?: SortOrder
    Company?: CompanyOrderByWithRelationInput
    ReportRuns?: ReportRunOrderByRelationAggregateInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    name?: string
    id?: number
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    description?: StringFilter<"Report"> | string
    companyId?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
    createdBy?: StringFilter<"Report"> | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    parameters?: JsonNullableFilter<"Report">
    visibility?: EnumReportVisibilityFilter<"Report"> | $Enums.ReportVisibility
    tags?: StringNullableListFilter<"Report">
    Company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    ReportRuns?: ReportRunListRelationFilter
  }, "id" | "name">

  export type ReportOrderByWithAggregationInput = {
    name?: SortOrder
    description?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    parameters?: SortOrderInput | SortOrder
    visibility?: SortOrder
    tags?: SortOrder
    id?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _avg?: ReportAvgOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
    _sum?: ReportSumOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"Report"> | string
    description?: StringWithAggregatesFilter<"Report"> | string
    companyId?: StringWithAggregatesFilter<"Report"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    createdBy?: StringWithAggregatesFilter<"Report"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    parameters?: JsonNullableWithAggregatesFilter<"Report">
    visibility?: EnumReportVisibilityWithAggregatesFilter<"Report"> | $Enums.ReportVisibility
    tags?: StringNullableListFilter<"Report">
    id?: IntWithAggregatesFilter<"Report"> | number
  }

  export type ReportRunWhereInput = {
    AND?: ReportRunWhereInput | ReportRunWhereInput[]
    OR?: ReportRunWhereInput[]
    NOT?: ReportRunWhereInput | ReportRunWhereInput[]
    id?: StringFilter<"ReportRun"> | string
    runAt?: DateTimeFilter<"ReportRun"> | Date | string
    status?: EnumReportStatusFilter<"ReportRun"> | $Enums.ReportStatus
    results?: JsonNullableFilter<"ReportRun">
    duration?: IntNullableFilter<"ReportRun"> | number | null
    startDate?: DateTimeNullableFilter<"ReportRun"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ReportRun"> | Date | string | null
    customParams?: JsonNullableFilter<"ReportRun">
    exportFormats?: StringNullableListFilter<"ReportRun">
    lastExportedAt?: DateTimeNullableFilter<"ReportRun"> | Date | string | null
    reportId?: IntFilter<"ReportRun"> | number
    Report?: XOR<ReportScalarRelationFilter, ReportWhereInput>
  }

  export type ReportRunOrderByWithRelationInput = {
    id?: SortOrder
    runAt?: SortOrder
    status?: SortOrder
    results?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    customParams?: SortOrderInput | SortOrder
    exportFormats?: SortOrder
    lastExportedAt?: SortOrderInput | SortOrder
    reportId?: SortOrder
    Report?: ReportOrderByWithRelationInput
  }

  export type ReportRunWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportRunWhereInput | ReportRunWhereInput[]
    OR?: ReportRunWhereInput[]
    NOT?: ReportRunWhereInput | ReportRunWhereInput[]
    runAt?: DateTimeFilter<"ReportRun"> | Date | string
    status?: EnumReportStatusFilter<"ReportRun"> | $Enums.ReportStatus
    results?: JsonNullableFilter<"ReportRun">
    duration?: IntNullableFilter<"ReportRun"> | number | null
    startDate?: DateTimeNullableFilter<"ReportRun"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ReportRun"> | Date | string | null
    customParams?: JsonNullableFilter<"ReportRun">
    exportFormats?: StringNullableListFilter<"ReportRun">
    lastExportedAt?: DateTimeNullableFilter<"ReportRun"> | Date | string | null
    reportId?: IntFilter<"ReportRun"> | number
    Report?: XOR<ReportScalarRelationFilter, ReportWhereInput>
  }, "id">

  export type ReportRunOrderByWithAggregationInput = {
    id?: SortOrder
    runAt?: SortOrder
    status?: SortOrder
    results?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    customParams?: SortOrderInput | SortOrder
    exportFormats?: SortOrder
    lastExportedAt?: SortOrderInput | SortOrder
    reportId?: SortOrder
    _count?: ReportRunCountOrderByAggregateInput
    _avg?: ReportRunAvgOrderByAggregateInput
    _max?: ReportRunMaxOrderByAggregateInput
    _min?: ReportRunMinOrderByAggregateInput
    _sum?: ReportRunSumOrderByAggregateInput
  }

  export type ReportRunScalarWhereWithAggregatesInput = {
    AND?: ReportRunScalarWhereWithAggregatesInput | ReportRunScalarWhereWithAggregatesInput[]
    OR?: ReportRunScalarWhereWithAggregatesInput[]
    NOT?: ReportRunScalarWhereWithAggregatesInput | ReportRunScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportRun"> | string
    runAt?: DateTimeWithAggregatesFilter<"ReportRun"> | Date | string
    status?: EnumReportStatusWithAggregatesFilter<"ReportRun"> | $Enums.ReportStatus
    results?: JsonNullableWithAggregatesFilter<"ReportRun">
    duration?: IntNullableWithAggregatesFilter<"ReportRun"> | number | null
    startDate?: DateTimeNullableWithAggregatesFilter<"ReportRun"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"ReportRun"> | Date | string | null
    customParams?: JsonNullableWithAggregatesFilter<"ReportRun">
    exportFormats?: StringNullableListFilter<"ReportRun">
    lastExportedAt?: DateTimeNullableWithAggregatesFilter<"ReportRun"> | Date | string | null
    reportId?: IntWithAggregatesFilter<"ReportRun"> | number
  }

  export type TimeSheetWhereInput = {
    AND?: TimeSheetWhereInput | TimeSheetWhereInput[]
    OR?: TimeSheetWhereInput[]
    NOT?: TimeSheetWhereInput | TimeSheetWhereInput[]
    date?: DateTimeFilter<"TimeSheet"> | Date | string
    userId?: StringFilter<"TimeSheet"> | string
    jobsiteId?: StringFilter<"TimeSheet"> | string
    costcode?: StringFilter<"TimeSheet"> | string
    nu?: StringFilter<"TimeSheet"> | string
    Fp?: StringFilter<"TimeSheet"> | string
    startTime?: DateTimeFilter<"TimeSheet"> | Date | string
    endTime?: DateTimeNullableFilter<"TimeSheet"> | Date | string | null
    comment?: StringNullableFilter<"TimeSheet"> | string | null
    statusComment?: StringNullableFilter<"TimeSheet"> | string | null
    location?: StringNullableFilter<"TimeSheet"> | string | null
    status?: EnumApprovalStatusFilter<"TimeSheet"> | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFilter<"TimeSheet"> | $Enums.WorkType
    editedByUserId?: StringNullableFilter<"TimeSheet"> | string | null
    newTimeSheetId?: StringNullableFilter<"TimeSheet"> | string | null
    createdByAdmin?: BoolFilter<"TimeSheet"> | boolean
    createdAt?: DateTimeFilter<"TimeSheet"> | Date | string
    updatedAt?: DateTimeFilter<"TimeSheet"> | Date | string
    clockInLat?: FloatNullableFilter<"TimeSheet"> | number | null
    clockInLng?: FloatNullableFilter<"TimeSheet"> | number | null
    clockOutLat?: FloatNullableFilter<"TimeSheet"> | number | null
    clockOutLng?: FloatNullableFilter<"TimeSheet"> | number | null
    withinFenceIn?: BoolNullableFilter<"TimeSheet"> | boolean | null
    withinFenceOut?: BoolNullableFilter<"TimeSheet"> | boolean | null
    wasInjured?: BoolNullableFilter<"TimeSheet"> | boolean | null
    id?: IntFilter<"TimeSheet"> | number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogListRelationFilter
    MaintenanceLogs?: MaintenanceLogListRelationFilter
    TascoLogs?: TascoLogListRelationFilter
    CostCode?: XOR<CostCodeScalarRelationFilter, CostCodeWhereInput>
    Jobsite?: XOR<JobsiteScalarRelationFilter, JobsiteWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    ChangeLogs?: TimeSheetChangeLogListRelationFilter
    TruckingLogs?: TruckingLogListRelationFilter
    Maintenance?: MechanicProjectsListRelationFilter
  }

  export type TimeSheetOrderByWithRelationInput = {
    date?: SortOrder
    userId?: SortOrder
    jobsiteId?: SortOrder
    costcode?: SortOrder
    nu?: SortOrder
    Fp?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    statusComment?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    workType?: SortOrder
    editedByUserId?: SortOrderInput | SortOrder
    newTimeSheetId?: SortOrderInput | SortOrder
    createdByAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clockInLat?: SortOrderInput | SortOrder
    clockInLng?: SortOrderInput | SortOrder
    clockOutLat?: SortOrderInput | SortOrder
    clockOutLng?: SortOrderInput | SortOrder
    withinFenceIn?: SortOrderInput | SortOrder
    withinFenceOut?: SortOrderInput | SortOrder
    wasInjured?: SortOrderInput | SortOrder
    id?: SortOrder
    EmployeeEquipmentLogs?: EmployeeEquipmentLogOrderByRelationAggregateInput
    MaintenanceLogs?: MaintenanceLogOrderByRelationAggregateInput
    TascoLogs?: TascoLogOrderByRelationAggregateInput
    CostCode?: CostCodeOrderByWithRelationInput
    Jobsite?: JobsiteOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    ChangeLogs?: TimeSheetChangeLogOrderByRelationAggregateInput
    TruckingLogs?: TruckingLogOrderByRelationAggregateInput
    Maintenance?: mechanicProjectsOrderByRelationAggregateInput
  }

  export type TimeSheetWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TimeSheetWhereInput | TimeSheetWhereInput[]
    OR?: TimeSheetWhereInput[]
    NOT?: TimeSheetWhereInput | TimeSheetWhereInput[]
    date?: DateTimeFilter<"TimeSheet"> | Date | string
    userId?: StringFilter<"TimeSheet"> | string
    jobsiteId?: StringFilter<"TimeSheet"> | string
    costcode?: StringFilter<"TimeSheet"> | string
    nu?: StringFilter<"TimeSheet"> | string
    Fp?: StringFilter<"TimeSheet"> | string
    startTime?: DateTimeFilter<"TimeSheet"> | Date | string
    endTime?: DateTimeNullableFilter<"TimeSheet"> | Date | string | null
    comment?: StringNullableFilter<"TimeSheet"> | string | null
    statusComment?: StringNullableFilter<"TimeSheet"> | string | null
    location?: StringNullableFilter<"TimeSheet"> | string | null
    status?: EnumApprovalStatusFilter<"TimeSheet"> | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFilter<"TimeSheet"> | $Enums.WorkType
    editedByUserId?: StringNullableFilter<"TimeSheet"> | string | null
    newTimeSheetId?: StringNullableFilter<"TimeSheet"> | string | null
    createdByAdmin?: BoolFilter<"TimeSheet"> | boolean
    createdAt?: DateTimeFilter<"TimeSheet"> | Date | string
    updatedAt?: DateTimeFilter<"TimeSheet"> | Date | string
    clockInLat?: FloatNullableFilter<"TimeSheet"> | number | null
    clockInLng?: FloatNullableFilter<"TimeSheet"> | number | null
    clockOutLat?: FloatNullableFilter<"TimeSheet"> | number | null
    clockOutLng?: FloatNullableFilter<"TimeSheet"> | number | null
    withinFenceIn?: BoolNullableFilter<"TimeSheet"> | boolean | null
    withinFenceOut?: BoolNullableFilter<"TimeSheet"> | boolean | null
    wasInjured?: BoolNullableFilter<"TimeSheet"> | boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogListRelationFilter
    MaintenanceLogs?: MaintenanceLogListRelationFilter
    TascoLogs?: TascoLogListRelationFilter
    CostCode?: XOR<CostCodeScalarRelationFilter, CostCodeWhereInput>
    Jobsite?: XOR<JobsiteScalarRelationFilter, JobsiteWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    ChangeLogs?: TimeSheetChangeLogListRelationFilter
    TruckingLogs?: TruckingLogListRelationFilter
    Maintenance?: MechanicProjectsListRelationFilter
  }, "id">

  export type TimeSheetOrderByWithAggregationInput = {
    date?: SortOrder
    userId?: SortOrder
    jobsiteId?: SortOrder
    costcode?: SortOrder
    nu?: SortOrder
    Fp?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    statusComment?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    workType?: SortOrder
    editedByUserId?: SortOrderInput | SortOrder
    newTimeSheetId?: SortOrderInput | SortOrder
    createdByAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clockInLat?: SortOrderInput | SortOrder
    clockInLng?: SortOrderInput | SortOrder
    clockOutLat?: SortOrderInput | SortOrder
    clockOutLng?: SortOrderInput | SortOrder
    withinFenceIn?: SortOrderInput | SortOrder
    withinFenceOut?: SortOrderInput | SortOrder
    wasInjured?: SortOrderInput | SortOrder
    id?: SortOrder
    _count?: TimeSheetCountOrderByAggregateInput
    _avg?: TimeSheetAvgOrderByAggregateInput
    _max?: TimeSheetMaxOrderByAggregateInput
    _min?: TimeSheetMinOrderByAggregateInput
    _sum?: TimeSheetSumOrderByAggregateInput
  }

  export type TimeSheetScalarWhereWithAggregatesInput = {
    AND?: TimeSheetScalarWhereWithAggregatesInput | TimeSheetScalarWhereWithAggregatesInput[]
    OR?: TimeSheetScalarWhereWithAggregatesInput[]
    NOT?: TimeSheetScalarWhereWithAggregatesInput | TimeSheetScalarWhereWithAggregatesInput[]
    date?: DateTimeWithAggregatesFilter<"TimeSheet"> | Date | string
    userId?: StringWithAggregatesFilter<"TimeSheet"> | string
    jobsiteId?: StringWithAggregatesFilter<"TimeSheet"> | string
    costcode?: StringWithAggregatesFilter<"TimeSheet"> | string
    nu?: StringWithAggregatesFilter<"TimeSheet"> | string
    Fp?: StringWithAggregatesFilter<"TimeSheet"> | string
    startTime?: DateTimeWithAggregatesFilter<"TimeSheet"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"TimeSheet"> | Date | string | null
    comment?: StringNullableWithAggregatesFilter<"TimeSheet"> | string | null
    statusComment?: StringNullableWithAggregatesFilter<"TimeSheet"> | string | null
    location?: StringNullableWithAggregatesFilter<"TimeSheet"> | string | null
    status?: EnumApprovalStatusWithAggregatesFilter<"TimeSheet"> | $Enums.ApprovalStatus
    workType?: EnumWorkTypeWithAggregatesFilter<"TimeSheet"> | $Enums.WorkType
    editedByUserId?: StringNullableWithAggregatesFilter<"TimeSheet"> | string | null
    newTimeSheetId?: StringNullableWithAggregatesFilter<"TimeSheet"> | string | null
    createdByAdmin?: BoolWithAggregatesFilter<"TimeSheet"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TimeSheet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TimeSheet"> | Date | string
    clockInLat?: FloatNullableWithAggregatesFilter<"TimeSheet"> | number | null
    clockInLng?: FloatNullableWithAggregatesFilter<"TimeSheet"> | number | null
    clockOutLat?: FloatNullableWithAggregatesFilter<"TimeSheet"> | number | null
    clockOutLng?: FloatNullableWithAggregatesFilter<"TimeSheet"> | number | null
    withinFenceIn?: BoolNullableWithAggregatesFilter<"TimeSheet"> | boolean | null
    withinFenceOut?: BoolNullableWithAggregatesFilter<"TimeSheet"> | boolean | null
    wasInjured?: BoolNullableWithAggregatesFilter<"TimeSheet"> | boolean | null
    id?: IntWithAggregatesFilter<"TimeSheet"> | number
  }

  export type mechanicProjectsWhereInput = {
    AND?: mechanicProjectsWhereInput | mechanicProjectsWhereInput[]
    OR?: mechanicProjectsWhereInput[]
    NOT?: mechanicProjectsWhereInput | mechanicProjectsWhereInput[]
    id?: IntFilter<"mechanicProjects"> | number
    timeSheetId?: IntFilter<"mechanicProjects"> | number
    hours?: FloatNullableFilter<"mechanicProjects"> | number | null
    equipmentId?: StringFilter<"mechanicProjects"> | string
    description?: StringNullableFilter<"mechanicProjects"> | string | null
    Equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
    TimeSheet?: XOR<TimeSheetScalarRelationFilter, TimeSheetWhereInput>
  }

  export type mechanicProjectsOrderByWithRelationInput = {
    id?: SortOrder
    timeSheetId?: SortOrder
    hours?: SortOrderInput | SortOrder
    equipmentId?: SortOrder
    description?: SortOrderInput | SortOrder
    Equipment?: EquipmentOrderByWithRelationInput
    TimeSheet?: TimeSheetOrderByWithRelationInput
  }

  export type mechanicProjectsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: mechanicProjectsWhereInput | mechanicProjectsWhereInput[]
    OR?: mechanicProjectsWhereInput[]
    NOT?: mechanicProjectsWhereInput | mechanicProjectsWhereInput[]
    timeSheetId?: IntFilter<"mechanicProjects"> | number
    hours?: FloatNullableFilter<"mechanicProjects"> | number | null
    equipmentId?: StringFilter<"mechanicProjects"> | string
    description?: StringNullableFilter<"mechanicProjects"> | string | null
    Equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
    TimeSheet?: XOR<TimeSheetScalarRelationFilter, TimeSheetWhereInput>
  }, "id">

  export type mechanicProjectsOrderByWithAggregationInput = {
    id?: SortOrder
    timeSheetId?: SortOrder
    hours?: SortOrderInput | SortOrder
    equipmentId?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: mechanicProjectsCountOrderByAggregateInput
    _avg?: mechanicProjectsAvgOrderByAggregateInput
    _max?: mechanicProjectsMaxOrderByAggregateInput
    _min?: mechanicProjectsMinOrderByAggregateInput
    _sum?: mechanicProjectsSumOrderByAggregateInput
  }

  export type mechanicProjectsScalarWhereWithAggregatesInput = {
    AND?: mechanicProjectsScalarWhereWithAggregatesInput | mechanicProjectsScalarWhereWithAggregatesInput[]
    OR?: mechanicProjectsScalarWhereWithAggregatesInput[]
    NOT?: mechanicProjectsScalarWhereWithAggregatesInput | mechanicProjectsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"mechanicProjects"> | number
    timeSheetId?: IntWithAggregatesFilter<"mechanicProjects"> | number
    hours?: FloatNullableWithAggregatesFilter<"mechanicProjects"> | number | null
    equipmentId?: StringWithAggregatesFilter<"mechanicProjects"> | string
    description?: StringNullableWithAggregatesFilter<"mechanicProjects"> | string | null
  }

  export type MaintenanceLogWhereInput = {
    AND?: MaintenanceLogWhereInput | MaintenanceLogWhereInput[]
    OR?: MaintenanceLogWhereInput[]
    NOT?: MaintenanceLogWhereInput | MaintenanceLogWhereInput[]
    id?: StringFilter<"MaintenanceLog"> | string
    userId?: StringFilter<"MaintenanceLog"> | string
    maintenanceId?: StringFilter<"MaintenanceLog"> | string
    startTime?: DateTimeFilter<"MaintenanceLog"> | Date | string
    endTime?: DateTimeNullableFilter<"MaintenanceLog"> | Date | string | null
    comment?: StringNullableFilter<"MaintenanceLog"> | string | null
    timeSheetId?: IntFilter<"MaintenanceLog"> | number
    Maintenance?: XOR<MaintenanceScalarRelationFilter, MaintenanceWhereInput>
    TimeSheet?: XOR<TimeSheetScalarRelationFilter, TimeSheetWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MaintenanceLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    maintenanceId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    timeSheetId?: SortOrder
    Maintenance?: MaintenanceOrderByWithRelationInput
    TimeSheet?: TimeSheetOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type MaintenanceLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceLogWhereInput | MaintenanceLogWhereInput[]
    OR?: MaintenanceLogWhereInput[]
    NOT?: MaintenanceLogWhereInput | MaintenanceLogWhereInput[]
    userId?: StringFilter<"MaintenanceLog"> | string
    maintenanceId?: StringFilter<"MaintenanceLog"> | string
    startTime?: DateTimeFilter<"MaintenanceLog"> | Date | string
    endTime?: DateTimeNullableFilter<"MaintenanceLog"> | Date | string | null
    comment?: StringNullableFilter<"MaintenanceLog"> | string | null
    timeSheetId?: IntFilter<"MaintenanceLog"> | number
    Maintenance?: XOR<MaintenanceScalarRelationFilter, MaintenanceWhereInput>
    TimeSheet?: XOR<TimeSheetScalarRelationFilter, TimeSheetWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MaintenanceLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    maintenanceId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    timeSheetId?: SortOrder
    _count?: MaintenanceLogCountOrderByAggregateInput
    _avg?: MaintenanceLogAvgOrderByAggregateInput
    _max?: MaintenanceLogMaxOrderByAggregateInput
    _min?: MaintenanceLogMinOrderByAggregateInput
    _sum?: MaintenanceLogSumOrderByAggregateInput
  }

  export type MaintenanceLogScalarWhereWithAggregatesInput = {
    AND?: MaintenanceLogScalarWhereWithAggregatesInput | MaintenanceLogScalarWhereWithAggregatesInput[]
    OR?: MaintenanceLogScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceLogScalarWhereWithAggregatesInput | MaintenanceLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceLog"> | string
    userId?: StringWithAggregatesFilter<"MaintenanceLog"> | string
    maintenanceId?: StringWithAggregatesFilter<"MaintenanceLog"> | string
    startTime?: DateTimeWithAggregatesFilter<"MaintenanceLog"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"MaintenanceLog"> | Date | string | null
    comment?: StringNullableWithAggregatesFilter<"MaintenanceLog"> | string | null
    timeSheetId?: IntWithAggregatesFilter<"MaintenanceLog"> | number
  }

  export type MaintenanceWhereInput = {
    AND?: MaintenanceWhereInput | MaintenanceWhereInput[]
    OR?: MaintenanceWhereInput[]
    NOT?: MaintenanceWhereInput | MaintenanceWhereInput[]
    id?: StringFilter<"Maintenance"> | string
    equipmentId?: StringFilter<"Maintenance"> | string
    equipmentIssue?: StringNullableFilter<"Maintenance"> | string | null
    employeeEquipmentLogId?: StringNullableFilter<"Maintenance"> | string | null
    additionalInfo?: StringNullableFilter<"Maintenance"> | string | null
    location?: StringNullableFilter<"Maintenance"> | string | null
    problemDiagnosis?: StringNullableFilter<"Maintenance"> | string | null
    solution?: StringNullableFilter<"Maintenance"> | string | null
    totalHoursLaboured?: FloatNullableFilter<"Maintenance"> | number | null
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    priority?: EnumPriorityFilter<"Maintenance"> | $Enums.Priority
    delay?: DateTimeNullableFilter<"Maintenance"> | Date | string | null
    delayReasoning?: StringNullableFilter<"Maintenance"> | string | null
    repaired?: BoolFilter<"Maintenance"> | boolean
    selected?: BoolFilter<"Maintenance"> | boolean
    hasBeenDelayed?: BoolFilter<"Maintenance"> | boolean
    createdBy?: StringNullableFilter<"Maintenance"> | string | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogListRelationFilter
    Equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
    MaintenanceLogs?: MaintenanceLogListRelationFilter
  }

  export type MaintenanceOrderByWithRelationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    equipmentIssue?: SortOrderInput | SortOrder
    employeeEquipmentLogId?: SortOrderInput | SortOrder
    additionalInfo?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    problemDiagnosis?: SortOrderInput | SortOrder
    solution?: SortOrderInput | SortOrder
    totalHoursLaboured?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    priority?: SortOrder
    delay?: SortOrderInput | SortOrder
    delayReasoning?: SortOrderInput | SortOrder
    repaired?: SortOrder
    selected?: SortOrder
    hasBeenDelayed?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    EmployeeEquipmentLog?: EmployeeEquipmentLogOrderByRelationAggregateInput
    Equipment?: EquipmentOrderByWithRelationInput
    MaintenanceLogs?: MaintenanceLogOrderByRelationAggregateInput
  }

  export type MaintenanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeEquipmentLogId?: string
    AND?: MaintenanceWhereInput | MaintenanceWhereInput[]
    OR?: MaintenanceWhereInput[]
    NOT?: MaintenanceWhereInput | MaintenanceWhereInput[]
    equipmentId?: StringFilter<"Maintenance"> | string
    equipmentIssue?: StringNullableFilter<"Maintenance"> | string | null
    additionalInfo?: StringNullableFilter<"Maintenance"> | string | null
    location?: StringNullableFilter<"Maintenance"> | string | null
    problemDiagnosis?: StringNullableFilter<"Maintenance"> | string | null
    solution?: StringNullableFilter<"Maintenance"> | string | null
    totalHoursLaboured?: FloatNullableFilter<"Maintenance"> | number | null
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    priority?: EnumPriorityFilter<"Maintenance"> | $Enums.Priority
    delay?: DateTimeNullableFilter<"Maintenance"> | Date | string | null
    delayReasoning?: StringNullableFilter<"Maintenance"> | string | null
    repaired?: BoolFilter<"Maintenance"> | boolean
    selected?: BoolFilter<"Maintenance"> | boolean
    hasBeenDelayed?: BoolFilter<"Maintenance"> | boolean
    createdBy?: StringNullableFilter<"Maintenance"> | string | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogListRelationFilter
    Equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
    MaintenanceLogs?: MaintenanceLogListRelationFilter
  }, "id" | "employeeEquipmentLogId">

  export type MaintenanceOrderByWithAggregationInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    equipmentIssue?: SortOrderInput | SortOrder
    employeeEquipmentLogId?: SortOrderInput | SortOrder
    additionalInfo?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    problemDiagnosis?: SortOrderInput | SortOrder
    solution?: SortOrderInput | SortOrder
    totalHoursLaboured?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    priority?: SortOrder
    delay?: SortOrderInput | SortOrder
    delayReasoning?: SortOrderInput | SortOrder
    repaired?: SortOrder
    selected?: SortOrder
    hasBeenDelayed?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: MaintenanceCountOrderByAggregateInput
    _avg?: MaintenanceAvgOrderByAggregateInput
    _max?: MaintenanceMaxOrderByAggregateInput
    _min?: MaintenanceMinOrderByAggregateInput
    _sum?: MaintenanceSumOrderByAggregateInput
  }

  export type MaintenanceScalarWhereWithAggregatesInput = {
    AND?: MaintenanceScalarWhereWithAggregatesInput | MaintenanceScalarWhereWithAggregatesInput[]
    OR?: MaintenanceScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceScalarWhereWithAggregatesInput | MaintenanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Maintenance"> | string
    equipmentId?: StringWithAggregatesFilter<"Maintenance"> | string
    equipmentIssue?: StringNullableWithAggregatesFilter<"Maintenance"> | string | null
    employeeEquipmentLogId?: StringNullableWithAggregatesFilter<"Maintenance"> | string | null
    additionalInfo?: StringNullableWithAggregatesFilter<"Maintenance"> | string | null
    location?: StringNullableWithAggregatesFilter<"Maintenance"> | string | null
    problemDiagnosis?: StringNullableWithAggregatesFilter<"Maintenance"> | string | null
    solution?: StringNullableWithAggregatesFilter<"Maintenance"> | string | null
    totalHoursLaboured?: FloatNullableWithAggregatesFilter<"Maintenance"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Maintenance"> | Date | string
    priority?: EnumPriorityWithAggregatesFilter<"Maintenance"> | $Enums.Priority
    delay?: DateTimeNullableWithAggregatesFilter<"Maintenance"> | Date | string | null
    delayReasoning?: StringNullableWithAggregatesFilter<"Maintenance"> | string | null
    repaired?: BoolWithAggregatesFilter<"Maintenance"> | boolean
    selected?: BoolWithAggregatesFilter<"Maintenance"> | boolean
    hasBeenDelayed?: BoolWithAggregatesFilter<"Maintenance"> | boolean
    createdBy?: StringNullableWithAggregatesFilter<"Maintenance"> | string | null
  }

  export type TascoLogWhereInput = {
    AND?: TascoLogWhereInput | TascoLogWhereInput[]
    OR?: TascoLogWhereInput[]
    NOT?: TascoLogWhereInput | TascoLogWhereInput[]
    id?: StringFilter<"TascoLog"> | string
    shiftType?: StringFilter<"TascoLog"> | string
    equipmentId?: StringNullableFilter<"TascoLog"> | string | null
    laborType?: StringNullableFilter<"TascoLog"> | string | null
    materialType?: StringNullableFilter<"TascoLog"> | string | null
    LoadQuantity?: IntFilter<"TascoLog"> | number
    screenType?: EnumLoadTypeNullableFilter<"TascoLog"> | $Enums.LoadType | null
    timeSheetId?: IntFilter<"TascoLog"> | number
    RefuelLogs?: RefuelLogListRelationFilter
    TascoFLoads?: TascoFLoadsListRelationFilter
    Equipment?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
    TascoMaterialTypes?: XOR<TascoMaterialTypesNullableScalarRelationFilter, TascoMaterialTypesWhereInput> | null
    TimeSheet?: XOR<TimeSheetScalarRelationFilter, TimeSheetWhereInput>
  }

  export type TascoLogOrderByWithRelationInput = {
    id?: SortOrder
    shiftType?: SortOrder
    equipmentId?: SortOrderInput | SortOrder
    laborType?: SortOrderInput | SortOrder
    materialType?: SortOrderInput | SortOrder
    LoadQuantity?: SortOrder
    screenType?: SortOrderInput | SortOrder
    timeSheetId?: SortOrder
    RefuelLogs?: RefuelLogOrderByRelationAggregateInput
    TascoFLoads?: TascoFLoadsOrderByRelationAggregateInput
    Equipment?: EquipmentOrderByWithRelationInput
    TascoMaterialTypes?: TascoMaterialTypesOrderByWithRelationInput
    TimeSheet?: TimeSheetOrderByWithRelationInput
  }

  export type TascoLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TascoLogWhereInput | TascoLogWhereInput[]
    OR?: TascoLogWhereInput[]
    NOT?: TascoLogWhereInput | TascoLogWhereInput[]
    shiftType?: StringFilter<"TascoLog"> | string
    equipmentId?: StringNullableFilter<"TascoLog"> | string | null
    laborType?: StringNullableFilter<"TascoLog"> | string | null
    materialType?: StringNullableFilter<"TascoLog"> | string | null
    LoadQuantity?: IntFilter<"TascoLog"> | number
    screenType?: EnumLoadTypeNullableFilter<"TascoLog"> | $Enums.LoadType | null
    timeSheetId?: IntFilter<"TascoLog"> | number
    RefuelLogs?: RefuelLogListRelationFilter
    TascoFLoads?: TascoFLoadsListRelationFilter
    Equipment?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
    TascoMaterialTypes?: XOR<TascoMaterialTypesNullableScalarRelationFilter, TascoMaterialTypesWhereInput> | null
    TimeSheet?: XOR<TimeSheetScalarRelationFilter, TimeSheetWhereInput>
  }, "id">

  export type TascoLogOrderByWithAggregationInput = {
    id?: SortOrder
    shiftType?: SortOrder
    equipmentId?: SortOrderInput | SortOrder
    laborType?: SortOrderInput | SortOrder
    materialType?: SortOrderInput | SortOrder
    LoadQuantity?: SortOrder
    screenType?: SortOrderInput | SortOrder
    timeSheetId?: SortOrder
    _count?: TascoLogCountOrderByAggregateInput
    _avg?: TascoLogAvgOrderByAggregateInput
    _max?: TascoLogMaxOrderByAggregateInput
    _min?: TascoLogMinOrderByAggregateInput
    _sum?: TascoLogSumOrderByAggregateInput
  }

  export type TascoLogScalarWhereWithAggregatesInput = {
    AND?: TascoLogScalarWhereWithAggregatesInput | TascoLogScalarWhereWithAggregatesInput[]
    OR?: TascoLogScalarWhereWithAggregatesInput[]
    NOT?: TascoLogScalarWhereWithAggregatesInput | TascoLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TascoLog"> | string
    shiftType?: StringWithAggregatesFilter<"TascoLog"> | string
    equipmentId?: StringNullableWithAggregatesFilter<"TascoLog"> | string | null
    laborType?: StringNullableWithAggregatesFilter<"TascoLog"> | string | null
    materialType?: StringNullableWithAggregatesFilter<"TascoLog"> | string | null
    LoadQuantity?: IntWithAggregatesFilter<"TascoLog"> | number
    screenType?: EnumLoadTypeNullableWithAggregatesFilter<"TascoLog"> | $Enums.LoadType | null
    timeSheetId?: IntWithAggregatesFilter<"TascoLog"> | number
  }

  export type TascoFLoadsWhereInput = {
    AND?: TascoFLoadsWhereInput | TascoFLoadsWhereInput[]
    OR?: TascoFLoadsWhereInput[]
    NOT?: TascoFLoadsWhereInput | TascoFLoadsWhereInput[]
    id?: IntFilter<"TascoFLoads"> | number
    tascoLogId?: StringFilter<"TascoFLoads"> | string
    weight?: FloatNullableFilter<"TascoFLoads"> | number | null
    screenType?: EnumLoadTypeNullableFilter<"TascoFLoads"> | $Enums.LoadType | null
    TascoLog?: XOR<TascoLogScalarRelationFilter, TascoLogWhereInput>
  }

  export type TascoFLoadsOrderByWithRelationInput = {
    id?: SortOrder
    tascoLogId?: SortOrder
    weight?: SortOrderInput | SortOrder
    screenType?: SortOrderInput | SortOrder
    TascoLog?: TascoLogOrderByWithRelationInput
  }

  export type TascoFLoadsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TascoFLoadsWhereInput | TascoFLoadsWhereInput[]
    OR?: TascoFLoadsWhereInput[]
    NOT?: TascoFLoadsWhereInput | TascoFLoadsWhereInput[]
    tascoLogId?: StringFilter<"TascoFLoads"> | string
    weight?: FloatNullableFilter<"TascoFLoads"> | number | null
    screenType?: EnumLoadTypeNullableFilter<"TascoFLoads"> | $Enums.LoadType | null
    TascoLog?: XOR<TascoLogScalarRelationFilter, TascoLogWhereInput>
  }, "id">

  export type TascoFLoadsOrderByWithAggregationInput = {
    id?: SortOrder
    tascoLogId?: SortOrder
    weight?: SortOrderInput | SortOrder
    screenType?: SortOrderInput | SortOrder
    _count?: TascoFLoadsCountOrderByAggregateInput
    _avg?: TascoFLoadsAvgOrderByAggregateInput
    _max?: TascoFLoadsMaxOrderByAggregateInput
    _min?: TascoFLoadsMinOrderByAggregateInput
    _sum?: TascoFLoadsSumOrderByAggregateInput
  }

  export type TascoFLoadsScalarWhereWithAggregatesInput = {
    AND?: TascoFLoadsScalarWhereWithAggregatesInput | TascoFLoadsScalarWhereWithAggregatesInput[]
    OR?: TascoFLoadsScalarWhereWithAggregatesInput[]
    NOT?: TascoFLoadsScalarWhereWithAggregatesInput | TascoFLoadsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TascoFLoads"> | number
    tascoLogId?: StringWithAggregatesFilter<"TascoFLoads"> | string
    weight?: FloatNullableWithAggregatesFilter<"TascoFLoads"> | number | null
    screenType?: EnumLoadTypeNullableWithAggregatesFilter<"TascoFLoads"> | $Enums.LoadType | null
  }

  export type TascoMaterialTypesWhereInput = {
    AND?: TascoMaterialTypesWhereInput | TascoMaterialTypesWhereInput[]
    OR?: TascoMaterialTypesWhereInput[]
    NOT?: TascoMaterialTypesWhereInput | TascoMaterialTypesWhereInput[]
    id?: StringFilter<"TascoMaterialTypes"> | string
    name?: StringFilter<"TascoMaterialTypes"> | string
    TascoLog?: TascoLogListRelationFilter
  }

  export type TascoMaterialTypesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    TascoLog?: TascoLogOrderByRelationAggregateInput
  }

  export type TascoMaterialTypesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TascoMaterialTypesWhereInput | TascoMaterialTypesWhereInput[]
    OR?: TascoMaterialTypesWhereInput[]
    NOT?: TascoMaterialTypesWhereInput | TascoMaterialTypesWhereInput[]
    TascoLog?: TascoLogListRelationFilter
  }, "id" | "name">

  export type TascoMaterialTypesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: TascoMaterialTypesCountOrderByAggregateInput
    _max?: TascoMaterialTypesMaxOrderByAggregateInput
    _min?: TascoMaterialTypesMinOrderByAggregateInput
  }

  export type TascoMaterialTypesScalarWhereWithAggregatesInput = {
    AND?: TascoMaterialTypesScalarWhereWithAggregatesInput | TascoMaterialTypesScalarWhereWithAggregatesInput[]
    OR?: TascoMaterialTypesScalarWhereWithAggregatesInput[]
    NOT?: TascoMaterialTypesScalarWhereWithAggregatesInput | TascoMaterialTypesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TascoMaterialTypes"> | string
    name?: StringWithAggregatesFilter<"TascoMaterialTypes"> | string
  }

  export type TruckingLogWhereInput = {
    AND?: TruckingLogWhereInput | TruckingLogWhereInput[]
    OR?: TruckingLogWhereInput[]
    NOT?: TruckingLogWhereInput | TruckingLogWhereInput[]
    id?: StringFilter<"TruckingLog"> | string
    laborType?: StringFilter<"TruckingLog"> | string
    taskName?: StringNullableFilter<"TruckingLog"> | string | null
    equipmentId?: StringNullableFilter<"TruckingLog"> | string | null
    startingMileage?: IntNullableFilter<"TruckingLog"> | number | null
    endingMileage?: IntNullableFilter<"TruckingLog"> | number | null
    truckLaborLogId?: StringNullableFilter<"TruckingLog"> | string | null
    trailerNumber?: StringNullableFilter<"TruckingLog"> | string | null
    truckNumber?: StringNullableFilter<"TruckingLog"> | string | null
    timeSheetId?: IntFilter<"TruckingLog"> | number
    EquipmentHauled?: EquipmentHauledListRelationFilter
    Materials?: MaterialListRelationFilter
    RefuelLogs?: RefuelLogListRelationFilter
    StateMileages?: StateMileageListRelationFilter
    Equipment?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
    TimeSheet?: XOR<TimeSheetScalarRelationFilter, TimeSheetWhereInput>
    Trailer?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
    Truck?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
  }

  export type TruckingLogOrderByWithRelationInput = {
    id?: SortOrder
    laborType?: SortOrder
    taskName?: SortOrderInput | SortOrder
    equipmentId?: SortOrderInput | SortOrder
    startingMileage?: SortOrderInput | SortOrder
    endingMileage?: SortOrderInput | SortOrder
    truckLaborLogId?: SortOrderInput | SortOrder
    trailerNumber?: SortOrderInput | SortOrder
    truckNumber?: SortOrderInput | SortOrder
    timeSheetId?: SortOrder
    EquipmentHauled?: EquipmentHauledOrderByRelationAggregateInput
    Materials?: MaterialOrderByRelationAggregateInput
    RefuelLogs?: RefuelLogOrderByRelationAggregateInput
    StateMileages?: StateMileageOrderByRelationAggregateInput
    Equipment?: EquipmentOrderByWithRelationInput
    TimeSheet?: TimeSheetOrderByWithRelationInput
    Trailer?: EquipmentOrderByWithRelationInput
    Truck?: EquipmentOrderByWithRelationInput
  }

  export type TruckingLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TruckingLogWhereInput | TruckingLogWhereInput[]
    OR?: TruckingLogWhereInput[]
    NOT?: TruckingLogWhereInput | TruckingLogWhereInput[]
    laborType?: StringFilter<"TruckingLog"> | string
    taskName?: StringNullableFilter<"TruckingLog"> | string | null
    equipmentId?: StringNullableFilter<"TruckingLog"> | string | null
    startingMileage?: IntNullableFilter<"TruckingLog"> | number | null
    endingMileage?: IntNullableFilter<"TruckingLog"> | number | null
    truckLaborLogId?: StringNullableFilter<"TruckingLog"> | string | null
    trailerNumber?: StringNullableFilter<"TruckingLog"> | string | null
    truckNumber?: StringNullableFilter<"TruckingLog"> | string | null
    timeSheetId?: IntFilter<"TruckingLog"> | number
    EquipmentHauled?: EquipmentHauledListRelationFilter
    Materials?: MaterialListRelationFilter
    RefuelLogs?: RefuelLogListRelationFilter
    StateMileages?: StateMileageListRelationFilter
    Equipment?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
    TimeSheet?: XOR<TimeSheetScalarRelationFilter, TimeSheetWhereInput>
    Trailer?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
    Truck?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
  }, "id">

  export type TruckingLogOrderByWithAggregationInput = {
    id?: SortOrder
    laborType?: SortOrder
    taskName?: SortOrderInput | SortOrder
    equipmentId?: SortOrderInput | SortOrder
    startingMileage?: SortOrderInput | SortOrder
    endingMileage?: SortOrderInput | SortOrder
    truckLaborLogId?: SortOrderInput | SortOrder
    trailerNumber?: SortOrderInput | SortOrder
    truckNumber?: SortOrderInput | SortOrder
    timeSheetId?: SortOrder
    _count?: TruckingLogCountOrderByAggregateInput
    _avg?: TruckingLogAvgOrderByAggregateInput
    _max?: TruckingLogMaxOrderByAggregateInput
    _min?: TruckingLogMinOrderByAggregateInput
    _sum?: TruckingLogSumOrderByAggregateInput
  }

  export type TruckingLogScalarWhereWithAggregatesInput = {
    AND?: TruckingLogScalarWhereWithAggregatesInput | TruckingLogScalarWhereWithAggregatesInput[]
    OR?: TruckingLogScalarWhereWithAggregatesInput[]
    NOT?: TruckingLogScalarWhereWithAggregatesInput | TruckingLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TruckingLog"> | string
    laborType?: StringWithAggregatesFilter<"TruckingLog"> | string
    taskName?: StringNullableWithAggregatesFilter<"TruckingLog"> | string | null
    equipmentId?: StringNullableWithAggregatesFilter<"TruckingLog"> | string | null
    startingMileage?: IntNullableWithAggregatesFilter<"TruckingLog"> | number | null
    endingMileage?: IntNullableWithAggregatesFilter<"TruckingLog"> | number | null
    truckLaborLogId?: StringNullableWithAggregatesFilter<"TruckingLog"> | string | null
    trailerNumber?: StringNullableWithAggregatesFilter<"TruckingLog"> | string | null
    truckNumber?: StringNullableWithAggregatesFilter<"TruckingLog"> | string | null
    timeSheetId?: IntWithAggregatesFilter<"TruckingLog"> | number
  }

  export type StateMileageWhereInput = {
    AND?: StateMileageWhereInput | StateMileageWhereInput[]
    OR?: StateMileageWhereInput[]
    NOT?: StateMileageWhereInput | StateMileageWhereInput[]
    id?: StringFilter<"StateMileage"> | string
    truckingLogId?: StringFilter<"StateMileage"> | string
    state?: StringNullableFilter<"StateMileage"> | string | null
    stateLineMileage?: IntNullableFilter<"StateMileage"> | number | null
    TruckingLog?: XOR<TruckingLogScalarRelationFilter, TruckingLogWhereInput>
  }

  export type StateMileageOrderByWithRelationInput = {
    id?: SortOrder
    truckingLogId?: SortOrder
    state?: SortOrderInput | SortOrder
    stateLineMileage?: SortOrderInput | SortOrder
    TruckingLog?: TruckingLogOrderByWithRelationInput
  }

  export type StateMileageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StateMileageWhereInput | StateMileageWhereInput[]
    OR?: StateMileageWhereInput[]
    NOT?: StateMileageWhereInput | StateMileageWhereInput[]
    truckingLogId?: StringFilter<"StateMileage"> | string
    state?: StringNullableFilter<"StateMileage"> | string | null
    stateLineMileage?: IntNullableFilter<"StateMileage"> | number | null
    TruckingLog?: XOR<TruckingLogScalarRelationFilter, TruckingLogWhereInput>
  }, "id">

  export type StateMileageOrderByWithAggregationInput = {
    id?: SortOrder
    truckingLogId?: SortOrder
    state?: SortOrderInput | SortOrder
    stateLineMileage?: SortOrderInput | SortOrder
    _count?: StateMileageCountOrderByAggregateInput
    _avg?: StateMileageAvgOrderByAggregateInput
    _max?: StateMileageMaxOrderByAggregateInput
    _min?: StateMileageMinOrderByAggregateInput
    _sum?: StateMileageSumOrderByAggregateInput
  }

  export type StateMileageScalarWhereWithAggregatesInput = {
    AND?: StateMileageScalarWhereWithAggregatesInput | StateMileageScalarWhereWithAggregatesInput[]
    OR?: StateMileageScalarWhereWithAggregatesInput[]
    NOT?: StateMileageScalarWhereWithAggregatesInput | StateMileageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StateMileage"> | string
    truckingLogId?: StringWithAggregatesFilter<"StateMileage"> | string
    state?: StringNullableWithAggregatesFilter<"StateMileage"> | string | null
    stateLineMileage?: IntNullableWithAggregatesFilter<"StateMileage"> | number | null
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: StringFilter<"Material"> | string
    truckingLogId?: StringFilter<"Material"> | string
    LocationOfMaterial?: StringNullableFilter<"Material"> | string | null
    name?: StringNullableFilter<"Material"> | string | null
    quantity?: FloatNullableFilter<"Material"> | number | null
    materialWeight?: FloatNullableFilter<"Material"> | number | null
    loadType?: EnumLoadTypeNullableFilter<"Material"> | $Enums.LoadType | null
    createdAt?: DateTimeNullableFilter<"Material"> | Date | string | null
    unit?: EnummaterialUnitNullableFilter<"Material"> | $Enums.materialUnit | null
    TruckingLog?: XOR<TruckingLogScalarRelationFilter, TruckingLogWhereInput>
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    truckingLogId?: SortOrder
    LocationOfMaterial?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    materialWeight?: SortOrderInput | SortOrder
    loadType?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    TruckingLog?: TruckingLogOrderByWithRelationInput
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    truckingLogId?: StringFilter<"Material"> | string
    LocationOfMaterial?: StringNullableFilter<"Material"> | string | null
    name?: StringNullableFilter<"Material"> | string | null
    quantity?: FloatNullableFilter<"Material"> | number | null
    materialWeight?: FloatNullableFilter<"Material"> | number | null
    loadType?: EnumLoadTypeNullableFilter<"Material"> | $Enums.LoadType | null
    createdAt?: DateTimeNullableFilter<"Material"> | Date | string | null
    unit?: EnummaterialUnitNullableFilter<"Material"> | $Enums.materialUnit | null
    TruckingLog?: XOR<TruckingLogScalarRelationFilter, TruckingLogWhereInput>
  }, "id">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    truckingLogId?: SortOrder
    LocationOfMaterial?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    materialWeight?: SortOrderInput | SortOrder
    loadType?: SortOrderInput | SortOrder
    createdAt?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _avg?: MaterialAvgOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
    _sum?: MaterialSumOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Material"> | string
    truckingLogId?: StringWithAggregatesFilter<"Material"> | string
    LocationOfMaterial?: StringNullableWithAggregatesFilter<"Material"> | string | null
    name?: StringNullableWithAggregatesFilter<"Material"> | string | null
    quantity?: FloatNullableWithAggregatesFilter<"Material"> | number | null
    materialWeight?: FloatNullableWithAggregatesFilter<"Material"> | number | null
    loadType?: EnumLoadTypeNullableWithAggregatesFilter<"Material"> | $Enums.LoadType | null
    createdAt?: DateTimeNullableWithAggregatesFilter<"Material"> | Date | string | null
    unit?: EnummaterialUnitNullableWithAggregatesFilter<"Material"> | $Enums.materialUnit | null
  }

  export type RefuelLogWhereInput = {
    AND?: RefuelLogWhereInput | RefuelLogWhereInput[]
    OR?: RefuelLogWhereInput[]
    NOT?: RefuelLogWhereInput | RefuelLogWhereInput[]
    id?: StringFilter<"RefuelLog"> | string
    employeeEquipmentLogId?: StringNullableFilter<"RefuelLog"> | string | null
    truckingLogId?: StringNullableFilter<"RefuelLog"> | string | null
    tascoLogId?: StringNullableFilter<"RefuelLog"> | string | null
    gallonsRefueled?: FloatNullableFilter<"RefuelLog"> | number | null
    milesAtFueling?: IntNullableFilter<"RefuelLog"> | number | null
    EmployeeEquipmentLog?: XOR<EmployeeEquipmentLogNullableScalarRelationFilter, EmployeeEquipmentLogWhereInput> | null
    TascoLog?: XOR<TascoLogNullableScalarRelationFilter, TascoLogWhereInput> | null
    TruckingLog?: XOR<TruckingLogNullableScalarRelationFilter, TruckingLogWhereInput> | null
  }

  export type RefuelLogOrderByWithRelationInput = {
    id?: SortOrder
    employeeEquipmentLogId?: SortOrderInput | SortOrder
    truckingLogId?: SortOrderInput | SortOrder
    tascoLogId?: SortOrderInput | SortOrder
    gallonsRefueled?: SortOrderInput | SortOrder
    milesAtFueling?: SortOrderInput | SortOrder
    EmployeeEquipmentLog?: EmployeeEquipmentLogOrderByWithRelationInput
    TascoLog?: TascoLogOrderByWithRelationInput
    TruckingLog?: TruckingLogOrderByWithRelationInput
  }

  export type RefuelLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeEquipmentLogId?: string
    AND?: RefuelLogWhereInput | RefuelLogWhereInput[]
    OR?: RefuelLogWhereInput[]
    NOT?: RefuelLogWhereInput | RefuelLogWhereInput[]
    truckingLogId?: StringNullableFilter<"RefuelLog"> | string | null
    tascoLogId?: StringNullableFilter<"RefuelLog"> | string | null
    gallonsRefueled?: FloatNullableFilter<"RefuelLog"> | number | null
    milesAtFueling?: IntNullableFilter<"RefuelLog"> | number | null
    EmployeeEquipmentLog?: XOR<EmployeeEquipmentLogNullableScalarRelationFilter, EmployeeEquipmentLogWhereInput> | null
    TascoLog?: XOR<TascoLogNullableScalarRelationFilter, TascoLogWhereInput> | null
    TruckingLog?: XOR<TruckingLogNullableScalarRelationFilter, TruckingLogWhereInput> | null
  }, "id" | "employeeEquipmentLogId">

  export type RefuelLogOrderByWithAggregationInput = {
    id?: SortOrder
    employeeEquipmentLogId?: SortOrderInput | SortOrder
    truckingLogId?: SortOrderInput | SortOrder
    tascoLogId?: SortOrderInput | SortOrder
    gallonsRefueled?: SortOrderInput | SortOrder
    milesAtFueling?: SortOrderInput | SortOrder
    _count?: RefuelLogCountOrderByAggregateInput
    _avg?: RefuelLogAvgOrderByAggregateInput
    _max?: RefuelLogMaxOrderByAggregateInput
    _min?: RefuelLogMinOrderByAggregateInput
    _sum?: RefuelLogSumOrderByAggregateInput
  }

  export type RefuelLogScalarWhereWithAggregatesInput = {
    AND?: RefuelLogScalarWhereWithAggregatesInput | RefuelLogScalarWhereWithAggregatesInput[]
    OR?: RefuelLogScalarWhereWithAggregatesInput[]
    NOT?: RefuelLogScalarWhereWithAggregatesInput | RefuelLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefuelLog"> | string
    employeeEquipmentLogId?: StringNullableWithAggregatesFilter<"RefuelLog"> | string | null
    truckingLogId?: StringNullableWithAggregatesFilter<"RefuelLog"> | string | null
    tascoLogId?: StringNullableWithAggregatesFilter<"RefuelLog"> | string | null
    gallonsRefueled?: FloatNullableWithAggregatesFilter<"RefuelLog"> | number | null
    milesAtFueling?: IntNullableWithAggregatesFilter<"RefuelLog"> | number | null
  }

  export type EquipmentHauledWhereInput = {
    AND?: EquipmentHauledWhereInput | EquipmentHauledWhereInput[]
    OR?: EquipmentHauledWhereInput[]
    NOT?: EquipmentHauledWhereInput | EquipmentHauledWhereInput[]
    id?: StringFilter<"EquipmentHauled"> | string
    truckingLogId?: StringNullableFilter<"EquipmentHauled"> | string | null
    equipmentId?: StringNullableFilter<"EquipmentHauled"> | string | null
    createdAt?: DateTimeFilter<"EquipmentHauled"> | Date | string
    endMileage?: IntNullableFilter<"EquipmentHauled"> | number | null
    startMileage?: IntNullableFilter<"EquipmentHauled"> | number | null
    destination?: StringNullableFilter<"EquipmentHauled"> | string | null
    source?: StringNullableFilter<"EquipmentHauled"> | string | null
    Equipment?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
    TruckingLog?: XOR<TruckingLogNullableScalarRelationFilter, TruckingLogWhereInput> | null
  }

  export type EquipmentHauledOrderByWithRelationInput = {
    id?: SortOrder
    truckingLogId?: SortOrderInput | SortOrder
    equipmentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    endMileage?: SortOrderInput | SortOrder
    startMileage?: SortOrderInput | SortOrder
    destination?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    Equipment?: EquipmentOrderByWithRelationInput
    TruckingLog?: TruckingLogOrderByWithRelationInput
  }

  export type EquipmentHauledWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EquipmentHauledWhereInput | EquipmentHauledWhereInput[]
    OR?: EquipmentHauledWhereInput[]
    NOT?: EquipmentHauledWhereInput | EquipmentHauledWhereInput[]
    truckingLogId?: StringNullableFilter<"EquipmentHauled"> | string | null
    equipmentId?: StringNullableFilter<"EquipmentHauled"> | string | null
    createdAt?: DateTimeFilter<"EquipmentHauled"> | Date | string
    endMileage?: IntNullableFilter<"EquipmentHauled"> | number | null
    startMileage?: IntNullableFilter<"EquipmentHauled"> | number | null
    destination?: StringNullableFilter<"EquipmentHauled"> | string | null
    source?: StringNullableFilter<"EquipmentHauled"> | string | null
    Equipment?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
    TruckingLog?: XOR<TruckingLogNullableScalarRelationFilter, TruckingLogWhereInput> | null
  }, "id">

  export type EquipmentHauledOrderByWithAggregationInput = {
    id?: SortOrder
    truckingLogId?: SortOrderInput | SortOrder
    equipmentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    endMileage?: SortOrderInput | SortOrder
    startMileage?: SortOrderInput | SortOrder
    destination?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    _count?: EquipmentHauledCountOrderByAggregateInput
    _avg?: EquipmentHauledAvgOrderByAggregateInput
    _max?: EquipmentHauledMaxOrderByAggregateInput
    _min?: EquipmentHauledMinOrderByAggregateInput
    _sum?: EquipmentHauledSumOrderByAggregateInput
  }

  export type EquipmentHauledScalarWhereWithAggregatesInput = {
    AND?: EquipmentHauledScalarWhereWithAggregatesInput | EquipmentHauledScalarWhereWithAggregatesInput[]
    OR?: EquipmentHauledScalarWhereWithAggregatesInput[]
    NOT?: EquipmentHauledScalarWhereWithAggregatesInput | EquipmentHauledScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EquipmentHauled"> | string
    truckingLogId?: StringNullableWithAggregatesFilter<"EquipmentHauled"> | string | null
    equipmentId?: StringNullableWithAggregatesFilter<"EquipmentHauled"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EquipmentHauled"> | Date | string
    endMileage?: IntNullableWithAggregatesFilter<"EquipmentHauled"> | number | null
    startMileage?: IntNullableWithAggregatesFilter<"EquipmentHauled"> | number | null
    destination?: StringNullableWithAggregatesFilter<"EquipmentHauled"> | string | null
    source?: StringNullableWithAggregatesFilter<"EquipmentHauled"> | string | null
  }

  export type TimeSheetChangeLogWhereInput = {
    AND?: TimeSheetChangeLogWhereInput | TimeSheetChangeLogWhereInput[]
    OR?: TimeSheetChangeLogWhereInput[]
    NOT?: TimeSheetChangeLogWhereInput | TimeSheetChangeLogWhereInput[]
    id?: StringFilter<"TimeSheetChangeLog"> | string
    timeSheetId?: IntFilter<"TimeSheetChangeLog"> | number
    changedBy?: StringFilter<"TimeSheetChangeLog"> | string
    changedAt?: DateTimeFilter<"TimeSheetChangeLog"> | Date | string
    changeReason?: StringNullableFilter<"TimeSheetChangeLog"> | string | null
    changes?: JsonFilter<"TimeSheetChangeLog">
    wasStatusChange?: BoolFilter<"TimeSheetChangeLog"> | boolean
    numberOfChanges?: IntFilter<"TimeSheetChangeLog"> | number
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    TimeSheet?: XOR<TimeSheetScalarRelationFilter, TimeSheetWhereInput>
  }

  export type TimeSheetChangeLogOrderByWithRelationInput = {
    id?: SortOrder
    timeSheetId?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
    changeReason?: SortOrderInput | SortOrder
    changes?: SortOrder
    wasStatusChange?: SortOrder
    numberOfChanges?: SortOrder
    User?: UserOrderByWithRelationInput
    TimeSheet?: TimeSheetOrderByWithRelationInput
  }

  export type TimeSheetChangeLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimeSheetChangeLogWhereInput | TimeSheetChangeLogWhereInput[]
    OR?: TimeSheetChangeLogWhereInput[]
    NOT?: TimeSheetChangeLogWhereInput | TimeSheetChangeLogWhereInput[]
    timeSheetId?: IntFilter<"TimeSheetChangeLog"> | number
    changedBy?: StringFilter<"TimeSheetChangeLog"> | string
    changedAt?: DateTimeFilter<"TimeSheetChangeLog"> | Date | string
    changeReason?: StringNullableFilter<"TimeSheetChangeLog"> | string | null
    changes?: JsonFilter<"TimeSheetChangeLog">
    wasStatusChange?: BoolFilter<"TimeSheetChangeLog"> | boolean
    numberOfChanges?: IntFilter<"TimeSheetChangeLog"> | number
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    TimeSheet?: XOR<TimeSheetScalarRelationFilter, TimeSheetWhereInput>
  }, "id">

  export type TimeSheetChangeLogOrderByWithAggregationInput = {
    id?: SortOrder
    timeSheetId?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
    changeReason?: SortOrderInput | SortOrder
    changes?: SortOrder
    wasStatusChange?: SortOrder
    numberOfChanges?: SortOrder
    _count?: TimeSheetChangeLogCountOrderByAggregateInput
    _avg?: TimeSheetChangeLogAvgOrderByAggregateInput
    _max?: TimeSheetChangeLogMaxOrderByAggregateInput
    _min?: TimeSheetChangeLogMinOrderByAggregateInput
    _sum?: TimeSheetChangeLogSumOrderByAggregateInput
  }

  export type TimeSheetChangeLogScalarWhereWithAggregatesInput = {
    AND?: TimeSheetChangeLogScalarWhereWithAggregatesInput | TimeSheetChangeLogScalarWhereWithAggregatesInput[]
    OR?: TimeSheetChangeLogScalarWhereWithAggregatesInput[]
    NOT?: TimeSheetChangeLogScalarWhereWithAggregatesInput | TimeSheetChangeLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimeSheetChangeLog"> | string
    timeSheetId?: IntWithAggregatesFilter<"TimeSheetChangeLog"> | number
    changedBy?: StringWithAggregatesFilter<"TimeSheetChangeLog"> | string
    changedAt?: DateTimeWithAggregatesFilter<"TimeSheetChangeLog"> | Date | string
    changeReason?: StringNullableWithAggregatesFilter<"TimeSheetChangeLog"> | string | null
    changes?: JsonWithAggregatesFilter<"TimeSheetChangeLog">
    wasStatusChange?: BoolWithAggregatesFilter<"TimeSheetChangeLog"> | boolean
    numberOfChanges?: IntWithAggregatesFilter<"TimeSheetChangeLog"> | number
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    signature?: StringNullableFilter<"User"> | string | null
    DOB?: DateTimeNullableFilter<"User"> | Date | string | null
    truckView?: BoolFilter<"User"> | boolean
    tascoView?: BoolFilter<"User"> | boolean
    laborView?: BoolFilter<"User"> | boolean
    mechanicView?: BoolFilter<"User"> | boolean
    permission?: EnumPermissionFilter<"User"> | $Enums.Permission
    image?: StringNullableFilter<"User"> | string | null
    startDate?: DateTimeNullableFilter<"User"> | Date | string | null
    terminationDate?: DateTimeNullableFilter<"User"> | Date | string | null
    accountSetup?: BoolFilter<"User"> | boolean
    clockedIn?: BoolFilter<"User"> | boolean
    companyId?: StringFilter<"User"> | string
    passwordResetTokenId?: StringNullableFilter<"User"> | string | null
    workTypeId?: StringNullableFilter<"User"> | string | null
    middleName?: StringNullableFilter<"User"> | string | null
    secondLastName?: StringNullableFilter<"User"> | string | null
    lastSeen?: DateTimeNullableFilter<"User"> | Date | string | null
    accountSetupToken?: XOR<AccountSetupTokenNullableScalarRelationFilter, AccountSetupTokenWhereInput> | null
    Contact?: XOR<ContactsNullableScalarRelationFilter, ContactsWhereInput> | null
    Equipment?: EquipmentListRelationFilter
    FCMToken?: FCMTokenListRelationFilter
    FormApprovals?: FormApprovalListRelationFilter
    FormSubmissions?: FormSubmissionListRelationFilter
    Jobsite?: JobsiteListRelationFilter
    MaintenanceLogs?: MaintenanceLogListRelationFilter
    NotificationRead?: NotificationReadListRelationFilter
    NotificationResponse?: NotificationResponseListRelationFilter
    PasswordResetTokens?: PasswordResetTokenListRelationFilter
    TimeSheets?: TimeSheetListRelationFilter
    TimeSheetChanges?: TimeSheetChangeLogListRelationFilter
    topicSubscriptions?: TopicSubscriptionListRelationFilter
    Company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    UserSettings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    Crews?: CrewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrder
    signature?: SortOrderInput | SortOrder
    DOB?: SortOrderInput | SortOrder
    truckView?: SortOrder
    tascoView?: SortOrder
    laborView?: SortOrder
    mechanicView?: SortOrder
    permission?: SortOrder
    image?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    terminationDate?: SortOrderInput | SortOrder
    accountSetup?: SortOrder
    clockedIn?: SortOrder
    companyId?: SortOrder
    passwordResetTokenId?: SortOrderInput | SortOrder
    workTypeId?: SortOrderInput | SortOrder
    middleName?: SortOrderInput | SortOrder
    secondLastName?: SortOrderInput | SortOrder
    lastSeen?: SortOrderInput | SortOrder
    accountSetupToken?: AccountSetupTokenOrderByWithRelationInput
    Contact?: ContactsOrderByWithRelationInput
    Equipment?: EquipmentOrderByRelationAggregateInput
    FCMToken?: FCMTokenOrderByRelationAggregateInput
    FormApprovals?: FormApprovalOrderByRelationAggregateInput
    FormSubmissions?: FormSubmissionOrderByRelationAggregateInput
    Jobsite?: JobsiteOrderByRelationAggregateInput
    MaintenanceLogs?: MaintenanceLogOrderByRelationAggregateInput
    NotificationRead?: NotificationReadOrderByRelationAggregateInput
    NotificationResponse?: NotificationResponseOrderByRelationAggregateInput
    PasswordResetTokens?: PasswordResetTokenOrderByRelationAggregateInput
    TimeSheets?: TimeSheetOrderByRelationAggregateInput
    TimeSheetChanges?: TimeSheetChangeLogOrderByRelationAggregateInput
    topicSubscriptions?: TopicSubscriptionOrderByRelationAggregateInput
    Company?: CompanyOrderByWithRelationInput
    UserSettings?: UserSettingsOrderByWithRelationInput
    Crews?: CrewOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    firstName_lastName_username?: UserFirstNameLastNameUsernameCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    signature?: StringNullableFilter<"User"> | string | null
    DOB?: DateTimeNullableFilter<"User"> | Date | string | null
    truckView?: BoolFilter<"User"> | boolean
    tascoView?: BoolFilter<"User"> | boolean
    laborView?: BoolFilter<"User"> | boolean
    mechanicView?: BoolFilter<"User"> | boolean
    permission?: EnumPermissionFilter<"User"> | $Enums.Permission
    image?: StringNullableFilter<"User"> | string | null
    startDate?: DateTimeNullableFilter<"User"> | Date | string | null
    terminationDate?: DateTimeNullableFilter<"User"> | Date | string | null
    accountSetup?: BoolFilter<"User"> | boolean
    clockedIn?: BoolFilter<"User"> | boolean
    companyId?: StringFilter<"User"> | string
    passwordResetTokenId?: StringNullableFilter<"User"> | string | null
    workTypeId?: StringNullableFilter<"User"> | string | null
    middleName?: StringNullableFilter<"User"> | string | null
    secondLastName?: StringNullableFilter<"User"> | string | null
    lastSeen?: DateTimeNullableFilter<"User"> | Date | string | null
    accountSetupToken?: XOR<AccountSetupTokenNullableScalarRelationFilter, AccountSetupTokenWhereInput> | null
    Contact?: XOR<ContactsNullableScalarRelationFilter, ContactsWhereInput> | null
    Equipment?: EquipmentListRelationFilter
    FCMToken?: FCMTokenListRelationFilter
    FormApprovals?: FormApprovalListRelationFilter
    FormSubmissions?: FormSubmissionListRelationFilter
    Jobsite?: JobsiteListRelationFilter
    MaintenanceLogs?: MaintenanceLogListRelationFilter
    NotificationRead?: NotificationReadListRelationFilter
    NotificationResponse?: NotificationResponseListRelationFilter
    PasswordResetTokens?: PasswordResetTokenListRelationFilter
    TimeSheets?: TimeSheetListRelationFilter
    TimeSheetChanges?: TimeSheetChangeLogListRelationFilter
    topicSubscriptions?: TopicSubscriptionListRelationFilter
    Company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    UserSettings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    Crews?: CrewListRelationFilter
  }, "id" | "username" | "email" | "firstName_lastName_username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrder
    signature?: SortOrderInput | SortOrder
    DOB?: SortOrderInput | SortOrder
    truckView?: SortOrder
    tascoView?: SortOrder
    laborView?: SortOrder
    mechanicView?: SortOrder
    permission?: SortOrder
    image?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    terminationDate?: SortOrderInput | SortOrder
    accountSetup?: SortOrder
    clockedIn?: SortOrder
    companyId?: SortOrder
    passwordResetTokenId?: SortOrderInput | SortOrder
    workTypeId?: SortOrderInput | SortOrder
    middleName?: SortOrderInput | SortOrder
    secondLastName?: SortOrderInput | SortOrder
    lastSeen?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    signature?: StringNullableWithAggregatesFilter<"User"> | string | null
    DOB?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    truckView?: BoolWithAggregatesFilter<"User"> | boolean
    tascoView?: BoolWithAggregatesFilter<"User"> | boolean
    laborView?: BoolWithAggregatesFilter<"User"> | boolean
    mechanicView?: BoolWithAggregatesFilter<"User"> | boolean
    permission?: EnumPermissionWithAggregatesFilter<"User"> | $Enums.Permission
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    startDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    terminationDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    accountSetup?: BoolWithAggregatesFilter<"User"> | boolean
    clockedIn?: BoolWithAggregatesFilter<"User"> | boolean
    companyId?: StringWithAggregatesFilter<"User"> | string
    passwordResetTokenId?: StringNullableWithAggregatesFilter<"User"> | string | null
    workTypeId?: StringNullableWithAggregatesFilter<"User"> | string | null
    middleName?: StringNullableWithAggregatesFilter<"User"> | string | null
    secondLastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastSeen?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    id?: StringFilter<"UserSettings"> | string
    userId?: StringFilter<"UserSettings"> | string
    language?: StringFilter<"UserSettings"> | string
    generalReminders?: BoolFilter<"UserSettings"> | boolean
    personalReminders?: BoolFilter<"UserSettings"> | boolean
    cameraAccess?: BoolFilter<"UserSettings"> | boolean
    locationAccess?: BoolFilter<"UserSettings"> | boolean
    cookiesAccess?: BoolFilter<"UserSettings"> | boolean
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    lastUpdated?: DateTimeFilter<"UserSettings"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    language?: SortOrder
    generalReminders?: SortOrder
    personalReminders?: SortOrder
    cameraAccess?: SortOrder
    locationAccess?: SortOrder
    cookiesAccess?: SortOrder
    createdAt?: SortOrder
    lastUpdated?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    language?: StringFilter<"UserSettings"> | string
    generalReminders?: BoolFilter<"UserSettings"> | boolean
    personalReminders?: BoolFilter<"UserSettings"> | boolean
    cameraAccess?: BoolFilter<"UserSettings"> | boolean
    locationAccess?: BoolFilter<"UserSettings"> | boolean
    cookiesAccess?: BoolFilter<"UserSettings"> | boolean
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    lastUpdated?: DateTimeFilter<"UserSettings"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    language?: SortOrder
    generalReminders?: SortOrder
    personalReminders?: SortOrder
    cameraAccess?: SortOrder
    locationAccess?: SortOrder
    cookiesAccess?: SortOrder
    createdAt?: SortOrder
    lastUpdated?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSettings"> | string
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
    language?: StringWithAggregatesFilter<"UserSettings"> | string
    generalReminders?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    personalReminders?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    cameraAccess?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    locationAccess?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    cookiesAccess?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    lastUpdated?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
  }

  export type ContactsWhereInput = {
    AND?: ContactsWhereInput | ContactsWhereInput[]
    OR?: ContactsWhereInput[]
    NOT?: ContactsWhereInput | ContactsWhereInput[]
    id?: StringFilter<"Contacts"> | string
    userId?: StringFilter<"Contacts"> | string
    phoneNumber?: StringNullableFilter<"Contacts"> | string | null
    emergencyContact?: StringNullableFilter<"Contacts"> | string | null
    emergencyContactNumber?: StringNullableFilter<"Contacts"> | string | null
    createdAt?: DateTimeFilter<"Contacts"> | Date | string
    updatedAt?: DateTimeFilter<"Contacts"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ContactsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    emergencyContactNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type ContactsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ContactsWhereInput | ContactsWhereInput[]
    OR?: ContactsWhereInput[]
    NOT?: ContactsWhereInput | ContactsWhereInput[]
    phoneNumber?: StringNullableFilter<"Contacts"> | string | null
    emergencyContact?: StringNullableFilter<"Contacts"> | string | null
    emergencyContactNumber?: StringNullableFilter<"Contacts"> | string | null
    createdAt?: DateTimeFilter<"Contacts"> | Date | string
    updatedAt?: DateTimeFilter<"Contacts"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ContactsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    emergencyContactNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactsCountOrderByAggregateInput
    _max?: ContactsMaxOrderByAggregateInput
    _min?: ContactsMinOrderByAggregateInput
  }

  export type ContactsScalarWhereWithAggregatesInput = {
    AND?: ContactsScalarWhereWithAggregatesInput | ContactsScalarWhereWithAggregatesInput[]
    OR?: ContactsScalarWhereWithAggregatesInput[]
    NOT?: ContactsScalarWhereWithAggregatesInput | ContactsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contacts"> | string
    userId?: StringWithAggregatesFilter<"Contacts"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Contacts"> | string | null
    emergencyContact?: StringNullableWithAggregatesFilter<"Contacts"> | string | null
    emergencyContactNumber?: StringNullableWithAggregatesFilter<"Contacts"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Contacts"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contacts"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expiration?: DateTimeFilter<"PasswordResetToken"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expiration?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: PasswordResetTokenEmailTokenCompoundUniqueInput
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    email?: StringFilter<"PasswordResetToken"> | string
    expiration?: DateTimeFilter<"PasswordResetToken"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token" | "email_token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expiration?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    email?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiration?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type AccountSetupTokenWhereInput = {
    AND?: AccountSetupTokenWhereInput | AccountSetupTokenWhereInput[]
    OR?: AccountSetupTokenWhereInput[]
    NOT?: AccountSetupTokenWhereInput | AccountSetupTokenWhereInput[]
    id?: StringFilter<"AccountSetupToken"> | string
    code?: StringFilter<"AccountSetupToken"> | string
    userId?: StringFilter<"AccountSetupToken"> | string
    expiresAt?: DateTimeFilter<"AccountSetupToken"> | Date | string
    used?: BoolFilter<"AccountSetupToken"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountSetupTokenOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountSetupTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AccountSetupTokenWhereInput | AccountSetupTokenWhereInput[]
    OR?: AccountSetupTokenWhereInput[]
    NOT?: AccountSetupTokenWhereInput | AccountSetupTokenWhereInput[]
    code?: StringFilter<"AccountSetupToken"> | string
    expiresAt?: DateTimeFilter<"AccountSetupToken"> | Date | string
    used?: BoolFilter<"AccountSetupToken"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type AccountSetupTokenOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    _count?: AccountSetupTokenCountOrderByAggregateInput
    _max?: AccountSetupTokenMaxOrderByAggregateInput
    _min?: AccountSetupTokenMinOrderByAggregateInput
  }

  export type AccountSetupTokenScalarWhereWithAggregatesInput = {
    AND?: AccountSetupTokenScalarWhereWithAggregatesInput | AccountSetupTokenScalarWhereWithAggregatesInput[]
    OR?: AccountSetupTokenScalarWhereWithAggregatesInput[]
    NOT?: AccountSetupTokenScalarWhereWithAggregatesInput | AccountSetupTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountSetupToken"> | string
    code?: StringWithAggregatesFilter<"AccountSetupToken"> | string
    userId?: StringWithAggregatesFilter<"AccountSetupToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"AccountSetupToken"> | Date | string
    used?: BoolWithAggregatesFilter<"AccountSetupToken"> | boolean
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: StringFilter<"Address"> | string
    street?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    zipCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    Company?: CompanyListRelationFilter
    Jobsite?: JobsiteListRelationFilter
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    Company?: CompanyOrderByRelationAggregateInput
    Jobsite?: JobsiteOrderByRelationAggregateInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    street_city_state_zipCode?: AddressStreet_city_state_zipCodeCompoundUniqueInput
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    street?: StringFilter<"Address"> | string
    city?: StringFilter<"Address"> | string
    state?: StringFilter<"Address"> | string
    zipCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    Company?: CompanyListRelationFilter
    Jobsite?: JobsiteListRelationFilter
  }, "id" | "street_city_state_zipCode">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Address"> | string
    street?: StringWithAggregatesFilter<"Address"> | string
    city?: StringWithAggregatesFilter<"Address"> | string
    state?: StringWithAggregatesFilter<"Address"> | string
    zipCode?: StringWithAggregatesFilter<"Address"> | string
    country?: StringWithAggregatesFilter<"Address"> | string
  }

  export type FCMTokenWhereInput = {
    AND?: FCMTokenWhereInput | FCMTokenWhereInput[]
    OR?: FCMTokenWhereInput[]
    NOT?: FCMTokenWhereInput | FCMTokenWhereInput[]
    id?: StringFilter<"FCMToken"> | string
    token?: StringFilter<"FCMToken"> | string
    userId?: StringFilter<"FCMToken"> | string
    platform?: StringNullableFilter<"FCMToken"> | string | null
    lastUsedAt?: DateTimeNullableFilter<"FCMToken"> | Date | string | null
    isValid?: BoolFilter<"FCMToken"> | boolean
    createdAt?: DateTimeFilter<"FCMToken"> | Date | string
    updatedAt?: DateTimeFilter<"FCMToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FCMTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    platform?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FCMTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: FCMTokenWhereInput | FCMTokenWhereInput[]
    OR?: FCMTokenWhereInput[]
    NOT?: FCMTokenWhereInput | FCMTokenWhereInput[]
    userId?: StringFilter<"FCMToken"> | string
    platform?: StringNullableFilter<"FCMToken"> | string | null
    lastUsedAt?: DateTimeNullableFilter<"FCMToken"> | Date | string | null
    isValid?: BoolFilter<"FCMToken"> | boolean
    createdAt?: DateTimeFilter<"FCMToken"> | Date | string
    updatedAt?: DateTimeFilter<"FCMToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type FCMTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    platform?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FCMTokenCountOrderByAggregateInput
    _max?: FCMTokenMaxOrderByAggregateInput
    _min?: FCMTokenMinOrderByAggregateInput
  }

  export type FCMTokenScalarWhereWithAggregatesInput = {
    AND?: FCMTokenScalarWhereWithAggregatesInput | FCMTokenScalarWhereWithAggregatesInput[]
    OR?: FCMTokenScalarWhereWithAggregatesInput[]
    NOT?: FCMTokenScalarWhereWithAggregatesInput | FCMTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FCMToken"> | string
    token?: StringWithAggregatesFilter<"FCMToken"> | string
    userId?: StringWithAggregatesFilter<"FCMToken"> | string
    platform?: StringNullableWithAggregatesFilter<"FCMToken"> | string | null
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"FCMToken"> | Date | string | null
    isValid?: BoolWithAggregatesFilter<"FCMToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FCMToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FCMToken"> | Date | string
  }

  export type TopicSubscriptionWhereInput = {
    AND?: TopicSubscriptionWhereInput | TopicSubscriptionWhereInput[]
    OR?: TopicSubscriptionWhereInput[]
    NOT?: TopicSubscriptionWhereInput | TopicSubscriptionWhereInput[]
    id?: StringFilter<"TopicSubscription"> | string
    topic?: StringFilter<"TopicSubscription"> | string
    createdAt?: DateTimeFilter<"TopicSubscription"> | Date | string
    userId?: StringFilter<"TopicSubscription"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TopicSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    topic?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TopicSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_topic?: TopicSubscriptionUserIdTopicCompoundUniqueInput
    AND?: TopicSubscriptionWhereInput | TopicSubscriptionWhereInput[]
    OR?: TopicSubscriptionWhereInput[]
    NOT?: TopicSubscriptionWhereInput | TopicSubscriptionWhereInput[]
    topic?: StringFilter<"TopicSubscription"> | string
    createdAt?: DateTimeFilter<"TopicSubscription"> | Date | string
    userId?: StringFilter<"TopicSubscription"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_topic">

  export type TopicSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    topic?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: TopicSubscriptionCountOrderByAggregateInput
    _max?: TopicSubscriptionMaxOrderByAggregateInput
    _min?: TopicSubscriptionMinOrderByAggregateInput
  }

  export type TopicSubscriptionScalarWhereWithAggregatesInput = {
    AND?: TopicSubscriptionScalarWhereWithAggregatesInput | TopicSubscriptionScalarWhereWithAggregatesInput[]
    OR?: TopicSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: TopicSubscriptionScalarWhereWithAggregatesInput | TopicSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TopicSubscription"> | string
    topic?: StringWithAggregatesFilter<"TopicSubscription"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TopicSubscription"> | Date | string
    userId?: StringWithAggregatesFilter<"TopicSubscription"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    topic?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    body?: StringNullableFilter<"Notification"> | string | null
    url?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    pushedAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    pushAttempts?: IntFilter<"Notification"> | number
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    id?: IntFilter<"Notification"> | number
    referenceId?: StringNullableFilter<"Notification"> | string | null
    Reads?: NotificationReadListRelationFilter
    Response?: XOR<NotificationResponseNullableScalarRelationFilter, NotificationResponseWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    topic?: SortOrderInput | SortOrder
    title?: SortOrder
    body?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    pushedAt?: SortOrderInput | SortOrder
    pushAttempts?: SortOrder
    readAt?: SortOrderInput | SortOrder
    id?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    Reads?: NotificationReadOrderByRelationAggregateInput
    Response?: NotificationResponseOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    topic?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    body?: StringNullableFilter<"Notification"> | string | null
    url?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    pushedAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    pushAttempts?: IntFilter<"Notification"> | number
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    referenceId?: StringNullableFilter<"Notification"> | string | null
    Reads?: NotificationReadListRelationFilter
    Response?: XOR<NotificationResponseNullableScalarRelationFilter, NotificationResponseWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    topic?: SortOrderInput | SortOrder
    title?: SortOrder
    body?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    pushedAt?: SortOrderInput | SortOrder
    pushAttempts?: SortOrder
    readAt?: SortOrderInput | SortOrder
    id?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    topic?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    url?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    pushedAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    pushAttempts?: IntWithAggregatesFilter<"Notification"> | number
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    id?: IntWithAggregatesFilter<"Notification"> | number
    referenceId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
  }

  export type NotificationResponseWhereInput = {
    AND?: NotificationResponseWhereInput | NotificationResponseWhereInput[]
    OR?: NotificationResponseWhereInput[]
    NOT?: NotificationResponseWhereInput | NotificationResponseWhereInput[]
    id?: IntFilter<"NotificationResponse"> | number
    notificationId?: IntFilter<"NotificationResponse"> | number
    userId?: StringFilter<"NotificationResponse"> | string
    response?: StringNullableFilter<"NotificationResponse"> | string | null
    respondedAt?: DateTimeFilter<"NotificationResponse"> | Date | string
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationResponseOrderByWithRelationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    response?: SortOrderInput | SortOrder
    respondedAt?: SortOrder
    notification?: NotificationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NotificationResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    notificationId?: number
    AND?: NotificationResponseWhereInput | NotificationResponseWhereInput[]
    OR?: NotificationResponseWhereInput[]
    NOT?: NotificationResponseWhereInput | NotificationResponseWhereInput[]
    userId?: StringFilter<"NotificationResponse"> | string
    response?: StringNullableFilter<"NotificationResponse"> | string | null
    respondedAt?: DateTimeFilter<"NotificationResponse"> | Date | string
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "notificationId">

  export type NotificationResponseOrderByWithAggregationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    response?: SortOrderInput | SortOrder
    respondedAt?: SortOrder
    _count?: NotificationResponseCountOrderByAggregateInput
    _avg?: NotificationResponseAvgOrderByAggregateInput
    _max?: NotificationResponseMaxOrderByAggregateInput
    _min?: NotificationResponseMinOrderByAggregateInput
    _sum?: NotificationResponseSumOrderByAggregateInput
  }

  export type NotificationResponseScalarWhereWithAggregatesInput = {
    AND?: NotificationResponseScalarWhereWithAggregatesInput | NotificationResponseScalarWhereWithAggregatesInput[]
    OR?: NotificationResponseScalarWhereWithAggregatesInput[]
    NOT?: NotificationResponseScalarWhereWithAggregatesInput | NotificationResponseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NotificationResponse"> | number
    notificationId?: IntWithAggregatesFilter<"NotificationResponse"> | number
    userId?: StringWithAggregatesFilter<"NotificationResponse"> | string
    response?: StringNullableWithAggregatesFilter<"NotificationResponse"> | string | null
    respondedAt?: DateTimeWithAggregatesFilter<"NotificationResponse"> | Date | string
  }

  export type NotificationReadWhereInput = {
    AND?: NotificationReadWhereInput | NotificationReadWhereInput[]
    OR?: NotificationReadWhereInput[]
    NOT?: NotificationReadWhereInput | NotificationReadWhereInput[]
    id?: IntFilter<"NotificationRead"> | number
    notificationId?: IntFilter<"NotificationRead"> | number
    userId?: StringFilter<"NotificationRead"> | string
    readAt?: DateTimeFilter<"NotificationRead"> | Date | string
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationReadOrderByWithRelationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    notification?: NotificationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NotificationReadWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    notificationId_userId?: NotificationReadNotificationIdUserIdCompoundUniqueInput
    AND?: NotificationReadWhereInput | NotificationReadWhereInput[]
    OR?: NotificationReadWhereInput[]
    NOT?: NotificationReadWhereInput | NotificationReadWhereInput[]
    notificationId?: IntFilter<"NotificationRead"> | number
    userId?: StringFilter<"NotificationRead"> | string
    readAt?: DateTimeFilter<"NotificationRead"> | Date | string
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "notificationId_userId">

  export type NotificationReadOrderByWithAggregationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    _count?: NotificationReadCountOrderByAggregateInput
    _avg?: NotificationReadAvgOrderByAggregateInput
    _max?: NotificationReadMaxOrderByAggregateInput
    _min?: NotificationReadMinOrderByAggregateInput
    _sum?: NotificationReadSumOrderByAggregateInput
  }

  export type NotificationReadScalarWhereWithAggregatesInput = {
    AND?: NotificationReadScalarWhereWithAggregatesInput | NotificationReadScalarWhereWithAggregatesInput[]
    OR?: NotificationReadScalarWhereWithAggregatesInput[]
    NOT?: NotificationReadScalarWhereWithAggregatesInput | NotificationReadScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NotificationRead"> | number
    notificationId?: IntWithAggregatesFilter<"NotificationRead"> | number
    userId?: StringWithAggregatesFilter<"NotificationRead"> | string
    readAt?: DateTimeWithAggregatesFilter<"NotificationRead"> | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubscriptionDate?: Date | string
    Address?: AddressCreateNestedOneWithoutCompanyInput
    FormTemplates?: FormTemplateCreateNestedManyWithoutCompanyInput
    Reports?: ReportCreateNestedManyWithoutCompanyInput
    Users?: UserCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    addressId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SubscriptionDate?: Date | string
    FormTemplates?: FormTemplateUncheckedCreateNestedManyWithoutCompanyInput
    Reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    Users?: UserUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubscriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Address?: AddressUpdateOneWithoutCompanyNestedInput
    FormTemplates?: FormTemplateUpdateManyWithoutCompanyNestedInput
    Reports?: ReportUpdateManyWithoutCompanyNestedInput
    Users?: UserUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubscriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FormTemplates?: FormTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    Reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    Users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    addressId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SubscriptionDate?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubscriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubscriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCodeCreateInput = {
    id?: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code?: string | null
    Timesheets?: TimeSheetCreateNestedManyWithoutCostCodeInput
    CCTags?: CCTagCreateNestedManyWithoutCostCodesInput
  }

  export type CostCodeUncheckedCreateInput = {
    id?: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code?: string | null
    Timesheets?: TimeSheetUncheckedCreateNestedManyWithoutCostCodeInput
    CCTags?: CCTagUncheckedCreateNestedManyWithoutCostCodesInput
  }

  export type CostCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    Timesheets?: TimeSheetUpdateManyWithoutCostCodeNestedInput
    CCTags?: CCTagUpdateManyWithoutCostCodesNestedInput
  }

  export type CostCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    Timesheets?: TimeSheetUncheckedUpdateManyWithoutCostCodeNestedInput
    CCTags?: CCTagUncheckedUpdateManyWithoutCostCodesNestedInput
  }

  export type CostCodeCreateManyInput = {
    id?: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code?: string | null
  }

  export type CostCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CostCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CCTagCreateInput = {
    id?: string
    name: string
    description?: string | null
    CostCodes?: CostCodeCreateNestedManyWithoutCCTagsInput
    Jobsites?: JobsiteCreateNestedManyWithoutCCTagsInput
  }

  export type CCTagUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    CostCodes?: CostCodeUncheckedCreateNestedManyWithoutCCTagsInput
    Jobsites?: JobsiteUncheckedCreateNestedManyWithoutCCTagsInput
  }

  export type CCTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    CostCodes?: CostCodeUpdateManyWithoutCCTagsNestedInput
    Jobsites?: JobsiteUpdateManyWithoutCCTagsNestedInput
  }

  export type CCTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    CostCodes?: CostCodeUncheckedUpdateManyWithoutCCTagsNestedInput
    Jobsites?: JobsiteUncheckedUpdateManyWithoutCCTagsNestedInput
  }

  export type CCTagCreateManyInput = {
    id?: string
    name: string
    description?: string | null
  }

  export type CCTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CCTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CrewCreateInput = {
    id?: string
    name: string
    leadId: string
    crewType: $Enums.WorkType
    createdAt?: Date | string
    updatedAt?: Date | string
    Users?: UserCreateNestedManyWithoutCrewsInput
  }

  export type CrewUncheckedCreateInput = {
    id?: string
    name: string
    leadId: string
    crewType: $Enums.WorkType
    createdAt?: Date | string
    updatedAt?: Date | string
    Users?: UserUncheckedCreateNestedManyWithoutCrewsInput
  }

  export type CrewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    crewType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UserUpdateManyWithoutCrewsNestedInput
  }

  export type CrewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    crewType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Users?: UserUncheckedUpdateManyWithoutCrewsNestedInput
  }

  export type CrewCreateManyInput = {
    id?: string
    name: string
    leadId: string
    crewType: $Enums.WorkType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    crewType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    crewType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfDocumentCreateInput = {
    id?: string
    qrId: string
    fileName: string
    description?: string | null
    fileData: Bytes
    contentType?: string
    size: number
    isActive?: boolean
    createdAt?: Date | string
    uploadDate?: Date | string
    DocumentTags?: DocumentTagCreateNestedManyWithoutDocumentsInput
  }

  export type PdfDocumentUncheckedCreateInput = {
    id?: string
    qrId: string
    fileName: string
    description?: string | null
    fileData: Bytes
    contentType?: string
    size: number
    isActive?: boolean
    createdAt?: Date | string
    uploadDate?: Date | string
    DocumentTags?: DocumentTagUncheckedCreateNestedManyWithoutDocumentsInput
  }

  export type PdfDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileData?: BytesFieldUpdateOperationsInput | Bytes
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    DocumentTags?: DocumentTagUpdateManyWithoutDocumentsNestedInput
  }

  export type PdfDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileData?: BytesFieldUpdateOperationsInput | Bytes
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
    DocumentTags?: DocumentTagUncheckedUpdateManyWithoutDocumentsNestedInput
  }

  export type PdfDocumentCreateManyInput = {
    id?: string
    qrId: string
    fileName: string
    description?: string | null
    fileData: Bytes
    contentType?: string
    size: number
    isActive?: boolean
    createdAt?: Date | string
    uploadDate?: Date | string
  }

  export type PdfDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileData?: BytesFieldUpdateOperationsInput | Bytes
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileData?: BytesFieldUpdateOperationsInput | Bytes
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentTagCreateInput = {
    id?: string
    tagName: string
    Equipment?: EquipmentCreateNestedManyWithoutDocumentTagsInput
    Documents?: PdfDocumentCreateNestedManyWithoutDocumentTagsInput
  }

  export type DocumentTagUncheckedCreateInput = {
    id?: string
    tagName: string
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutDocumentTagsInput
    Documents?: PdfDocumentUncheckedCreateNestedManyWithoutDocumentTagsInput
  }

  export type DocumentTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    Equipment?: EquipmentUpdateManyWithoutDocumentTagsNestedInput
    Documents?: PdfDocumentUpdateManyWithoutDocumentTagsNestedInput
  }

  export type DocumentTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    Equipment?: EquipmentUncheckedUpdateManyWithoutDocumentTagsNestedInput
    Documents?: PdfDocumentUncheckedUpdateManyWithoutDocumentTagsNestedInput
  }

  export type DocumentTagCreateManyInput = {
    id?: string
    tagName: string
  }

  export type DocumentTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
  }

  export type EquipmentCreateInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutEquipmentInput
    createdBy?: UserCreateNestedOneWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogUncheckedCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogUncheckedCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogUncheckedCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutEquipmentNestedInput
    createdBy?: UserUpdateOneWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUncheckedUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUncheckedUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUncheckedUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentCreateManyInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
  }

  export type EquipmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
  }

  export type EquipmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
  }

  export type EmployeeEquipmentLogCreateInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    comment?: string | null
    rental?: boolean
    Equipment?: EquipmentCreateNestedOneWithoutEmployeeEquipmentLogsInput
    Maintenance?: MaintenanceCreateNestedOneWithoutEmployeeEquipmentLogInput
    TimeSheet: TimeSheetCreateNestedOneWithoutEmployeeEquipmentLogsInput
    RefuelLog?: RefuelLogCreateNestedOneWithoutEmployeeEquipmentLogInput
  }

  export type EmployeeEquipmentLogUncheckedCreateInput = {
    id?: string
    equipmentId?: string | null
    maintenanceId?: string | null
    startTime?: Date | string
    endTime?: Date | string | null
    comment?: string | null
    timeSheetId: number
    rental?: boolean
    RefuelLog?: RefuelLogUncheckedCreateNestedOneWithoutEmployeeEquipmentLogInput
  }

  export type EmployeeEquipmentLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    rental?: BoolFieldUpdateOperationsInput | boolean
    Equipment?: EquipmentUpdateOneWithoutEmployeeEquipmentLogsNestedInput
    Maintenance?: MaintenanceUpdateOneWithoutEmployeeEquipmentLogNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutEmployeeEquipmentLogsNestedInput
    RefuelLog?: RefuelLogUpdateOneWithoutEmployeeEquipmentLogNestedInput
  }

  export type EmployeeEquipmentLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    rental?: BoolFieldUpdateOperationsInput | boolean
    RefuelLog?: RefuelLogUncheckedUpdateOneWithoutEmployeeEquipmentLogNestedInput
  }

  export type EmployeeEquipmentLogCreateManyInput = {
    id?: string
    equipmentId?: string | null
    maintenanceId?: string | null
    startTime?: Date | string
    endTime?: Date | string | null
    comment?: string | null
    timeSheetId: number
    rental?: boolean
  }

  export type EmployeeEquipmentLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    rental?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmployeeEquipmentLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    rental?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FormTemplateCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isSignatureRequired?: boolean
    description?: string | null
    isActive?: $Enums.FormTemplateStatus
    formType?: $Enums.FormTemplateCategory
    isApprovalRequired?: boolean
    Submissions?: FormSubmissionCreateNestedManyWithoutFormTemplateInput
    Company: CompanyCreateNestedOneWithoutFormTemplatesInput
    FormGrouping?: FormGroupingCreateNestedManyWithoutFormTemplateInput
  }

  export type FormTemplateUncheckedCreateInput = {
    id?: string
    companyId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isSignatureRequired?: boolean
    description?: string | null
    isActive?: $Enums.FormTemplateStatus
    formType?: $Enums.FormTemplateCategory
    isApprovalRequired?: boolean
    Submissions?: FormSubmissionUncheckedCreateNestedManyWithoutFormTemplateInput
    FormGrouping?: FormGroupingUncheckedCreateNestedManyWithoutFormTemplateInput
  }

  export type FormTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSignatureRequired?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    formType?: EnumFormTemplateCategoryFieldUpdateOperationsInput | $Enums.FormTemplateCategory
    isApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    Submissions?: FormSubmissionUpdateManyWithoutFormTemplateNestedInput
    Company?: CompanyUpdateOneRequiredWithoutFormTemplatesNestedInput
    FormGrouping?: FormGroupingUpdateManyWithoutFormTemplateNestedInput
  }

  export type FormTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSignatureRequired?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    formType?: EnumFormTemplateCategoryFieldUpdateOperationsInput | $Enums.FormTemplateCategory
    isApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    Submissions?: FormSubmissionUncheckedUpdateManyWithoutFormTemplateNestedInput
    FormGrouping?: FormGroupingUncheckedUpdateManyWithoutFormTemplateNestedInput
  }

  export type FormTemplateCreateManyInput = {
    id?: string
    companyId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isSignatureRequired?: boolean
    description?: string | null
    isActive?: $Enums.FormTemplateStatus
    formType?: $Enums.FormTemplateCategory
    isApprovalRequired?: boolean
  }

  export type FormTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSignatureRequired?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    formType?: EnumFormTemplateCategoryFieldUpdateOperationsInput | $Enums.FormTemplateCategory
    isApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FormTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSignatureRequired?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    formType?: EnumFormTemplateCategoryFieldUpdateOperationsInput | $Enums.FormTemplateCategory
    isApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FormGroupingCreateInput = {
    id?: string
    title?: string | null
    order: number
    Fields?: FormFieldCreateNestedManyWithoutFormGroupingInput
    FormTemplate?: FormTemplateCreateNestedManyWithoutFormGroupingInput
  }

  export type FormGroupingUncheckedCreateInput = {
    id?: string
    title?: string | null
    order: number
    Fields?: FormFieldUncheckedCreateNestedManyWithoutFormGroupingInput
    FormTemplate?: FormTemplateUncheckedCreateNestedManyWithoutFormGroupingInput
  }

  export type FormGroupingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    Fields?: FormFieldUpdateManyWithoutFormGroupingNestedInput
    FormTemplate?: FormTemplateUpdateManyWithoutFormGroupingNestedInput
  }

  export type FormGroupingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    Fields?: FormFieldUncheckedUpdateManyWithoutFormGroupingNestedInput
    FormTemplate?: FormTemplateUncheckedUpdateManyWithoutFormGroupingNestedInput
  }

  export type FormGroupingCreateManyInput = {
    id?: string
    title?: string | null
    order: number
  }

  export type FormGroupingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type FormGroupingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type FormFieldCreateInput = {
    id?: string
    label: string
    type: $Enums.FieldType
    required?: boolean
    order: number
    placeholder?: string | null
    maxLength?: number | null
    content?: string | null
    filter?: string | null
    minLength?: number | null
    multiple?: boolean | null
    FormGrouping: FormGroupingCreateNestedOneWithoutFieldsInput
    Options?: FormFieldOptionCreateNestedManyWithoutFieldInput
  }

  export type FormFieldUncheckedCreateInput = {
    id?: string
    formGroupingId: string
    label: string
    type: $Enums.FieldType
    required?: boolean
    order: number
    placeholder?: string | null
    maxLength?: number | null
    content?: string | null
    filter?: string | null
    minLength?: number | null
    multiple?: boolean | null
    Options?: FormFieldOptionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FormFieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    minLength?: NullableIntFieldUpdateOperationsInput | number | null
    multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    FormGrouping?: FormGroupingUpdateOneRequiredWithoutFieldsNestedInput
    Options?: FormFieldOptionUpdateManyWithoutFieldNestedInput
  }

  export type FormFieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    formGroupingId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    minLength?: NullableIntFieldUpdateOperationsInput | number | null
    multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Options?: FormFieldOptionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type FormFieldCreateManyInput = {
    id?: string
    formGroupingId: string
    label: string
    type: $Enums.FieldType
    required?: boolean
    order: number
    placeholder?: string | null
    maxLength?: number | null
    content?: string | null
    filter?: string | null
    minLength?: number | null
    multiple?: boolean | null
  }

  export type FormFieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    minLength?: NullableIntFieldUpdateOperationsInput | number | null
    multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FormFieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    formGroupingId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    minLength?: NullableIntFieldUpdateOperationsInput | number | null
    multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FormFieldOptionCreateInput = {
    id?: string
    value: string
    Field: FormFieldCreateNestedOneWithoutOptionsInput
  }

  export type FormFieldOptionUncheckedCreateInput = {
    id?: string
    fieldId: string
    value: string
  }

  export type FormFieldOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    Field?: FormFieldUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type FormFieldOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type FormFieldOptionCreateManyInput = {
    id?: string
    fieldId: string
    value: string
  }

  export type FormFieldOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type FormFieldOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fieldId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type FormSubmissionCreateInput = {
    title?: string | null
    formType?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    status?: $Enums.FormStatus
    Approvals?: FormApprovalCreateNestedManyWithoutFormSubmissionInput
    FormTemplate: FormTemplateCreateNestedOneWithoutSubmissionsInput
    User: UserCreateNestedOneWithoutFormSubmissionsInput
  }

  export type FormSubmissionUncheckedCreateInput = {
    title?: string | null
    formTemplateId: string
    userId: string
    formType?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    status?: $Enums.FormStatus
    id?: number
    Approvals?: FormApprovalUncheckedCreateNestedManyWithoutFormSubmissionInput
  }

  export type FormSubmissionUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    formType?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    Approvals?: FormApprovalUpdateManyWithoutFormSubmissionNestedInput
    FormTemplate?: FormTemplateUpdateOneRequiredWithoutSubmissionsNestedInput
    User?: UserUpdateOneRequiredWithoutFormSubmissionsNestedInput
  }

  export type FormSubmissionUncheckedUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    formTemplateId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    formType?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    id?: IntFieldUpdateOperationsInput | number
    Approvals?: FormApprovalUncheckedUpdateManyWithoutFormSubmissionNestedInput
  }

  export type FormSubmissionCreateManyInput = {
    title?: string | null
    formTemplateId: string
    userId: string
    formType?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    status?: $Enums.FormStatus
    id?: number
  }

  export type FormSubmissionUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    formType?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
  }

  export type FormSubmissionUncheckedUpdateManyInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    formTemplateId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    formType?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    id?: IntFieldUpdateOperationsInput | number
  }

  export type FormApprovalCreateInput = {
    id?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    signature?: string | null
    comment?: string | null
    FormSubmission: FormSubmissionCreateNestedOneWithoutApprovalsInput
    Approver?: UserCreateNestedOneWithoutFormApprovalsInput
  }

  export type FormApprovalUncheckedCreateInput = {
    id?: string
    signedBy?: string | null
    submittedAt?: Date | string
    updatedAt?: Date | string
    signature?: string | null
    comment?: string | null
    formSubmissionId: number
  }

  export type FormApprovalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    FormSubmission?: FormSubmissionUpdateOneRequiredWithoutApprovalsNestedInput
    Approver?: UserUpdateOneWithoutFormApprovalsNestedInput
  }

  export type FormApprovalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    formSubmissionId?: IntFieldUpdateOperationsInput | number
  }

  export type FormApprovalCreateManyInput = {
    id?: string
    signedBy?: string | null
    submittedAt?: Date | string
    updatedAt?: Date | string
    signature?: string | null
    comment?: string | null
    formSubmissionId: number
  }

  export type FormApprovalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FormApprovalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    formSubmissionId?: IntFieldUpdateOperationsInput | number
  }

  export type JobsiteCreateInput = {
    id?: string
    qrId?: string
    name: string
    description: string
    creationReason?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    archiveDate?: Date | string | null
    createdVia?: $Enums.CreatedVia
    code?: string | null
    latitude?: number | null
    longitude?: number | null
    radiusMeters?: number | null
    status?: $Enums.FormTemplateStatus
    Address?: AddressCreateNestedOneWithoutJobsiteInput
    createdBy?: UserCreateNestedOneWithoutJobsiteInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutJobsiteInput
    CCTags?: CCTagCreateNestedManyWithoutJobsitesInput
  }

  export type JobsiteUncheckedCreateInput = {
    id?: string
    qrId?: string
    name: string
    description: string
    creationReason?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    addressId?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    archiveDate?: Date | string | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    code?: string | null
    latitude?: number | null
    longitude?: number | null
    radiusMeters?: number | null
    status?: $Enums.FormTemplateStatus
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutJobsiteInput
    CCTags?: CCTagUncheckedCreateNestedManyWithoutJobsitesInput
  }

  export type JobsiteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    code?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radiusMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    Address?: AddressUpdateOneWithoutJobsiteNestedInput
    createdBy?: UserUpdateOneWithoutJobsiteNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutJobsiteNestedInput
    CCTags?: CCTagUpdateManyWithoutJobsitesNestedInput
  }

  export type JobsiteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    code?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radiusMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutJobsiteNestedInput
    CCTags?: CCTagUncheckedUpdateManyWithoutJobsitesNestedInput
  }

  export type JobsiteCreateManyInput = {
    id?: string
    qrId?: string
    name: string
    description: string
    creationReason?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    addressId?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    archiveDate?: Date | string | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    code?: string | null
    latitude?: number | null
    longitude?: number | null
    radiusMeters?: number | null
    status?: $Enums.FormTemplateStatus
  }

  export type JobsiteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    code?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radiusMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
  }

  export type JobsiteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    code?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radiusMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
  }

  export type ReportCreateInput = {
    name: string
    description: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.ReportVisibility
    tags?: ReportCreatetagsInput | string[]
    id: number
    Company: CompanyCreateNestedOneWithoutReportsInput
    ReportRuns?: ReportRunCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateInput = {
    name: string
    description: string
    companyId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.ReportVisibility
    tags?: ReportCreatetagsInput | string[]
    id: number
    ReportRuns?: ReportRunUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumReportVisibilityFieldUpdateOperationsInput | $Enums.ReportVisibility
    tags?: ReportUpdatetagsInput | string[]
    id?: IntFieldUpdateOperationsInput | number
    Company?: CompanyUpdateOneRequiredWithoutReportsNestedInput
    ReportRuns?: ReportRunUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumReportVisibilityFieldUpdateOperationsInput | $Enums.ReportVisibility
    tags?: ReportUpdatetagsInput | string[]
    id?: IntFieldUpdateOperationsInput | number
    ReportRuns?: ReportRunUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportCreateManyInput = {
    name: string
    description: string
    companyId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.ReportVisibility
    tags?: ReportCreatetagsInput | string[]
    id: number
  }

  export type ReportUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumReportVisibilityFieldUpdateOperationsInput | $Enums.ReportVisibility
    tags?: ReportUpdatetagsInput | string[]
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ReportUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumReportVisibilityFieldUpdateOperationsInput | $Enums.ReportVisibility
    tags?: ReportUpdatetagsInput | string[]
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ReportRunCreateInput = {
    id?: string
    runAt?: Date | string
    status: $Enums.ReportStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    customParams?: NullableJsonNullValueInput | InputJsonValue
    exportFormats?: ReportRunCreateexportFormatsInput | string[]
    lastExportedAt?: Date | string | null
    Report: ReportCreateNestedOneWithoutReportRunsInput
  }

  export type ReportRunUncheckedCreateInput = {
    id?: string
    runAt?: Date | string
    status: $Enums.ReportStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    customParams?: NullableJsonNullValueInput | InputJsonValue
    exportFormats?: ReportRunCreateexportFormatsInput | string[]
    lastExportedAt?: Date | string | null
    reportId: number
  }

  export type ReportRunUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customParams?: NullableJsonNullValueInput | InputJsonValue
    exportFormats?: ReportRunUpdateexportFormatsInput | string[]
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Report?: ReportUpdateOneRequiredWithoutReportRunsNestedInput
  }

  export type ReportRunUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customParams?: NullableJsonNullValueInput | InputJsonValue
    exportFormats?: ReportRunUpdateexportFormatsInput | string[]
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportId?: IntFieldUpdateOperationsInput | number
  }

  export type ReportRunCreateManyInput = {
    id?: string
    runAt?: Date | string
    status: $Enums.ReportStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    customParams?: NullableJsonNullValueInput | InputJsonValue
    exportFormats?: ReportRunCreateexportFormatsInput | string[]
    lastExportedAt?: Date | string | null
    reportId: number
  }

  export type ReportRunUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customParams?: NullableJsonNullValueInput | InputJsonValue
    exportFormats?: ReportRunUpdateexportFormatsInput | string[]
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportRunUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customParams?: NullableJsonNullValueInput | InputJsonValue
    exportFormats?: ReportRunUpdateexportFormatsInput | string[]
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reportId?: IntFieldUpdateOperationsInput | number
  }

  export type TimeSheetCreateInput = {
    date: Date | string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutTimeSheetInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogCreateNestedManyWithoutTimeSheetInput
    CostCode: CostCodeCreateNestedOneWithoutTimesheetsInput
    Jobsite: JobsiteCreateNestedOneWithoutTimeSheetsInput
    User: UserCreateNestedOneWithoutTimeSheetsInput
    ChangeLogs?: TimeSheetChangeLogCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetUncheckedCreateInput = {
    date: Date | string
    userId: string
    jobsiteId: string
    costcode: string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    id?: number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutTimeSheetInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutTimeSheetInput
    ChangeLogs?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogUncheckedCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutTimeSheetNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutTimeSheetNestedInput
    CostCode?: CostCodeUpdateOneRequiredWithoutTimesheetsNestedInput
    Jobsite?: JobsiteUpdateOneRequiredWithoutTimeSheetsNestedInput
    User?: UserUpdateOneRequiredWithoutTimeSheetsNestedInput
    ChangeLogs?: TimeSheetChangeLogUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutTimeSheetNestedInput
  }

  export type TimeSheetUncheckedUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    jobsiteId?: StringFieldUpdateOperationsInput | string
    costcode?: StringFieldUpdateOperationsInput | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    ChangeLogs?: TimeSheetChangeLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutTimeSheetNestedInput
  }

  export type TimeSheetCreateManyInput = {
    date: Date | string
    userId: string
    jobsiteId: string
    costcode: string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    id?: number
  }

  export type TimeSheetUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TimeSheetUncheckedUpdateManyInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    jobsiteId?: StringFieldUpdateOperationsInput | string
    costcode?: StringFieldUpdateOperationsInput | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type mechanicProjectsCreateInput = {
    hours?: number | null
    description?: string | null
    Equipment: EquipmentCreateNestedOneWithoutMaintenanceInput
    TimeSheet: TimeSheetCreateNestedOneWithoutMaintenanceInput
  }

  export type mechanicProjectsUncheckedCreateInput = {
    id?: number
    timeSheetId: number
    hours?: number | null
    equipmentId: string
    description?: string | null
  }

  export type mechanicProjectsUpdateInput = {
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Equipment?: EquipmentUpdateOneRequiredWithoutMaintenanceNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutMaintenanceNestedInput
  }

  export type mechanicProjectsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timeSheetId?: IntFieldUpdateOperationsInput | number
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mechanicProjectsCreateManyInput = {
    id?: number
    timeSheetId: number
    hours?: number | null
    equipmentId: string
    description?: string | null
  }

  export type mechanicProjectsUpdateManyMutationInput = {
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mechanicProjectsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timeSheetId?: IntFieldUpdateOperationsInput | number
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceLogCreateInput = {
    id?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    Maintenance: MaintenanceCreateNestedOneWithoutMaintenanceLogsInput
    TimeSheet: TimeSheetCreateNestedOneWithoutMaintenanceLogsInput
    User: UserCreateNestedOneWithoutMaintenanceLogsInput
  }

  export type MaintenanceLogUncheckedCreateInput = {
    id?: string
    userId: string
    maintenanceId: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    timeSheetId: number
  }

  export type MaintenanceLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    Maintenance?: MaintenanceUpdateOneRequiredWithoutMaintenanceLogsNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutMaintenanceLogsNestedInput
    User?: UserUpdateOneRequiredWithoutMaintenanceLogsNestedInput
  }

  export type MaintenanceLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    maintenanceId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
  }

  export type MaintenanceLogCreateManyInput = {
    id?: string
    userId: string
    maintenanceId: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    timeSheetId: number
  }

  export type MaintenanceLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    maintenanceId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
  }

  export type MaintenanceCreateInput = {
    id?: string
    equipmentIssue?: string | null
    employeeEquipmentLogId?: string | null
    additionalInfo?: string | null
    location?: string | null
    problemDiagnosis?: string | null
    solution?: string | null
    totalHoursLaboured?: number | null
    createdAt?: Date | string
    priority: $Enums.Priority
    delay?: Date | string | null
    delayReasoning?: string | null
    repaired?: boolean
    selected?: boolean
    hasBeenDelayed?: boolean
    createdBy?: string | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogCreateNestedManyWithoutMaintenanceInput
    Equipment: EquipmentCreateNestedOneWithoutMaintenancesInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutMaintenanceInput
  }

  export type MaintenanceUncheckedCreateInput = {
    id?: string
    equipmentId: string
    equipmentIssue?: string | null
    employeeEquipmentLogId?: string | null
    additionalInfo?: string | null
    location?: string | null
    problemDiagnosis?: string | null
    solution?: string | null
    totalHoursLaboured?: number | null
    createdAt?: Date | string
    priority: $Enums.Priority
    delay?: Date | string | null
    delayReasoning?: string | null
    repaired?: boolean
    selected?: boolean
    hasBeenDelayed?: boolean
    createdBy?: string | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutMaintenanceInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutMaintenanceInput
  }

  export type MaintenanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentIssue?: NullableStringFieldUpdateOperationsInput | string | null
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    problemDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    totalHoursLaboured?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    delay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delayReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    repaired?: BoolFieldUpdateOperationsInput | boolean
    selected?: BoolFieldUpdateOperationsInput | boolean
    hasBeenDelayed?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogUpdateManyWithoutMaintenanceNestedInput
    Equipment?: EquipmentUpdateOneRequiredWithoutMaintenancesNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutMaintenanceNestedInput
  }

  export type MaintenanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    equipmentIssue?: NullableStringFieldUpdateOperationsInput | string | null
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    problemDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    totalHoursLaboured?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    delay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delayReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    repaired?: BoolFieldUpdateOperationsInput | boolean
    selected?: BoolFieldUpdateOperationsInput | boolean
    hasBeenDelayed?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogUncheckedUpdateManyWithoutMaintenanceNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutMaintenanceNestedInput
  }

  export type MaintenanceCreateManyInput = {
    id?: string
    equipmentId: string
    equipmentIssue?: string | null
    employeeEquipmentLogId?: string | null
    additionalInfo?: string | null
    location?: string | null
    problemDiagnosis?: string | null
    solution?: string | null
    totalHoursLaboured?: number | null
    createdAt?: Date | string
    priority: $Enums.Priority
    delay?: Date | string | null
    delayReasoning?: string | null
    repaired?: boolean
    selected?: boolean
    hasBeenDelayed?: boolean
    createdBy?: string | null
  }

  export type MaintenanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentIssue?: NullableStringFieldUpdateOperationsInput | string | null
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    problemDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    totalHoursLaboured?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    delay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delayReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    repaired?: BoolFieldUpdateOperationsInput | boolean
    selected?: BoolFieldUpdateOperationsInput | boolean
    hasBeenDelayed?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    equipmentIssue?: NullableStringFieldUpdateOperationsInput | string | null
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    problemDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    totalHoursLaboured?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    delay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delayReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    repaired?: BoolFieldUpdateOperationsInput | boolean
    selected?: BoolFieldUpdateOperationsInput | boolean
    hasBeenDelayed?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TascoLogCreateInput = {
    id?: string
    shiftType: string
    laborType?: string | null
    LoadQuantity?: number
    screenType?: $Enums.LoadType | null
    RefuelLogs?: RefuelLogCreateNestedManyWithoutTascoLogInput
    TascoFLoads?: TascoFLoadsCreateNestedManyWithoutTascoLogInput
    Equipment?: EquipmentCreateNestedOneWithoutTascoLogsInput
    TascoMaterialTypes?: TascoMaterialTypesCreateNestedOneWithoutTascoLogInput
    TimeSheet: TimeSheetCreateNestedOneWithoutTascoLogsInput
  }

  export type TascoLogUncheckedCreateInput = {
    id?: string
    shiftType: string
    equipmentId?: string | null
    laborType?: string | null
    materialType?: string | null
    LoadQuantity?: number
    screenType?: $Enums.LoadType | null
    timeSheetId: number
    RefuelLogs?: RefuelLogUncheckedCreateNestedManyWithoutTascoLogInput
    TascoFLoads?: TascoFLoadsUncheckedCreateNestedManyWithoutTascoLogInput
  }

  export type TascoLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    RefuelLogs?: RefuelLogUpdateManyWithoutTascoLogNestedInput
    TascoFLoads?: TascoFLoadsUpdateManyWithoutTascoLogNestedInput
    Equipment?: EquipmentUpdateOneWithoutTascoLogsNestedInput
    TascoMaterialTypes?: TascoMaterialTypesUpdateOneWithoutTascoLogNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutTascoLogsNestedInput
  }

  export type TascoLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    materialType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    RefuelLogs?: RefuelLogUncheckedUpdateManyWithoutTascoLogNestedInput
    TascoFLoads?: TascoFLoadsUncheckedUpdateManyWithoutTascoLogNestedInput
  }

  export type TascoLogCreateManyInput = {
    id?: string
    shiftType: string
    equipmentId?: string | null
    laborType?: string | null
    materialType?: string | null
    LoadQuantity?: number
    screenType?: $Enums.LoadType | null
    timeSheetId: number
  }

  export type TascoLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
  }

  export type TascoLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    materialType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
  }

  export type TascoFLoadsCreateInput = {
    weight?: number | null
    screenType?: $Enums.LoadType | null
    TascoLog: TascoLogCreateNestedOneWithoutTascoFLoadsInput
  }

  export type TascoFLoadsUncheckedCreateInput = {
    id?: number
    tascoLogId: string
    weight?: number | null
    screenType?: $Enums.LoadType | null
  }

  export type TascoFLoadsUpdateInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    TascoLog?: TascoLogUpdateOneRequiredWithoutTascoFLoadsNestedInput
  }

  export type TascoFLoadsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tascoLogId?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
  }

  export type TascoFLoadsCreateManyInput = {
    id?: number
    tascoLogId: string
    weight?: number | null
    screenType?: $Enums.LoadType | null
  }

  export type TascoFLoadsUpdateManyMutationInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
  }

  export type TascoFLoadsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tascoLogId?: StringFieldUpdateOperationsInput | string
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
  }

  export type TascoMaterialTypesCreateInput = {
    id?: string
    name: string
    TascoLog?: TascoLogCreateNestedManyWithoutTascoMaterialTypesInput
  }

  export type TascoMaterialTypesUncheckedCreateInput = {
    id?: string
    name: string
    TascoLog?: TascoLogUncheckedCreateNestedManyWithoutTascoMaterialTypesInput
  }

  export type TascoMaterialTypesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    TascoLog?: TascoLogUpdateManyWithoutTascoMaterialTypesNestedInput
  }

  export type TascoMaterialTypesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    TascoLog?: TascoLogUncheckedUpdateManyWithoutTascoMaterialTypesNestedInput
  }

  export type TascoMaterialTypesCreateManyInput = {
    id?: string
    name: string
  }

  export type TascoMaterialTypesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TascoMaterialTypesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TruckingLogCreateInput = {
    id?: string
    laborType: string
    taskName?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutTruckingLogInput
    Materials?: MaterialCreateNestedManyWithoutTruckingLogInput
    RefuelLogs?: RefuelLogCreateNestedManyWithoutTruckingLogInput
    StateMileages?: StateMileageCreateNestedManyWithoutTruckingLogInput
    Equipment?: EquipmentCreateNestedOneWithoutHauledInLogsInput
    TimeSheet: TimeSheetCreateNestedOneWithoutTruckingLogsInput
    Trailer?: EquipmentCreateNestedOneWithoutUsedAsTrailerInput
    Truck?: EquipmentCreateNestedOneWithoutUsedAsTruckInput
  }

  export type TruckingLogUncheckedCreateInput = {
    id?: string
    laborType: string
    taskName?: string | null
    equipmentId?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    trailerNumber?: string | null
    truckNumber?: string | null
    timeSheetId: number
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutTruckingLogInput
    Materials?: MaterialUncheckedCreateNestedManyWithoutTruckingLogInput
    RefuelLogs?: RefuelLogUncheckedCreateNestedManyWithoutTruckingLogInput
    StateMileages?: StateMileageUncheckedCreateNestedManyWithoutTruckingLogInput
  }

  export type TruckingLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutTruckingLogNestedInput
    Materials?: MaterialUpdateManyWithoutTruckingLogNestedInput
    RefuelLogs?: RefuelLogUpdateManyWithoutTruckingLogNestedInput
    StateMileages?: StateMileageUpdateManyWithoutTruckingLogNestedInput
    Equipment?: EquipmentUpdateOneWithoutHauledInLogsNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutTruckingLogsNestedInput
    Trailer?: EquipmentUpdateOneWithoutUsedAsTrailerNestedInput
    Truck?: EquipmentUpdateOneWithoutUsedAsTruckNestedInput
  }

  export type TruckingLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    trailerNumber?: NullableStringFieldUpdateOperationsInput | string | null
    truckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutTruckingLogNestedInput
    Materials?: MaterialUncheckedUpdateManyWithoutTruckingLogNestedInput
    RefuelLogs?: RefuelLogUncheckedUpdateManyWithoutTruckingLogNestedInput
    StateMileages?: StateMileageUncheckedUpdateManyWithoutTruckingLogNestedInput
  }

  export type TruckingLogCreateManyInput = {
    id?: string
    laborType: string
    taskName?: string | null
    equipmentId?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    trailerNumber?: string | null
    truckNumber?: string | null
    timeSheetId: number
  }

  export type TruckingLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TruckingLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    trailerNumber?: NullableStringFieldUpdateOperationsInput | string | null
    truckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
  }

  export type StateMileageCreateInput = {
    id?: string
    state?: string | null
    stateLineMileage?: number | null
    TruckingLog: TruckingLogCreateNestedOneWithoutStateMileagesInput
  }

  export type StateMileageUncheckedCreateInput = {
    id?: string
    truckingLogId: string
    state?: string | null
    stateLineMileage?: number | null
  }

  export type StateMileageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    stateLineMileage?: NullableIntFieldUpdateOperationsInput | number | null
    TruckingLog?: TruckingLogUpdateOneRequiredWithoutStateMileagesNestedInput
  }

  export type StateMileageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckingLogId?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    stateLineMileage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StateMileageCreateManyInput = {
    id?: string
    truckingLogId: string
    state?: string | null
    stateLineMileage?: number | null
  }

  export type StateMileageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    stateLineMileage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StateMileageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckingLogId?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    stateLineMileage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MaterialCreateInput = {
    id?: string
    LocationOfMaterial?: string | null
    name?: string | null
    quantity?: number | null
    materialWeight?: number | null
    loadType?: $Enums.LoadType | null
    createdAt?: Date | string | null
    unit?: $Enums.materialUnit | null
    TruckingLog: TruckingLogCreateNestedOneWithoutMaterialsInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: string
    truckingLogId: string
    LocationOfMaterial?: string | null
    name?: string | null
    quantity?: number | null
    materialWeight?: number | null
    loadType?: $Enums.LoadType | null
    createdAt?: Date | string | null
    unit?: $Enums.materialUnit | null
  }

  export type MaterialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    LocationOfMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    materialWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    loadType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: NullableEnummaterialUnitFieldUpdateOperationsInput | $Enums.materialUnit | null
    TruckingLog?: TruckingLogUpdateOneRequiredWithoutMaterialsNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckingLogId?: StringFieldUpdateOperationsInput | string
    LocationOfMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    materialWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    loadType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: NullableEnummaterialUnitFieldUpdateOperationsInput | $Enums.materialUnit | null
  }

  export type MaterialCreateManyInput = {
    id?: string
    truckingLogId: string
    LocationOfMaterial?: string | null
    name?: string | null
    quantity?: number | null
    materialWeight?: number | null
    loadType?: $Enums.LoadType | null
    createdAt?: Date | string | null
    unit?: $Enums.materialUnit | null
  }

  export type MaterialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    LocationOfMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    materialWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    loadType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: NullableEnummaterialUnitFieldUpdateOperationsInput | $Enums.materialUnit | null
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckingLogId?: StringFieldUpdateOperationsInput | string
    LocationOfMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    materialWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    loadType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: NullableEnummaterialUnitFieldUpdateOperationsInput | $Enums.materialUnit | null
  }

  export type RefuelLogCreateInput = {
    id?: string
    gallonsRefueled?: number | null
    milesAtFueling?: number | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogCreateNestedOneWithoutRefuelLogInput
    TascoLog?: TascoLogCreateNestedOneWithoutRefuelLogsInput
    TruckingLog?: TruckingLogCreateNestedOneWithoutRefuelLogsInput
  }

  export type RefuelLogUncheckedCreateInput = {
    id?: string
    employeeEquipmentLogId?: string | null
    truckingLogId?: string | null
    tascoLogId?: string | null
    gallonsRefueled?: number | null
    milesAtFueling?: number | null
  }

  export type RefuelLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gallonsRefueled?: NullableFloatFieldUpdateOperationsInput | number | null
    milesAtFueling?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogUpdateOneWithoutRefuelLogNestedInput
    TascoLog?: TascoLogUpdateOneWithoutRefuelLogsNestedInput
    TruckingLog?: TruckingLogUpdateOneWithoutRefuelLogsNestedInput
  }

  export type RefuelLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    truckingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    tascoLogId?: NullableStringFieldUpdateOperationsInput | string | null
    gallonsRefueled?: NullableFloatFieldUpdateOperationsInput | number | null
    milesAtFueling?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RefuelLogCreateManyInput = {
    id?: string
    employeeEquipmentLogId?: string | null
    truckingLogId?: string | null
    tascoLogId?: string | null
    gallonsRefueled?: number | null
    milesAtFueling?: number | null
  }

  export type RefuelLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gallonsRefueled?: NullableFloatFieldUpdateOperationsInput | number | null
    milesAtFueling?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RefuelLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    truckingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    tascoLogId?: NullableStringFieldUpdateOperationsInput | string | null
    gallonsRefueled?: NullableFloatFieldUpdateOperationsInput | number | null
    milesAtFueling?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EquipmentHauledCreateInput = {
    id?: string
    createdAt?: Date | string
    endMileage?: number | null
    startMileage?: number | null
    destination?: string | null
    source?: string | null
    Equipment?: EquipmentCreateNestedOneWithoutEquipmentHauledInput
    TruckingLog?: TruckingLogCreateNestedOneWithoutEquipmentHauledInput
  }

  export type EquipmentHauledUncheckedCreateInput = {
    id?: string
    truckingLogId?: string | null
    equipmentId?: string | null
    createdAt?: Date | string
    endMileage?: number | null
    startMileage?: number | null
    destination?: string | null
    source?: string | null
  }

  export type EquipmentHauledUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startMileage?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    Equipment?: EquipmentUpdateOneWithoutEquipmentHauledNestedInput
    TruckingLog?: TruckingLogUpdateOneWithoutEquipmentHauledNestedInput
  }

  export type EquipmentHauledUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startMileage?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentHauledCreateManyInput = {
    id?: string
    truckingLogId?: string | null
    equipmentId?: string | null
    createdAt?: Date | string
    endMileage?: number | null
    startMileage?: number | null
    destination?: string | null
    source?: string | null
  }

  export type EquipmentHauledUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startMileage?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentHauledUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startMileage?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeSheetChangeLogCreateInput = {
    id?: string
    changedAt?: Date | string
    changeReason?: string | null
    changes: JsonNullValueInput | InputJsonValue
    wasStatusChange?: boolean
    numberOfChanges?: number
    User: UserCreateNestedOneWithoutTimeSheetChangesInput
    TimeSheet: TimeSheetCreateNestedOneWithoutChangeLogsInput
  }

  export type TimeSheetChangeLogUncheckedCreateInput = {
    id?: string
    timeSheetId: number
    changedBy: string
    changedAt?: Date | string
    changeReason?: string | null
    changes: JsonNullValueInput | InputJsonValue
    wasStatusChange?: boolean
    numberOfChanges?: number
  }

  export type TimeSheetChangeLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    wasStatusChange?: BoolFieldUpdateOperationsInput | boolean
    numberOfChanges?: IntFieldUpdateOperationsInput | number
    User?: UserUpdateOneRequiredWithoutTimeSheetChangesNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutChangeLogsNestedInput
  }

  export type TimeSheetChangeLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeSheetId?: IntFieldUpdateOperationsInput | number
    changedBy?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    wasStatusChange?: BoolFieldUpdateOperationsInput | boolean
    numberOfChanges?: IntFieldUpdateOperationsInput | number
  }

  export type TimeSheetChangeLogCreateManyInput = {
    id?: string
    timeSheetId: number
    changedBy: string
    changedAt?: Date | string
    changeReason?: string | null
    changes: JsonNullValueInput | InputJsonValue
    wasStatusChange?: boolean
    numberOfChanges?: number
  }

  export type TimeSheetChangeLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    wasStatusChange?: BoolFieldUpdateOperationsInput | boolean
    numberOfChanges?: IntFieldUpdateOperationsInput | number
  }

  export type TimeSheetChangeLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeSheetId?: IntFieldUpdateOperationsInput | number
    changedBy?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    wasStatusChange?: BoolFieldUpdateOperationsInput | boolean
    numberOfChanges?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Contact?: ContactsCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserSettingsCreateInput = {
    id?: string
    language?: string
    generalReminders?: boolean
    personalReminders?: boolean
    cameraAccess?: boolean
    locationAccess?: boolean
    cookiesAccess?: boolean
    createdAt?: Date | string
    lastUpdated?: Date | string
    User: UserCreateNestedOneWithoutUserSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    language?: string
    generalReminders?: boolean
    personalReminders?: boolean
    cameraAccess?: boolean
    locationAccess?: boolean
    cookiesAccess?: boolean
    createdAt?: Date | string
    lastUpdated?: Date | string
  }

  export type UserSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    generalReminders?: BoolFieldUpdateOperationsInput | boolean
    personalReminders?: BoolFieldUpdateOperationsInput | boolean
    cameraAccess?: BoolFieldUpdateOperationsInput | boolean
    locationAccess?: BoolFieldUpdateOperationsInput | boolean
    cookiesAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutUserSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    generalReminders?: BoolFieldUpdateOperationsInput | boolean
    personalReminders?: BoolFieldUpdateOperationsInput | boolean
    cameraAccess?: BoolFieldUpdateOperationsInput | boolean
    locationAccess?: BoolFieldUpdateOperationsInput | boolean
    cookiesAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateManyInput = {
    id?: string
    userId: string
    language?: string
    generalReminders?: boolean
    personalReminders?: boolean
    cameraAccess?: boolean
    locationAccess?: boolean
    cookiesAccess?: boolean
    createdAt?: Date | string
    lastUpdated?: Date | string
  }

  export type UserSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    generalReminders?: BoolFieldUpdateOperationsInput | boolean
    personalReminders?: BoolFieldUpdateOperationsInput | boolean
    cameraAccess?: BoolFieldUpdateOperationsInput | boolean
    locationAccess?: BoolFieldUpdateOperationsInput | boolean
    cookiesAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    generalReminders?: BoolFieldUpdateOperationsInput | boolean
    personalReminders?: BoolFieldUpdateOperationsInput | boolean
    cameraAccess?: BoolFieldUpdateOperationsInput | boolean
    locationAccess?: BoolFieldUpdateOperationsInput | boolean
    cookiesAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactsCreateInput = {
    id?: string
    phoneNumber?: string | null
    emergencyContact?: string | null
    emergencyContactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutContactInput
  }

  export type ContactsUncheckedCreateInput = {
    id?: string
    userId: string
    phoneNumber?: string | null
    emergencyContact?: string | null
    emergencyContactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutContactNestedInput
  }

  export type ContactsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactsCreateManyInput = {
    id?: string
    userId: string
    phoneNumber?: string | null
    emergencyContact?: string | null
    emergencyContactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    token: string
    expiration: Date | string
    User: UserCreateNestedOneWithoutPasswordResetTokensInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expiration: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiration?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiration?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expiration: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiration?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiration?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountSetupTokenCreateInput = {
    id?: string
    code: string
    expiresAt: Date | string
    used?: boolean
    user: UserCreateNestedOneWithoutAccountSetupTokenInput
  }

  export type AccountSetupTokenUncheckedCreateInput = {
    id?: string
    code: string
    userId: string
    expiresAt: Date | string
    used?: boolean
  }

  export type AccountSetupTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutAccountSetupTokenNestedInput
  }

  export type AccountSetupTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountSetupTokenCreateManyInput = {
    id?: string
    code: string
    userId: string
    expiresAt: Date | string
    used?: boolean
  }

  export type AccountSetupTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountSetupTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AddressCreateInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country?: string
    Company?: CompanyCreateNestedManyWithoutAddressInput
    Jobsite?: JobsiteCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country?: string
    Company?: CompanyUncheckedCreateNestedManyWithoutAddressInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Company?: CompanyUpdateManyWithoutAddressNestedInput
    Jobsite?: JobsiteUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Company?: CompanyUncheckedUpdateManyWithoutAddressNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country?: string
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
  }

  export type FCMTokenCreateInput = {
    id?: string
    token: string
    platform?: string | null
    lastUsedAt?: Date | string | null
    isValid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFCMTokenInput
  }

  export type FCMTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    platform?: string | null
    lastUsedAt?: Date | string | null
    isValid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FCMTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFCMTokenNestedInput
  }

  export type FCMTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FCMTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    platform?: string | null
    lastUsedAt?: Date | string | null
    isValid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FCMTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FCMTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicSubscriptionCreateInput = {
    id?: string
    topic: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTopicSubscriptionsInput
  }

  export type TopicSubscriptionUncheckedCreateInput = {
    id?: string
    topic: string
    createdAt?: Date | string
    userId: string
  }

  export type TopicSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTopicSubscriptionsNestedInput
  }

  export type TopicSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type TopicSubscriptionCreateManyInput = {
    id?: string
    topic: string
    createdAt?: Date | string
    userId: string
  }

  export type TopicSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    topic?: string | null
    title: string
    body?: string | null
    url?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    pushedAt?: Date | string | null
    pushAttempts?: number
    readAt?: Date | string | null
    referenceId?: string | null
    Reads?: NotificationReadCreateNestedManyWithoutNotificationInput
    Response?: NotificationResponseCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    topic?: string | null
    title: string
    body?: string | null
    url?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    pushedAt?: Date | string | null
    pushAttempts?: number
    readAt?: Date | string | null
    id?: number
    referenceId?: string | null
    Reads?: NotificationReadUncheckedCreateNestedManyWithoutNotificationInput
    Response?: NotificationResponseUncheckedCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUpdateInput = {
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushAttempts?: IntFieldUpdateOperationsInput | number
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Reads?: NotificationReadUpdateManyWithoutNotificationNestedInput
    Response?: NotificationResponseUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushAttempts?: IntFieldUpdateOperationsInput | number
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Reads?: NotificationReadUncheckedUpdateManyWithoutNotificationNestedInput
    Response?: NotificationResponseUncheckedUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationCreateManyInput = {
    topic?: string | null
    title: string
    body?: string | null
    url?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    pushedAt?: Date | string | null
    pushAttempts?: number
    readAt?: Date | string | null
    id?: number
    referenceId?: string | null
  }

  export type NotificationUpdateManyMutationInput = {
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushAttempts?: IntFieldUpdateOperationsInput | number
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationUncheckedUpdateManyInput = {
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushAttempts?: IntFieldUpdateOperationsInput | number
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationResponseCreateInput = {
    response?: string | null
    respondedAt?: Date | string
    notification: NotificationCreateNestedOneWithoutResponseInput
    user: UserCreateNestedOneWithoutNotificationResponseInput
  }

  export type NotificationResponseUncheckedCreateInput = {
    id?: number
    notificationId: number
    userId: string
    response?: string | null
    respondedAt?: Date | string
  }

  export type NotificationResponseUpdateInput = {
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutResponseNestedInput
    user?: UserUpdateOneRequiredWithoutNotificationResponseNestedInput
  }

  export type NotificationResponseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationResponseCreateManyInput = {
    id?: number
    notificationId: number
    userId: string
    response?: string | null
    respondedAt?: Date | string
  }

  export type NotificationResponseUpdateManyMutationInput = {
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationResponseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationReadCreateInput = {
    readAt?: Date | string
    notification: NotificationCreateNestedOneWithoutReadsInput
    user: UserCreateNestedOneWithoutNotificationReadInput
  }

  export type NotificationReadUncheckedCreateInput = {
    id?: number
    notificationId: number
    userId: string
    readAt?: Date | string
  }

  export type NotificationReadUpdateInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutReadsNestedInput
    user?: UserUpdateOneRequiredWithoutNotificationReadNestedInput
  }

  export type NotificationReadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationReadCreateManyInput = {
    id?: number
    notificationId: number
    userId: string
    readAt?: Date | string
  }

  export type NotificationReadUpdateManyMutationInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationReadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AddressNullableScalarRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type FormTemplateListRelationFilter = {
    every?: FormTemplateWhereInput
    some?: FormTemplateWhereInput
    none?: FormTemplateWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FormTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    SubscriptionDate?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    SubscriptionDate?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    addressId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    SubscriptionDate?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TimeSheetListRelationFilter = {
    every?: TimeSheetWhereInput
    some?: TimeSheetWhereInput
    none?: TimeSheetWhereInput
  }

  export type CCTagListRelationFilter = {
    every?: CCTagWhereInput
    some?: CCTagWhereInput
    none?: CCTagWhereInput
  }

  export type TimeSheetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CCTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CostCodeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
  }

  export type CostCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
  }

  export type CostCodeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    code?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CostCodeListRelationFilter = {
    every?: CostCodeWhereInput
    some?: CostCodeWhereInput
    none?: CostCodeWhereInput
  }

  export type JobsiteListRelationFilter = {
    every?: JobsiteWhereInput
    some?: JobsiteWhereInput
    none?: JobsiteWhereInput
  }

  export type CostCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobsiteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CCTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CCTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CCTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type EnumWorkTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkType | EnumWorkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkType[] | ListEnumWorkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkType[] | ListEnumWorkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTypeFilter<$PrismaModel> | $Enums.WorkType
  }

  export type CrewCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    leadId?: SortOrder
    crewType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrewMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    leadId?: SortOrder
    crewType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CrewMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    leadId?: SortOrder
    crewType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWorkTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkType | EnumWorkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkType[] | ListEnumWorkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkType[] | ListEnumWorkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkTypeFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Bytes
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DocumentTagListRelationFilter = {
    every?: DocumentTagWhereInput
    some?: DocumentTagWhereInput
    none?: DocumentTagWhereInput
  }

  export type DocumentTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PdfDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    qrId?: SortOrder
    fileName?: SortOrder
    description?: SortOrder
    fileData?: SortOrder
    contentType?: SortOrder
    size?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    uploadDate?: SortOrder
  }

  export type PdfDocumentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type PdfDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    qrId?: SortOrder
    fileName?: SortOrder
    description?: SortOrder
    fileData?: SortOrder
    contentType?: SortOrder
    size?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    uploadDate?: SortOrder
  }

  export type PdfDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    qrId?: SortOrder
    fileName?: SortOrder
    description?: SortOrder
    fileData?: SortOrder
    contentType?: SortOrder
    size?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    uploadDate?: SortOrder
  }

  export type PdfDocumentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Bytes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EquipmentListRelationFilter = {
    every?: EquipmentWhereInput
    some?: EquipmentWhereInput
    none?: EquipmentWhereInput
  }

  export type PdfDocumentListRelationFilter = {
    every?: PdfDocumentWhereInput
    some?: PdfDocumentWhereInput
    none?: PdfDocumentWhereInput
  }

  export type EquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PdfDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentTagCountOrderByAggregateInput = {
    id?: SortOrder
    tagName?: SortOrder
  }

  export type DocumentTagMaxOrderByAggregateInput = {
    id?: SortOrder
    tagName?: SortOrder
  }

  export type DocumentTagMinOrderByAggregateInput = {
    id?: SortOrder
    tagName?: SortOrder
  }

  export type EnumEquipmentTagsFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentTags | EnumEquipmentTagsFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentTags[] | ListEnumEquipmentTagsFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentTags[] | ListEnumEquipmentTagsFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentTagsFilter<$PrismaModel> | $Enums.EquipmentTags
  }

  export type EnumEquipmentStateFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentState | EnumEquipmentStateFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentState[] | ListEnumEquipmentStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentState[] | ListEnumEquipmentStateFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStateFilter<$PrismaModel> | $Enums.EquipmentState
  }

  export type EnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumCreatedViaFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatedVia | EnumCreatedViaFieldRefInput<$PrismaModel>
    in?: $Enums.CreatedVia[] | ListEnumCreatedViaFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreatedVia[] | ListEnumCreatedViaFieldRefInput<$PrismaModel>
    not?: NestedEnumCreatedViaFilter<$PrismaModel> | $Enums.CreatedVia
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumOwnershipTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnershipType | EnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOwnershipTypeNullableFilter<$PrismaModel> | $Enums.OwnershipType | null
  }

  export type EnumConditionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Condition | EnumConditionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Condition[] | ListEnumConditionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Condition[] | ListEnumConditionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConditionNullableFilter<$PrismaModel> | $Enums.Condition | null
  }

  export type EnumFormTemplateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FormTemplateStatus | EnumFormTemplateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FormTemplateStatus[] | ListEnumFormTemplateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormTemplateStatus[] | ListEnumFormTemplateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFormTemplateStatusFilter<$PrismaModel> | $Enums.FormTemplateStatus
  }

  export type EmployeeEquipmentLogListRelationFilter = {
    every?: EmployeeEquipmentLogWhereInput
    some?: EmployeeEquipmentLogWhereInput
    none?: EmployeeEquipmentLogWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type EquipmentHauledListRelationFilter = {
    every?: EquipmentHauledWhereInput
    some?: EquipmentHauledWhereInput
    none?: EquipmentHauledWhereInput
  }

  export type MaintenanceListRelationFilter = {
    every?: MaintenanceWhereInput
    some?: MaintenanceWhereInput
    none?: MaintenanceWhereInput
  }

  export type TascoLogListRelationFilter = {
    every?: TascoLogWhereInput
    some?: TascoLogWhereInput
    none?: TascoLogWhereInput
  }

  export type TruckingLogListRelationFilter = {
    every?: TruckingLogWhereInput
    some?: TruckingLogWhereInput
    none?: TruckingLogWhereInput
  }

  export type MechanicProjectsListRelationFilter = {
    every?: mechanicProjectsWhereInput
    some?: mechanicProjectsWhereInput
    none?: mechanicProjectsWhereInput
  }

  export type EmployeeEquipmentLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentHauledOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TascoLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TruckingLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mechanicProjectsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    qrId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creationReason?: SortOrder
    equipmentTag?: SortOrder
    state?: SortOrder
    approvalStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    overWeight?: SortOrder
    currentWeight?: SortOrder
    createdById?: SortOrder
    createdVia?: SortOrder
    acquiredDate?: SortOrder
    code?: SortOrder
    color?: SortOrder
    licensePlate?: SortOrder
    licenseState?: SortOrder
    make?: SortOrder
    memo?: SortOrder
    model?: SortOrder
    ownershipType?: SortOrder
    registrationExpiration?: SortOrder
    serialNumber?: SortOrder
    year?: SortOrder
    acquiredCondition?: SortOrder
    status?: SortOrder
  }

  export type EquipmentAvgOrderByAggregateInput = {
    currentWeight?: SortOrder
  }

  export type EquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    qrId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creationReason?: SortOrder
    equipmentTag?: SortOrder
    state?: SortOrder
    approvalStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    overWeight?: SortOrder
    currentWeight?: SortOrder
    createdById?: SortOrder
    createdVia?: SortOrder
    acquiredDate?: SortOrder
    code?: SortOrder
    color?: SortOrder
    licensePlate?: SortOrder
    licenseState?: SortOrder
    make?: SortOrder
    memo?: SortOrder
    model?: SortOrder
    ownershipType?: SortOrder
    registrationExpiration?: SortOrder
    serialNumber?: SortOrder
    year?: SortOrder
    acquiredCondition?: SortOrder
    status?: SortOrder
  }

  export type EquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    qrId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creationReason?: SortOrder
    equipmentTag?: SortOrder
    state?: SortOrder
    approvalStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    overWeight?: SortOrder
    currentWeight?: SortOrder
    createdById?: SortOrder
    createdVia?: SortOrder
    acquiredDate?: SortOrder
    code?: SortOrder
    color?: SortOrder
    licensePlate?: SortOrder
    licenseState?: SortOrder
    make?: SortOrder
    memo?: SortOrder
    model?: SortOrder
    ownershipType?: SortOrder
    registrationExpiration?: SortOrder
    serialNumber?: SortOrder
    year?: SortOrder
    acquiredCondition?: SortOrder
    status?: SortOrder
  }

  export type EquipmentSumOrderByAggregateInput = {
    currentWeight?: SortOrder
  }

  export type EnumEquipmentTagsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentTags | EnumEquipmentTagsFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentTags[] | ListEnumEquipmentTagsFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentTags[] | ListEnumEquipmentTagsFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentTagsWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentTags
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentTagsFilter<$PrismaModel>
    _max?: NestedEnumEquipmentTagsFilter<$PrismaModel>
  }

  export type EnumEquipmentStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentState | EnumEquipmentStateFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentState[] | ListEnumEquipmentStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentState[] | ListEnumEquipmentStateFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStateWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentStateFilter<$PrismaModel>
    _max?: NestedEnumEquipmentStateFilter<$PrismaModel>
  }

  export type EnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumCreatedViaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatedVia | EnumCreatedViaFieldRefInput<$PrismaModel>
    in?: $Enums.CreatedVia[] | ListEnumCreatedViaFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreatedVia[] | ListEnumCreatedViaFieldRefInput<$PrismaModel>
    not?: NestedEnumCreatedViaWithAggregatesFilter<$PrismaModel> | $Enums.CreatedVia
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreatedViaFilter<$PrismaModel>
    _max?: NestedEnumCreatedViaFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumOwnershipTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnershipType | EnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOwnershipTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.OwnershipType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOwnershipTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumOwnershipTypeNullableFilter<$PrismaModel>
  }

  export type EnumConditionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Condition | EnumConditionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Condition[] | ListEnumConditionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Condition[] | ListEnumConditionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConditionNullableWithAggregatesFilter<$PrismaModel> | $Enums.Condition | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumConditionNullableFilter<$PrismaModel>
    _max?: NestedEnumConditionNullableFilter<$PrismaModel>
  }

  export type EnumFormTemplateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormTemplateStatus | EnumFormTemplateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FormTemplateStatus[] | ListEnumFormTemplateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormTemplateStatus[] | ListEnumFormTemplateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFormTemplateStatusWithAggregatesFilter<$PrismaModel> | $Enums.FormTemplateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormTemplateStatusFilter<$PrismaModel>
    _max?: NestedEnumFormTemplateStatusFilter<$PrismaModel>
  }

  export type EquipmentNullableScalarRelationFilter = {
    is?: EquipmentWhereInput | null
    isNot?: EquipmentWhereInput | null
  }

  export type MaintenanceNullableScalarRelationFilter = {
    is?: MaintenanceWhereInput | null
    isNot?: MaintenanceWhereInput | null
  }

  export type TimeSheetScalarRelationFilter = {
    is?: TimeSheetWhereInput
    isNot?: TimeSheetWhereInput
  }

  export type RefuelLogNullableScalarRelationFilter = {
    is?: RefuelLogWhereInput | null
    isNot?: RefuelLogWhereInput | null
  }

  export type EmployeeEquipmentLogCountOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    maintenanceId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    comment?: SortOrder
    timeSheetId?: SortOrder
    rental?: SortOrder
  }

  export type EmployeeEquipmentLogAvgOrderByAggregateInput = {
    timeSheetId?: SortOrder
  }

  export type EmployeeEquipmentLogMaxOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    maintenanceId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    comment?: SortOrder
    timeSheetId?: SortOrder
    rental?: SortOrder
  }

  export type EmployeeEquipmentLogMinOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    maintenanceId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    comment?: SortOrder
    timeSheetId?: SortOrder
    rental?: SortOrder
  }

  export type EmployeeEquipmentLogSumOrderByAggregateInput = {
    timeSheetId?: SortOrder
  }

  export type EnumFormTemplateCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FormTemplateCategory | EnumFormTemplateCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FormTemplateCategory[] | ListEnumFormTemplateCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormTemplateCategory[] | ListEnumFormTemplateCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFormTemplateCategoryFilter<$PrismaModel> | $Enums.FormTemplateCategory
  }

  export type FormSubmissionListRelationFilter = {
    every?: FormSubmissionWhereInput
    some?: FormSubmissionWhereInput
    none?: FormSubmissionWhereInput
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type FormGroupingListRelationFilter = {
    every?: FormGroupingWhereInput
    some?: FormGroupingWhereInput
    none?: FormGroupingWhereInput
  }

  export type FormSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormGroupingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSignatureRequired?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    formType?: SortOrder
    isApprovalRequired?: SortOrder
  }

  export type FormTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSignatureRequired?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    formType?: SortOrder
    isApprovalRequired?: SortOrder
  }

  export type FormTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSignatureRequired?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    formType?: SortOrder
    isApprovalRequired?: SortOrder
  }

  export type EnumFormTemplateCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormTemplateCategory | EnumFormTemplateCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FormTemplateCategory[] | ListEnumFormTemplateCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormTemplateCategory[] | ListEnumFormTemplateCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFormTemplateCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FormTemplateCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormTemplateCategoryFilter<$PrismaModel>
    _max?: NestedEnumFormTemplateCategoryFilter<$PrismaModel>
  }

  export type FormFieldListRelationFilter = {
    every?: FormFieldWhereInput
    some?: FormFieldWhereInput
    none?: FormFieldWhereInput
  }

  export type FormFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormGroupingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrder
  }

  export type FormGroupingAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type FormGroupingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrder
  }

  export type FormGroupingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrder
  }

  export type FormGroupingSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumFieldTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldTypeFilter<$PrismaModel> | $Enums.FieldType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FormGroupingScalarRelationFilter = {
    is?: FormGroupingWhereInput
    isNot?: FormGroupingWhereInput
  }

  export type FormFieldOptionListRelationFilter = {
    every?: FormFieldOptionWhereInput
    some?: FormFieldOptionWhereInput
    none?: FormFieldOptionWhereInput
  }

  export type FormFieldOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormFieldCountOrderByAggregateInput = {
    id?: SortOrder
    formGroupingId?: SortOrder
    label?: SortOrder
    type?: SortOrder
    required?: SortOrder
    order?: SortOrder
    placeholder?: SortOrder
    maxLength?: SortOrder
    content?: SortOrder
    filter?: SortOrder
    minLength?: SortOrder
    multiple?: SortOrder
  }

  export type FormFieldAvgOrderByAggregateInput = {
    order?: SortOrder
    maxLength?: SortOrder
    minLength?: SortOrder
  }

  export type FormFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    formGroupingId?: SortOrder
    label?: SortOrder
    type?: SortOrder
    required?: SortOrder
    order?: SortOrder
    placeholder?: SortOrder
    maxLength?: SortOrder
    content?: SortOrder
    filter?: SortOrder
    minLength?: SortOrder
    multiple?: SortOrder
  }

  export type FormFieldMinOrderByAggregateInput = {
    id?: SortOrder
    formGroupingId?: SortOrder
    label?: SortOrder
    type?: SortOrder
    required?: SortOrder
    order?: SortOrder
    placeholder?: SortOrder
    maxLength?: SortOrder
    content?: SortOrder
    filter?: SortOrder
    minLength?: SortOrder
    multiple?: SortOrder
  }

  export type FormFieldSumOrderByAggregateInput = {
    order?: SortOrder
    maxLength?: SortOrder
    minLength?: SortOrder
  }

  export type EnumFieldTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel> | $Enums.FieldType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFieldTypeFilter<$PrismaModel>
    _max?: NestedEnumFieldTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FormFieldScalarRelationFilter = {
    is?: FormFieldWhereInput
    isNot?: FormFieldWhereInput
  }

  export type FormFieldOptionCountOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    value?: SortOrder
  }

  export type FormFieldOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    value?: SortOrder
  }

  export type FormFieldOptionMinOrderByAggregateInput = {
    id?: SortOrder
    fieldId?: SortOrder
    value?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumFormStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FormStatus | EnumFormStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FormStatus[] | ListEnumFormStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormStatus[] | ListEnumFormStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFormStatusFilter<$PrismaModel> | $Enums.FormStatus
  }

  export type FormApprovalListRelationFilter = {
    every?: FormApprovalWhereInput
    some?: FormApprovalWhereInput
    none?: FormApprovalWhereInput
  }

  export type FormTemplateScalarRelationFilter = {
    is?: FormTemplateWhereInput
    isNot?: FormTemplateWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FormApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormSubmissionCountOrderByAggregateInput = {
    title?: SortOrder
    formTemplateId?: SortOrder
    userId?: SortOrder
    formType?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submittedAt?: SortOrder
    status?: SortOrder
    id?: SortOrder
  }

  export type FormSubmissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FormSubmissionMaxOrderByAggregateInput = {
    title?: SortOrder
    formTemplateId?: SortOrder
    userId?: SortOrder
    formType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submittedAt?: SortOrder
    status?: SortOrder
    id?: SortOrder
  }

  export type FormSubmissionMinOrderByAggregateInput = {
    title?: SortOrder
    formTemplateId?: SortOrder
    userId?: SortOrder
    formType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    submittedAt?: SortOrder
    status?: SortOrder
    id?: SortOrder
  }

  export type FormSubmissionSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumFormStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormStatus | EnumFormStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FormStatus[] | ListEnumFormStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormStatus[] | ListEnumFormStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFormStatusWithAggregatesFilter<$PrismaModel> | $Enums.FormStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormStatusFilter<$PrismaModel>
    _max?: NestedEnumFormStatusFilter<$PrismaModel>
  }

  export type FormSubmissionScalarRelationFilter = {
    is?: FormSubmissionWhereInput
    isNot?: FormSubmissionWhereInput
  }

  export type FormApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    signedBy?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    signature?: SortOrder
    comment?: SortOrder
    formSubmissionId?: SortOrder
  }

  export type FormApprovalAvgOrderByAggregateInput = {
    formSubmissionId?: SortOrder
  }

  export type FormApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    signedBy?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    signature?: SortOrder
    comment?: SortOrder
    formSubmissionId?: SortOrder
  }

  export type FormApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    signedBy?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    signature?: SortOrder
    comment?: SortOrder
    formSubmissionId?: SortOrder
  }

  export type FormApprovalSumOrderByAggregateInput = {
    formSubmissionId?: SortOrder
  }

  export type JobsiteCountOrderByAggregateInput = {
    id?: SortOrder
    qrId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creationReason?: SortOrder
    approvalStatus?: SortOrder
    addressId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archiveDate?: SortOrder
    createdById?: SortOrder
    createdVia?: SortOrder
    code?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    radiusMeters?: SortOrder
    status?: SortOrder
  }

  export type JobsiteAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    radiusMeters?: SortOrder
  }

  export type JobsiteMaxOrderByAggregateInput = {
    id?: SortOrder
    qrId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creationReason?: SortOrder
    approvalStatus?: SortOrder
    addressId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archiveDate?: SortOrder
    createdById?: SortOrder
    createdVia?: SortOrder
    code?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    radiusMeters?: SortOrder
    status?: SortOrder
  }

  export type JobsiteMinOrderByAggregateInput = {
    id?: SortOrder
    qrId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    creationReason?: SortOrder
    approvalStatus?: SortOrder
    addressId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archiveDate?: SortOrder
    createdById?: SortOrder
    createdVia?: SortOrder
    code?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    radiusMeters?: SortOrder
    status?: SortOrder
  }

  export type JobsiteSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    radiusMeters?: SortOrder
  }

  export type EnumReportVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportVisibility | EnumReportVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ReportVisibility[] | ListEnumReportVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportVisibility[] | ListEnumReportVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumReportVisibilityFilter<$PrismaModel> | $Enums.ReportVisibility
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ReportRunListRelationFilter = {
    every?: ReportRunWhereInput
    some?: ReportRunWhereInput
    none?: ReportRunWhereInput
  }

  export type ReportRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportCountOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    parameters?: SortOrder
    visibility?: SortOrder
    tags?: SortOrder
    id?: SortOrder
  }

  export type ReportAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    visibility?: SortOrder
    id?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    name?: SortOrder
    description?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    createdBy?: SortOrder
    updatedAt?: SortOrder
    visibility?: SortOrder
    id?: SortOrder
  }

  export type ReportSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumReportVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportVisibility | EnumReportVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ReportVisibility[] | ListEnumReportVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportVisibility[] | ListEnumReportVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumReportVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.ReportVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportVisibilityFilter<$PrismaModel>
    _max?: NestedEnumReportVisibilityFilter<$PrismaModel>
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type ReportScalarRelationFilter = {
    is?: ReportWhereInput
    isNot?: ReportWhereInput
  }

  export type ReportRunCountOrderByAggregateInput = {
    id?: SortOrder
    runAt?: SortOrder
    status?: SortOrder
    results?: SortOrder
    duration?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    customParams?: SortOrder
    exportFormats?: SortOrder
    lastExportedAt?: SortOrder
    reportId?: SortOrder
  }

  export type ReportRunAvgOrderByAggregateInput = {
    duration?: SortOrder
    reportId?: SortOrder
  }

  export type ReportRunMaxOrderByAggregateInput = {
    id?: SortOrder
    runAt?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    lastExportedAt?: SortOrder
    reportId?: SortOrder
  }

  export type ReportRunMinOrderByAggregateInput = {
    id?: SortOrder
    runAt?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    lastExportedAt?: SortOrder
    reportId?: SortOrder
  }

  export type ReportRunSumOrderByAggregateInput = {
    duration?: SortOrder
    reportId?: SortOrder
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type MaintenanceLogListRelationFilter = {
    every?: MaintenanceLogWhereInput
    some?: MaintenanceLogWhereInput
    none?: MaintenanceLogWhereInput
  }

  export type CostCodeScalarRelationFilter = {
    is?: CostCodeWhereInput
    isNot?: CostCodeWhereInput
  }

  export type JobsiteScalarRelationFilter = {
    is?: JobsiteWhereInput
    isNot?: JobsiteWhereInput
  }

  export type TimeSheetChangeLogListRelationFilter = {
    every?: TimeSheetChangeLogWhereInput
    some?: TimeSheetChangeLogWhereInput
    none?: TimeSheetChangeLogWhereInput
  }

  export type MaintenanceLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeSheetChangeLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeSheetCountOrderByAggregateInput = {
    date?: SortOrder
    userId?: SortOrder
    jobsiteId?: SortOrder
    costcode?: SortOrder
    nu?: SortOrder
    Fp?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    comment?: SortOrder
    statusComment?: SortOrder
    location?: SortOrder
    status?: SortOrder
    workType?: SortOrder
    editedByUserId?: SortOrder
    newTimeSheetId?: SortOrder
    createdByAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clockInLat?: SortOrder
    clockInLng?: SortOrder
    clockOutLat?: SortOrder
    clockOutLng?: SortOrder
    withinFenceIn?: SortOrder
    withinFenceOut?: SortOrder
    wasInjured?: SortOrder
    id?: SortOrder
  }

  export type TimeSheetAvgOrderByAggregateInput = {
    clockInLat?: SortOrder
    clockInLng?: SortOrder
    clockOutLat?: SortOrder
    clockOutLng?: SortOrder
    id?: SortOrder
  }

  export type TimeSheetMaxOrderByAggregateInput = {
    date?: SortOrder
    userId?: SortOrder
    jobsiteId?: SortOrder
    costcode?: SortOrder
    nu?: SortOrder
    Fp?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    comment?: SortOrder
    statusComment?: SortOrder
    location?: SortOrder
    status?: SortOrder
    workType?: SortOrder
    editedByUserId?: SortOrder
    newTimeSheetId?: SortOrder
    createdByAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clockInLat?: SortOrder
    clockInLng?: SortOrder
    clockOutLat?: SortOrder
    clockOutLng?: SortOrder
    withinFenceIn?: SortOrder
    withinFenceOut?: SortOrder
    wasInjured?: SortOrder
    id?: SortOrder
  }

  export type TimeSheetMinOrderByAggregateInput = {
    date?: SortOrder
    userId?: SortOrder
    jobsiteId?: SortOrder
    costcode?: SortOrder
    nu?: SortOrder
    Fp?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    comment?: SortOrder
    statusComment?: SortOrder
    location?: SortOrder
    status?: SortOrder
    workType?: SortOrder
    editedByUserId?: SortOrder
    newTimeSheetId?: SortOrder
    createdByAdmin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clockInLat?: SortOrder
    clockInLng?: SortOrder
    clockOutLat?: SortOrder
    clockOutLng?: SortOrder
    withinFenceIn?: SortOrder
    withinFenceOut?: SortOrder
    wasInjured?: SortOrder
    id?: SortOrder
  }

  export type TimeSheetSumOrderByAggregateInput = {
    clockInLat?: SortOrder
    clockInLng?: SortOrder
    clockOutLat?: SortOrder
    clockOutLng?: SortOrder
    id?: SortOrder
  }

  export type EquipmentScalarRelationFilter = {
    is?: EquipmentWhereInput
    isNot?: EquipmentWhereInput
  }

  export type mechanicProjectsCountOrderByAggregateInput = {
    id?: SortOrder
    timeSheetId?: SortOrder
    hours?: SortOrder
    equipmentId?: SortOrder
    description?: SortOrder
  }

  export type mechanicProjectsAvgOrderByAggregateInput = {
    id?: SortOrder
    timeSheetId?: SortOrder
    hours?: SortOrder
  }

  export type mechanicProjectsMaxOrderByAggregateInput = {
    id?: SortOrder
    timeSheetId?: SortOrder
    hours?: SortOrder
    equipmentId?: SortOrder
    description?: SortOrder
  }

  export type mechanicProjectsMinOrderByAggregateInput = {
    id?: SortOrder
    timeSheetId?: SortOrder
    hours?: SortOrder
    equipmentId?: SortOrder
    description?: SortOrder
  }

  export type mechanicProjectsSumOrderByAggregateInput = {
    id?: SortOrder
    timeSheetId?: SortOrder
    hours?: SortOrder
  }

  export type MaintenanceScalarRelationFilter = {
    is?: MaintenanceWhereInput
    isNot?: MaintenanceWhereInput
  }

  export type MaintenanceLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    maintenanceId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    comment?: SortOrder
    timeSheetId?: SortOrder
  }

  export type MaintenanceLogAvgOrderByAggregateInput = {
    timeSheetId?: SortOrder
  }

  export type MaintenanceLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    maintenanceId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    comment?: SortOrder
    timeSheetId?: SortOrder
  }

  export type MaintenanceLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    maintenanceId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    comment?: SortOrder
    timeSheetId?: SortOrder
  }

  export type MaintenanceLogSumOrderByAggregateInput = {
    timeSheetId?: SortOrder
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type MaintenanceCountOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    equipmentIssue?: SortOrder
    employeeEquipmentLogId?: SortOrder
    additionalInfo?: SortOrder
    location?: SortOrder
    problemDiagnosis?: SortOrder
    solution?: SortOrder
    totalHoursLaboured?: SortOrder
    createdAt?: SortOrder
    priority?: SortOrder
    delay?: SortOrder
    delayReasoning?: SortOrder
    repaired?: SortOrder
    selected?: SortOrder
    hasBeenDelayed?: SortOrder
    createdBy?: SortOrder
  }

  export type MaintenanceAvgOrderByAggregateInput = {
    totalHoursLaboured?: SortOrder
  }

  export type MaintenanceMaxOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    equipmentIssue?: SortOrder
    employeeEquipmentLogId?: SortOrder
    additionalInfo?: SortOrder
    location?: SortOrder
    problemDiagnosis?: SortOrder
    solution?: SortOrder
    totalHoursLaboured?: SortOrder
    createdAt?: SortOrder
    priority?: SortOrder
    delay?: SortOrder
    delayReasoning?: SortOrder
    repaired?: SortOrder
    selected?: SortOrder
    hasBeenDelayed?: SortOrder
    createdBy?: SortOrder
  }

  export type MaintenanceMinOrderByAggregateInput = {
    id?: SortOrder
    equipmentId?: SortOrder
    equipmentIssue?: SortOrder
    employeeEquipmentLogId?: SortOrder
    additionalInfo?: SortOrder
    location?: SortOrder
    problemDiagnosis?: SortOrder
    solution?: SortOrder
    totalHoursLaboured?: SortOrder
    createdAt?: SortOrder
    priority?: SortOrder
    delay?: SortOrder
    delayReasoning?: SortOrder
    repaired?: SortOrder
    selected?: SortOrder
    hasBeenDelayed?: SortOrder
    createdBy?: SortOrder
  }

  export type MaintenanceSumOrderByAggregateInput = {
    totalHoursLaboured?: SortOrder
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumLoadTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LoadType | EnumLoadTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.LoadType[] | ListEnumLoadTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LoadType[] | ListEnumLoadTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLoadTypeNullableFilter<$PrismaModel> | $Enums.LoadType | null
  }

  export type RefuelLogListRelationFilter = {
    every?: RefuelLogWhereInput
    some?: RefuelLogWhereInput
    none?: RefuelLogWhereInput
  }

  export type TascoFLoadsListRelationFilter = {
    every?: TascoFLoadsWhereInput
    some?: TascoFLoadsWhereInput
    none?: TascoFLoadsWhereInput
  }

  export type TascoMaterialTypesNullableScalarRelationFilter = {
    is?: TascoMaterialTypesWhereInput | null
    isNot?: TascoMaterialTypesWhereInput | null
  }

  export type RefuelLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TascoFLoadsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TascoLogCountOrderByAggregateInput = {
    id?: SortOrder
    shiftType?: SortOrder
    equipmentId?: SortOrder
    laborType?: SortOrder
    materialType?: SortOrder
    LoadQuantity?: SortOrder
    screenType?: SortOrder
    timeSheetId?: SortOrder
  }

  export type TascoLogAvgOrderByAggregateInput = {
    LoadQuantity?: SortOrder
    timeSheetId?: SortOrder
  }

  export type TascoLogMaxOrderByAggregateInput = {
    id?: SortOrder
    shiftType?: SortOrder
    equipmentId?: SortOrder
    laborType?: SortOrder
    materialType?: SortOrder
    LoadQuantity?: SortOrder
    screenType?: SortOrder
    timeSheetId?: SortOrder
  }

  export type TascoLogMinOrderByAggregateInput = {
    id?: SortOrder
    shiftType?: SortOrder
    equipmentId?: SortOrder
    laborType?: SortOrder
    materialType?: SortOrder
    LoadQuantity?: SortOrder
    screenType?: SortOrder
    timeSheetId?: SortOrder
  }

  export type TascoLogSumOrderByAggregateInput = {
    LoadQuantity?: SortOrder
    timeSheetId?: SortOrder
  }

  export type EnumLoadTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoadType | EnumLoadTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.LoadType[] | ListEnumLoadTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LoadType[] | ListEnumLoadTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLoadTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.LoadType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLoadTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumLoadTypeNullableFilter<$PrismaModel>
  }

  export type TascoLogScalarRelationFilter = {
    is?: TascoLogWhereInput
    isNot?: TascoLogWhereInput
  }

  export type TascoFLoadsCountOrderByAggregateInput = {
    id?: SortOrder
    tascoLogId?: SortOrder
    weight?: SortOrder
    screenType?: SortOrder
  }

  export type TascoFLoadsAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
  }

  export type TascoFLoadsMaxOrderByAggregateInput = {
    id?: SortOrder
    tascoLogId?: SortOrder
    weight?: SortOrder
    screenType?: SortOrder
  }

  export type TascoFLoadsMinOrderByAggregateInput = {
    id?: SortOrder
    tascoLogId?: SortOrder
    weight?: SortOrder
    screenType?: SortOrder
  }

  export type TascoFLoadsSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
  }

  export type TascoMaterialTypesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TascoMaterialTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TascoMaterialTypesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type MaterialListRelationFilter = {
    every?: MaterialWhereInput
    some?: MaterialWhereInput
    none?: MaterialWhereInput
  }

  export type StateMileageListRelationFilter = {
    every?: StateMileageWhereInput
    some?: StateMileageWhereInput
    none?: StateMileageWhereInput
  }

  export type MaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StateMileageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TruckingLogCountOrderByAggregateInput = {
    id?: SortOrder
    laborType?: SortOrder
    taskName?: SortOrder
    equipmentId?: SortOrder
    startingMileage?: SortOrder
    endingMileage?: SortOrder
    truckLaborLogId?: SortOrder
    trailerNumber?: SortOrder
    truckNumber?: SortOrder
    timeSheetId?: SortOrder
  }

  export type TruckingLogAvgOrderByAggregateInput = {
    startingMileage?: SortOrder
    endingMileage?: SortOrder
    timeSheetId?: SortOrder
  }

  export type TruckingLogMaxOrderByAggregateInput = {
    id?: SortOrder
    laborType?: SortOrder
    taskName?: SortOrder
    equipmentId?: SortOrder
    startingMileage?: SortOrder
    endingMileage?: SortOrder
    truckLaborLogId?: SortOrder
    trailerNumber?: SortOrder
    truckNumber?: SortOrder
    timeSheetId?: SortOrder
  }

  export type TruckingLogMinOrderByAggregateInput = {
    id?: SortOrder
    laborType?: SortOrder
    taskName?: SortOrder
    equipmentId?: SortOrder
    startingMileage?: SortOrder
    endingMileage?: SortOrder
    truckLaborLogId?: SortOrder
    trailerNumber?: SortOrder
    truckNumber?: SortOrder
    timeSheetId?: SortOrder
  }

  export type TruckingLogSumOrderByAggregateInput = {
    startingMileage?: SortOrder
    endingMileage?: SortOrder
    timeSheetId?: SortOrder
  }

  export type TruckingLogScalarRelationFilter = {
    is?: TruckingLogWhereInput
    isNot?: TruckingLogWhereInput
  }

  export type StateMileageCountOrderByAggregateInput = {
    id?: SortOrder
    truckingLogId?: SortOrder
    state?: SortOrder
    stateLineMileage?: SortOrder
  }

  export type StateMileageAvgOrderByAggregateInput = {
    stateLineMileage?: SortOrder
  }

  export type StateMileageMaxOrderByAggregateInput = {
    id?: SortOrder
    truckingLogId?: SortOrder
    state?: SortOrder
    stateLineMileage?: SortOrder
  }

  export type StateMileageMinOrderByAggregateInput = {
    id?: SortOrder
    truckingLogId?: SortOrder
    state?: SortOrder
    stateLineMileage?: SortOrder
  }

  export type StateMileageSumOrderByAggregateInput = {
    stateLineMileage?: SortOrder
  }

  export type EnummaterialUnitNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.materialUnit | EnummaterialUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.materialUnit[] | ListEnummaterialUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.materialUnit[] | ListEnummaterialUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnummaterialUnitNullableFilter<$PrismaModel> | $Enums.materialUnit | null
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    truckingLogId?: SortOrder
    LocationOfMaterial?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    materialWeight?: SortOrder
    loadType?: SortOrder
    createdAt?: SortOrder
    unit?: SortOrder
  }

  export type MaterialAvgOrderByAggregateInput = {
    quantity?: SortOrder
    materialWeight?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    truckingLogId?: SortOrder
    LocationOfMaterial?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    materialWeight?: SortOrder
    loadType?: SortOrder
    createdAt?: SortOrder
    unit?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    truckingLogId?: SortOrder
    LocationOfMaterial?: SortOrder
    name?: SortOrder
    quantity?: SortOrder
    materialWeight?: SortOrder
    loadType?: SortOrder
    createdAt?: SortOrder
    unit?: SortOrder
  }

  export type MaterialSumOrderByAggregateInput = {
    quantity?: SortOrder
    materialWeight?: SortOrder
  }

  export type EnummaterialUnitNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.materialUnit | EnummaterialUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.materialUnit[] | ListEnummaterialUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.materialUnit[] | ListEnummaterialUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnummaterialUnitNullableWithAggregatesFilter<$PrismaModel> | $Enums.materialUnit | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnummaterialUnitNullableFilter<$PrismaModel>
    _max?: NestedEnummaterialUnitNullableFilter<$PrismaModel>
  }

  export type EmployeeEquipmentLogNullableScalarRelationFilter = {
    is?: EmployeeEquipmentLogWhereInput | null
    isNot?: EmployeeEquipmentLogWhereInput | null
  }

  export type TascoLogNullableScalarRelationFilter = {
    is?: TascoLogWhereInput | null
    isNot?: TascoLogWhereInput | null
  }

  export type TruckingLogNullableScalarRelationFilter = {
    is?: TruckingLogWhereInput | null
    isNot?: TruckingLogWhereInput | null
  }

  export type RefuelLogCountOrderByAggregateInput = {
    id?: SortOrder
    employeeEquipmentLogId?: SortOrder
    truckingLogId?: SortOrder
    tascoLogId?: SortOrder
    gallonsRefueled?: SortOrder
    milesAtFueling?: SortOrder
  }

  export type RefuelLogAvgOrderByAggregateInput = {
    gallonsRefueled?: SortOrder
    milesAtFueling?: SortOrder
  }

  export type RefuelLogMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeEquipmentLogId?: SortOrder
    truckingLogId?: SortOrder
    tascoLogId?: SortOrder
    gallonsRefueled?: SortOrder
    milesAtFueling?: SortOrder
  }

  export type RefuelLogMinOrderByAggregateInput = {
    id?: SortOrder
    employeeEquipmentLogId?: SortOrder
    truckingLogId?: SortOrder
    tascoLogId?: SortOrder
    gallonsRefueled?: SortOrder
    milesAtFueling?: SortOrder
  }

  export type RefuelLogSumOrderByAggregateInput = {
    gallonsRefueled?: SortOrder
    milesAtFueling?: SortOrder
  }

  export type EquipmentHauledCountOrderByAggregateInput = {
    id?: SortOrder
    truckingLogId?: SortOrder
    equipmentId?: SortOrder
    createdAt?: SortOrder
    endMileage?: SortOrder
    startMileage?: SortOrder
    destination?: SortOrder
    source?: SortOrder
  }

  export type EquipmentHauledAvgOrderByAggregateInput = {
    endMileage?: SortOrder
    startMileage?: SortOrder
  }

  export type EquipmentHauledMaxOrderByAggregateInput = {
    id?: SortOrder
    truckingLogId?: SortOrder
    equipmentId?: SortOrder
    createdAt?: SortOrder
    endMileage?: SortOrder
    startMileage?: SortOrder
    destination?: SortOrder
    source?: SortOrder
  }

  export type EquipmentHauledMinOrderByAggregateInput = {
    id?: SortOrder
    truckingLogId?: SortOrder
    equipmentId?: SortOrder
    createdAt?: SortOrder
    endMileage?: SortOrder
    startMileage?: SortOrder
    destination?: SortOrder
    source?: SortOrder
  }

  export type EquipmentHauledSumOrderByAggregateInput = {
    endMileage?: SortOrder
    startMileage?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TimeSheetChangeLogCountOrderByAggregateInput = {
    id?: SortOrder
    timeSheetId?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
    changeReason?: SortOrder
    changes?: SortOrder
    wasStatusChange?: SortOrder
    numberOfChanges?: SortOrder
  }

  export type TimeSheetChangeLogAvgOrderByAggregateInput = {
    timeSheetId?: SortOrder
    numberOfChanges?: SortOrder
  }

  export type TimeSheetChangeLogMaxOrderByAggregateInput = {
    id?: SortOrder
    timeSheetId?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
    changeReason?: SortOrder
    wasStatusChange?: SortOrder
    numberOfChanges?: SortOrder
  }

  export type TimeSheetChangeLogMinOrderByAggregateInput = {
    id?: SortOrder
    timeSheetId?: SortOrder
    changedBy?: SortOrder
    changedAt?: SortOrder
    changeReason?: SortOrder
    wasStatusChange?: SortOrder
    numberOfChanges?: SortOrder
  }

  export type TimeSheetChangeLogSumOrderByAggregateInput = {
    timeSheetId?: SortOrder
    numberOfChanges?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumPermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionFilter<$PrismaModel> | $Enums.Permission
  }

  export type AccountSetupTokenNullableScalarRelationFilter = {
    is?: AccountSetupTokenWhereInput | null
    isNot?: AccountSetupTokenWhereInput | null
  }

  export type ContactsNullableScalarRelationFilter = {
    is?: ContactsWhereInput | null
    isNot?: ContactsWhereInput | null
  }

  export type FCMTokenListRelationFilter = {
    every?: FCMTokenWhereInput
    some?: FCMTokenWhereInput
    none?: FCMTokenWhereInput
  }

  export type NotificationReadListRelationFilter = {
    every?: NotificationReadWhereInput
    some?: NotificationReadWhereInput
    none?: NotificationReadWhereInput
  }

  export type NotificationResponseListRelationFilter = {
    every?: NotificationResponseWhereInput
    some?: NotificationResponseWhereInput
    none?: NotificationResponseWhereInput
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type TopicSubscriptionListRelationFilter = {
    every?: TopicSubscriptionWhereInput
    some?: TopicSubscriptionWhereInput
    none?: TopicSubscriptionWhereInput
  }

  export type UserSettingsNullableScalarRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type CrewListRelationFilter = {
    every?: CrewWhereInput
    some?: CrewWhereInput
    none?: CrewWhereInput
  }

  export type FCMTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationReadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TopicSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CrewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserFirstNameLastNameUsernameCompoundUniqueInput = {
    firstName: string
    lastName: string
    username: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    signature?: SortOrder
    DOB?: SortOrder
    truckView?: SortOrder
    tascoView?: SortOrder
    laborView?: SortOrder
    mechanicView?: SortOrder
    permission?: SortOrder
    image?: SortOrder
    startDate?: SortOrder
    terminationDate?: SortOrder
    accountSetup?: SortOrder
    clockedIn?: SortOrder
    companyId?: SortOrder
    passwordResetTokenId?: SortOrder
    workTypeId?: SortOrder
    middleName?: SortOrder
    secondLastName?: SortOrder
    lastSeen?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    signature?: SortOrder
    DOB?: SortOrder
    truckView?: SortOrder
    tascoView?: SortOrder
    laborView?: SortOrder
    mechanicView?: SortOrder
    permission?: SortOrder
    image?: SortOrder
    startDate?: SortOrder
    terminationDate?: SortOrder
    accountSetup?: SortOrder
    clockedIn?: SortOrder
    companyId?: SortOrder
    passwordResetTokenId?: SortOrder
    workTypeId?: SortOrder
    middleName?: SortOrder
    secondLastName?: SortOrder
    lastSeen?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    signature?: SortOrder
    DOB?: SortOrder
    truckView?: SortOrder
    tascoView?: SortOrder
    laborView?: SortOrder
    mechanicView?: SortOrder
    permission?: SortOrder
    image?: SortOrder
    startDate?: SortOrder
    terminationDate?: SortOrder
    accountSetup?: SortOrder
    clockedIn?: SortOrder
    companyId?: SortOrder
    passwordResetTokenId?: SortOrder
    workTypeId?: SortOrder
    middleName?: SortOrder
    secondLastName?: SortOrder
    lastSeen?: SortOrder
  }

  export type EnumPermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionWithAggregatesFilter<$PrismaModel> | $Enums.Permission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionFilter<$PrismaModel>
    _max?: NestedEnumPermissionFilter<$PrismaModel>
  }

  export type UserSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    language?: SortOrder
    generalReminders?: SortOrder
    personalReminders?: SortOrder
    cameraAccess?: SortOrder
    locationAccess?: SortOrder
    cookiesAccess?: SortOrder
    createdAt?: SortOrder
    lastUpdated?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    language?: SortOrder
    generalReminders?: SortOrder
    personalReminders?: SortOrder
    cameraAccess?: SortOrder
    locationAccess?: SortOrder
    cookiesAccess?: SortOrder
    createdAt?: SortOrder
    lastUpdated?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    language?: SortOrder
    generalReminders?: SortOrder
    personalReminders?: SortOrder
    cameraAccess?: SortOrder
    locationAccess?: SortOrder
    cookiesAccess?: SortOrder
    createdAt?: SortOrder
    lastUpdated?: SortOrder
  }

  export type ContactsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    emergencyContact?: SortOrder
    emergencyContactNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    emergencyContact?: SortOrder
    emergencyContactNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    phoneNumber?: SortOrder
    emergencyContact?: SortOrder
    emergencyContactNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordResetTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expiration?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expiration?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expiration?: SortOrder
  }

  export type AccountSetupTokenCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
  }

  export type AccountSetupTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
  }

  export type AccountSetupTokenMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
  }

  export type CompanyListRelationFilter = {
    every?: CompanyWhereInput
    some?: CompanyWhereInput
    none?: CompanyWhereInput
  }

  export type CompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AddressStreet_city_state_zipCodeCompoundUniqueInput = {
    street: string
    city: string
    state: string
    zipCode: string
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    country?: SortOrder
  }

  export type FCMTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    lastUsedAt?: SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FCMTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    lastUsedAt?: SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FCMTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    lastUsedAt?: SortOrder
    isValid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TopicSubscriptionUserIdTopicCompoundUniqueInput = {
    userId: string
    topic: string
  }

  export type TopicSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type TopicSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type TopicSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    topic?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type NotificationResponseNullableScalarRelationFilter = {
    is?: NotificationResponseWhereInput | null
    isNot?: NotificationResponseWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    topic?: SortOrder
    title?: SortOrder
    body?: SortOrder
    url?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    pushedAt?: SortOrder
    pushAttempts?: SortOrder
    readAt?: SortOrder
    id?: SortOrder
    referenceId?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    pushAttempts?: SortOrder
    id?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    topic?: SortOrder
    title?: SortOrder
    body?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    pushedAt?: SortOrder
    pushAttempts?: SortOrder
    readAt?: SortOrder
    id?: SortOrder
    referenceId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    topic?: SortOrder
    title?: SortOrder
    body?: SortOrder
    url?: SortOrder
    createdAt?: SortOrder
    pushedAt?: SortOrder
    pushAttempts?: SortOrder
    readAt?: SortOrder
    id?: SortOrder
    referenceId?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    pushAttempts?: SortOrder
    id?: SortOrder
  }

  export type NotificationScalarRelationFilter = {
    is?: NotificationWhereInput
    isNot?: NotificationWhereInput
  }

  export type NotificationResponseCountOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    response?: SortOrder
    respondedAt?: SortOrder
  }

  export type NotificationResponseAvgOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
  }

  export type NotificationResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    response?: SortOrder
    respondedAt?: SortOrder
  }

  export type NotificationResponseMinOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    response?: SortOrder
    respondedAt?: SortOrder
  }

  export type NotificationResponseSumOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
  }

  export type NotificationReadNotificationIdUserIdCompoundUniqueInput = {
    notificationId: number
    userId: string
  }

  export type NotificationReadCountOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationReadAvgOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
  }

  export type NotificationReadMaxOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationReadMinOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type NotificationReadSumOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
  }

  export type AddressCreateNestedOneWithoutCompanyInput = {
    create?: XOR<AddressCreateWithoutCompanyInput, AddressUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCompanyInput
    connect?: AddressWhereUniqueInput
  }

  export type FormTemplateCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FormTemplateCreateWithoutCompanyInput, FormTemplateUncheckedCreateWithoutCompanyInput> | FormTemplateCreateWithoutCompanyInput[] | FormTemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FormTemplateCreateOrConnectWithoutCompanyInput | FormTemplateCreateOrConnectWithoutCompanyInput[]
    createMany?: FormTemplateCreateManyCompanyInputEnvelope
    connect?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput> | ReportCreateWithoutCompanyInput[] | ReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCompanyInput | ReportCreateOrConnectWithoutCompanyInput[]
    createMany?: ReportCreateManyCompanyInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type FormTemplateUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<FormTemplateCreateWithoutCompanyInput, FormTemplateUncheckedCreateWithoutCompanyInput> | FormTemplateCreateWithoutCompanyInput[] | FormTemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FormTemplateCreateOrConnectWithoutCompanyInput | FormTemplateCreateOrConnectWithoutCompanyInput[]
    createMany?: FormTemplateCreateManyCompanyInputEnvelope
    connect?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput> | ReportCreateWithoutCompanyInput[] | ReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCompanyInput | ReportCreateOrConnectWithoutCompanyInput[]
    createMany?: ReportCreateManyCompanyInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AddressUpdateOneWithoutCompanyNestedInput = {
    create?: XOR<AddressCreateWithoutCompanyInput, AddressUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: AddressCreateOrConnectWithoutCompanyInput
    upsert?: AddressUpsertWithoutCompanyInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutCompanyInput, AddressUpdateWithoutCompanyInput>, AddressUncheckedUpdateWithoutCompanyInput>
  }

  export type FormTemplateUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FormTemplateCreateWithoutCompanyInput, FormTemplateUncheckedCreateWithoutCompanyInput> | FormTemplateCreateWithoutCompanyInput[] | FormTemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FormTemplateCreateOrConnectWithoutCompanyInput | FormTemplateCreateOrConnectWithoutCompanyInput[]
    upsert?: FormTemplateUpsertWithWhereUniqueWithoutCompanyInput | FormTemplateUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FormTemplateCreateManyCompanyInputEnvelope
    set?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
    disconnect?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
    delete?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
    connect?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
    update?: FormTemplateUpdateWithWhereUniqueWithoutCompanyInput | FormTemplateUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FormTemplateUpdateManyWithWhereWithoutCompanyInput | FormTemplateUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FormTemplateScalarWhereInput | FormTemplateScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput> | ReportCreateWithoutCompanyInput[] | ReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCompanyInput | ReportCreateOrConnectWithoutCompanyInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutCompanyInput | ReportUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ReportCreateManyCompanyInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutCompanyInput | ReportUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutCompanyInput | ReportUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type UserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type FormTemplateUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<FormTemplateCreateWithoutCompanyInput, FormTemplateUncheckedCreateWithoutCompanyInput> | FormTemplateCreateWithoutCompanyInput[] | FormTemplateUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: FormTemplateCreateOrConnectWithoutCompanyInput | FormTemplateCreateOrConnectWithoutCompanyInput[]
    upsert?: FormTemplateUpsertWithWhereUniqueWithoutCompanyInput | FormTemplateUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: FormTemplateCreateManyCompanyInputEnvelope
    set?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
    disconnect?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
    delete?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
    connect?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
    update?: FormTemplateUpdateWithWhereUniqueWithoutCompanyInput | FormTemplateUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: FormTemplateUpdateManyWithWhereWithoutCompanyInput | FormTemplateUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: FormTemplateScalarWhereInput | FormTemplateScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput> | ReportCreateWithoutCompanyInput[] | ReportUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutCompanyInput | ReportCreateOrConnectWithoutCompanyInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutCompanyInput | ReportUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: ReportCreateManyCompanyInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutCompanyInput | ReportUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutCompanyInput | ReportUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput> | UserCreateWithoutCompanyInput[] | UserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCompanyInput | UserCreateOrConnectWithoutCompanyInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCompanyInput | UserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCreateManyCompanyInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCompanyInput | UserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCompanyInput | UserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TimeSheetCreateNestedManyWithoutCostCodeInput = {
    create?: XOR<TimeSheetCreateWithoutCostCodeInput, TimeSheetUncheckedCreateWithoutCostCodeInput> | TimeSheetCreateWithoutCostCodeInput[] | TimeSheetUncheckedCreateWithoutCostCodeInput[]
    connectOrCreate?: TimeSheetCreateOrConnectWithoutCostCodeInput | TimeSheetCreateOrConnectWithoutCostCodeInput[]
    createMany?: TimeSheetCreateManyCostCodeInputEnvelope
    connect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
  }

  export type CCTagCreateNestedManyWithoutCostCodesInput = {
    create?: XOR<CCTagCreateWithoutCostCodesInput, CCTagUncheckedCreateWithoutCostCodesInput> | CCTagCreateWithoutCostCodesInput[] | CCTagUncheckedCreateWithoutCostCodesInput[]
    connectOrCreate?: CCTagCreateOrConnectWithoutCostCodesInput | CCTagCreateOrConnectWithoutCostCodesInput[]
    connect?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
  }

  export type TimeSheetUncheckedCreateNestedManyWithoutCostCodeInput = {
    create?: XOR<TimeSheetCreateWithoutCostCodeInput, TimeSheetUncheckedCreateWithoutCostCodeInput> | TimeSheetCreateWithoutCostCodeInput[] | TimeSheetUncheckedCreateWithoutCostCodeInput[]
    connectOrCreate?: TimeSheetCreateOrConnectWithoutCostCodeInput | TimeSheetCreateOrConnectWithoutCostCodeInput[]
    createMany?: TimeSheetCreateManyCostCodeInputEnvelope
    connect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
  }

  export type CCTagUncheckedCreateNestedManyWithoutCostCodesInput = {
    create?: XOR<CCTagCreateWithoutCostCodesInput, CCTagUncheckedCreateWithoutCostCodesInput> | CCTagCreateWithoutCostCodesInput[] | CCTagUncheckedCreateWithoutCostCodesInput[]
    connectOrCreate?: CCTagCreateOrConnectWithoutCostCodesInput | CCTagCreateOrConnectWithoutCostCodesInput[]
    connect?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TimeSheetUpdateManyWithoutCostCodeNestedInput = {
    create?: XOR<TimeSheetCreateWithoutCostCodeInput, TimeSheetUncheckedCreateWithoutCostCodeInput> | TimeSheetCreateWithoutCostCodeInput[] | TimeSheetUncheckedCreateWithoutCostCodeInput[]
    connectOrCreate?: TimeSheetCreateOrConnectWithoutCostCodeInput | TimeSheetCreateOrConnectWithoutCostCodeInput[]
    upsert?: TimeSheetUpsertWithWhereUniqueWithoutCostCodeInput | TimeSheetUpsertWithWhereUniqueWithoutCostCodeInput[]
    createMany?: TimeSheetCreateManyCostCodeInputEnvelope
    set?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    disconnect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    delete?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    connect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    update?: TimeSheetUpdateWithWhereUniqueWithoutCostCodeInput | TimeSheetUpdateWithWhereUniqueWithoutCostCodeInput[]
    updateMany?: TimeSheetUpdateManyWithWhereWithoutCostCodeInput | TimeSheetUpdateManyWithWhereWithoutCostCodeInput[]
    deleteMany?: TimeSheetScalarWhereInput | TimeSheetScalarWhereInput[]
  }

  export type CCTagUpdateManyWithoutCostCodesNestedInput = {
    create?: XOR<CCTagCreateWithoutCostCodesInput, CCTagUncheckedCreateWithoutCostCodesInput> | CCTagCreateWithoutCostCodesInput[] | CCTagUncheckedCreateWithoutCostCodesInput[]
    connectOrCreate?: CCTagCreateOrConnectWithoutCostCodesInput | CCTagCreateOrConnectWithoutCostCodesInput[]
    upsert?: CCTagUpsertWithWhereUniqueWithoutCostCodesInput | CCTagUpsertWithWhereUniqueWithoutCostCodesInput[]
    set?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
    disconnect?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
    delete?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
    connect?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
    update?: CCTagUpdateWithWhereUniqueWithoutCostCodesInput | CCTagUpdateWithWhereUniqueWithoutCostCodesInput[]
    updateMany?: CCTagUpdateManyWithWhereWithoutCostCodesInput | CCTagUpdateManyWithWhereWithoutCostCodesInput[]
    deleteMany?: CCTagScalarWhereInput | CCTagScalarWhereInput[]
  }

  export type TimeSheetUncheckedUpdateManyWithoutCostCodeNestedInput = {
    create?: XOR<TimeSheetCreateWithoutCostCodeInput, TimeSheetUncheckedCreateWithoutCostCodeInput> | TimeSheetCreateWithoutCostCodeInput[] | TimeSheetUncheckedCreateWithoutCostCodeInput[]
    connectOrCreate?: TimeSheetCreateOrConnectWithoutCostCodeInput | TimeSheetCreateOrConnectWithoutCostCodeInput[]
    upsert?: TimeSheetUpsertWithWhereUniqueWithoutCostCodeInput | TimeSheetUpsertWithWhereUniqueWithoutCostCodeInput[]
    createMany?: TimeSheetCreateManyCostCodeInputEnvelope
    set?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    disconnect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    delete?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    connect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    update?: TimeSheetUpdateWithWhereUniqueWithoutCostCodeInput | TimeSheetUpdateWithWhereUniqueWithoutCostCodeInput[]
    updateMany?: TimeSheetUpdateManyWithWhereWithoutCostCodeInput | TimeSheetUpdateManyWithWhereWithoutCostCodeInput[]
    deleteMany?: TimeSheetScalarWhereInput | TimeSheetScalarWhereInput[]
  }

  export type CCTagUncheckedUpdateManyWithoutCostCodesNestedInput = {
    create?: XOR<CCTagCreateWithoutCostCodesInput, CCTagUncheckedCreateWithoutCostCodesInput> | CCTagCreateWithoutCostCodesInput[] | CCTagUncheckedCreateWithoutCostCodesInput[]
    connectOrCreate?: CCTagCreateOrConnectWithoutCostCodesInput | CCTagCreateOrConnectWithoutCostCodesInput[]
    upsert?: CCTagUpsertWithWhereUniqueWithoutCostCodesInput | CCTagUpsertWithWhereUniqueWithoutCostCodesInput[]
    set?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
    disconnect?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
    delete?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
    connect?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
    update?: CCTagUpdateWithWhereUniqueWithoutCostCodesInput | CCTagUpdateWithWhereUniqueWithoutCostCodesInput[]
    updateMany?: CCTagUpdateManyWithWhereWithoutCostCodesInput | CCTagUpdateManyWithWhereWithoutCostCodesInput[]
    deleteMany?: CCTagScalarWhereInput | CCTagScalarWhereInput[]
  }

  export type CostCodeCreateNestedManyWithoutCCTagsInput = {
    create?: XOR<CostCodeCreateWithoutCCTagsInput, CostCodeUncheckedCreateWithoutCCTagsInput> | CostCodeCreateWithoutCCTagsInput[] | CostCodeUncheckedCreateWithoutCCTagsInput[]
    connectOrCreate?: CostCodeCreateOrConnectWithoutCCTagsInput | CostCodeCreateOrConnectWithoutCCTagsInput[]
    connect?: CostCodeWhereUniqueInput | CostCodeWhereUniqueInput[]
  }

  export type JobsiteCreateNestedManyWithoutCCTagsInput = {
    create?: XOR<JobsiteCreateWithoutCCTagsInput, JobsiteUncheckedCreateWithoutCCTagsInput> | JobsiteCreateWithoutCCTagsInput[] | JobsiteUncheckedCreateWithoutCCTagsInput[]
    connectOrCreate?: JobsiteCreateOrConnectWithoutCCTagsInput | JobsiteCreateOrConnectWithoutCCTagsInput[]
    connect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
  }

  export type CostCodeUncheckedCreateNestedManyWithoutCCTagsInput = {
    create?: XOR<CostCodeCreateWithoutCCTagsInput, CostCodeUncheckedCreateWithoutCCTagsInput> | CostCodeCreateWithoutCCTagsInput[] | CostCodeUncheckedCreateWithoutCCTagsInput[]
    connectOrCreate?: CostCodeCreateOrConnectWithoutCCTagsInput | CostCodeCreateOrConnectWithoutCCTagsInput[]
    connect?: CostCodeWhereUniqueInput | CostCodeWhereUniqueInput[]
  }

  export type JobsiteUncheckedCreateNestedManyWithoutCCTagsInput = {
    create?: XOR<JobsiteCreateWithoutCCTagsInput, JobsiteUncheckedCreateWithoutCCTagsInput> | JobsiteCreateWithoutCCTagsInput[] | JobsiteUncheckedCreateWithoutCCTagsInput[]
    connectOrCreate?: JobsiteCreateOrConnectWithoutCCTagsInput | JobsiteCreateOrConnectWithoutCCTagsInput[]
    connect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
  }

  export type CostCodeUpdateManyWithoutCCTagsNestedInput = {
    create?: XOR<CostCodeCreateWithoutCCTagsInput, CostCodeUncheckedCreateWithoutCCTagsInput> | CostCodeCreateWithoutCCTagsInput[] | CostCodeUncheckedCreateWithoutCCTagsInput[]
    connectOrCreate?: CostCodeCreateOrConnectWithoutCCTagsInput | CostCodeCreateOrConnectWithoutCCTagsInput[]
    upsert?: CostCodeUpsertWithWhereUniqueWithoutCCTagsInput | CostCodeUpsertWithWhereUniqueWithoutCCTagsInput[]
    set?: CostCodeWhereUniqueInput | CostCodeWhereUniqueInput[]
    disconnect?: CostCodeWhereUniqueInput | CostCodeWhereUniqueInput[]
    delete?: CostCodeWhereUniqueInput | CostCodeWhereUniqueInput[]
    connect?: CostCodeWhereUniqueInput | CostCodeWhereUniqueInput[]
    update?: CostCodeUpdateWithWhereUniqueWithoutCCTagsInput | CostCodeUpdateWithWhereUniqueWithoutCCTagsInput[]
    updateMany?: CostCodeUpdateManyWithWhereWithoutCCTagsInput | CostCodeUpdateManyWithWhereWithoutCCTagsInput[]
    deleteMany?: CostCodeScalarWhereInput | CostCodeScalarWhereInput[]
  }

  export type JobsiteUpdateManyWithoutCCTagsNestedInput = {
    create?: XOR<JobsiteCreateWithoutCCTagsInput, JobsiteUncheckedCreateWithoutCCTagsInput> | JobsiteCreateWithoutCCTagsInput[] | JobsiteUncheckedCreateWithoutCCTagsInput[]
    connectOrCreate?: JobsiteCreateOrConnectWithoutCCTagsInput | JobsiteCreateOrConnectWithoutCCTagsInput[]
    upsert?: JobsiteUpsertWithWhereUniqueWithoutCCTagsInput | JobsiteUpsertWithWhereUniqueWithoutCCTagsInput[]
    set?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    disconnect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    delete?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    connect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    update?: JobsiteUpdateWithWhereUniqueWithoutCCTagsInput | JobsiteUpdateWithWhereUniqueWithoutCCTagsInput[]
    updateMany?: JobsiteUpdateManyWithWhereWithoutCCTagsInput | JobsiteUpdateManyWithWhereWithoutCCTagsInput[]
    deleteMany?: JobsiteScalarWhereInput | JobsiteScalarWhereInput[]
  }

  export type CostCodeUncheckedUpdateManyWithoutCCTagsNestedInput = {
    create?: XOR<CostCodeCreateWithoutCCTagsInput, CostCodeUncheckedCreateWithoutCCTagsInput> | CostCodeCreateWithoutCCTagsInput[] | CostCodeUncheckedCreateWithoutCCTagsInput[]
    connectOrCreate?: CostCodeCreateOrConnectWithoutCCTagsInput | CostCodeCreateOrConnectWithoutCCTagsInput[]
    upsert?: CostCodeUpsertWithWhereUniqueWithoutCCTagsInput | CostCodeUpsertWithWhereUniqueWithoutCCTagsInput[]
    set?: CostCodeWhereUniqueInput | CostCodeWhereUniqueInput[]
    disconnect?: CostCodeWhereUniqueInput | CostCodeWhereUniqueInput[]
    delete?: CostCodeWhereUniqueInput | CostCodeWhereUniqueInput[]
    connect?: CostCodeWhereUniqueInput | CostCodeWhereUniqueInput[]
    update?: CostCodeUpdateWithWhereUniqueWithoutCCTagsInput | CostCodeUpdateWithWhereUniqueWithoutCCTagsInput[]
    updateMany?: CostCodeUpdateManyWithWhereWithoutCCTagsInput | CostCodeUpdateManyWithWhereWithoutCCTagsInput[]
    deleteMany?: CostCodeScalarWhereInput | CostCodeScalarWhereInput[]
  }

  export type JobsiteUncheckedUpdateManyWithoutCCTagsNestedInput = {
    create?: XOR<JobsiteCreateWithoutCCTagsInput, JobsiteUncheckedCreateWithoutCCTagsInput> | JobsiteCreateWithoutCCTagsInput[] | JobsiteUncheckedCreateWithoutCCTagsInput[]
    connectOrCreate?: JobsiteCreateOrConnectWithoutCCTagsInput | JobsiteCreateOrConnectWithoutCCTagsInput[]
    upsert?: JobsiteUpsertWithWhereUniqueWithoutCCTagsInput | JobsiteUpsertWithWhereUniqueWithoutCCTagsInput[]
    set?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    disconnect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    delete?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    connect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    update?: JobsiteUpdateWithWhereUniqueWithoutCCTagsInput | JobsiteUpdateWithWhereUniqueWithoutCCTagsInput[]
    updateMany?: JobsiteUpdateManyWithWhereWithoutCCTagsInput | JobsiteUpdateManyWithWhereWithoutCCTagsInput[]
    deleteMany?: JobsiteScalarWhereInput | JobsiteScalarWhereInput[]
  }

  export type UserCreateNestedManyWithoutCrewsInput = {
    create?: XOR<UserCreateWithoutCrewsInput, UserUncheckedCreateWithoutCrewsInput> | UserCreateWithoutCrewsInput[] | UserUncheckedCreateWithoutCrewsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCrewsInput | UserCreateOrConnectWithoutCrewsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCrewsInput = {
    create?: XOR<UserCreateWithoutCrewsInput, UserUncheckedCreateWithoutCrewsInput> | UserCreateWithoutCrewsInput[] | UserUncheckedCreateWithoutCrewsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCrewsInput | UserCreateOrConnectWithoutCrewsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type EnumWorkTypeFieldUpdateOperationsInput = {
    set?: $Enums.WorkType
  }

  export type UserUpdateManyWithoutCrewsNestedInput = {
    create?: XOR<UserCreateWithoutCrewsInput, UserUncheckedCreateWithoutCrewsInput> | UserCreateWithoutCrewsInput[] | UserUncheckedCreateWithoutCrewsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCrewsInput | UserCreateOrConnectWithoutCrewsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCrewsInput | UserUpsertWithWhereUniqueWithoutCrewsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCrewsInput | UserUpdateWithWhereUniqueWithoutCrewsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCrewsInput | UserUpdateManyWithWhereWithoutCrewsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCrewsNestedInput = {
    create?: XOR<UserCreateWithoutCrewsInput, UserUncheckedCreateWithoutCrewsInput> | UserCreateWithoutCrewsInput[] | UserUncheckedCreateWithoutCrewsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCrewsInput | UserCreateOrConnectWithoutCrewsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCrewsInput | UserUpsertWithWhereUniqueWithoutCrewsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCrewsInput | UserUpdateWithWhereUniqueWithoutCrewsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCrewsInput | UserUpdateManyWithWhereWithoutCrewsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type DocumentTagCreateNestedManyWithoutDocumentsInput = {
    create?: XOR<DocumentTagCreateWithoutDocumentsInput, DocumentTagUncheckedCreateWithoutDocumentsInput> | DocumentTagCreateWithoutDocumentsInput[] | DocumentTagUncheckedCreateWithoutDocumentsInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutDocumentsInput | DocumentTagCreateOrConnectWithoutDocumentsInput[]
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
  }

  export type DocumentTagUncheckedCreateNestedManyWithoutDocumentsInput = {
    create?: XOR<DocumentTagCreateWithoutDocumentsInput, DocumentTagUncheckedCreateWithoutDocumentsInput> | DocumentTagCreateWithoutDocumentsInput[] | DocumentTagUncheckedCreateWithoutDocumentsInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutDocumentsInput | DocumentTagCreateOrConnectWithoutDocumentsInput[]
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Bytes
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DocumentTagUpdateManyWithoutDocumentsNestedInput = {
    create?: XOR<DocumentTagCreateWithoutDocumentsInput, DocumentTagUncheckedCreateWithoutDocumentsInput> | DocumentTagCreateWithoutDocumentsInput[] | DocumentTagUncheckedCreateWithoutDocumentsInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutDocumentsInput | DocumentTagCreateOrConnectWithoutDocumentsInput[]
    upsert?: DocumentTagUpsertWithWhereUniqueWithoutDocumentsInput | DocumentTagUpsertWithWhereUniqueWithoutDocumentsInput[]
    set?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    disconnect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    delete?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    update?: DocumentTagUpdateWithWhereUniqueWithoutDocumentsInput | DocumentTagUpdateWithWhereUniqueWithoutDocumentsInput[]
    updateMany?: DocumentTagUpdateManyWithWhereWithoutDocumentsInput | DocumentTagUpdateManyWithWhereWithoutDocumentsInput[]
    deleteMany?: DocumentTagScalarWhereInput | DocumentTagScalarWhereInput[]
  }

  export type DocumentTagUncheckedUpdateManyWithoutDocumentsNestedInput = {
    create?: XOR<DocumentTagCreateWithoutDocumentsInput, DocumentTagUncheckedCreateWithoutDocumentsInput> | DocumentTagCreateWithoutDocumentsInput[] | DocumentTagUncheckedCreateWithoutDocumentsInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutDocumentsInput | DocumentTagCreateOrConnectWithoutDocumentsInput[]
    upsert?: DocumentTagUpsertWithWhereUniqueWithoutDocumentsInput | DocumentTagUpsertWithWhereUniqueWithoutDocumentsInput[]
    set?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    disconnect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    delete?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    update?: DocumentTagUpdateWithWhereUniqueWithoutDocumentsInput | DocumentTagUpdateWithWhereUniqueWithoutDocumentsInput[]
    updateMany?: DocumentTagUpdateManyWithWhereWithoutDocumentsInput | DocumentTagUpdateManyWithWhereWithoutDocumentsInput[]
    deleteMany?: DocumentTagScalarWhereInput | DocumentTagScalarWhereInput[]
  }

  export type EquipmentCreateNestedManyWithoutDocumentTagsInput = {
    create?: XOR<EquipmentCreateWithoutDocumentTagsInput, EquipmentUncheckedCreateWithoutDocumentTagsInput> | EquipmentCreateWithoutDocumentTagsInput[] | EquipmentUncheckedCreateWithoutDocumentTagsInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutDocumentTagsInput | EquipmentCreateOrConnectWithoutDocumentTagsInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type PdfDocumentCreateNestedManyWithoutDocumentTagsInput = {
    create?: XOR<PdfDocumentCreateWithoutDocumentTagsInput, PdfDocumentUncheckedCreateWithoutDocumentTagsInput> | PdfDocumentCreateWithoutDocumentTagsInput[] | PdfDocumentUncheckedCreateWithoutDocumentTagsInput[]
    connectOrCreate?: PdfDocumentCreateOrConnectWithoutDocumentTagsInput | PdfDocumentCreateOrConnectWithoutDocumentTagsInput[]
    connect?: PdfDocumentWhereUniqueInput | PdfDocumentWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutDocumentTagsInput = {
    create?: XOR<EquipmentCreateWithoutDocumentTagsInput, EquipmentUncheckedCreateWithoutDocumentTagsInput> | EquipmentCreateWithoutDocumentTagsInput[] | EquipmentUncheckedCreateWithoutDocumentTagsInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutDocumentTagsInput | EquipmentCreateOrConnectWithoutDocumentTagsInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type PdfDocumentUncheckedCreateNestedManyWithoutDocumentTagsInput = {
    create?: XOR<PdfDocumentCreateWithoutDocumentTagsInput, PdfDocumentUncheckedCreateWithoutDocumentTagsInput> | PdfDocumentCreateWithoutDocumentTagsInput[] | PdfDocumentUncheckedCreateWithoutDocumentTagsInput[]
    connectOrCreate?: PdfDocumentCreateOrConnectWithoutDocumentTagsInput | PdfDocumentCreateOrConnectWithoutDocumentTagsInput[]
    connect?: PdfDocumentWhereUniqueInput | PdfDocumentWhereUniqueInput[]
  }

  export type EquipmentUpdateManyWithoutDocumentTagsNestedInput = {
    create?: XOR<EquipmentCreateWithoutDocumentTagsInput, EquipmentUncheckedCreateWithoutDocumentTagsInput> | EquipmentCreateWithoutDocumentTagsInput[] | EquipmentUncheckedCreateWithoutDocumentTagsInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutDocumentTagsInput | EquipmentCreateOrConnectWithoutDocumentTagsInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutDocumentTagsInput | EquipmentUpsertWithWhereUniqueWithoutDocumentTagsInput[]
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutDocumentTagsInput | EquipmentUpdateWithWhereUniqueWithoutDocumentTagsInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutDocumentTagsInput | EquipmentUpdateManyWithWhereWithoutDocumentTagsInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type PdfDocumentUpdateManyWithoutDocumentTagsNestedInput = {
    create?: XOR<PdfDocumentCreateWithoutDocumentTagsInput, PdfDocumentUncheckedCreateWithoutDocumentTagsInput> | PdfDocumentCreateWithoutDocumentTagsInput[] | PdfDocumentUncheckedCreateWithoutDocumentTagsInput[]
    connectOrCreate?: PdfDocumentCreateOrConnectWithoutDocumentTagsInput | PdfDocumentCreateOrConnectWithoutDocumentTagsInput[]
    upsert?: PdfDocumentUpsertWithWhereUniqueWithoutDocumentTagsInput | PdfDocumentUpsertWithWhereUniqueWithoutDocumentTagsInput[]
    set?: PdfDocumentWhereUniqueInput | PdfDocumentWhereUniqueInput[]
    disconnect?: PdfDocumentWhereUniqueInput | PdfDocumentWhereUniqueInput[]
    delete?: PdfDocumentWhereUniqueInput | PdfDocumentWhereUniqueInput[]
    connect?: PdfDocumentWhereUniqueInput | PdfDocumentWhereUniqueInput[]
    update?: PdfDocumentUpdateWithWhereUniqueWithoutDocumentTagsInput | PdfDocumentUpdateWithWhereUniqueWithoutDocumentTagsInput[]
    updateMany?: PdfDocumentUpdateManyWithWhereWithoutDocumentTagsInput | PdfDocumentUpdateManyWithWhereWithoutDocumentTagsInput[]
    deleteMany?: PdfDocumentScalarWhereInput | PdfDocumentScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutDocumentTagsNestedInput = {
    create?: XOR<EquipmentCreateWithoutDocumentTagsInput, EquipmentUncheckedCreateWithoutDocumentTagsInput> | EquipmentCreateWithoutDocumentTagsInput[] | EquipmentUncheckedCreateWithoutDocumentTagsInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutDocumentTagsInput | EquipmentCreateOrConnectWithoutDocumentTagsInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutDocumentTagsInput | EquipmentUpsertWithWhereUniqueWithoutDocumentTagsInput[]
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutDocumentTagsInput | EquipmentUpdateWithWhereUniqueWithoutDocumentTagsInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutDocumentTagsInput | EquipmentUpdateManyWithWhereWithoutDocumentTagsInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type PdfDocumentUncheckedUpdateManyWithoutDocumentTagsNestedInput = {
    create?: XOR<PdfDocumentCreateWithoutDocumentTagsInput, PdfDocumentUncheckedCreateWithoutDocumentTagsInput> | PdfDocumentCreateWithoutDocumentTagsInput[] | PdfDocumentUncheckedCreateWithoutDocumentTagsInput[]
    connectOrCreate?: PdfDocumentCreateOrConnectWithoutDocumentTagsInput | PdfDocumentCreateOrConnectWithoutDocumentTagsInput[]
    upsert?: PdfDocumentUpsertWithWhereUniqueWithoutDocumentTagsInput | PdfDocumentUpsertWithWhereUniqueWithoutDocumentTagsInput[]
    set?: PdfDocumentWhereUniqueInput | PdfDocumentWhereUniqueInput[]
    disconnect?: PdfDocumentWhereUniqueInput | PdfDocumentWhereUniqueInput[]
    delete?: PdfDocumentWhereUniqueInput | PdfDocumentWhereUniqueInput[]
    connect?: PdfDocumentWhereUniqueInput | PdfDocumentWhereUniqueInput[]
    update?: PdfDocumentUpdateWithWhereUniqueWithoutDocumentTagsInput | PdfDocumentUpdateWithWhereUniqueWithoutDocumentTagsInput[]
    updateMany?: PdfDocumentUpdateManyWithWhereWithoutDocumentTagsInput | PdfDocumentUpdateManyWithWhereWithoutDocumentTagsInput[]
    deleteMany?: PdfDocumentScalarWhereInput | PdfDocumentScalarWhereInput[]
  }

  export type EmployeeEquipmentLogCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<EmployeeEquipmentLogCreateWithoutEquipmentInput, EmployeeEquipmentLogUncheckedCreateWithoutEquipmentInput> | EmployeeEquipmentLogCreateWithoutEquipmentInput[] | EmployeeEquipmentLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EmployeeEquipmentLogCreateOrConnectWithoutEquipmentInput | EmployeeEquipmentLogCreateOrConnectWithoutEquipmentInput[]
    createMany?: EmployeeEquipmentLogCreateManyEquipmentInputEnvelope
    connect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutEquipmentInput = {
    create?: XOR<UserCreateWithoutEquipmentInput, UserUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutEquipmentInput
    connect?: UserWhereUniqueInput
  }

  export type EquipmentHauledCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<EquipmentHauledCreateWithoutEquipmentInput, EquipmentHauledUncheckedCreateWithoutEquipmentInput> | EquipmentHauledCreateWithoutEquipmentInput[] | EquipmentHauledUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentHauledCreateOrConnectWithoutEquipmentInput | EquipmentHauledCreateOrConnectWithoutEquipmentInput[]
    createMany?: EquipmentHauledCreateManyEquipmentInputEnvelope
    connect?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
  }

  export type MaintenanceCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<MaintenanceCreateWithoutEquipmentInput, MaintenanceUncheckedCreateWithoutEquipmentInput> | MaintenanceCreateWithoutEquipmentInput[] | MaintenanceUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutEquipmentInput | MaintenanceCreateOrConnectWithoutEquipmentInput[]
    createMany?: MaintenanceCreateManyEquipmentInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type TascoLogCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<TascoLogCreateWithoutEquipmentInput, TascoLogUncheckedCreateWithoutEquipmentInput> | TascoLogCreateWithoutEquipmentInput[] | TascoLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: TascoLogCreateOrConnectWithoutEquipmentInput | TascoLogCreateOrConnectWithoutEquipmentInput[]
    createMany?: TascoLogCreateManyEquipmentInputEnvelope
    connect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
  }

  export type TruckingLogCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<TruckingLogCreateWithoutEquipmentInput, TruckingLogUncheckedCreateWithoutEquipmentInput> | TruckingLogCreateWithoutEquipmentInput[] | TruckingLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: TruckingLogCreateOrConnectWithoutEquipmentInput | TruckingLogCreateOrConnectWithoutEquipmentInput[]
    createMany?: TruckingLogCreateManyEquipmentInputEnvelope
    connect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
  }

  export type TruckingLogCreateNestedManyWithoutTrailerInput = {
    create?: XOR<TruckingLogCreateWithoutTrailerInput, TruckingLogUncheckedCreateWithoutTrailerInput> | TruckingLogCreateWithoutTrailerInput[] | TruckingLogUncheckedCreateWithoutTrailerInput[]
    connectOrCreate?: TruckingLogCreateOrConnectWithoutTrailerInput | TruckingLogCreateOrConnectWithoutTrailerInput[]
    createMany?: TruckingLogCreateManyTrailerInputEnvelope
    connect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
  }

  export type TruckingLogCreateNestedManyWithoutTruckInput = {
    create?: XOR<TruckingLogCreateWithoutTruckInput, TruckingLogUncheckedCreateWithoutTruckInput> | TruckingLogCreateWithoutTruckInput[] | TruckingLogUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: TruckingLogCreateOrConnectWithoutTruckInput | TruckingLogCreateOrConnectWithoutTruckInput[]
    createMany?: TruckingLogCreateManyTruckInputEnvelope
    connect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
  }

  export type mechanicProjectsCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<mechanicProjectsCreateWithoutEquipmentInput, mechanicProjectsUncheckedCreateWithoutEquipmentInput> | mechanicProjectsCreateWithoutEquipmentInput[] | mechanicProjectsUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: mechanicProjectsCreateOrConnectWithoutEquipmentInput | mechanicProjectsCreateOrConnectWithoutEquipmentInput[]
    createMany?: mechanicProjectsCreateManyEquipmentInputEnvelope
    connect?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
  }

  export type DocumentTagCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<DocumentTagCreateWithoutEquipmentInput, DocumentTagUncheckedCreateWithoutEquipmentInput> | DocumentTagCreateWithoutEquipmentInput[] | DocumentTagUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutEquipmentInput | DocumentTagCreateOrConnectWithoutEquipmentInput[]
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
  }

  export type EmployeeEquipmentLogUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<EmployeeEquipmentLogCreateWithoutEquipmentInput, EmployeeEquipmentLogUncheckedCreateWithoutEquipmentInput> | EmployeeEquipmentLogCreateWithoutEquipmentInput[] | EmployeeEquipmentLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EmployeeEquipmentLogCreateOrConnectWithoutEquipmentInput | EmployeeEquipmentLogCreateOrConnectWithoutEquipmentInput[]
    createMany?: EmployeeEquipmentLogCreateManyEquipmentInputEnvelope
    connect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
  }

  export type EquipmentHauledUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<EquipmentHauledCreateWithoutEquipmentInput, EquipmentHauledUncheckedCreateWithoutEquipmentInput> | EquipmentHauledCreateWithoutEquipmentInput[] | EquipmentHauledUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentHauledCreateOrConnectWithoutEquipmentInput | EquipmentHauledCreateOrConnectWithoutEquipmentInput[]
    createMany?: EquipmentHauledCreateManyEquipmentInputEnvelope
    connect?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
  }

  export type MaintenanceUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<MaintenanceCreateWithoutEquipmentInput, MaintenanceUncheckedCreateWithoutEquipmentInput> | MaintenanceCreateWithoutEquipmentInput[] | MaintenanceUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutEquipmentInput | MaintenanceCreateOrConnectWithoutEquipmentInput[]
    createMany?: MaintenanceCreateManyEquipmentInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type TascoLogUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<TascoLogCreateWithoutEquipmentInput, TascoLogUncheckedCreateWithoutEquipmentInput> | TascoLogCreateWithoutEquipmentInput[] | TascoLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: TascoLogCreateOrConnectWithoutEquipmentInput | TascoLogCreateOrConnectWithoutEquipmentInput[]
    createMany?: TascoLogCreateManyEquipmentInputEnvelope
    connect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
  }

  export type TruckingLogUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<TruckingLogCreateWithoutEquipmentInput, TruckingLogUncheckedCreateWithoutEquipmentInput> | TruckingLogCreateWithoutEquipmentInput[] | TruckingLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: TruckingLogCreateOrConnectWithoutEquipmentInput | TruckingLogCreateOrConnectWithoutEquipmentInput[]
    createMany?: TruckingLogCreateManyEquipmentInputEnvelope
    connect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
  }

  export type TruckingLogUncheckedCreateNestedManyWithoutTrailerInput = {
    create?: XOR<TruckingLogCreateWithoutTrailerInput, TruckingLogUncheckedCreateWithoutTrailerInput> | TruckingLogCreateWithoutTrailerInput[] | TruckingLogUncheckedCreateWithoutTrailerInput[]
    connectOrCreate?: TruckingLogCreateOrConnectWithoutTrailerInput | TruckingLogCreateOrConnectWithoutTrailerInput[]
    createMany?: TruckingLogCreateManyTrailerInputEnvelope
    connect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
  }

  export type TruckingLogUncheckedCreateNestedManyWithoutTruckInput = {
    create?: XOR<TruckingLogCreateWithoutTruckInput, TruckingLogUncheckedCreateWithoutTruckInput> | TruckingLogCreateWithoutTruckInput[] | TruckingLogUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: TruckingLogCreateOrConnectWithoutTruckInput | TruckingLogCreateOrConnectWithoutTruckInput[]
    createMany?: TruckingLogCreateManyTruckInputEnvelope
    connect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
  }

  export type mechanicProjectsUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<mechanicProjectsCreateWithoutEquipmentInput, mechanicProjectsUncheckedCreateWithoutEquipmentInput> | mechanicProjectsCreateWithoutEquipmentInput[] | mechanicProjectsUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: mechanicProjectsCreateOrConnectWithoutEquipmentInput | mechanicProjectsCreateOrConnectWithoutEquipmentInput[]
    createMany?: mechanicProjectsCreateManyEquipmentInputEnvelope
    connect?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
  }

  export type DocumentTagUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<DocumentTagCreateWithoutEquipmentInput, DocumentTagUncheckedCreateWithoutEquipmentInput> | DocumentTagCreateWithoutEquipmentInput[] | DocumentTagUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutEquipmentInput | DocumentTagCreateOrConnectWithoutEquipmentInput[]
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
  }

  export type EnumEquipmentTagsFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentTags
  }

  export type EnumEquipmentStateFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentState
  }

  export type EnumApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalStatus
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCreatedViaFieldUpdateOperationsInput = {
    set?: $Enums.CreatedVia
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumOwnershipTypeFieldUpdateOperationsInput = {
    set?: $Enums.OwnershipType | null
  }

  export type NullableEnumConditionFieldUpdateOperationsInput = {
    set?: $Enums.Condition | null
  }

  export type EnumFormTemplateStatusFieldUpdateOperationsInput = {
    set?: $Enums.FormTemplateStatus
  }

  export type EmployeeEquipmentLogUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<EmployeeEquipmentLogCreateWithoutEquipmentInput, EmployeeEquipmentLogUncheckedCreateWithoutEquipmentInput> | EmployeeEquipmentLogCreateWithoutEquipmentInput[] | EmployeeEquipmentLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EmployeeEquipmentLogCreateOrConnectWithoutEquipmentInput | EmployeeEquipmentLogCreateOrConnectWithoutEquipmentInput[]
    upsert?: EmployeeEquipmentLogUpsertWithWhereUniqueWithoutEquipmentInput | EmployeeEquipmentLogUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: EmployeeEquipmentLogCreateManyEquipmentInputEnvelope
    set?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    disconnect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    delete?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    connect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    update?: EmployeeEquipmentLogUpdateWithWhereUniqueWithoutEquipmentInput | EmployeeEquipmentLogUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: EmployeeEquipmentLogUpdateManyWithWhereWithoutEquipmentInput | EmployeeEquipmentLogUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: EmployeeEquipmentLogScalarWhereInput | EmployeeEquipmentLogScalarWhereInput[]
  }

  export type UserUpdateOneWithoutEquipmentNestedInput = {
    create?: XOR<UserCreateWithoutEquipmentInput, UserUncheckedCreateWithoutEquipmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutEquipmentInput
    upsert?: UserUpsertWithoutEquipmentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEquipmentInput, UserUpdateWithoutEquipmentInput>, UserUncheckedUpdateWithoutEquipmentInput>
  }

  export type EquipmentHauledUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<EquipmentHauledCreateWithoutEquipmentInput, EquipmentHauledUncheckedCreateWithoutEquipmentInput> | EquipmentHauledCreateWithoutEquipmentInput[] | EquipmentHauledUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentHauledCreateOrConnectWithoutEquipmentInput | EquipmentHauledCreateOrConnectWithoutEquipmentInput[]
    upsert?: EquipmentHauledUpsertWithWhereUniqueWithoutEquipmentInput | EquipmentHauledUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: EquipmentHauledCreateManyEquipmentInputEnvelope
    set?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
    disconnect?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
    delete?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
    connect?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
    update?: EquipmentHauledUpdateWithWhereUniqueWithoutEquipmentInput | EquipmentHauledUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: EquipmentHauledUpdateManyWithWhereWithoutEquipmentInput | EquipmentHauledUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: EquipmentHauledScalarWhereInput | EquipmentHauledScalarWhereInput[]
  }

  export type MaintenanceUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<MaintenanceCreateWithoutEquipmentInput, MaintenanceUncheckedCreateWithoutEquipmentInput> | MaintenanceCreateWithoutEquipmentInput[] | MaintenanceUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutEquipmentInput | MaintenanceCreateOrConnectWithoutEquipmentInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutEquipmentInput | MaintenanceUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: MaintenanceCreateManyEquipmentInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutEquipmentInput | MaintenanceUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutEquipmentInput | MaintenanceUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type TascoLogUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<TascoLogCreateWithoutEquipmentInput, TascoLogUncheckedCreateWithoutEquipmentInput> | TascoLogCreateWithoutEquipmentInput[] | TascoLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: TascoLogCreateOrConnectWithoutEquipmentInput | TascoLogCreateOrConnectWithoutEquipmentInput[]
    upsert?: TascoLogUpsertWithWhereUniqueWithoutEquipmentInput | TascoLogUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: TascoLogCreateManyEquipmentInputEnvelope
    set?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    disconnect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    delete?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    connect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    update?: TascoLogUpdateWithWhereUniqueWithoutEquipmentInput | TascoLogUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: TascoLogUpdateManyWithWhereWithoutEquipmentInput | TascoLogUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: TascoLogScalarWhereInput | TascoLogScalarWhereInput[]
  }

  export type TruckingLogUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<TruckingLogCreateWithoutEquipmentInput, TruckingLogUncheckedCreateWithoutEquipmentInput> | TruckingLogCreateWithoutEquipmentInput[] | TruckingLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: TruckingLogCreateOrConnectWithoutEquipmentInput | TruckingLogCreateOrConnectWithoutEquipmentInput[]
    upsert?: TruckingLogUpsertWithWhereUniqueWithoutEquipmentInput | TruckingLogUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: TruckingLogCreateManyEquipmentInputEnvelope
    set?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    disconnect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    delete?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    connect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    update?: TruckingLogUpdateWithWhereUniqueWithoutEquipmentInput | TruckingLogUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: TruckingLogUpdateManyWithWhereWithoutEquipmentInput | TruckingLogUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: TruckingLogScalarWhereInput | TruckingLogScalarWhereInput[]
  }

  export type TruckingLogUpdateManyWithoutTrailerNestedInput = {
    create?: XOR<TruckingLogCreateWithoutTrailerInput, TruckingLogUncheckedCreateWithoutTrailerInput> | TruckingLogCreateWithoutTrailerInput[] | TruckingLogUncheckedCreateWithoutTrailerInput[]
    connectOrCreate?: TruckingLogCreateOrConnectWithoutTrailerInput | TruckingLogCreateOrConnectWithoutTrailerInput[]
    upsert?: TruckingLogUpsertWithWhereUniqueWithoutTrailerInput | TruckingLogUpsertWithWhereUniqueWithoutTrailerInput[]
    createMany?: TruckingLogCreateManyTrailerInputEnvelope
    set?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    disconnect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    delete?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    connect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    update?: TruckingLogUpdateWithWhereUniqueWithoutTrailerInput | TruckingLogUpdateWithWhereUniqueWithoutTrailerInput[]
    updateMany?: TruckingLogUpdateManyWithWhereWithoutTrailerInput | TruckingLogUpdateManyWithWhereWithoutTrailerInput[]
    deleteMany?: TruckingLogScalarWhereInput | TruckingLogScalarWhereInput[]
  }

  export type TruckingLogUpdateManyWithoutTruckNestedInput = {
    create?: XOR<TruckingLogCreateWithoutTruckInput, TruckingLogUncheckedCreateWithoutTruckInput> | TruckingLogCreateWithoutTruckInput[] | TruckingLogUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: TruckingLogCreateOrConnectWithoutTruckInput | TruckingLogCreateOrConnectWithoutTruckInput[]
    upsert?: TruckingLogUpsertWithWhereUniqueWithoutTruckInput | TruckingLogUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: TruckingLogCreateManyTruckInputEnvelope
    set?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    disconnect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    delete?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    connect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    update?: TruckingLogUpdateWithWhereUniqueWithoutTruckInput | TruckingLogUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: TruckingLogUpdateManyWithWhereWithoutTruckInput | TruckingLogUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: TruckingLogScalarWhereInput | TruckingLogScalarWhereInput[]
  }

  export type mechanicProjectsUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<mechanicProjectsCreateWithoutEquipmentInput, mechanicProjectsUncheckedCreateWithoutEquipmentInput> | mechanicProjectsCreateWithoutEquipmentInput[] | mechanicProjectsUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: mechanicProjectsCreateOrConnectWithoutEquipmentInput | mechanicProjectsCreateOrConnectWithoutEquipmentInput[]
    upsert?: mechanicProjectsUpsertWithWhereUniqueWithoutEquipmentInput | mechanicProjectsUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: mechanicProjectsCreateManyEquipmentInputEnvelope
    set?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
    disconnect?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
    delete?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
    connect?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
    update?: mechanicProjectsUpdateWithWhereUniqueWithoutEquipmentInput | mechanicProjectsUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: mechanicProjectsUpdateManyWithWhereWithoutEquipmentInput | mechanicProjectsUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: mechanicProjectsScalarWhereInput | mechanicProjectsScalarWhereInput[]
  }

  export type DocumentTagUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<DocumentTagCreateWithoutEquipmentInput, DocumentTagUncheckedCreateWithoutEquipmentInput> | DocumentTagCreateWithoutEquipmentInput[] | DocumentTagUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutEquipmentInput | DocumentTagCreateOrConnectWithoutEquipmentInput[]
    upsert?: DocumentTagUpsertWithWhereUniqueWithoutEquipmentInput | DocumentTagUpsertWithWhereUniqueWithoutEquipmentInput[]
    set?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    disconnect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    delete?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    update?: DocumentTagUpdateWithWhereUniqueWithoutEquipmentInput | DocumentTagUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: DocumentTagUpdateManyWithWhereWithoutEquipmentInput | DocumentTagUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: DocumentTagScalarWhereInput | DocumentTagScalarWhereInput[]
  }

  export type EmployeeEquipmentLogUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<EmployeeEquipmentLogCreateWithoutEquipmentInput, EmployeeEquipmentLogUncheckedCreateWithoutEquipmentInput> | EmployeeEquipmentLogCreateWithoutEquipmentInput[] | EmployeeEquipmentLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EmployeeEquipmentLogCreateOrConnectWithoutEquipmentInput | EmployeeEquipmentLogCreateOrConnectWithoutEquipmentInput[]
    upsert?: EmployeeEquipmentLogUpsertWithWhereUniqueWithoutEquipmentInput | EmployeeEquipmentLogUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: EmployeeEquipmentLogCreateManyEquipmentInputEnvelope
    set?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    disconnect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    delete?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    connect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    update?: EmployeeEquipmentLogUpdateWithWhereUniqueWithoutEquipmentInput | EmployeeEquipmentLogUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: EmployeeEquipmentLogUpdateManyWithWhereWithoutEquipmentInput | EmployeeEquipmentLogUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: EmployeeEquipmentLogScalarWhereInput | EmployeeEquipmentLogScalarWhereInput[]
  }

  export type EquipmentHauledUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<EquipmentHauledCreateWithoutEquipmentInput, EquipmentHauledUncheckedCreateWithoutEquipmentInput> | EquipmentHauledCreateWithoutEquipmentInput[] | EquipmentHauledUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: EquipmentHauledCreateOrConnectWithoutEquipmentInput | EquipmentHauledCreateOrConnectWithoutEquipmentInput[]
    upsert?: EquipmentHauledUpsertWithWhereUniqueWithoutEquipmentInput | EquipmentHauledUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: EquipmentHauledCreateManyEquipmentInputEnvelope
    set?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
    disconnect?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
    delete?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
    connect?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
    update?: EquipmentHauledUpdateWithWhereUniqueWithoutEquipmentInput | EquipmentHauledUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: EquipmentHauledUpdateManyWithWhereWithoutEquipmentInput | EquipmentHauledUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: EquipmentHauledScalarWhereInput | EquipmentHauledScalarWhereInput[]
  }

  export type MaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<MaintenanceCreateWithoutEquipmentInput, MaintenanceUncheckedCreateWithoutEquipmentInput> | MaintenanceCreateWithoutEquipmentInput[] | MaintenanceUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutEquipmentInput | MaintenanceCreateOrConnectWithoutEquipmentInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutEquipmentInput | MaintenanceUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: MaintenanceCreateManyEquipmentInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutEquipmentInput | MaintenanceUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutEquipmentInput | MaintenanceUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type TascoLogUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<TascoLogCreateWithoutEquipmentInput, TascoLogUncheckedCreateWithoutEquipmentInput> | TascoLogCreateWithoutEquipmentInput[] | TascoLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: TascoLogCreateOrConnectWithoutEquipmentInput | TascoLogCreateOrConnectWithoutEquipmentInput[]
    upsert?: TascoLogUpsertWithWhereUniqueWithoutEquipmentInput | TascoLogUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: TascoLogCreateManyEquipmentInputEnvelope
    set?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    disconnect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    delete?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    connect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    update?: TascoLogUpdateWithWhereUniqueWithoutEquipmentInput | TascoLogUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: TascoLogUpdateManyWithWhereWithoutEquipmentInput | TascoLogUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: TascoLogScalarWhereInput | TascoLogScalarWhereInput[]
  }

  export type TruckingLogUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<TruckingLogCreateWithoutEquipmentInput, TruckingLogUncheckedCreateWithoutEquipmentInput> | TruckingLogCreateWithoutEquipmentInput[] | TruckingLogUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: TruckingLogCreateOrConnectWithoutEquipmentInput | TruckingLogCreateOrConnectWithoutEquipmentInput[]
    upsert?: TruckingLogUpsertWithWhereUniqueWithoutEquipmentInput | TruckingLogUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: TruckingLogCreateManyEquipmentInputEnvelope
    set?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    disconnect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    delete?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    connect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    update?: TruckingLogUpdateWithWhereUniqueWithoutEquipmentInput | TruckingLogUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: TruckingLogUpdateManyWithWhereWithoutEquipmentInput | TruckingLogUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: TruckingLogScalarWhereInput | TruckingLogScalarWhereInput[]
  }

  export type TruckingLogUncheckedUpdateManyWithoutTrailerNestedInput = {
    create?: XOR<TruckingLogCreateWithoutTrailerInput, TruckingLogUncheckedCreateWithoutTrailerInput> | TruckingLogCreateWithoutTrailerInput[] | TruckingLogUncheckedCreateWithoutTrailerInput[]
    connectOrCreate?: TruckingLogCreateOrConnectWithoutTrailerInput | TruckingLogCreateOrConnectWithoutTrailerInput[]
    upsert?: TruckingLogUpsertWithWhereUniqueWithoutTrailerInput | TruckingLogUpsertWithWhereUniqueWithoutTrailerInput[]
    createMany?: TruckingLogCreateManyTrailerInputEnvelope
    set?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    disconnect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    delete?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    connect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    update?: TruckingLogUpdateWithWhereUniqueWithoutTrailerInput | TruckingLogUpdateWithWhereUniqueWithoutTrailerInput[]
    updateMany?: TruckingLogUpdateManyWithWhereWithoutTrailerInput | TruckingLogUpdateManyWithWhereWithoutTrailerInput[]
    deleteMany?: TruckingLogScalarWhereInput | TruckingLogScalarWhereInput[]
  }

  export type TruckingLogUncheckedUpdateManyWithoutTruckNestedInput = {
    create?: XOR<TruckingLogCreateWithoutTruckInput, TruckingLogUncheckedCreateWithoutTruckInput> | TruckingLogCreateWithoutTruckInput[] | TruckingLogUncheckedCreateWithoutTruckInput[]
    connectOrCreate?: TruckingLogCreateOrConnectWithoutTruckInput | TruckingLogCreateOrConnectWithoutTruckInput[]
    upsert?: TruckingLogUpsertWithWhereUniqueWithoutTruckInput | TruckingLogUpsertWithWhereUniqueWithoutTruckInput[]
    createMany?: TruckingLogCreateManyTruckInputEnvelope
    set?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    disconnect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    delete?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    connect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    update?: TruckingLogUpdateWithWhereUniqueWithoutTruckInput | TruckingLogUpdateWithWhereUniqueWithoutTruckInput[]
    updateMany?: TruckingLogUpdateManyWithWhereWithoutTruckInput | TruckingLogUpdateManyWithWhereWithoutTruckInput[]
    deleteMany?: TruckingLogScalarWhereInput | TruckingLogScalarWhereInput[]
  }

  export type mechanicProjectsUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<mechanicProjectsCreateWithoutEquipmentInput, mechanicProjectsUncheckedCreateWithoutEquipmentInput> | mechanicProjectsCreateWithoutEquipmentInput[] | mechanicProjectsUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: mechanicProjectsCreateOrConnectWithoutEquipmentInput | mechanicProjectsCreateOrConnectWithoutEquipmentInput[]
    upsert?: mechanicProjectsUpsertWithWhereUniqueWithoutEquipmentInput | mechanicProjectsUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: mechanicProjectsCreateManyEquipmentInputEnvelope
    set?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
    disconnect?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
    delete?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
    connect?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
    update?: mechanicProjectsUpdateWithWhereUniqueWithoutEquipmentInput | mechanicProjectsUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: mechanicProjectsUpdateManyWithWhereWithoutEquipmentInput | mechanicProjectsUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: mechanicProjectsScalarWhereInput | mechanicProjectsScalarWhereInput[]
  }

  export type DocumentTagUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<DocumentTagCreateWithoutEquipmentInput, DocumentTagUncheckedCreateWithoutEquipmentInput> | DocumentTagCreateWithoutEquipmentInput[] | DocumentTagUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutEquipmentInput | DocumentTagCreateOrConnectWithoutEquipmentInput[]
    upsert?: DocumentTagUpsertWithWhereUniqueWithoutEquipmentInput | DocumentTagUpsertWithWhereUniqueWithoutEquipmentInput[]
    set?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    disconnect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    delete?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    update?: DocumentTagUpdateWithWhereUniqueWithoutEquipmentInput | DocumentTagUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: DocumentTagUpdateManyWithWhereWithoutEquipmentInput | DocumentTagUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: DocumentTagScalarWhereInput | DocumentTagScalarWhereInput[]
  }

  export type EquipmentCreateNestedOneWithoutEmployeeEquipmentLogsInput = {
    create?: XOR<EquipmentCreateWithoutEmployeeEquipmentLogsInput, EquipmentUncheckedCreateWithoutEmployeeEquipmentLogsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutEmployeeEquipmentLogsInput
    connect?: EquipmentWhereUniqueInput
  }

  export type MaintenanceCreateNestedOneWithoutEmployeeEquipmentLogInput = {
    create?: XOR<MaintenanceCreateWithoutEmployeeEquipmentLogInput, MaintenanceUncheckedCreateWithoutEmployeeEquipmentLogInput>
    connectOrCreate?: MaintenanceCreateOrConnectWithoutEmployeeEquipmentLogInput
    connect?: MaintenanceWhereUniqueInput
  }

  export type TimeSheetCreateNestedOneWithoutEmployeeEquipmentLogsInput = {
    create?: XOR<TimeSheetCreateWithoutEmployeeEquipmentLogsInput, TimeSheetUncheckedCreateWithoutEmployeeEquipmentLogsInput>
    connectOrCreate?: TimeSheetCreateOrConnectWithoutEmployeeEquipmentLogsInput
    connect?: TimeSheetWhereUniqueInput
  }

  export type RefuelLogCreateNestedOneWithoutEmployeeEquipmentLogInput = {
    create?: XOR<RefuelLogCreateWithoutEmployeeEquipmentLogInput, RefuelLogUncheckedCreateWithoutEmployeeEquipmentLogInput>
    connectOrCreate?: RefuelLogCreateOrConnectWithoutEmployeeEquipmentLogInput
    connect?: RefuelLogWhereUniqueInput
  }

  export type RefuelLogUncheckedCreateNestedOneWithoutEmployeeEquipmentLogInput = {
    create?: XOR<RefuelLogCreateWithoutEmployeeEquipmentLogInput, RefuelLogUncheckedCreateWithoutEmployeeEquipmentLogInput>
    connectOrCreate?: RefuelLogCreateOrConnectWithoutEmployeeEquipmentLogInput
    connect?: RefuelLogWhereUniqueInput
  }

  export type EquipmentUpdateOneWithoutEmployeeEquipmentLogsNestedInput = {
    create?: XOR<EquipmentCreateWithoutEmployeeEquipmentLogsInput, EquipmentUncheckedCreateWithoutEmployeeEquipmentLogsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutEmployeeEquipmentLogsInput
    upsert?: EquipmentUpsertWithoutEmployeeEquipmentLogsInput
    disconnect?: EquipmentWhereInput | boolean
    delete?: EquipmentWhereInput | boolean
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutEmployeeEquipmentLogsInput, EquipmentUpdateWithoutEmployeeEquipmentLogsInput>, EquipmentUncheckedUpdateWithoutEmployeeEquipmentLogsInput>
  }

  export type MaintenanceUpdateOneWithoutEmployeeEquipmentLogNestedInput = {
    create?: XOR<MaintenanceCreateWithoutEmployeeEquipmentLogInput, MaintenanceUncheckedCreateWithoutEmployeeEquipmentLogInput>
    connectOrCreate?: MaintenanceCreateOrConnectWithoutEmployeeEquipmentLogInput
    upsert?: MaintenanceUpsertWithoutEmployeeEquipmentLogInput
    disconnect?: MaintenanceWhereInput | boolean
    delete?: MaintenanceWhereInput | boolean
    connect?: MaintenanceWhereUniqueInput
    update?: XOR<XOR<MaintenanceUpdateToOneWithWhereWithoutEmployeeEquipmentLogInput, MaintenanceUpdateWithoutEmployeeEquipmentLogInput>, MaintenanceUncheckedUpdateWithoutEmployeeEquipmentLogInput>
  }

  export type TimeSheetUpdateOneRequiredWithoutEmployeeEquipmentLogsNestedInput = {
    create?: XOR<TimeSheetCreateWithoutEmployeeEquipmentLogsInput, TimeSheetUncheckedCreateWithoutEmployeeEquipmentLogsInput>
    connectOrCreate?: TimeSheetCreateOrConnectWithoutEmployeeEquipmentLogsInput
    upsert?: TimeSheetUpsertWithoutEmployeeEquipmentLogsInput
    connect?: TimeSheetWhereUniqueInput
    update?: XOR<XOR<TimeSheetUpdateToOneWithWhereWithoutEmployeeEquipmentLogsInput, TimeSheetUpdateWithoutEmployeeEquipmentLogsInput>, TimeSheetUncheckedUpdateWithoutEmployeeEquipmentLogsInput>
  }

  export type RefuelLogUpdateOneWithoutEmployeeEquipmentLogNestedInput = {
    create?: XOR<RefuelLogCreateWithoutEmployeeEquipmentLogInput, RefuelLogUncheckedCreateWithoutEmployeeEquipmentLogInput>
    connectOrCreate?: RefuelLogCreateOrConnectWithoutEmployeeEquipmentLogInput
    upsert?: RefuelLogUpsertWithoutEmployeeEquipmentLogInput
    disconnect?: RefuelLogWhereInput | boolean
    delete?: RefuelLogWhereInput | boolean
    connect?: RefuelLogWhereUniqueInput
    update?: XOR<XOR<RefuelLogUpdateToOneWithWhereWithoutEmployeeEquipmentLogInput, RefuelLogUpdateWithoutEmployeeEquipmentLogInput>, RefuelLogUncheckedUpdateWithoutEmployeeEquipmentLogInput>
  }

  export type RefuelLogUncheckedUpdateOneWithoutEmployeeEquipmentLogNestedInput = {
    create?: XOR<RefuelLogCreateWithoutEmployeeEquipmentLogInput, RefuelLogUncheckedCreateWithoutEmployeeEquipmentLogInput>
    connectOrCreate?: RefuelLogCreateOrConnectWithoutEmployeeEquipmentLogInput
    upsert?: RefuelLogUpsertWithoutEmployeeEquipmentLogInput
    disconnect?: RefuelLogWhereInput | boolean
    delete?: RefuelLogWhereInput | boolean
    connect?: RefuelLogWhereUniqueInput
    update?: XOR<XOR<RefuelLogUpdateToOneWithWhereWithoutEmployeeEquipmentLogInput, RefuelLogUpdateWithoutEmployeeEquipmentLogInput>, RefuelLogUncheckedUpdateWithoutEmployeeEquipmentLogInput>
  }

  export type FormSubmissionCreateNestedManyWithoutFormTemplateInput = {
    create?: XOR<FormSubmissionCreateWithoutFormTemplateInput, FormSubmissionUncheckedCreateWithoutFormTemplateInput> | FormSubmissionCreateWithoutFormTemplateInput[] | FormSubmissionUncheckedCreateWithoutFormTemplateInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFormTemplateInput | FormSubmissionCreateOrConnectWithoutFormTemplateInput[]
    createMany?: FormSubmissionCreateManyFormTemplateInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutFormTemplatesInput = {
    create?: XOR<CompanyCreateWithoutFormTemplatesInput, CompanyUncheckedCreateWithoutFormTemplatesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFormTemplatesInput
    connect?: CompanyWhereUniqueInput
  }

  export type FormGroupingCreateNestedManyWithoutFormTemplateInput = {
    create?: XOR<FormGroupingCreateWithoutFormTemplateInput, FormGroupingUncheckedCreateWithoutFormTemplateInput> | FormGroupingCreateWithoutFormTemplateInput[] | FormGroupingUncheckedCreateWithoutFormTemplateInput[]
    connectOrCreate?: FormGroupingCreateOrConnectWithoutFormTemplateInput | FormGroupingCreateOrConnectWithoutFormTemplateInput[]
    connect?: FormGroupingWhereUniqueInput | FormGroupingWhereUniqueInput[]
  }

  export type FormSubmissionUncheckedCreateNestedManyWithoutFormTemplateInput = {
    create?: XOR<FormSubmissionCreateWithoutFormTemplateInput, FormSubmissionUncheckedCreateWithoutFormTemplateInput> | FormSubmissionCreateWithoutFormTemplateInput[] | FormSubmissionUncheckedCreateWithoutFormTemplateInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFormTemplateInput | FormSubmissionCreateOrConnectWithoutFormTemplateInput[]
    createMany?: FormSubmissionCreateManyFormTemplateInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type FormGroupingUncheckedCreateNestedManyWithoutFormTemplateInput = {
    create?: XOR<FormGroupingCreateWithoutFormTemplateInput, FormGroupingUncheckedCreateWithoutFormTemplateInput> | FormGroupingCreateWithoutFormTemplateInput[] | FormGroupingUncheckedCreateWithoutFormTemplateInput[]
    connectOrCreate?: FormGroupingCreateOrConnectWithoutFormTemplateInput | FormGroupingCreateOrConnectWithoutFormTemplateInput[]
    connect?: FormGroupingWhereUniqueInput | FormGroupingWhereUniqueInput[]
  }

  export type EnumFormTemplateCategoryFieldUpdateOperationsInput = {
    set?: $Enums.FormTemplateCategory
  }

  export type FormSubmissionUpdateManyWithoutFormTemplateNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutFormTemplateInput, FormSubmissionUncheckedCreateWithoutFormTemplateInput> | FormSubmissionCreateWithoutFormTemplateInput[] | FormSubmissionUncheckedCreateWithoutFormTemplateInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFormTemplateInput | FormSubmissionCreateOrConnectWithoutFormTemplateInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutFormTemplateInput | FormSubmissionUpsertWithWhereUniqueWithoutFormTemplateInput[]
    createMany?: FormSubmissionCreateManyFormTemplateInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutFormTemplateInput | FormSubmissionUpdateWithWhereUniqueWithoutFormTemplateInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutFormTemplateInput | FormSubmissionUpdateManyWithWhereWithoutFormTemplateInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutFormTemplatesNestedInput = {
    create?: XOR<CompanyCreateWithoutFormTemplatesInput, CompanyUncheckedCreateWithoutFormTemplatesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutFormTemplatesInput
    upsert?: CompanyUpsertWithoutFormTemplatesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutFormTemplatesInput, CompanyUpdateWithoutFormTemplatesInput>, CompanyUncheckedUpdateWithoutFormTemplatesInput>
  }

  export type FormGroupingUpdateManyWithoutFormTemplateNestedInput = {
    create?: XOR<FormGroupingCreateWithoutFormTemplateInput, FormGroupingUncheckedCreateWithoutFormTemplateInput> | FormGroupingCreateWithoutFormTemplateInput[] | FormGroupingUncheckedCreateWithoutFormTemplateInput[]
    connectOrCreate?: FormGroupingCreateOrConnectWithoutFormTemplateInput | FormGroupingCreateOrConnectWithoutFormTemplateInput[]
    upsert?: FormGroupingUpsertWithWhereUniqueWithoutFormTemplateInput | FormGroupingUpsertWithWhereUniqueWithoutFormTemplateInput[]
    set?: FormGroupingWhereUniqueInput | FormGroupingWhereUniqueInput[]
    disconnect?: FormGroupingWhereUniqueInput | FormGroupingWhereUniqueInput[]
    delete?: FormGroupingWhereUniqueInput | FormGroupingWhereUniqueInput[]
    connect?: FormGroupingWhereUniqueInput | FormGroupingWhereUniqueInput[]
    update?: FormGroupingUpdateWithWhereUniqueWithoutFormTemplateInput | FormGroupingUpdateWithWhereUniqueWithoutFormTemplateInput[]
    updateMany?: FormGroupingUpdateManyWithWhereWithoutFormTemplateInput | FormGroupingUpdateManyWithWhereWithoutFormTemplateInput[]
    deleteMany?: FormGroupingScalarWhereInput | FormGroupingScalarWhereInput[]
  }

  export type FormSubmissionUncheckedUpdateManyWithoutFormTemplateNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutFormTemplateInput, FormSubmissionUncheckedCreateWithoutFormTemplateInput> | FormSubmissionCreateWithoutFormTemplateInput[] | FormSubmissionUncheckedCreateWithoutFormTemplateInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutFormTemplateInput | FormSubmissionCreateOrConnectWithoutFormTemplateInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutFormTemplateInput | FormSubmissionUpsertWithWhereUniqueWithoutFormTemplateInput[]
    createMany?: FormSubmissionCreateManyFormTemplateInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutFormTemplateInput | FormSubmissionUpdateWithWhereUniqueWithoutFormTemplateInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutFormTemplateInput | FormSubmissionUpdateManyWithWhereWithoutFormTemplateInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type FormGroupingUncheckedUpdateManyWithoutFormTemplateNestedInput = {
    create?: XOR<FormGroupingCreateWithoutFormTemplateInput, FormGroupingUncheckedCreateWithoutFormTemplateInput> | FormGroupingCreateWithoutFormTemplateInput[] | FormGroupingUncheckedCreateWithoutFormTemplateInput[]
    connectOrCreate?: FormGroupingCreateOrConnectWithoutFormTemplateInput | FormGroupingCreateOrConnectWithoutFormTemplateInput[]
    upsert?: FormGroupingUpsertWithWhereUniqueWithoutFormTemplateInput | FormGroupingUpsertWithWhereUniqueWithoutFormTemplateInput[]
    set?: FormGroupingWhereUniqueInput | FormGroupingWhereUniqueInput[]
    disconnect?: FormGroupingWhereUniqueInput | FormGroupingWhereUniqueInput[]
    delete?: FormGroupingWhereUniqueInput | FormGroupingWhereUniqueInput[]
    connect?: FormGroupingWhereUniqueInput | FormGroupingWhereUniqueInput[]
    update?: FormGroupingUpdateWithWhereUniqueWithoutFormTemplateInput | FormGroupingUpdateWithWhereUniqueWithoutFormTemplateInput[]
    updateMany?: FormGroupingUpdateManyWithWhereWithoutFormTemplateInput | FormGroupingUpdateManyWithWhereWithoutFormTemplateInput[]
    deleteMany?: FormGroupingScalarWhereInput | FormGroupingScalarWhereInput[]
  }

  export type FormFieldCreateNestedManyWithoutFormGroupingInput = {
    create?: XOR<FormFieldCreateWithoutFormGroupingInput, FormFieldUncheckedCreateWithoutFormGroupingInput> | FormFieldCreateWithoutFormGroupingInput[] | FormFieldUncheckedCreateWithoutFormGroupingInput[]
    connectOrCreate?: FormFieldCreateOrConnectWithoutFormGroupingInput | FormFieldCreateOrConnectWithoutFormGroupingInput[]
    createMany?: FormFieldCreateManyFormGroupingInputEnvelope
    connect?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
  }

  export type FormTemplateCreateNestedManyWithoutFormGroupingInput = {
    create?: XOR<FormTemplateCreateWithoutFormGroupingInput, FormTemplateUncheckedCreateWithoutFormGroupingInput> | FormTemplateCreateWithoutFormGroupingInput[] | FormTemplateUncheckedCreateWithoutFormGroupingInput[]
    connectOrCreate?: FormTemplateCreateOrConnectWithoutFormGroupingInput | FormTemplateCreateOrConnectWithoutFormGroupingInput[]
    connect?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
  }

  export type FormFieldUncheckedCreateNestedManyWithoutFormGroupingInput = {
    create?: XOR<FormFieldCreateWithoutFormGroupingInput, FormFieldUncheckedCreateWithoutFormGroupingInput> | FormFieldCreateWithoutFormGroupingInput[] | FormFieldUncheckedCreateWithoutFormGroupingInput[]
    connectOrCreate?: FormFieldCreateOrConnectWithoutFormGroupingInput | FormFieldCreateOrConnectWithoutFormGroupingInput[]
    createMany?: FormFieldCreateManyFormGroupingInputEnvelope
    connect?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
  }

  export type FormTemplateUncheckedCreateNestedManyWithoutFormGroupingInput = {
    create?: XOR<FormTemplateCreateWithoutFormGroupingInput, FormTemplateUncheckedCreateWithoutFormGroupingInput> | FormTemplateCreateWithoutFormGroupingInput[] | FormTemplateUncheckedCreateWithoutFormGroupingInput[]
    connectOrCreate?: FormTemplateCreateOrConnectWithoutFormGroupingInput | FormTemplateCreateOrConnectWithoutFormGroupingInput[]
    connect?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
  }

  export type FormFieldUpdateManyWithoutFormGroupingNestedInput = {
    create?: XOR<FormFieldCreateWithoutFormGroupingInput, FormFieldUncheckedCreateWithoutFormGroupingInput> | FormFieldCreateWithoutFormGroupingInput[] | FormFieldUncheckedCreateWithoutFormGroupingInput[]
    connectOrCreate?: FormFieldCreateOrConnectWithoutFormGroupingInput | FormFieldCreateOrConnectWithoutFormGroupingInput[]
    upsert?: FormFieldUpsertWithWhereUniqueWithoutFormGroupingInput | FormFieldUpsertWithWhereUniqueWithoutFormGroupingInput[]
    createMany?: FormFieldCreateManyFormGroupingInputEnvelope
    set?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
    disconnect?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
    delete?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
    connect?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
    update?: FormFieldUpdateWithWhereUniqueWithoutFormGroupingInput | FormFieldUpdateWithWhereUniqueWithoutFormGroupingInput[]
    updateMany?: FormFieldUpdateManyWithWhereWithoutFormGroupingInput | FormFieldUpdateManyWithWhereWithoutFormGroupingInput[]
    deleteMany?: FormFieldScalarWhereInput | FormFieldScalarWhereInput[]
  }

  export type FormTemplateUpdateManyWithoutFormGroupingNestedInput = {
    create?: XOR<FormTemplateCreateWithoutFormGroupingInput, FormTemplateUncheckedCreateWithoutFormGroupingInput> | FormTemplateCreateWithoutFormGroupingInput[] | FormTemplateUncheckedCreateWithoutFormGroupingInput[]
    connectOrCreate?: FormTemplateCreateOrConnectWithoutFormGroupingInput | FormTemplateCreateOrConnectWithoutFormGroupingInput[]
    upsert?: FormTemplateUpsertWithWhereUniqueWithoutFormGroupingInput | FormTemplateUpsertWithWhereUniqueWithoutFormGroupingInput[]
    set?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
    disconnect?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
    delete?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
    connect?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
    update?: FormTemplateUpdateWithWhereUniqueWithoutFormGroupingInput | FormTemplateUpdateWithWhereUniqueWithoutFormGroupingInput[]
    updateMany?: FormTemplateUpdateManyWithWhereWithoutFormGroupingInput | FormTemplateUpdateManyWithWhereWithoutFormGroupingInput[]
    deleteMany?: FormTemplateScalarWhereInput | FormTemplateScalarWhereInput[]
  }

  export type FormFieldUncheckedUpdateManyWithoutFormGroupingNestedInput = {
    create?: XOR<FormFieldCreateWithoutFormGroupingInput, FormFieldUncheckedCreateWithoutFormGroupingInput> | FormFieldCreateWithoutFormGroupingInput[] | FormFieldUncheckedCreateWithoutFormGroupingInput[]
    connectOrCreate?: FormFieldCreateOrConnectWithoutFormGroupingInput | FormFieldCreateOrConnectWithoutFormGroupingInput[]
    upsert?: FormFieldUpsertWithWhereUniqueWithoutFormGroupingInput | FormFieldUpsertWithWhereUniqueWithoutFormGroupingInput[]
    createMany?: FormFieldCreateManyFormGroupingInputEnvelope
    set?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
    disconnect?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
    delete?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
    connect?: FormFieldWhereUniqueInput | FormFieldWhereUniqueInput[]
    update?: FormFieldUpdateWithWhereUniqueWithoutFormGroupingInput | FormFieldUpdateWithWhereUniqueWithoutFormGroupingInput[]
    updateMany?: FormFieldUpdateManyWithWhereWithoutFormGroupingInput | FormFieldUpdateManyWithWhereWithoutFormGroupingInput[]
    deleteMany?: FormFieldScalarWhereInput | FormFieldScalarWhereInput[]
  }

  export type FormTemplateUncheckedUpdateManyWithoutFormGroupingNestedInput = {
    create?: XOR<FormTemplateCreateWithoutFormGroupingInput, FormTemplateUncheckedCreateWithoutFormGroupingInput> | FormTemplateCreateWithoutFormGroupingInput[] | FormTemplateUncheckedCreateWithoutFormGroupingInput[]
    connectOrCreate?: FormTemplateCreateOrConnectWithoutFormGroupingInput | FormTemplateCreateOrConnectWithoutFormGroupingInput[]
    upsert?: FormTemplateUpsertWithWhereUniqueWithoutFormGroupingInput | FormTemplateUpsertWithWhereUniqueWithoutFormGroupingInput[]
    set?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
    disconnect?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
    delete?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
    connect?: FormTemplateWhereUniqueInput | FormTemplateWhereUniqueInput[]
    update?: FormTemplateUpdateWithWhereUniqueWithoutFormGroupingInput | FormTemplateUpdateWithWhereUniqueWithoutFormGroupingInput[]
    updateMany?: FormTemplateUpdateManyWithWhereWithoutFormGroupingInput | FormTemplateUpdateManyWithWhereWithoutFormGroupingInput[]
    deleteMany?: FormTemplateScalarWhereInput | FormTemplateScalarWhereInput[]
  }

  export type FormGroupingCreateNestedOneWithoutFieldsInput = {
    create?: XOR<FormGroupingCreateWithoutFieldsInput, FormGroupingUncheckedCreateWithoutFieldsInput>
    connectOrCreate?: FormGroupingCreateOrConnectWithoutFieldsInput
    connect?: FormGroupingWhereUniqueInput
  }

  export type FormFieldOptionCreateNestedManyWithoutFieldInput = {
    create?: XOR<FormFieldOptionCreateWithoutFieldInput, FormFieldOptionUncheckedCreateWithoutFieldInput> | FormFieldOptionCreateWithoutFieldInput[] | FormFieldOptionUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FormFieldOptionCreateOrConnectWithoutFieldInput | FormFieldOptionCreateOrConnectWithoutFieldInput[]
    createMany?: FormFieldOptionCreateManyFieldInputEnvelope
    connect?: FormFieldOptionWhereUniqueInput | FormFieldOptionWhereUniqueInput[]
  }

  export type FormFieldOptionUncheckedCreateNestedManyWithoutFieldInput = {
    create?: XOR<FormFieldOptionCreateWithoutFieldInput, FormFieldOptionUncheckedCreateWithoutFieldInput> | FormFieldOptionCreateWithoutFieldInput[] | FormFieldOptionUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FormFieldOptionCreateOrConnectWithoutFieldInput | FormFieldOptionCreateOrConnectWithoutFieldInput[]
    createMany?: FormFieldOptionCreateManyFieldInputEnvelope
    connect?: FormFieldOptionWhereUniqueInput | FormFieldOptionWhereUniqueInput[]
  }

  export type EnumFieldTypeFieldUpdateOperationsInput = {
    set?: $Enums.FieldType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FormGroupingUpdateOneRequiredWithoutFieldsNestedInput = {
    create?: XOR<FormGroupingCreateWithoutFieldsInput, FormGroupingUncheckedCreateWithoutFieldsInput>
    connectOrCreate?: FormGroupingCreateOrConnectWithoutFieldsInput
    upsert?: FormGroupingUpsertWithoutFieldsInput
    connect?: FormGroupingWhereUniqueInput
    update?: XOR<XOR<FormGroupingUpdateToOneWithWhereWithoutFieldsInput, FormGroupingUpdateWithoutFieldsInput>, FormGroupingUncheckedUpdateWithoutFieldsInput>
  }

  export type FormFieldOptionUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FormFieldOptionCreateWithoutFieldInput, FormFieldOptionUncheckedCreateWithoutFieldInput> | FormFieldOptionCreateWithoutFieldInput[] | FormFieldOptionUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FormFieldOptionCreateOrConnectWithoutFieldInput | FormFieldOptionCreateOrConnectWithoutFieldInput[]
    upsert?: FormFieldOptionUpsertWithWhereUniqueWithoutFieldInput | FormFieldOptionUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FormFieldOptionCreateManyFieldInputEnvelope
    set?: FormFieldOptionWhereUniqueInput | FormFieldOptionWhereUniqueInput[]
    disconnect?: FormFieldOptionWhereUniqueInput | FormFieldOptionWhereUniqueInput[]
    delete?: FormFieldOptionWhereUniqueInput | FormFieldOptionWhereUniqueInput[]
    connect?: FormFieldOptionWhereUniqueInput | FormFieldOptionWhereUniqueInput[]
    update?: FormFieldOptionUpdateWithWhereUniqueWithoutFieldInput | FormFieldOptionUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FormFieldOptionUpdateManyWithWhereWithoutFieldInput | FormFieldOptionUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FormFieldOptionScalarWhereInput | FormFieldOptionScalarWhereInput[]
  }

  export type FormFieldOptionUncheckedUpdateManyWithoutFieldNestedInput = {
    create?: XOR<FormFieldOptionCreateWithoutFieldInput, FormFieldOptionUncheckedCreateWithoutFieldInput> | FormFieldOptionCreateWithoutFieldInput[] | FormFieldOptionUncheckedCreateWithoutFieldInput[]
    connectOrCreate?: FormFieldOptionCreateOrConnectWithoutFieldInput | FormFieldOptionCreateOrConnectWithoutFieldInput[]
    upsert?: FormFieldOptionUpsertWithWhereUniqueWithoutFieldInput | FormFieldOptionUpsertWithWhereUniqueWithoutFieldInput[]
    createMany?: FormFieldOptionCreateManyFieldInputEnvelope
    set?: FormFieldOptionWhereUniqueInput | FormFieldOptionWhereUniqueInput[]
    disconnect?: FormFieldOptionWhereUniqueInput | FormFieldOptionWhereUniqueInput[]
    delete?: FormFieldOptionWhereUniqueInput | FormFieldOptionWhereUniqueInput[]
    connect?: FormFieldOptionWhereUniqueInput | FormFieldOptionWhereUniqueInput[]
    update?: FormFieldOptionUpdateWithWhereUniqueWithoutFieldInput | FormFieldOptionUpdateWithWhereUniqueWithoutFieldInput[]
    updateMany?: FormFieldOptionUpdateManyWithWhereWithoutFieldInput | FormFieldOptionUpdateManyWithWhereWithoutFieldInput[]
    deleteMany?: FormFieldOptionScalarWhereInput | FormFieldOptionScalarWhereInput[]
  }

  export type FormFieldCreateNestedOneWithoutOptionsInput = {
    create?: XOR<FormFieldCreateWithoutOptionsInput, FormFieldUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: FormFieldCreateOrConnectWithoutOptionsInput
    connect?: FormFieldWhereUniqueInput
  }

  export type FormFieldUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<FormFieldCreateWithoutOptionsInput, FormFieldUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: FormFieldCreateOrConnectWithoutOptionsInput
    upsert?: FormFieldUpsertWithoutOptionsInput
    connect?: FormFieldWhereUniqueInput
    update?: XOR<XOR<FormFieldUpdateToOneWithWhereWithoutOptionsInput, FormFieldUpdateWithoutOptionsInput>, FormFieldUncheckedUpdateWithoutOptionsInput>
  }

  export type FormApprovalCreateNestedManyWithoutFormSubmissionInput = {
    create?: XOR<FormApprovalCreateWithoutFormSubmissionInput, FormApprovalUncheckedCreateWithoutFormSubmissionInput> | FormApprovalCreateWithoutFormSubmissionInput[] | FormApprovalUncheckedCreateWithoutFormSubmissionInput[]
    connectOrCreate?: FormApprovalCreateOrConnectWithoutFormSubmissionInput | FormApprovalCreateOrConnectWithoutFormSubmissionInput[]
    createMany?: FormApprovalCreateManyFormSubmissionInputEnvelope
    connect?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
  }

  export type FormTemplateCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<FormTemplateCreateWithoutSubmissionsInput, FormTemplateUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: FormTemplateCreateOrConnectWithoutSubmissionsInput
    connect?: FormTemplateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFormSubmissionsInput = {
    create?: XOR<UserCreateWithoutFormSubmissionsInput, UserUncheckedCreateWithoutFormSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFormSubmissionsInput
    connect?: UserWhereUniqueInput
  }

  export type FormApprovalUncheckedCreateNestedManyWithoutFormSubmissionInput = {
    create?: XOR<FormApprovalCreateWithoutFormSubmissionInput, FormApprovalUncheckedCreateWithoutFormSubmissionInput> | FormApprovalCreateWithoutFormSubmissionInput[] | FormApprovalUncheckedCreateWithoutFormSubmissionInput[]
    connectOrCreate?: FormApprovalCreateOrConnectWithoutFormSubmissionInput | FormApprovalCreateOrConnectWithoutFormSubmissionInput[]
    createMany?: FormApprovalCreateManyFormSubmissionInputEnvelope
    connect?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
  }

  export type EnumFormStatusFieldUpdateOperationsInput = {
    set?: $Enums.FormStatus
  }

  export type FormApprovalUpdateManyWithoutFormSubmissionNestedInput = {
    create?: XOR<FormApprovalCreateWithoutFormSubmissionInput, FormApprovalUncheckedCreateWithoutFormSubmissionInput> | FormApprovalCreateWithoutFormSubmissionInput[] | FormApprovalUncheckedCreateWithoutFormSubmissionInput[]
    connectOrCreate?: FormApprovalCreateOrConnectWithoutFormSubmissionInput | FormApprovalCreateOrConnectWithoutFormSubmissionInput[]
    upsert?: FormApprovalUpsertWithWhereUniqueWithoutFormSubmissionInput | FormApprovalUpsertWithWhereUniqueWithoutFormSubmissionInput[]
    createMany?: FormApprovalCreateManyFormSubmissionInputEnvelope
    set?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
    disconnect?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
    delete?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
    connect?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
    update?: FormApprovalUpdateWithWhereUniqueWithoutFormSubmissionInput | FormApprovalUpdateWithWhereUniqueWithoutFormSubmissionInput[]
    updateMany?: FormApprovalUpdateManyWithWhereWithoutFormSubmissionInput | FormApprovalUpdateManyWithWhereWithoutFormSubmissionInput[]
    deleteMany?: FormApprovalScalarWhereInput | FormApprovalScalarWhereInput[]
  }

  export type FormTemplateUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<FormTemplateCreateWithoutSubmissionsInput, FormTemplateUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: FormTemplateCreateOrConnectWithoutSubmissionsInput
    upsert?: FormTemplateUpsertWithoutSubmissionsInput
    connect?: FormTemplateWhereUniqueInput
    update?: XOR<XOR<FormTemplateUpdateToOneWithWhereWithoutSubmissionsInput, FormTemplateUpdateWithoutSubmissionsInput>, FormTemplateUncheckedUpdateWithoutSubmissionsInput>
  }

  export type UserUpdateOneRequiredWithoutFormSubmissionsNestedInput = {
    create?: XOR<UserCreateWithoutFormSubmissionsInput, UserUncheckedCreateWithoutFormSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFormSubmissionsInput
    upsert?: UserUpsertWithoutFormSubmissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFormSubmissionsInput, UserUpdateWithoutFormSubmissionsInput>, UserUncheckedUpdateWithoutFormSubmissionsInput>
  }

  export type FormApprovalUncheckedUpdateManyWithoutFormSubmissionNestedInput = {
    create?: XOR<FormApprovalCreateWithoutFormSubmissionInput, FormApprovalUncheckedCreateWithoutFormSubmissionInput> | FormApprovalCreateWithoutFormSubmissionInput[] | FormApprovalUncheckedCreateWithoutFormSubmissionInput[]
    connectOrCreate?: FormApprovalCreateOrConnectWithoutFormSubmissionInput | FormApprovalCreateOrConnectWithoutFormSubmissionInput[]
    upsert?: FormApprovalUpsertWithWhereUniqueWithoutFormSubmissionInput | FormApprovalUpsertWithWhereUniqueWithoutFormSubmissionInput[]
    createMany?: FormApprovalCreateManyFormSubmissionInputEnvelope
    set?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
    disconnect?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
    delete?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
    connect?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
    update?: FormApprovalUpdateWithWhereUniqueWithoutFormSubmissionInput | FormApprovalUpdateWithWhereUniqueWithoutFormSubmissionInput[]
    updateMany?: FormApprovalUpdateManyWithWhereWithoutFormSubmissionInput | FormApprovalUpdateManyWithWhereWithoutFormSubmissionInput[]
    deleteMany?: FormApprovalScalarWhereInput | FormApprovalScalarWhereInput[]
  }

  export type FormSubmissionCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<FormSubmissionCreateWithoutApprovalsInput, FormSubmissionUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutApprovalsInput
    connect?: FormSubmissionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFormApprovalsInput = {
    create?: XOR<UserCreateWithoutFormApprovalsInput, UserUncheckedCreateWithoutFormApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFormApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type FormSubmissionUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutApprovalsInput, FormSubmissionUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutApprovalsInput
    upsert?: FormSubmissionUpsertWithoutApprovalsInput
    connect?: FormSubmissionWhereUniqueInput
    update?: XOR<XOR<FormSubmissionUpdateToOneWithWhereWithoutApprovalsInput, FormSubmissionUpdateWithoutApprovalsInput>, FormSubmissionUncheckedUpdateWithoutApprovalsInput>
  }

  export type UserUpdateOneWithoutFormApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutFormApprovalsInput, UserUncheckedCreateWithoutFormApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFormApprovalsInput
    upsert?: UserUpsertWithoutFormApprovalsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFormApprovalsInput, UserUpdateWithoutFormApprovalsInput>, UserUncheckedUpdateWithoutFormApprovalsInput>
  }

  export type AddressCreateNestedOneWithoutJobsiteInput = {
    create?: XOR<AddressCreateWithoutJobsiteInput, AddressUncheckedCreateWithoutJobsiteInput>
    connectOrCreate?: AddressCreateOrConnectWithoutJobsiteInput
    connect?: AddressWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutJobsiteInput = {
    create?: XOR<UserCreateWithoutJobsiteInput, UserUncheckedCreateWithoutJobsiteInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobsiteInput
    connect?: UserWhereUniqueInput
  }

  export type TimeSheetCreateNestedManyWithoutJobsiteInput = {
    create?: XOR<TimeSheetCreateWithoutJobsiteInput, TimeSheetUncheckedCreateWithoutJobsiteInput> | TimeSheetCreateWithoutJobsiteInput[] | TimeSheetUncheckedCreateWithoutJobsiteInput[]
    connectOrCreate?: TimeSheetCreateOrConnectWithoutJobsiteInput | TimeSheetCreateOrConnectWithoutJobsiteInput[]
    createMany?: TimeSheetCreateManyJobsiteInputEnvelope
    connect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
  }

  export type CCTagCreateNestedManyWithoutJobsitesInput = {
    create?: XOR<CCTagCreateWithoutJobsitesInput, CCTagUncheckedCreateWithoutJobsitesInput> | CCTagCreateWithoutJobsitesInput[] | CCTagUncheckedCreateWithoutJobsitesInput[]
    connectOrCreate?: CCTagCreateOrConnectWithoutJobsitesInput | CCTagCreateOrConnectWithoutJobsitesInput[]
    connect?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
  }

  export type TimeSheetUncheckedCreateNestedManyWithoutJobsiteInput = {
    create?: XOR<TimeSheetCreateWithoutJobsiteInput, TimeSheetUncheckedCreateWithoutJobsiteInput> | TimeSheetCreateWithoutJobsiteInput[] | TimeSheetUncheckedCreateWithoutJobsiteInput[]
    connectOrCreate?: TimeSheetCreateOrConnectWithoutJobsiteInput | TimeSheetCreateOrConnectWithoutJobsiteInput[]
    createMany?: TimeSheetCreateManyJobsiteInputEnvelope
    connect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
  }

  export type CCTagUncheckedCreateNestedManyWithoutJobsitesInput = {
    create?: XOR<CCTagCreateWithoutJobsitesInput, CCTagUncheckedCreateWithoutJobsitesInput> | CCTagCreateWithoutJobsitesInput[] | CCTagUncheckedCreateWithoutJobsitesInput[]
    connectOrCreate?: CCTagCreateOrConnectWithoutJobsitesInput | CCTagCreateOrConnectWithoutJobsitesInput[]
    connect?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
  }

  export type AddressUpdateOneWithoutJobsiteNestedInput = {
    create?: XOR<AddressCreateWithoutJobsiteInput, AddressUncheckedCreateWithoutJobsiteInput>
    connectOrCreate?: AddressCreateOrConnectWithoutJobsiteInput
    upsert?: AddressUpsertWithoutJobsiteInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutJobsiteInput, AddressUpdateWithoutJobsiteInput>, AddressUncheckedUpdateWithoutJobsiteInput>
  }

  export type UserUpdateOneWithoutJobsiteNestedInput = {
    create?: XOR<UserCreateWithoutJobsiteInput, UserUncheckedCreateWithoutJobsiteInput>
    connectOrCreate?: UserCreateOrConnectWithoutJobsiteInput
    upsert?: UserUpsertWithoutJobsiteInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutJobsiteInput, UserUpdateWithoutJobsiteInput>, UserUncheckedUpdateWithoutJobsiteInput>
  }

  export type TimeSheetUpdateManyWithoutJobsiteNestedInput = {
    create?: XOR<TimeSheetCreateWithoutJobsiteInput, TimeSheetUncheckedCreateWithoutJobsiteInput> | TimeSheetCreateWithoutJobsiteInput[] | TimeSheetUncheckedCreateWithoutJobsiteInput[]
    connectOrCreate?: TimeSheetCreateOrConnectWithoutJobsiteInput | TimeSheetCreateOrConnectWithoutJobsiteInput[]
    upsert?: TimeSheetUpsertWithWhereUniqueWithoutJobsiteInput | TimeSheetUpsertWithWhereUniqueWithoutJobsiteInput[]
    createMany?: TimeSheetCreateManyJobsiteInputEnvelope
    set?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    disconnect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    delete?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    connect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    update?: TimeSheetUpdateWithWhereUniqueWithoutJobsiteInput | TimeSheetUpdateWithWhereUniqueWithoutJobsiteInput[]
    updateMany?: TimeSheetUpdateManyWithWhereWithoutJobsiteInput | TimeSheetUpdateManyWithWhereWithoutJobsiteInput[]
    deleteMany?: TimeSheetScalarWhereInput | TimeSheetScalarWhereInput[]
  }

  export type CCTagUpdateManyWithoutJobsitesNestedInput = {
    create?: XOR<CCTagCreateWithoutJobsitesInput, CCTagUncheckedCreateWithoutJobsitesInput> | CCTagCreateWithoutJobsitesInput[] | CCTagUncheckedCreateWithoutJobsitesInput[]
    connectOrCreate?: CCTagCreateOrConnectWithoutJobsitesInput | CCTagCreateOrConnectWithoutJobsitesInput[]
    upsert?: CCTagUpsertWithWhereUniqueWithoutJobsitesInput | CCTagUpsertWithWhereUniqueWithoutJobsitesInput[]
    set?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
    disconnect?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
    delete?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
    connect?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
    update?: CCTagUpdateWithWhereUniqueWithoutJobsitesInput | CCTagUpdateWithWhereUniqueWithoutJobsitesInput[]
    updateMany?: CCTagUpdateManyWithWhereWithoutJobsitesInput | CCTagUpdateManyWithWhereWithoutJobsitesInput[]
    deleteMany?: CCTagScalarWhereInput | CCTagScalarWhereInput[]
  }

  export type TimeSheetUncheckedUpdateManyWithoutJobsiteNestedInput = {
    create?: XOR<TimeSheetCreateWithoutJobsiteInput, TimeSheetUncheckedCreateWithoutJobsiteInput> | TimeSheetCreateWithoutJobsiteInput[] | TimeSheetUncheckedCreateWithoutJobsiteInput[]
    connectOrCreate?: TimeSheetCreateOrConnectWithoutJobsiteInput | TimeSheetCreateOrConnectWithoutJobsiteInput[]
    upsert?: TimeSheetUpsertWithWhereUniqueWithoutJobsiteInput | TimeSheetUpsertWithWhereUniqueWithoutJobsiteInput[]
    createMany?: TimeSheetCreateManyJobsiteInputEnvelope
    set?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    disconnect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    delete?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    connect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    update?: TimeSheetUpdateWithWhereUniqueWithoutJobsiteInput | TimeSheetUpdateWithWhereUniqueWithoutJobsiteInput[]
    updateMany?: TimeSheetUpdateManyWithWhereWithoutJobsiteInput | TimeSheetUpdateManyWithWhereWithoutJobsiteInput[]
    deleteMany?: TimeSheetScalarWhereInput | TimeSheetScalarWhereInput[]
  }

  export type CCTagUncheckedUpdateManyWithoutJobsitesNestedInput = {
    create?: XOR<CCTagCreateWithoutJobsitesInput, CCTagUncheckedCreateWithoutJobsitesInput> | CCTagCreateWithoutJobsitesInput[] | CCTagUncheckedCreateWithoutJobsitesInput[]
    connectOrCreate?: CCTagCreateOrConnectWithoutJobsitesInput | CCTagCreateOrConnectWithoutJobsitesInput[]
    upsert?: CCTagUpsertWithWhereUniqueWithoutJobsitesInput | CCTagUpsertWithWhereUniqueWithoutJobsitesInput[]
    set?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
    disconnect?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
    delete?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
    connect?: CCTagWhereUniqueInput | CCTagWhereUniqueInput[]
    update?: CCTagUpdateWithWhereUniqueWithoutJobsitesInput | CCTagUpdateWithWhereUniqueWithoutJobsitesInput[]
    updateMany?: CCTagUpdateManyWithWhereWithoutJobsitesInput | CCTagUpdateManyWithWhereWithoutJobsitesInput[]
    deleteMany?: CCTagScalarWhereInput | CCTagScalarWhereInput[]
  }

  export type ReportCreatetagsInput = {
    set: string[]
  }

  export type CompanyCreateNestedOneWithoutReportsInput = {
    create?: XOR<CompanyCreateWithoutReportsInput, CompanyUncheckedCreateWithoutReportsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutReportsInput
    connect?: CompanyWhereUniqueInput
  }

  export type ReportRunCreateNestedManyWithoutReportInput = {
    create?: XOR<ReportRunCreateWithoutReportInput, ReportRunUncheckedCreateWithoutReportInput> | ReportRunCreateWithoutReportInput[] | ReportRunUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportRunCreateOrConnectWithoutReportInput | ReportRunCreateOrConnectWithoutReportInput[]
    createMany?: ReportRunCreateManyReportInputEnvelope
    connect?: ReportRunWhereUniqueInput | ReportRunWhereUniqueInput[]
  }

  export type ReportRunUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<ReportRunCreateWithoutReportInput, ReportRunUncheckedCreateWithoutReportInput> | ReportRunCreateWithoutReportInput[] | ReportRunUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportRunCreateOrConnectWithoutReportInput | ReportRunCreateOrConnectWithoutReportInput[]
    createMany?: ReportRunCreateManyReportInputEnvelope
    connect?: ReportRunWhereUniqueInput | ReportRunWhereUniqueInput[]
  }

  export type EnumReportVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.ReportVisibility
  }

  export type ReportUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CompanyUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<CompanyCreateWithoutReportsInput, CompanyUncheckedCreateWithoutReportsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutReportsInput
    upsert?: CompanyUpsertWithoutReportsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutReportsInput, CompanyUpdateWithoutReportsInput>, CompanyUncheckedUpdateWithoutReportsInput>
  }

  export type ReportRunUpdateManyWithoutReportNestedInput = {
    create?: XOR<ReportRunCreateWithoutReportInput, ReportRunUncheckedCreateWithoutReportInput> | ReportRunCreateWithoutReportInput[] | ReportRunUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportRunCreateOrConnectWithoutReportInput | ReportRunCreateOrConnectWithoutReportInput[]
    upsert?: ReportRunUpsertWithWhereUniqueWithoutReportInput | ReportRunUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: ReportRunCreateManyReportInputEnvelope
    set?: ReportRunWhereUniqueInput | ReportRunWhereUniqueInput[]
    disconnect?: ReportRunWhereUniqueInput | ReportRunWhereUniqueInput[]
    delete?: ReportRunWhereUniqueInput | ReportRunWhereUniqueInput[]
    connect?: ReportRunWhereUniqueInput | ReportRunWhereUniqueInput[]
    update?: ReportRunUpdateWithWhereUniqueWithoutReportInput | ReportRunUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: ReportRunUpdateManyWithWhereWithoutReportInput | ReportRunUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: ReportRunScalarWhereInput | ReportRunScalarWhereInput[]
  }

  export type ReportRunUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<ReportRunCreateWithoutReportInput, ReportRunUncheckedCreateWithoutReportInput> | ReportRunCreateWithoutReportInput[] | ReportRunUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportRunCreateOrConnectWithoutReportInput | ReportRunCreateOrConnectWithoutReportInput[]
    upsert?: ReportRunUpsertWithWhereUniqueWithoutReportInput | ReportRunUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: ReportRunCreateManyReportInputEnvelope
    set?: ReportRunWhereUniqueInput | ReportRunWhereUniqueInput[]
    disconnect?: ReportRunWhereUniqueInput | ReportRunWhereUniqueInput[]
    delete?: ReportRunWhereUniqueInput | ReportRunWhereUniqueInput[]
    connect?: ReportRunWhereUniqueInput | ReportRunWhereUniqueInput[]
    update?: ReportRunUpdateWithWhereUniqueWithoutReportInput | ReportRunUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: ReportRunUpdateManyWithWhereWithoutReportInput | ReportRunUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: ReportRunScalarWhereInput | ReportRunScalarWhereInput[]
  }

  export type ReportRunCreateexportFormatsInput = {
    set: string[]
  }

  export type ReportCreateNestedOneWithoutReportRunsInput = {
    create?: XOR<ReportCreateWithoutReportRunsInput, ReportUncheckedCreateWithoutReportRunsInput>
    connectOrCreate?: ReportCreateOrConnectWithoutReportRunsInput
    connect?: ReportWhereUniqueInput
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type ReportRunUpdateexportFormatsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ReportUpdateOneRequiredWithoutReportRunsNestedInput = {
    create?: XOR<ReportCreateWithoutReportRunsInput, ReportUncheckedCreateWithoutReportRunsInput>
    connectOrCreate?: ReportCreateOrConnectWithoutReportRunsInput
    upsert?: ReportUpsertWithoutReportRunsInput
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutReportRunsInput, ReportUpdateWithoutReportRunsInput>, ReportUncheckedUpdateWithoutReportRunsInput>
  }

  export type EmployeeEquipmentLogCreateNestedManyWithoutTimeSheetInput = {
    create?: XOR<EmployeeEquipmentLogCreateWithoutTimeSheetInput, EmployeeEquipmentLogUncheckedCreateWithoutTimeSheetInput> | EmployeeEquipmentLogCreateWithoutTimeSheetInput[] | EmployeeEquipmentLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: EmployeeEquipmentLogCreateOrConnectWithoutTimeSheetInput | EmployeeEquipmentLogCreateOrConnectWithoutTimeSheetInput[]
    createMany?: EmployeeEquipmentLogCreateManyTimeSheetInputEnvelope
    connect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
  }

  export type MaintenanceLogCreateNestedManyWithoutTimeSheetInput = {
    create?: XOR<MaintenanceLogCreateWithoutTimeSheetInput, MaintenanceLogUncheckedCreateWithoutTimeSheetInput> | MaintenanceLogCreateWithoutTimeSheetInput[] | MaintenanceLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutTimeSheetInput | MaintenanceLogCreateOrConnectWithoutTimeSheetInput[]
    createMany?: MaintenanceLogCreateManyTimeSheetInputEnvelope
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
  }

  export type TascoLogCreateNestedManyWithoutTimeSheetInput = {
    create?: XOR<TascoLogCreateWithoutTimeSheetInput, TascoLogUncheckedCreateWithoutTimeSheetInput> | TascoLogCreateWithoutTimeSheetInput[] | TascoLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: TascoLogCreateOrConnectWithoutTimeSheetInput | TascoLogCreateOrConnectWithoutTimeSheetInput[]
    createMany?: TascoLogCreateManyTimeSheetInputEnvelope
    connect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
  }

  export type CostCodeCreateNestedOneWithoutTimesheetsInput = {
    create?: XOR<CostCodeCreateWithoutTimesheetsInput, CostCodeUncheckedCreateWithoutTimesheetsInput>
    connectOrCreate?: CostCodeCreateOrConnectWithoutTimesheetsInput
    connect?: CostCodeWhereUniqueInput
  }

  export type JobsiteCreateNestedOneWithoutTimeSheetsInput = {
    create?: XOR<JobsiteCreateWithoutTimeSheetsInput, JobsiteUncheckedCreateWithoutTimeSheetsInput>
    connectOrCreate?: JobsiteCreateOrConnectWithoutTimeSheetsInput
    connect?: JobsiteWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTimeSheetsInput = {
    create?: XOR<UserCreateWithoutTimeSheetsInput, UserUncheckedCreateWithoutTimeSheetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeSheetsInput
    connect?: UserWhereUniqueInput
  }

  export type TimeSheetChangeLogCreateNestedManyWithoutTimeSheetInput = {
    create?: XOR<TimeSheetChangeLogCreateWithoutTimeSheetInput, TimeSheetChangeLogUncheckedCreateWithoutTimeSheetInput> | TimeSheetChangeLogCreateWithoutTimeSheetInput[] | TimeSheetChangeLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: TimeSheetChangeLogCreateOrConnectWithoutTimeSheetInput | TimeSheetChangeLogCreateOrConnectWithoutTimeSheetInput[]
    createMany?: TimeSheetChangeLogCreateManyTimeSheetInputEnvelope
    connect?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
  }

  export type TruckingLogCreateNestedManyWithoutTimeSheetInput = {
    create?: XOR<TruckingLogCreateWithoutTimeSheetInput, TruckingLogUncheckedCreateWithoutTimeSheetInput> | TruckingLogCreateWithoutTimeSheetInput[] | TruckingLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: TruckingLogCreateOrConnectWithoutTimeSheetInput | TruckingLogCreateOrConnectWithoutTimeSheetInput[]
    createMany?: TruckingLogCreateManyTimeSheetInputEnvelope
    connect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
  }

  export type mechanicProjectsCreateNestedManyWithoutTimeSheetInput = {
    create?: XOR<mechanicProjectsCreateWithoutTimeSheetInput, mechanicProjectsUncheckedCreateWithoutTimeSheetInput> | mechanicProjectsCreateWithoutTimeSheetInput[] | mechanicProjectsUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: mechanicProjectsCreateOrConnectWithoutTimeSheetInput | mechanicProjectsCreateOrConnectWithoutTimeSheetInput[]
    createMany?: mechanicProjectsCreateManyTimeSheetInputEnvelope
    connect?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
  }

  export type EmployeeEquipmentLogUncheckedCreateNestedManyWithoutTimeSheetInput = {
    create?: XOR<EmployeeEquipmentLogCreateWithoutTimeSheetInput, EmployeeEquipmentLogUncheckedCreateWithoutTimeSheetInput> | EmployeeEquipmentLogCreateWithoutTimeSheetInput[] | EmployeeEquipmentLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: EmployeeEquipmentLogCreateOrConnectWithoutTimeSheetInput | EmployeeEquipmentLogCreateOrConnectWithoutTimeSheetInput[]
    createMany?: EmployeeEquipmentLogCreateManyTimeSheetInputEnvelope
    connect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
  }

  export type MaintenanceLogUncheckedCreateNestedManyWithoutTimeSheetInput = {
    create?: XOR<MaintenanceLogCreateWithoutTimeSheetInput, MaintenanceLogUncheckedCreateWithoutTimeSheetInput> | MaintenanceLogCreateWithoutTimeSheetInput[] | MaintenanceLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutTimeSheetInput | MaintenanceLogCreateOrConnectWithoutTimeSheetInput[]
    createMany?: MaintenanceLogCreateManyTimeSheetInputEnvelope
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
  }

  export type TascoLogUncheckedCreateNestedManyWithoutTimeSheetInput = {
    create?: XOR<TascoLogCreateWithoutTimeSheetInput, TascoLogUncheckedCreateWithoutTimeSheetInput> | TascoLogCreateWithoutTimeSheetInput[] | TascoLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: TascoLogCreateOrConnectWithoutTimeSheetInput | TascoLogCreateOrConnectWithoutTimeSheetInput[]
    createMany?: TascoLogCreateManyTimeSheetInputEnvelope
    connect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
  }

  export type TimeSheetChangeLogUncheckedCreateNestedManyWithoutTimeSheetInput = {
    create?: XOR<TimeSheetChangeLogCreateWithoutTimeSheetInput, TimeSheetChangeLogUncheckedCreateWithoutTimeSheetInput> | TimeSheetChangeLogCreateWithoutTimeSheetInput[] | TimeSheetChangeLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: TimeSheetChangeLogCreateOrConnectWithoutTimeSheetInput | TimeSheetChangeLogCreateOrConnectWithoutTimeSheetInput[]
    createMany?: TimeSheetChangeLogCreateManyTimeSheetInputEnvelope
    connect?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
  }

  export type TruckingLogUncheckedCreateNestedManyWithoutTimeSheetInput = {
    create?: XOR<TruckingLogCreateWithoutTimeSheetInput, TruckingLogUncheckedCreateWithoutTimeSheetInput> | TruckingLogCreateWithoutTimeSheetInput[] | TruckingLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: TruckingLogCreateOrConnectWithoutTimeSheetInput | TruckingLogCreateOrConnectWithoutTimeSheetInput[]
    createMany?: TruckingLogCreateManyTimeSheetInputEnvelope
    connect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
  }

  export type mechanicProjectsUncheckedCreateNestedManyWithoutTimeSheetInput = {
    create?: XOR<mechanicProjectsCreateWithoutTimeSheetInput, mechanicProjectsUncheckedCreateWithoutTimeSheetInput> | mechanicProjectsCreateWithoutTimeSheetInput[] | mechanicProjectsUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: mechanicProjectsCreateOrConnectWithoutTimeSheetInput | mechanicProjectsCreateOrConnectWithoutTimeSheetInput[]
    createMany?: mechanicProjectsCreateManyTimeSheetInputEnvelope
    connect?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
  }

  export type EmployeeEquipmentLogUpdateManyWithoutTimeSheetNestedInput = {
    create?: XOR<EmployeeEquipmentLogCreateWithoutTimeSheetInput, EmployeeEquipmentLogUncheckedCreateWithoutTimeSheetInput> | EmployeeEquipmentLogCreateWithoutTimeSheetInput[] | EmployeeEquipmentLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: EmployeeEquipmentLogCreateOrConnectWithoutTimeSheetInput | EmployeeEquipmentLogCreateOrConnectWithoutTimeSheetInput[]
    upsert?: EmployeeEquipmentLogUpsertWithWhereUniqueWithoutTimeSheetInput | EmployeeEquipmentLogUpsertWithWhereUniqueWithoutTimeSheetInput[]
    createMany?: EmployeeEquipmentLogCreateManyTimeSheetInputEnvelope
    set?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    disconnect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    delete?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    connect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    update?: EmployeeEquipmentLogUpdateWithWhereUniqueWithoutTimeSheetInput | EmployeeEquipmentLogUpdateWithWhereUniqueWithoutTimeSheetInput[]
    updateMany?: EmployeeEquipmentLogUpdateManyWithWhereWithoutTimeSheetInput | EmployeeEquipmentLogUpdateManyWithWhereWithoutTimeSheetInput[]
    deleteMany?: EmployeeEquipmentLogScalarWhereInput | EmployeeEquipmentLogScalarWhereInput[]
  }

  export type MaintenanceLogUpdateManyWithoutTimeSheetNestedInput = {
    create?: XOR<MaintenanceLogCreateWithoutTimeSheetInput, MaintenanceLogUncheckedCreateWithoutTimeSheetInput> | MaintenanceLogCreateWithoutTimeSheetInput[] | MaintenanceLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutTimeSheetInput | MaintenanceLogCreateOrConnectWithoutTimeSheetInput[]
    upsert?: MaintenanceLogUpsertWithWhereUniqueWithoutTimeSheetInput | MaintenanceLogUpsertWithWhereUniqueWithoutTimeSheetInput[]
    createMany?: MaintenanceLogCreateManyTimeSheetInputEnvelope
    set?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    disconnect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    delete?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    update?: MaintenanceLogUpdateWithWhereUniqueWithoutTimeSheetInput | MaintenanceLogUpdateWithWhereUniqueWithoutTimeSheetInput[]
    updateMany?: MaintenanceLogUpdateManyWithWhereWithoutTimeSheetInput | MaintenanceLogUpdateManyWithWhereWithoutTimeSheetInput[]
    deleteMany?: MaintenanceLogScalarWhereInput | MaintenanceLogScalarWhereInput[]
  }

  export type TascoLogUpdateManyWithoutTimeSheetNestedInput = {
    create?: XOR<TascoLogCreateWithoutTimeSheetInput, TascoLogUncheckedCreateWithoutTimeSheetInput> | TascoLogCreateWithoutTimeSheetInput[] | TascoLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: TascoLogCreateOrConnectWithoutTimeSheetInput | TascoLogCreateOrConnectWithoutTimeSheetInput[]
    upsert?: TascoLogUpsertWithWhereUniqueWithoutTimeSheetInput | TascoLogUpsertWithWhereUniqueWithoutTimeSheetInput[]
    createMany?: TascoLogCreateManyTimeSheetInputEnvelope
    set?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    disconnect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    delete?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    connect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    update?: TascoLogUpdateWithWhereUniqueWithoutTimeSheetInput | TascoLogUpdateWithWhereUniqueWithoutTimeSheetInput[]
    updateMany?: TascoLogUpdateManyWithWhereWithoutTimeSheetInput | TascoLogUpdateManyWithWhereWithoutTimeSheetInput[]
    deleteMany?: TascoLogScalarWhereInput | TascoLogScalarWhereInput[]
  }

  export type CostCodeUpdateOneRequiredWithoutTimesheetsNestedInput = {
    create?: XOR<CostCodeCreateWithoutTimesheetsInput, CostCodeUncheckedCreateWithoutTimesheetsInput>
    connectOrCreate?: CostCodeCreateOrConnectWithoutTimesheetsInput
    upsert?: CostCodeUpsertWithoutTimesheetsInput
    connect?: CostCodeWhereUniqueInput
    update?: XOR<XOR<CostCodeUpdateToOneWithWhereWithoutTimesheetsInput, CostCodeUpdateWithoutTimesheetsInput>, CostCodeUncheckedUpdateWithoutTimesheetsInput>
  }

  export type JobsiteUpdateOneRequiredWithoutTimeSheetsNestedInput = {
    create?: XOR<JobsiteCreateWithoutTimeSheetsInput, JobsiteUncheckedCreateWithoutTimeSheetsInput>
    connectOrCreate?: JobsiteCreateOrConnectWithoutTimeSheetsInput
    upsert?: JobsiteUpsertWithoutTimeSheetsInput
    connect?: JobsiteWhereUniqueInput
    update?: XOR<XOR<JobsiteUpdateToOneWithWhereWithoutTimeSheetsInput, JobsiteUpdateWithoutTimeSheetsInput>, JobsiteUncheckedUpdateWithoutTimeSheetsInput>
  }

  export type UserUpdateOneRequiredWithoutTimeSheetsNestedInput = {
    create?: XOR<UserCreateWithoutTimeSheetsInput, UserUncheckedCreateWithoutTimeSheetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeSheetsInput
    upsert?: UserUpsertWithoutTimeSheetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTimeSheetsInput, UserUpdateWithoutTimeSheetsInput>, UserUncheckedUpdateWithoutTimeSheetsInput>
  }

  export type TimeSheetChangeLogUpdateManyWithoutTimeSheetNestedInput = {
    create?: XOR<TimeSheetChangeLogCreateWithoutTimeSheetInput, TimeSheetChangeLogUncheckedCreateWithoutTimeSheetInput> | TimeSheetChangeLogCreateWithoutTimeSheetInput[] | TimeSheetChangeLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: TimeSheetChangeLogCreateOrConnectWithoutTimeSheetInput | TimeSheetChangeLogCreateOrConnectWithoutTimeSheetInput[]
    upsert?: TimeSheetChangeLogUpsertWithWhereUniqueWithoutTimeSheetInput | TimeSheetChangeLogUpsertWithWhereUniqueWithoutTimeSheetInput[]
    createMany?: TimeSheetChangeLogCreateManyTimeSheetInputEnvelope
    set?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
    disconnect?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
    delete?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
    connect?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
    update?: TimeSheetChangeLogUpdateWithWhereUniqueWithoutTimeSheetInput | TimeSheetChangeLogUpdateWithWhereUniqueWithoutTimeSheetInput[]
    updateMany?: TimeSheetChangeLogUpdateManyWithWhereWithoutTimeSheetInput | TimeSheetChangeLogUpdateManyWithWhereWithoutTimeSheetInput[]
    deleteMany?: TimeSheetChangeLogScalarWhereInput | TimeSheetChangeLogScalarWhereInput[]
  }

  export type TruckingLogUpdateManyWithoutTimeSheetNestedInput = {
    create?: XOR<TruckingLogCreateWithoutTimeSheetInput, TruckingLogUncheckedCreateWithoutTimeSheetInput> | TruckingLogCreateWithoutTimeSheetInput[] | TruckingLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: TruckingLogCreateOrConnectWithoutTimeSheetInput | TruckingLogCreateOrConnectWithoutTimeSheetInput[]
    upsert?: TruckingLogUpsertWithWhereUniqueWithoutTimeSheetInput | TruckingLogUpsertWithWhereUniqueWithoutTimeSheetInput[]
    createMany?: TruckingLogCreateManyTimeSheetInputEnvelope
    set?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    disconnect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    delete?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    connect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    update?: TruckingLogUpdateWithWhereUniqueWithoutTimeSheetInput | TruckingLogUpdateWithWhereUniqueWithoutTimeSheetInput[]
    updateMany?: TruckingLogUpdateManyWithWhereWithoutTimeSheetInput | TruckingLogUpdateManyWithWhereWithoutTimeSheetInput[]
    deleteMany?: TruckingLogScalarWhereInput | TruckingLogScalarWhereInput[]
  }

  export type mechanicProjectsUpdateManyWithoutTimeSheetNestedInput = {
    create?: XOR<mechanicProjectsCreateWithoutTimeSheetInput, mechanicProjectsUncheckedCreateWithoutTimeSheetInput> | mechanicProjectsCreateWithoutTimeSheetInput[] | mechanicProjectsUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: mechanicProjectsCreateOrConnectWithoutTimeSheetInput | mechanicProjectsCreateOrConnectWithoutTimeSheetInput[]
    upsert?: mechanicProjectsUpsertWithWhereUniqueWithoutTimeSheetInput | mechanicProjectsUpsertWithWhereUniqueWithoutTimeSheetInput[]
    createMany?: mechanicProjectsCreateManyTimeSheetInputEnvelope
    set?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
    disconnect?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
    delete?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
    connect?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
    update?: mechanicProjectsUpdateWithWhereUniqueWithoutTimeSheetInput | mechanicProjectsUpdateWithWhereUniqueWithoutTimeSheetInput[]
    updateMany?: mechanicProjectsUpdateManyWithWhereWithoutTimeSheetInput | mechanicProjectsUpdateManyWithWhereWithoutTimeSheetInput[]
    deleteMany?: mechanicProjectsScalarWhereInput | mechanicProjectsScalarWhereInput[]
  }

  export type EmployeeEquipmentLogUncheckedUpdateManyWithoutTimeSheetNestedInput = {
    create?: XOR<EmployeeEquipmentLogCreateWithoutTimeSheetInput, EmployeeEquipmentLogUncheckedCreateWithoutTimeSheetInput> | EmployeeEquipmentLogCreateWithoutTimeSheetInput[] | EmployeeEquipmentLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: EmployeeEquipmentLogCreateOrConnectWithoutTimeSheetInput | EmployeeEquipmentLogCreateOrConnectWithoutTimeSheetInput[]
    upsert?: EmployeeEquipmentLogUpsertWithWhereUniqueWithoutTimeSheetInput | EmployeeEquipmentLogUpsertWithWhereUniqueWithoutTimeSheetInput[]
    createMany?: EmployeeEquipmentLogCreateManyTimeSheetInputEnvelope
    set?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    disconnect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    delete?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    connect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    update?: EmployeeEquipmentLogUpdateWithWhereUniqueWithoutTimeSheetInput | EmployeeEquipmentLogUpdateWithWhereUniqueWithoutTimeSheetInput[]
    updateMany?: EmployeeEquipmentLogUpdateManyWithWhereWithoutTimeSheetInput | EmployeeEquipmentLogUpdateManyWithWhereWithoutTimeSheetInput[]
    deleteMany?: EmployeeEquipmentLogScalarWhereInput | EmployeeEquipmentLogScalarWhereInput[]
  }

  export type MaintenanceLogUncheckedUpdateManyWithoutTimeSheetNestedInput = {
    create?: XOR<MaintenanceLogCreateWithoutTimeSheetInput, MaintenanceLogUncheckedCreateWithoutTimeSheetInput> | MaintenanceLogCreateWithoutTimeSheetInput[] | MaintenanceLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutTimeSheetInput | MaintenanceLogCreateOrConnectWithoutTimeSheetInput[]
    upsert?: MaintenanceLogUpsertWithWhereUniqueWithoutTimeSheetInput | MaintenanceLogUpsertWithWhereUniqueWithoutTimeSheetInput[]
    createMany?: MaintenanceLogCreateManyTimeSheetInputEnvelope
    set?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    disconnect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    delete?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    update?: MaintenanceLogUpdateWithWhereUniqueWithoutTimeSheetInput | MaintenanceLogUpdateWithWhereUniqueWithoutTimeSheetInput[]
    updateMany?: MaintenanceLogUpdateManyWithWhereWithoutTimeSheetInput | MaintenanceLogUpdateManyWithWhereWithoutTimeSheetInput[]
    deleteMany?: MaintenanceLogScalarWhereInput | MaintenanceLogScalarWhereInput[]
  }

  export type TascoLogUncheckedUpdateManyWithoutTimeSheetNestedInput = {
    create?: XOR<TascoLogCreateWithoutTimeSheetInput, TascoLogUncheckedCreateWithoutTimeSheetInput> | TascoLogCreateWithoutTimeSheetInput[] | TascoLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: TascoLogCreateOrConnectWithoutTimeSheetInput | TascoLogCreateOrConnectWithoutTimeSheetInput[]
    upsert?: TascoLogUpsertWithWhereUniqueWithoutTimeSheetInput | TascoLogUpsertWithWhereUniqueWithoutTimeSheetInput[]
    createMany?: TascoLogCreateManyTimeSheetInputEnvelope
    set?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    disconnect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    delete?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    connect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    update?: TascoLogUpdateWithWhereUniqueWithoutTimeSheetInput | TascoLogUpdateWithWhereUniqueWithoutTimeSheetInput[]
    updateMany?: TascoLogUpdateManyWithWhereWithoutTimeSheetInput | TascoLogUpdateManyWithWhereWithoutTimeSheetInput[]
    deleteMany?: TascoLogScalarWhereInput | TascoLogScalarWhereInput[]
  }

  export type TimeSheetChangeLogUncheckedUpdateManyWithoutTimeSheetNestedInput = {
    create?: XOR<TimeSheetChangeLogCreateWithoutTimeSheetInput, TimeSheetChangeLogUncheckedCreateWithoutTimeSheetInput> | TimeSheetChangeLogCreateWithoutTimeSheetInput[] | TimeSheetChangeLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: TimeSheetChangeLogCreateOrConnectWithoutTimeSheetInput | TimeSheetChangeLogCreateOrConnectWithoutTimeSheetInput[]
    upsert?: TimeSheetChangeLogUpsertWithWhereUniqueWithoutTimeSheetInput | TimeSheetChangeLogUpsertWithWhereUniqueWithoutTimeSheetInput[]
    createMany?: TimeSheetChangeLogCreateManyTimeSheetInputEnvelope
    set?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
    disconnect?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
    delete?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
    connect?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
    update?: TimeSheetChangeLogUpdateWithWhereUniqueWithoutTimeSheetInput | TimeSheetChangeLogUpdateWithWhereUniqueWithoutTimeSheetInput[]
    updateMany?: TimeSheetChangeLogUpdateManyWithWhereWithoutTimeSheetInput | TimeSheetChangeLogUpdateManyWithWhereWithoutTimeSheetInput[]
    deleteMany?: TimeSheetChangeLogScalarWhereInput | TimeSheetChangeLogScalarWhereInput[]
  }

  export type TruckingLogUncheckedUpdateManyWithoutTimeSheetNestedInput = {
    create?: XOR<TruckingLogCreateWithoutTimeSheetInput, TruckingLogUncheckedCreateWithoutTimeSheetInput> | TruckingLogCreateWithoutTimeSheetInput[] | TruckingLogUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: TruckingLogCreateOrConnectWithoutTimeSheetInput | TruckingLogCreateOrConnectWithoutTimeSheetInput[]
    upsert?: TruckingLogUpsertWithWhereUniqueWithoutTimeSheetInput | TruckingLogUpsertWithWhereUniqueWithoutTimeSheetInput[]
    createMany?: TruckingLogCreateManyTimeSheetInputEnvelope
    set?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    disconnect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    delete?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    connect?: TruckingLogWhereUniqueInput | TruckingLogWhereUniqueInput[]
    update?: TruckingLogUpdateWithWhereUniqueWithoutTimeSheetInput | TruckingLogUpdateWithWhereUniqueWithoutTimeSheetInput[]
    updateMany?: TruckingLogUpdateManyWithWhereWithoutTimeSheetInput | TruckingLogUpdateManyWithWhereWithoutTimeSheetInput[]
    deleteMany?: TruckingLogScalarWhereInput | TruckingLogScalarWhereInput[]
  }

  export type mechanicProjectsUncheckedUpdateManyWithoutTimeSheetNestedInput = {
    create?: XOR<mechanicProjectsCreateWithoutTimeSheetInput, mechanicProjectsUncheckedCreateWithoutTimeSheetInput> | mechanicProjectsCreateWithoutTimeSheetInput[] | mechanicProjectsUncheckedCreateWithoutTimeSheetInput[]
    connectOrCreate?: mechanicProjectsCreateOrConnectWithoutTimeSheetInput | mechanicProjectsCreateOrConnectWithoutTimeSheetInput[]
    upsert?: mechanicProjectsUpsertWithWhereUniqueWithoutTimeSheetInput | mechanicProjectsUpsertWithWhereUniqueWithoutTimeSheetInput[]
    createMany?: mechanicProjectsCreateManyTimeSheetInputEnvelope
    set?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
    disconnect?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
    delete?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
    connect?: mechanicProjectsWhereUniqueInput | mechanicProjectsWhereUniqueInput[]
    update?: mechanicProjectsUpdateWithWhereUniqueWithoutTimeSheetInput | mechanicProjectsUpdateWithWhereUniqueWithoutTimeSheetInput[]
    updateMany?: mechanicProjectsUpdateManyWithWhereWithoutTimeSheetInput | mechanicProjectsUpdateManyWithWhereWithoutTimeSheetInput[]
    deleteMany?: mechanicProjectsScalarWhereInput | mechanicProjectsScalarWhereInput[]
  }

  export type EquipmentCreateNestedOneWithoutMaintenanceInput = {
    create?: XOR<EquipmentCreateWithoutMaintenanceInput, EquipmentUncheckedCreateWithoutMaintenanceInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutMaintenanceInput
    connect?: EquipmentWhereUniqueInput
  }

  export type TimeSheetCreateNestedOneWithoutMaintenanceInput = {
    create?: XOR<TimeSheetCreateWithoutMaintenanceInput, TimeSheetUncheckedCreateWithoutMaintenanceInput>
    connectOrCreate?: TimeSheetCreateOrConnectWithoutMaintenanceInput
    connect?: TimeSheetWhereUniqueInput
  }

  export type EquipmentUpdateOneRequiredWithoutMaintenanceNestedInput = {
    create?: XOR<EquipmentCreateWithoutMaintenanceInput, EquipmentUncheckedCreateWithoutMaintenanceInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutMaintenanceInput
    upsert?: EquipmentUpsertWithoutMaintenanceInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutMaintenanceInput, EquipmentUpdateWithoutMaintenanceInput>, EquipmentUncheckedUpdateWithoutMaintenanceInput>
  }

  export type TimeSheetUpdateOneRequiredWithoutMaintenanceNestedInput = {
    create?: XOR<TimeSheetCreateWithoutMaintenanceInput, TimeSheetUncheckedCreateWithoutMaintenanceInput>
    connectOrCreate?: TimeSheetCreateOrConnectWithoutMaintenanceInput
    upsert?: TimeSheetUpsertWithoutMaintenanceInput
    connect?: TimeSheetWhereUniqueInput
    update?: XOR<XOR<TimeSheetUpdateToOneWithWhereWithoutMaintenanceInput, TimeSheetUpdateWithoutMaintenanceInput>, TimeSheetUncheckedUpdateWithoutMaintenanceInput>
  }

  export type MaintenanceCreateNestedOneWithoutMaintenanceLogsInput = {
    create?: XOR<MaintenanceCreateWithoutMaintenanceLogsInput, MaintenanceUncheckedCreateWithoutMaintenanceLogsInput>
    connectOrCreate?: MaintenanceCreateOrConnectWithoutMaintenanceLogsInput
    connect?: MaintenanceWhereUniqueInput
  }

  export type TimeSheetCreateNestedOneWithoutMaintenanceLogsInput = {
    create?: XOR<TimeSheetCreateWithoutMaintenanceLogsInput, TimeSheetUncheckedCreateWithoutMaintenanceLogsInput>
    connectOrCreate?: TimeSheetCreateOrConnectWithoutMaintenanceLogsInput
    connect?: TimeSheetWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMaintenanceLogsInput = {
    create?: XOR<UserCreateWithoutMaintenanceLogsInput, UserUncheckedCreateWithoutMaintenanceLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMaintenanceLogsInput
    connect?: UserWhereUniqueInput
  }

  export type MaintenanceUpdateOneRequiredWithoutMaintenanceLogsNestedInput = {
    create?: XOR<MaintenanceCreateWithoutMaintenanceLogsInput, MaintenanceUncheckedCreateWithoutMaintenanceLogsInput>
    connectOrCreate?: MaintenanceCreateOrConnectWithoutMaintenanceLogsInput
    upsert?: MaintenanceUpsertWithoutMaintenanceLogsInput
    connect?: MaintenanceWhereUniqueInput
    update?: XOR<XOR<MaintenanceUpdateToOneWithWhereWithoutMaintenanceLogsInput, MaintenanceUpdateWithoutMaintenanceLogsInput>, MaintenanceUncheckedUpdateWithoutMaintenanceLogsInput>
  }

  export type TimeSheetUpdateOneRequiredWithoutMaintenanceLogsNestedInput = {
    create?: XOR<TimeSheetCreateWithoutMaintenanceLogsInput, TimeSheetUncheckedCreateWithoutMaintenanceLogsInput>
    connectOrCreate?: TimeSheetCreateOrConnectWithoutMaintenanceLogsInput
    upsert?: TimeSheetUpsertWithoutMaintenanceLogsInput
    connect?: TimeSheetWhereUniqueInput
    update?: XOR<XOR<TimeSheetUpdateToOneWithWhereWithoutMaintenanceLogsInput, TimeSheetUpdateWithoutMaintenanceLogsInput>, TimeSheetUncheckedUpdateWithoutMaintenanceLogsInput>
  }

  export type UserUpdateOneRequiredWithoutMaintenanceLogsNestedInput = {
    create?: XOR<UserCreateWithoutMaintenanceLogsInput, UserUncheckedCreateWithoutMaintenanceLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMaintenanceLogsInput
    upsert?: UserUpsertWithoutMaintenanceLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMaintenanceLogsInput, UserUpdateWithoutMaintenanceLogsInput>, UserUncheckedUpdateWithoutMaintenanceLogsInput>
  }

  export type EmployeeEquipmentLogCreateNestedManyWithoutMaintenanceInput = {
    create?: XOR<EmployeeEquipmentLogCreateWithoutMaintenanceInput, EmployeeEquipmentLogUncheckedCreateWithoutMaintenanceInput> | EmployeeEquipmentLogCreateWithoutMaintenanceInput[] | EmployeeEquipmentLogUncheckedCreateWithoutMaintenanceInput[]
    connectOrCreate?: EmployeeEquipmentLogCreateOrConnectWithoutMaintenanceInput | EmployeeEquipmentLogCreateOrConnectWithoutMaintenanceInput[]
    createMany?: EmployeeEquipmentLogCreateManyMaintenanceInputEnvelope
    connect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
  }

  export type EquipmentCreateNestedOneWithoutMaintenancesInput = {
    create?: XOR<EquipmentCreateWithoutMaintenancesInput, EquipmentUncheckedCreateWithoutMaintenancesInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutMaintenancesInput
    connect?: EquipmentWhereUniqueInput
  }

  export type MaintenanceLogCreateNestedManyWithoutMaintenanceInput = {
    create?: XOR<MaintenanceLogCreateWithoutMaintenanceInput, MaintenanceLogUncheckedCreateWithoutMaintenanceInput> | MaintenanceLogCreateWithoutMaintenanceInput[] | MaintenanceLogUncheckedCreateWithoutMaintenanceInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutMaintenanceInput | MaintenanceLogCreateOrConnectWithoutMaintenanceInput[]
    createMany?: MaintenanceLogCreateManyMaintenanceInputEnvelope
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
  }

  export type EmployeeEquipmentLogUncheckedCreateNestedManyWithoutMaintenanceInput = {
    create?: XOR<EmployeeEquipmentLogCreateWithoutMaintenanceInput, EmployeeEquipmentLogUncheckedCreateWithoutMaintenanceInput> | EmployeeEquipmentLogCreateWithoutMaintenanceInput[] | EmployeeEquipmentLogUncheckedCreateWithoutMaintenanceInput[]
    connectOrCreate?: EmployeeEquipmentLogCreateOrConnectWithoutMaintenanceInput | EmployeeEquipmentLogCreateOrConnectWithoutMaintenanceInput[]
    createMany?: EmployeeEquipmentLogCreateManyMaintenanceInputEnvelope
    connect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
  }

  export type MaintenanceLogUncheckedCreateNestedManyWithoutMaintenanceInput = {
    create?: XOR<MaintenanceLogCreateWithoutMaintenanceInput, MaintenanceLogUncheckedCreateWithoutMaintenanceInput> | MaintenanceLogCreateWithoutMaintenanceInput[] | MaintenanceLogUncheckedCreateWithoutMaintenanceInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutMaintenanceInput | MaintenanceLogCreateOrConnectWithoutMaintenanceInput[]
    createMany?: MaintenanceLogCreateManyMaintenanceInputEnvelope
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type EmployeeEquipmentLogUpdateManyWithoutMaintenanceNestedInput = {
    create?: XOR<EmployeeEquipmentLogCreateWithoutMaintenanceInput, EmployeeEquipmentLogUncheckedCreateWithoutMaintenanceInput> | EmployeeEquipmentLogCreateWithoutMaintenanceInput[] | EmployeeEquipmentLogUncheckedCreateWithoutMaintenanceInput[]
    connectOrCreate?: EmployeeEquipmentLogCreateOrConnectWithoutMaintenanceInput | EmployeeEquipmentLogCreateOrConnectWithoutMaintenanceInput[]
    upsert?: EmployeeEquipmentLogUpsertWithWhereUniqueWithoutMaintenanceInput | EmployeeEquipmentLogUpsertWithWhereUniqueWithoutMaintenanceInput[]
    createMany?: EmployeeEquipmentLogCreateManyMaintenanceInputEnvelope
    set?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    disconnect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    delete?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    connect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    update?: EmployeeEquipmentLogUpdateWithWhereUniqueWithoutMaintenanceInput | EmployeeEquipmentLogUpdateWithWhereUniqueWithoutMaintenanceInput[]
    updateMany?: EmployeeEquipmentLogUpdateManyWithWhereWithoutMaintenanceInput | EmployeeEquipmentLogUpdateManyWithWhereWithoutMaintenanceInput[]
    deleteMany?: EmployeeEquipmentLogScalarWhereInput | EmployeeEquipmentLogScalarWhereInput[]
  }

  export type EquipmentUpdateOneRequiredWithoutMaintenancesNestedInput = {
    create?: XOR<EquipmentCreateWithoutMaintenancesInput, EquipmentUncheckedCreateWithoutMaintenancesInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutMaintenancesInput
    upsert?: EquipmentUpsertWithoutMaintenancesInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutMaintenancesInput, EquipmentUpdateWithoutMaintenancesInput>, EquipmentUncheckedUpdateWithoutMaintenancesInput>
  }

  export type MaintenanceLogUpdateManyWithoutMaintenanceNestedInput = {
    create?: XOR<MaintenanceLogCreateWithoutMaintenanceInput, MaintenanceLogUncheckedCreateWithoutMaintenanceInput> | MaintenanceLogCreateWithoutMaintenanceInput[] | MaintenanceLogUncheckedCreateWithoutMaintenanceInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutMaintenanceInput | MaintenanceLogCreateOrConnectWithoutMaintenanceInput[]
    upsert?: MaintenanceLogUpsertWithWhereUniqueWithoutMaintenanceInput | MaintenanceLogUpsertWithWhereUniqueWithoutMaintenanceInput[]
    createMany?: MaintenanceLogCreateManyMaintenanceInputEnvelope
    set?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    disconnect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    delete?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    update?: MaintenanceLogUpdateWithWhereUniqueWithoutMaintenanceInput | MaintenanceLogUpdateWithWhereUniqueWithoutMaintenanceInput[]
    updateMany?: MaintenanceLogUpdateManyWithWhereWithoutMaintenanceInput | MaintenanceLogUpdateManyWithWhereWithoutMaintenanceInput[]
    deleteMany?: MaintenanceLogScalarWhereInput | MaintenanceLogScalarWhereInput[]
  }

  export type EmployeeEquipmentLogUncheckedUpdateManyWithoutMaintenanceNestedInput = {
    create?: XOR<EmployeeEquipmentLogCreateWithoutMaintenanceInput, EmployeeEquipmentLogUncheckedCreateWithoutMaintenanceInput> | EmployeeEquipmentLogCreateWithoutMaintenanceInput[] | EmployeeEquipmentLogUncheckedCreateWithoutMaintenanceInput[]
    connectOrCreate?: EmployeeEquipmentLogCreateOrConnectWithoutMaintenanceInput | EmployeeEquipmentLogCreateOrConnectWithoutMaintenanceInput[]
    upsert?: EmployeeEquipmentLogUpsertWithWhereUniqueWithoutMaintenanceInput | EmployeeEquipmentLogUpsertWithWhereUniqueWithoutMaintenanceInput[]
    createMany?: EmployeeEquipmentLogCreateManyMaintenanceInputEnvelope
    set?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    disconnect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    delete?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    connect?: EmployeeEquipmentLogWhereUniqueInput | EmployeeEquipmentLogWhereUniqueInput[]
    update?: EmployeeEquipmentLogUpdateWithWhereUniqueWithoutMaintenanceInput | EmployeeEquipmentLogUpdateWithWhereUniqueWithoutMaintenanceInput[]
    updateMany?: EmployeeEquipmentLogUpdateManyWithWhereWithoutMaintenanceInput | EmployeeEquipmentLogUpdateManyWithWhereWithoutMaintenanceInput[]
    deleteMany?: EmployeeEquipmentLogScalarWhereInput | EmployeeEquipmentLogScalarWhereInput[]
  }

  export type MaintenanceLogUncheckedUpdateManyWithoutMaintenanceNestedInput = {
    create?: XOR<MaintenanceLogCreateWithoutMaintenanceInput, MaintenanceLogUncheckedCreateWithoutMaintenanceInput> | MaintenanceLogCreateWithoutMaintenanceInput[] | MaintenanceLogUncheckedCreateWithoutMaintenanceInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutMaintenanceInput | MaintenanceLogCreateOrConnectWithoutMaintenanceInput[]
    upsert?: MaintenanceLogUpsertWithWhereUniqueWithoutMaintenanceInput | MaintenanceLogUpsertWithWhereUniqueWithoutMaintenanceInput[]
    createMany?: MaintenanceLogCreateManyMaintenanceInputEnvelope
    set?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    disconnect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    delete?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    update?: MaintenanceLogUpdateWithWhereUniqueWithoutMaintenanceInput | MaintenanceLogUpdateWithWhereUniqueWithoutMaintenanceInput[]
    updateMany?: MaintenanceLogUpdateManyWithWhereWithoutMaintenanceInput | MaintenanceLogUpdateManyWithWhereWithoutMaintenanceInput[]
    deleteMany?: MaintenanceLogScalarWhereInput | MaintenanceLogScalarWhereInput[]
  }

  export type RefuelLogCreateNestedManyWithoutTascoLogInput = {
    create?: XOR<RefuelLogCreateWithoutTascoLogInput, RefuelLogUncheckedCreateWithoutTascoLogInput> | RefuelLogCreateWithoutTascoLogInput[] | RefuelLogUncheckedCreateWithoutTascoLogInput[]
    connectOrCreate?: RefuelLogCreateOrConnectWithoutTascoLogInput | RefuelLogCreateOrConnectWithoutTascoLogInput[]
    createMany?: RefuelLogCreateManyTascoLogInputEnvelope
    connect?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
  }

  export type TascoFLoadsCreateNestedManyWithoutTascoLogInput = {
    create?: XOR<TascoFLoadsCreateWithoutTascoLogInput, TascoFLoadsUncheckedCreateWithoutTascoLogInput> | TascoFLoadsCreateWithoutTascoLogInput[] | TascoFLoadsUncheckedCreateWithoutTascoLogInput[]
    connectOrCreate?: TascoFLoadsCreateOrConnectWithoutTascoLogInput | TascoFLoadsCreateOrConnectWithoutTascoLogInput[]
    createMany?: TascoFLoadsCreateManyTascoLogInputEnvelope
    connect?: TascoFLoadsWhereUniqueInput | TascoFLoadsWhereUniqueInput[]
  }

  export type EquipmentCreateNestedOneWithoutTascoLogsInput = {
    create?: XOR<EquipmentCreateWithoutTascoLogsInput, EquipmentUncheckedCreateWithoutTascoLogsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutTascoLogsInput
    connect?: EquipmentWhereUniqueInput
  }

  export type TascoMaterialTypesCreateNestedOneWithoutTascoLogInput = {
    create?: XOR<TascoMaterialTypesCreateWithoutTascoLogInput, TascoMaterialTypesUncheckedCreateWithoutTascoLogInput>
    connectOrCreate?: TascoMaterialTypesCreateOrConnectWithoutTascoLogInput
    connect?: TascoMaterialTypesWhereUniqueInput
  }

  export type TimeSheetCreateNestedOneWithoutTascoLogsInput = {
    create?: XOR<TimeSheetCreateWithoutTascoLogsInput, TimeSheetUncheckedCreateWithoutTascoLogsInput>
    connectOrCreate?: TimeSheetCreateOrConnectWithoutTascoLogsInput
    connect?: TimeSheetWhereUniqueInput
  }

  export type RefuelLogUncheckedCreateNestedManyWithoutTascoLogInput = {
    create?: XOR<RefuelLogCreateWithoutTascoLogInput, RefuelLogUncheckedCreateWithoutTascoLogInput> | RefuelLogCreateWithoutTascoLogInput[] | RefuelLogUncheckedCreateWithoutTascoLogInput[]
    connectOrCreate?: RefuelLogCreateOrConnectWithoutTascoLogInput | RefuelLogCreateOrConnectWithoutTascoLogInput[]
    createMany?: RefuelLogCreateManyTascoLogInputEnvelope
    connect?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
  }

  export type TascoFLoadsUncheckedCreateNestedManyWithoutTascoLogInput = {
    create?: XOR<TascoFLoadsCreateWithoutTascoLogInput, TascoFLoadsUncheckedCreateWithoutTascoLogInput> | TascoFLoadsCreateWithoutTascoLogInput[] | TascoFLoadsUncheckedCreateWithoutTascoLogInput[]
    connectOrCreate?: TascoFLoadsCreateOrConnectWithoutTascoLogInput | TascoFLoadsCreateOrConnectWithoutTascoLogInput[]
    createMany?: TascoFLoadsCreateManyTascoLogInputEnvelope
    connect?: TascoFLoadsWhereUniqueInput | TascoFLoadsWhereUniqueInput[]
  }

  export type NullableEnumLoadTypeFieldUpdateOperationsInput = {
    set?: $Enums.LoadType | null
  }

  export type RefuelLogUpdateManyWithoutTascoLogNestedInput = {
    create?: XOR<RefuelLogCreateWithoutTascoLogInput, RefuelLogUncheckedCreateWithoutTascoLogInput> | RefuelLogCreateWithoutTascoLogInput[] | RefuelLogUncheckedCreateWithoutTascoLogInput[]
    connectOrCreate?: RefuelLogCreateOrConnectWithoutTascoLogInput | RefuelLogCreateOrConnectWithoutTascoLogInput[]
    upsert?: RefuelLogUpsertWithWhereUniqueWithoutTascoLogInput | RefuelLogUpsertWithWhereUniqueWithoutTascoLogInput[]
    createMany?: RefuelLogCreateManyTascoLogInputEnvelope
    set?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
    disconnect?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
    delete?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
    connect?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
    update?: RefuelLogUpdateWithWhereUniqueWithoutTascoLogInput | RefuelLogUpdateWithWhereUniqueWithoutTascoLogInput[]
    updateMany?: RefuelLogUpdateManyWithWhereWithoutTascoLogInput | RefuelLogUpdateManyWithWhereWithoutTascoLogInput[]
    deleteMany?: RefuelLogScalarWhereInput | RefuelLogScalarWhereInput[]
  }

  export type TascoFLoadsUpdateManyWithoutTascoLogNestedInput = {
    create?: XOR<TascoFLoadsCreateWithoutTascoLogInput, TascoFLoadsUncheckedCreateWithoutTascoLogInput> | TascoFLoadsCreateWithoutTascoLogInput[] | TascoFLoadsUncheckedCreateWithoutTascoLogInput[]
    connectOrCreate?: TascoFLoadsCreateOrConnectWithoutTascoLogInput | TascoFLoadsCreateOrConnectWithoutTascoLogInput[]
    upsert?: TascoFLoadsUpsertWithWhereUniqueWithoutTascoLogInput | TascoFLoadsUpsertWithWhereUniqueWithoutTascoLogInput[]
    createMany?: TascoFLoadsCreateManyTascoLogInputEnvelope
    set?: TascoFLoadsWhereUniqueInput | TascoFLoadsWhereUniqueInput[]
    disconnect?: TascoFLoadsWhereUniqueInput | TascoFLoadsWhereUniqueInput[]
    delete?: TascoFLoadsWhereUniqueInput | TascoFLoadsWhereUniqueInput[]
    connect?: TascoFLoadsWhereUniqueInput | TascoFLoadsWhereUniqueInput[]
    update?: TascoFLoadsUpdateWithWhereUniqueWithoutTascoLogInput | TascoFLoadsUpdateWithWhereUniqueWithoutTascoLogInput[]
    updateMany?: TascoFLoadsUpdateManyWithWhereWithoutTascoLogInput | TascoFLoadsUpdateManyWithWhereWithoutTascoLogInput[]
    deleteMany?: TascoFLoadsScalarWhereInput | TascoFLoadsScalarWhereInput[]
  }

  export type EquipmentUpdateOneWithoutTascoLogsNestedInput = {
    create?: XOR<EquipmentCreateWithoutTascoLogsInput, EquipmentUncheckedCreateWithoutTascoLogsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutTascoLogsInput
    upsert?: EquipmentUpsertWithoutTascoLogsInput
    disconnect?: EquipmentWhereInput | boolean
    delete?: EquipmentWhereInput | boolean
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutTascoLogsInput, EquipmentUpdateWithoutTascoLogsInput>, EquipmentUncheckedUpdateWithoutTascoLogsInput>
  }

  export type TascoMaterialTypesUpdateOneWithoutTascoLogNestedInput = {
    create?: XOR<TascoMaterialTypesCreateWithoutTascoLogInput, TascoMaterialTypesUncheckedCreateWithoutTascoLogInput>
    connectOrCreate?: TascoMaterialTypesCreateOrConnectWithoutTascoLogInput
    upsert?: TascoMaterialTypesUpsertWithoutTascoLogInput
    disconnect?: TascoMaterialTypesWhereInput | boolean
    delete?: TascoMaterialTypesWhereInput | boolean
    connect?: TascoMaterialTypesWhereUniqueInput
    update?: XOR<XOR<TascoMaterialTypesUpdateToOneWithWhereWithoutTascoLogInput, TascoMaterialTypesUpdateWithoutTascoLogInput>, TascoMaterialTypesUncheckedUpdateWithoutTascoLogInput>
  }

  export type TimeSheetUpdateOneRequiredWithoutTascoLogsNestedInput = {
    create?: XOR<TimeSheetCreateWithoutTascoLogsInput, TimeSheetUncheckedCreateWithoutTascoLogsInput>
    connectOrCreate?: TimeSheetCreateOrConnectWithoutTascoLogsInput
    upsert?: TimeSheetUpsertWithoutTascoLogsInput
    connect?: TimeSheetWhereUniqueInput
    update?: XOR<XOR<TimeSheetUpdateToOneWithWhereWithoutTascoLogsInput, TimeSheetUpdateWithoutTascoLogsInput>, TimeSheetUncheckedUpdateWithoutTascoLogsInput>
  }

  export type RefuelLogUncheckedUpdateManyWithoutTascoLogNestedInput = {
    create?: XOR<RefuelLogCreateWithoutTascoLogInput, RefuelLogUncheckedCreateWithoutTascoLogInput> | RefuelLogCreateWithoutTascoLogInput[] | RefuelLogUncheckedCreateWithoutTascoLogInput[]
    connectOrCreate?: RefuelLogCreateOrConnectWithoutTascoLogInput | RefuelLogCreateOrConnectWithoutTascoLogInput[]
    upsert?: RefuelLogUpsertWithWhereUniqueWithoutTascoLogInput | RefuelLogUpsertWithWhereUniqueWithoutTascoLogInput[]
    createMany?: RefuelLogCreateManyTascoLogInputEnvelope
    set?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
    disconnect?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
    delete?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
    connect?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
    update?: RefuelLogUpdateWithWhereUniqueWithoutTascoLogInput | RefuelLogUpdateWithWhereUniqueWithoutTascoLogInput[]
    updateMany?: RefuelLogUpdateManyWithWhereWithoutTascoLogInput | RefuelLogUpdateManyWithWhereWithoutTascoLogInput[]
    deleteMany?: RefuelLogScalarWhereInput | RefuelLogScalarWhereInput[]
  }

  export type TascoFLoadsUncheckedUpdateManyWithoutTascoLogNestedInput = {
    create?: XOR<TascoFLoadsCreateWithoutTascoLogInput, TascoFLoadsUncheckedCreateWithoutTascoLogInput> | TascoFLoadsCreateWithoutTascoLogInput[] | TascoFLoadsUncheckedCreateWithoutTascoLogInput[]
    connectOrCreate?: TascoFLoadsCreateOrConnectWithoutTascoLogInput | TascoFLoadsCreateOrConnectWithoutTascoLogInput[]
    upsert?: TascoFLoadsUpsertWithWhereUniqueWithoutTascoLogInput | TascoFLoadsUpsertWithWhereUniqueWithoutTascoLogInput[]
    createMany?: TascoFLoadsCreateManyTascoLogInputEnvelope
    set?: TascoFLoadsWhereUniqueInput | TascoFLoadsWhereUniqueInput[]
    disconnect?: TascoFLoadsWhereUniqueInput | TascoFLoadsWhereUniqueInput[]
    delete?: TascoFLoadsWhereUniqueInput | TascoFLoadsWhereUniqueInput[]
    connect?: TascoFLoadsWhereUniqueInput | TascoFLoadsWhereUniqueInput[]
    update?: TascoFLoadsUpdateWithWhereUniqueWithoutTascoLogInput | TascoFLoadsUpdateWithWhereUniqueWithoutTascoLogInput[]
    updateMany?: TascoFLoadsUpdateManyWithWhereWithoutTascoLogInput | TascoFLoadsUpdateManyWithWhereWithoutTascoLogInput[]
    deleteMany?: TascoFLoadsScalarWhereInput | TascoFLoadsScalarWhereInput[]
  }

  export type TascoLogCreateNestedOneWithoutTascoFLoadsInput = {
    create?: XOR<TascoLogCreateWithoutTascoFLoadsInput, TascoLogUncheckedCreateWithoutTascoFLoadsInput>
    connectOrCreate?: TascoLogCreateOrConnectWithoutTascoFLoadsInput
    connect?: TascoLogWhereUniqueInput
  }

  export type TascoLogUpdateOneRequiredWithoutTascoFLoadsNestedInput = {
    create?: XOR<TascoLogCreateWithoutTascoFLoadsInput, TascoLogUncheckedCreateWithoutTascoFLoadsInput>
    connectOrCreate?: TascoLogCreateOrConnectWithoutTascoFLoadsInput
    upsert?: TascoLogUpsertWithoutTascoFLoadsInput
    connect?: TascoLogWhereUniqueInput
    update?: XOR<XOR<TascoLogUpdateToOneWithWhereWithoutTascoFLoadsInput, TascoLogUpdateWithoutTascoFLoadsInput>, TascoLogUncheckedUpdateWithoutTascoFLoadsInput>
  }

  export type TascoLogCreateNestedManyWithoutTascoMaterialTypesInput = {
    create?: XOR<TascoLogCreateWithoutTascoMaterialTypesInput, TascoLogUncheckedCreateWithoutTascoMaterialTypesInput> | TascoLogCreateWithoutTascoMaterialTypesInput[] | TascoLogUncheckedCreateWithoutTascoMaterialTypesInput[]
    connectOrCreate?: TascoLogCreateOrConnectWithoutTascoMaterialTypesInput | TascoLogCreateOrConnectWithoutTascoMaterialTypesInput[]
    createMany?: TascoLogCreateManyTascoMaterialTypesInputEnvelope
    connect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
  }

  export type TascoLogUncheckedCreateNestedManyWithoutTascoMaterialTypesInput = {
    create?: XOR<TascoLogCreateWithoutTascoMaterialTypesInput, TascoLogUncheckedCreateWithoutTascoMaterialTypesInput> | TascoLogCreateWithoutTascoMaterialTypesInput[] | TascoLogUncheckedCreateWithoutTascoMaterialTypesInput[]
    connectOrCreate?: TascoLogCreateOrConnectWithoutTascoMaterialTypesInput | TascoLogCreateOrConnectWithoutTascoMaterialTypesInput[]
    createMany?: TascoLogCreateManyTascoMaterialTypesInputEnvelope
    connect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
  }

  export type TascoLogUpdateManyWithoutTascoMaterialTypesNestedInput = {
    create?: XOR<TascoLogCreateWithoutTascoMaterialTypesInput, TascoLogUncheckedCreateWithoutTascoMaterialTypesInput> | TascoLogCreateWithoutTascoMaterialTypesInput[] | TascoLogUncheckedCreateWithoutTascoMaterialTypesInput[]
    connectOrCreate?: TascoLogCreateOrConnectWithoutTascoMaterialTypesInput | TascoLogCreateOrConnectWithoutTascoMaterialTypesInput[]
    upsert?: TascoLogUpsertWithWhereUniqueWithoutTascoMaterialTypesInput | TascoLogUpsertWithWhereUniqueWithoutTascoMaterialTypesInput[]
    createMany?: TascoLogCreateManyTascoMaterialTypesInputEnvelope
    set?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    disconnect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    delete?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    connect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    update?: TascoLogUpdateWithWhereUniqueWithoutTascoMaterialTypesInput | TascoLogUpdateWithWhereUniqueWithoutTascoMaterialTypesInput[]
    updateMany?: TascoLogUpdateManyWithWhereWithoutTascoMaterialTypesInput | TascoLogUpdateManyWithWhereWithoutTascoMaterialTypesInput[]
    deleteMany?: TascoLogScalarWhereInput | TascoLogScalarWhereInput[]
  }

  export type TascoLogUncheckedUpdateManyWithoutTascoMaterialTypesNestedInput = {
    create?: XOR<TascoLogCreateWithoutTascoMaterialTypesInput, TascoLogUncheckedCreateWithoutTascoMaterialTypesInput> | TascoLogCreateWithoutTascoMaterialTypesInput[] | TascoLogUncheckedCreateWithoutTascoMaterialTypesInput[]
    connectOrCreate?: TascoLogCreateOrConnectWithoutTascoMaterialTypesInput | TascoLogCreateOrConnectWithoutTascoMaterialTypesInput[]
    upsert?: TascoLogUpsertWithWhereUniqueWithoutTascoMaterialTypesInput | TascoLogUpsertWithWhereUniqueWithoutTascoMaterialTypesInput[]
    createMany?: TascoLogCreateManyTascoMaterialTypesInputEnvelope
    set?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    disconnect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    delete?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    connect?: TascoLogWhereUniqueInput | TascoLogWhereUniqueInput[]
    update?: TascoLogUpdateWithWhereUniqueWithoutTascoMaterialTypesInput | TascoLogUpdateWithWhereUniqueWithoutTascoMaterialTypesInput[]
    updateMany?: TascoLogUpdateManyWithWhereWithoutTascoMaterialTypesInput | TascoLogUpdateManyWithWhereWithoutTascoMaterialTypesInput[]
    deleteMany?: TascoLogScalarWhereInput | TascoLogScalarWhereInput[]
  }

  export type EquipmentHauledCreateNestedManyWithoutTruckingLogInput = {
    create?: XOR<EquipmentHauledCreateWithoutTruckingLogInput, EquipmentHauledUncheckedCreateWithoutTruckingLogInput> | EquipmentHauledCreateWithoutTruckingLogInput[] | EquipmentHauledUncheckedCreateWithoutTruckingLogInput[]
    connectOrCreate?: EquipmentHauledCreateOrConnectWithoutTruckingLogInput | EquipmentHauledCreateOrConnectWithoutTruckingLogInput[]
    createMany?: EquipmentHauledCreateManyTruckingLogInputEnvelope
    connect?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
  }

  export type MaterialCreateNestedManyWithoutTruckingLogInput = {
    create?: XOR<MaterialCreateWithoutTruckingLogInput, MaterialUncheckedCreateWithoutTruckingLogInput> | MaterialCreateWithoutTruckingLogInput[] | MaterialUncheckedCreateWithoutTruckingLogInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutTruckingLogInput | MaterialCreateOrConnectWithoutTruckingLogInput[]
    createMany?: MaterialCreateManyTruckingLogInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type RefuelLogCreateNestedManyWithoutTruckingLogInput = {
    create?: XOR<RefuelLogCreateWithoutTruckingLogInput, RefuelLogUncheckedCreateWithoutTruckingLogInput> | RefuelLogCreateWithoutTruckingLogInput[] | RefuelLogUncheckedCreateWithoutTruckingLogInput[]
    connectOrCreate?: RefuelLogCreateOrConnectWithoutTruckingLogInput | RefuelLogCreateOrConnectWithoutTruckingLogInput[]
    createMany?: RefuelLogCreateManyTruckingLogInputEnvelope
    connect?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
  }

  export type StateMileageCreateNestedManyWithoutTruckingLogInput = {
    create?: XOR<StateMileageCreateWithoutTruckingLogInput, StateMileageUncheckedCreateWithoutTruckingLogInput> | StateMileageCreateWithoutTruckingLogInput[] | StateMileageUncheckedCreateWithoutTruckingLogInput[]
    connectOrCreate?: StateMileageCreateOrConnectWithoutTruckingLogInput | StateMileageCreateOrConnectWithoutTruckingLogInput[]
    createMany?: StateMileageCreateManyTruckingLogInputEnvelope
    connect?: StateMileageWhereUniqueInput | StateMileageWhereUniqueInput[]
  }

  export type EquipmentCreateNestedOneWithoutHauledInLogsInput = {
    create?: XOR<EquipmentCreateWithoutHauledInLogsInput, EquipmentUncheckedCreateWithoutHauledInLogsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutHauledInLogsInput
    connect?: EquipmentWhereUniqueInput
  }

  export type TimeSheetCreateNestedOneWithoutTruckingLogsInput = {
    create?: XOR<TimeSheetCreateWithoutTruckingLogsInput, TimeSheetUncheckedCreateWithoutTruckingLogsInput>
    connectOrCreate?: TimeSheetCreateOrConnectWithoutTruckingLogsInput
    connect?: TimeSheetWhereUniqueInput
  }

  export type EquipmentCreateNestedOneWithoutUsedAsTrailerInput = {
    create?: XOR<EquipmentCreateWithoutUsedAsTrailerInput, EquipmentUncheckedCreateWithoutUsedAsTrailerInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutUsedAsTrailerInput
    connect?: EquipmentWhereUniqueInput
  }

  export type EquipmentCreateNestedOneWithoutUsedAsTruckInput = {
    create?: XOR<EquipmentCreateWithoutUsedAsTruckInput, EquipmentUncheckedCreateWithoutUsedAsTruckInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutUsedAsTruckInput
    connect?: EquipmentWhereUniqueInput
  }

  export type EquipmentHauledUncheckedCreateNestedManyWithoutTruckingLogInput = {
    create?: XOR<EquipmentHauledCreateWithoutTruckingLogInput, EquipmentHauledUncheckedCreateWithoutTruckingLogInput> | EquipmentHauledCreateWithoutTruckingLogInput[] | EquipmentHauledUncheckedCreateWithoutTruckingLogInput[]
    connectOrCreate?: EquipmentHauledCreateOrConnectWithoutTruckingLogInput | EquipmentHauledCreateOrConnectWithoutTruckingLogInput[]
    createMany?: EquipmentHauledCreateManyTruckingLogInputEnvelope
    connect?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutTruckingLogInput = {
    create?: XOR<MaterialCreateWithoutTruckingLogInput, MaterialUncheckedCreateWithoutTruckingLogInput> | MaterialCreateWithoutTruckingLogInput[] | MaterialUncheckedCreateWithoutTruckingLogInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutTruckingLogInput | MaterialCreateOrConnectWithoutTruckingLogInput[]
    createMany?: MaterialCreateManyTruckingLogInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type RefuelLogUncheckedCreateNestedManyWithoutTruckingLogInput = {
    create?: XOR<RefuelLogCreateWithoutTruckingLogInput, RefuelLogUncheckedCreateWithoutTruckingLogInput> | RefuelLogCreateWithoutTruckingLogInput[] | RefuelLogUncheckedCreateWithoutTruckingLogInput[]
    connectOrCreate?: RefuelLogCreateOrConnectWithoutTruckingLogInput | RefuelLogCreateOrConnectWithoutTruckingLogInput[]
    createMany?: RefuelLogCreateManyTruckingLogInputEnvelope
    connect?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
  }

  export type StateMileageUncheckedCreateNestedManyWithoutTruckingLogInput = {
    create?: XOR<StateMileageCreateWithoutTruckingLogInput, StateMileageUncheckedCreateWithoutTruckingLogInput> | StateMileageCreateWithoutTruckingLogInput[] | StateMileageUncheckedCreateWithoutTruckingLogInput[]
    connectOrCreate?: StateMileageCreateOrConnectWithoutTruckingLogInput | StateMileageCreateOrConnectWithoutTruckingLogInput[]
    createMany?: StateMileageCreateManyTruckingLogInputEnvelope
    connect?: StateMileageWhereUniqueInput | StateMileageWhereUniqueInput[]
  }

  export type EquipmentHauledUpdateManyWithoutTruckingLogNestedInput = {
    create?: XOR<EquipmentHauledCreateWithoutTruckingLogInput, EquipmentHauledUncheckedCreateWithoutTruckingLogInput> | EquipmentHauledCreateWithoutTruckingLogInput[] | EquipmentHauledUncheckedCreateWithoutTruckingLogInput[]
    connectOrCreate?: EquipmentHauledCreateOrConnectWithoutTruckingLogInput | EquipmentHauledCreateOrConnectWithoutTruckingLogInput[]
    upsert?: EquipmentHauledUpsertWithWhereUniqueWithoutTruckingLogInput | EquipmentHauledUpsertWithWhereUniqueWithoutTruckingLogInput[]
    createMany?: EquipmentHauledCreateManyTruckingLogInputEnvelope
    set?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
    disconnect?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
    delete?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
    connect?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
    update?: EquipmentHauledUpdateWithWhereUniqueWithoutTruckingLogInput | EquipmentHauledUpdateWithWhereUniqueWithoutTruckingLogInput[]
    updateMany?: EquipmentHauledUpdateManyWithWhereWithoutTruckingLogInput | EquipmentHauledUpdateManyWithWhereWithoutTruckingLogInput[]
    deleteMany?: EquipmentHauledScalarWhereInput | EquipmentHauledScalarWhereInput[]
  }

  export type MaterialUpdateManyWithoutTruckingLogNestedInput = {
    create?: XOR<MaterialCreateWithoutTruckingLogInput, MaterialUncheckedCreateWithoutTruckingLogInput> | MaterialCreateWithoutTruckingLogInput[] | MaterialUncheckedCreateWithoutTruckingLogInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutTruckingLogInput | MaterialCreateOrConnectWithoutTruckingLogInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutTruckingLogInput | MaterialUpsertWithWhereUniqueWithoutTruckingLogInput[]
    createMany?: MaterialCreateManyTruckingLogInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutTruckingLogInput | MaterialUpdateWithWhereUniqueWithoutTruckingLogInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutTruckingLogInput | MaterialUpdateManyWithWhereWithoutTruckingLogInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type RefuelLogUpdateManyWithoutTruckingLogNestedInput = {
    create?: XOR<RefuelLogCreateWithoutTruckingLogInput, RefuelLogUncheckedCreateWithoutTruckingLogInput> | RefuelLogCreateWithoutTruckingLogInput[] | RefuelLogUncheckedCreateWithoutTruckingLogInput[]
    connectOrCreate?: RefuelLogCreateOrConnectWithoutTruckingLogInput | RefuelLogCreateOrConnectWithoutTruckingLogInput[]
    upsert?: RefuelLogUpsertWithWhereUniqueWithoutTruckingLogInput | RefuelLogUpsertWithWhereUniqueWithoutTruckingLogInput[]
    createMany?: RefuelLogCreateManyTruckingLogInputEnvelope
    set?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
    disconnect?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
    delete?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
    connect?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
    update?: RefuelLogUpdateWithWhereUniqueWithoutTruckingLogInput | RefuelLogUpdateWithWhereUniqueWithoutTruckingLogInput[]
    updateMany?: RefuelLogUpdateManyWithWhereWithoutTruckingLogInput | RefuelLogUpdateManyWithWhereWithoutTruckingLogInput[]
    deleteMany?: RefuelLogScalarWhereInput | RefuelLogScalarWhereInput[]
  }

  export type StateMileageUpdateManyWithoutTruckingLogNestedInput = {
    create?: XOR<StateMileageCreateWithoutTruckingLogInput, StateMileageUncheckedCreateWithoutTruckingLogInput> | StateMileageCreateWithoutTruckingLogInput[] | StateMileageUncheckedCreateWithoutTruckingLogInput[]
    connectOrCreate?: StateMileageCreateOrConnectWithoutTruckingLogInput | StateMileageCreateOrConnectWithoutTruckingLogInput[]
    upsert?: StateMileageUpsertWithWhereUniqueWithoutTruckingLogInput | StateMileageUpsertWithWhereUniqueWithoutTruckingLogInput[]
    createMany?: StateMileageCreateManyTruckingLogInputEnvelope
    set?: StateMileageWhereUniqueInput | StateMileageWhereUniqueInput[]
    disconnect?: StateMileageWhereUniqueInput | StateMileageWhereUniqueInput[]
    delete?: StateMileageWhereUniqueInput | StateMileageWhereUniqueInput[]
    connect?: StateMileageWhereUniqueInput | StateMileageWhereUniqueInput[]
    update?: StateMileageUpdateWithWhereUniqueWithoutTruckingLogInput | StateMileageUpdateWithWhereUniqueWithoutTruckingLogInput[]
    updateMany?: StateMileageUpdateManyWithWhereWithoutTruckingLogInput | StateMileageUpdateManyWithWhereWithoutTruckingLogInput[]
    deleteMany?: StateMileageScalarWhereInput | StateMileageScalarWhereInput[]
  }

  export type EquipmentUpdateOneWithoutHauledInLogsNestedInput = {
    create?: XOR<EquipmentCreateWithoutHauledInLogsInput, EquipmentUncheckedCreateWithoutHauledInLogsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutHauledInLogsInput
    upsert?: EquipmentUpsertWithoutHauledInLogsInput
    disconnect?: EquipmentWhereInput | boolean
    delete?: EquipmentWhereInput | boolean
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutHauledInLogsInput, EquipmentUpdateWithoutHauledInLogsInput>, EquipmentUncheckedUpdateWithoutHauledInLogsInput>
  }

  export type TimeSheetUpdateOneRequiredWithoutTruckingLogsNestedInput = {
    create?: XOR<TimeSheetCreateWithoutTruckingLogsInput, TimeSheetUncheckedCreateWithoutTruckingLogsInput>
    connectOrCreate?: TimeSheetCreateOrConnectWithoutTruckingLogsInput
    upsert?: TimeSheetUpsertWithoutTruckingLogsInput
    connect?: TimeSheetWhereUniqueInput
    update?: XOR<XOR<TimeSheetUpdateToOneWithWhereWithoutTruckingLogsInput, TimeSheetUpdateWithoutTruckingLogsInput>, TimeSheetUncheckedUpdateWithoutTruckingLogsInput>
  }

  export type EquipmentUpdateOneWithoutUsedAsTrailerNestedInput = {
    create?: XOR<EquipmentCreateWithoutUsedAsTrailerInput, EquipmentUncheckedCreateWithoutUsedAsTrailerInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutUsedAsTrailerInput
    upsert?: EquipmentUpsertWithoutUsedAsTrailerInput
    disconnect?: EquipmentWhereInput | boolean
    delete?: EquipmentWhereInput | boolean
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutUsedAsTrailerInput, EquipmentUpdateWithoutUsedAsTrailerInput>, EquipmentUncheckedUpdateWithoutUsedAsTrailerInput>
  }

  export type EquipmentUpdateOneWithoutUsedAsTruckNestedInput = {
    create?: XOR<EquipmentCreateWithoutUsedAsTruckInput, EquipmentUncheckedCreateWithoutUsedAsTruckInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutUsedAsTruckInput
    upsert?: EquipmentUpsertWithoutUsedAsTruckInput
    disconnect?: EquipmentWhereInput | boolean
    delete?: EquipmentWhereInput | boolean
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutUsedAsTruckInput, EquipmentUpdateWithoutUsedAsTruckInput>, EquipmentUncheckedUpdateWithoutUsedAsTruckInput>
  }

  export type EquipmentHauledUncheckedUpdateManyWithoutTruckingLogNestedInput = {
    create?: XOR<EquipmentHauledCreateWithoutTruckingLogInput, EquipmentHauledUncheckedCreateWithoutTruckingLogInput> | EquipmentHauledCreateWithoutTruckingLogInput[] | EquipmentHauledUncheckedCreateWithoutTruckingLogInput[]
    connectOrCreate?: EquipmentHauledCreateOrConnectWithoutTruckingLogInput | EquipmentHauledCreateOrConnectWithoutTruckingLogInput[]
    upsert?: EquipmentHauledUpsertWithWhereUniqueWithoutTruckingLogInput | EquipmentHauledUpsertWithWhereUniqueWithoutTruckingLogInput[]
    createMany?: EquipmentHauledCreateManyTruckingLogInputEnvelope
    set?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
    disconnect?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
    delete?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
    connect?: EquipmentHauledWhereUniqueInput | EquipmentHauledWhereUniqueInput[]
    update?: EquipmentHauledUpdateWithWhereUniqueWithoutTruckingLogInput | EquipmentHauledUpdateWithWhereUniqueWithoutTruckingLogInput[]
    updateMany?: EquipmentHauledUpdateManyWithWhereWithoutTruckingLogInput | EquipmentHauledUpdateManyWithWhereWithoutTruckingLogInput[]
    deleteMany?: EquipmentHauledScalarWhereInput | EquipmentHauledScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutTruckingLogNestedInput = {
    create?: XOR<MaterialCreateWithoutTruckingLogInput, MaterialUncheckedCreateWithoutTruckingLogInput> | MaterialCreateWithoutTruckingLogInput[] | MaterialUncheckedCreateWithoutTruckingLogInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutTruckingLogInput | MaterialCreateOrConnectWithoutTruckingLogInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutTruckingLogInput | MaterialUpsertWithWhereUniqueWithoutTruckingLogInput[]
    createMany?: MaterialCreateManyTruckingLogInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutTruckingLogInput | MaterialUpdateWithWhereUniqueWithoutTruckingLogInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutTruckingLogInput | MaterialUpdateManyWithWhereWithoutTruckingLogInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type RefuelLogUncheckedUpdateManyWithoutTruckingLogNestedInput = {
    create?: XOR<RefuelLogCreateWithoutTruckingLogInput, RefuelLogUncheckedCreateWithoutTruckingLogInput> | RefuelLogCreateWithoutTruckingLogInput[] | RefuelLogUncheckedCreateWithoutTruckingLogInput[]
    connectOrCreate?: RefuelLogCreateOrConnectWithoutTruckingLogInput | RefuelLogCreateOrConnectWithoutTruckingLogInput[]
    upsert?: RefuelLogUpsertWithWhereUniqueWithoutTruckingLogInput | RefuelLogUpsertWithWhereUniqueWithoutTruckingLogInput[]
    createMany?: RefuelLogCreateManyTruckingLogInputEnvelope
    set?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
    disconnect?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
    delete?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
    connect?: RefuelLogWhereUniqueInput | RefuelLogWhereUniqueInput[]
    update?: RefuelLogUpdateWithWhereUniqueWithoutTruckingLogInput | RefuelLogUpdateWithWhereUniqueWithoutTruckingLogInput[]
    updateMany?: RefuelLogUpdateManyWithWhereWithoutTruckingLogInput | RefuelLogUpdateManyWithWhereWithoutTruckingLogInput[]
    deleteMany?: RefuelLogScalarWhereInput | RefuelLogScalarWhereInput[]
  }

  export type StateMileageUncheckedUpdateManyWithoutTruckingLogNestedInput = {
    create?: XOR<StateMileageCreateWithoutTruckingLogInput, StateMileageUncheckedCreateWithoutTruckingLogInput> | StateMileageCreateWithoutTruckingLogInput[] | StateMileageUncheckedCreateWithoutTruckingLogInput[]
    connectOrCreate?: StateMileageCreateOrConnectWithoutTruckingLogInput | StateMileageCreateOrConnectWithoutTruckingLogInput[]
    upsert?: StateMileageUpsertWithWhereUniqueWithoutTruckingLogInput | StateMileageUpsertWithWhereUniqueWithoutTruckingLogInput[]
    createMany?: StateMileageCreateManyTruckingLogInputEnvelope
    set?: StateMileageWhereUniqueInput | StateMileageWhereUniqueInput[]
    disconnect?: StateMileageWhereUniqueInput | StateMileageWhereUniqueInput[]
    delete?: StateMileageWhereUniqueInput | StateMileageWhereUniqueInput[]
    connect?: StateMileageWhereUniqueInput | StateMileageWhereUniqueInput[]
    update?: StateMileageUpdateWithWhereUniqueWithoutTruckingLogInput | StateMileageUpdateWithWhereUniqueWithoutTruckingLogInput[]
    updateMany?: StateMileageUpdateManyWithWhereWithoutTruckingLogInput | StateMileageUpdateManyWithWhereWithoutTruckingLogInput[]
    deleteMany?: StateMileageScalarWhereInput | StateMileageScalarWhereInput[]
  }

  export type TruckingLogCreateNestedOneWithoutStateMileagesInput = {
    create?: XOR<TruckingLogCreateWithoutStateMileagesInput, TruckingLogUncheckedCreateWithoutStateMileagesInput>
    connectOrCreate?: TruckingLogCreateOrConnectWithoutStateMileagesInput
    connect?: TruckingLogWhereUniqueInput
  }

  export type TruckingLogUpdateOneRequiredWithoutStateMileagesNestedInput = {
    create?: XOR<TruckingLogCreateWithoutStateMileagesInput, TruckingLogUncheckedCreateWithoutStateMileagesInput>
    connectOrCreate?: TruckingLogCreateOrConnectWithoutStateMileagesInput
    upsert?: TruckingLogUpsertWithoutStateMileagesInput
    connect?: TruckingLogWhereUniqueInput
    update?: XOR<XOR<TruckingLogUpdateToOneWithWhereWithoutStateMileagesInput, TruckingLogUpdateWithoutStateMileagesInput>, TruckingLogUncheckedUpdateWithoutStateMileagesInput>
  }

  export type TruckingLogCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<TruckingLogCreateWithoutMaterialsInput, TruckingLogUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: TruckingLogCreateOrConnectWithoutMaterialsInput
    connect?: TruckingLogWhereUniqueInput
  }

  export type NullableEnummaterialUnitFieldUpdateOperationsInput = {
    set?: $Enums.materialUnit | null
  }

  export type TruckingLogUpdateOneRequiredWithoutMaterialsNestedInput = {
    create?: XOR<TruckingLogCreateWithoutMaterialsInput, TruckingLogUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: TruckingLogCreateOrConnectWithoutMaterialsInput
    upsert?: TruckingLogUpsertWithoutMaterialsInput
    connect?: TruckingLogWhereUniqueInput
    update?: XOR<XOR<TruckingLogUpdateToOneWithWhereWithoutMaterialsInput, TruckingLogUpdateWithoutMaterialsInput>, TruckingLogUncheckedUpdateWithoutMaterialsInput>
  }

  export type EmployeeEquipmentLogCreateNestedOneWithoutRefuelLogInput = {
    create?: XOR<EmployeeEquipmentLogCreateWithoutRefuelLogInput, EmployeeEquipmentLogUncheckedCreateWithoutRefuelLogInput>
    connectOrCreate?: EmployeeEquipmentLogCreateOrConnectWithoutRefuelLogInput
    connect?: EmployeeEquipmentLogWhereUniqueInput
  }

  export type TascoLogCreateNestedOneWithoutRefuelLogsInput = {
    create?: XOR<TascoLogCreateWithoutRefuelLogsInput, TascoLogUncheckedCreateWithoutRefuelLogsInput>
    connectOrCreate?: TascoLogCreateOrConnectWithoutRefuelLogsInput
    connect?: TascoLogWhereUniqueInput
  }

  export type TruckingLogCreateNestedOneWithoutRefuelLogsInput = {
    create?: XOR<TruckingLogCreateWithoutRefuelLogsInput, TruckingLogUncheckedCreateWithoutRefuelLogsInput>
    connectOrCreate?: TruckingLogCreateOrConnectWithoutRefuelLogsInput
    connect?: TruckingLogWhereUniqueInput
  }

  export type EmployeeEquipmentLogUpdateOneWithoutRefuelLogNestedInput = {
    create?: XOR<EmployeeEquipmentLogCreateWithoutRefuelLogInput, EmployeeEquipmentLogUncheckedCreateWithoutRefuelLogInput>
    connectOrCreate?: EmployeeEquipmentLogCreateOrConnectWithoutRefuelLogInput
    upsert?: EmployeeEquipmentLogUpsertWithoutRefuelLogInput
    disconnect?: EmployeeEquipmentLogWhereInput | boolean
    delete?: EmployeeEquipmentLogWhereInput | boolean
    connect?: EmployeeEquipmentLogWhereUniqueInput
    update?: XOR<XOR<EmployeeEquipmentLogUpdateToOneWithWhereWithoutRefuelLogInput, EmployeeEquipmentLogUpdateWithoutRefuelLogInput>, EmployeeEquipmentLogUncheckedUpdateWithoutRefuelLogInput>
  }

  export type TascoLogUpdateOneWithoutRefuelLogsNestedInput = {
    create?: XOR<TascoLogCreateWithoutRefuelLogsInput, TascoLogUncheckedCreateWithoutRefuelLogsInput>
    connectOrCreate?: TascoLogCreateOrConnectWithoutRefuelLogsInput
    upsert?: TascoLogUpsertWithoutRefuelLogsInput
    disconnect?: TascoLogWhereInput | boolean
    delete?: TascoLogWhereInput | boolean
    connect?: TascoLogWhereUniqueInput
    update?: XOR<XOR<TascoLogUpdateToOneWithWhereWithoutRefuelLogsInput, TascoLogUpdateWithoutRefuelLogsInput>, TascoLogUncheckedUpdateWithoutRefuelLogsInput>
  }

  export type TruckingLogUpdateOneWithoutRefuelLogsNestedInput = {
    create?: XOR<TruckingLogCreateWithoutRefuelLogsInput, TruckingLogUncheckedCreateWithoutRefuelLogsInput>
    connectOrCreate?: TruckingLogCreateOrConnectWithoutRefuelLogsInput
    upsert?: TruckingLogUpsertWithoutRefuelLogsInput
    disconnect?: TruckingLogWhereInput | boolean
    delete?: TruckingLogWhereInput | boolean
    connect?: TruckingLogWhereUniqueInput
    update?: XOR<XOR<TruckingLogUpdateToOneWithWhereWithoutRefuelLogsInput, TruckingLogUpdateWithoutRefuelLogsInput>, TruckingLogUncheckedUpdateWithoutRefuelLogsInput>
  }

  export type EquipmentCreateNestedOneWithoutEquipmentHauledInput = {
    create?: XOR<EquipmentCreateWithoutEquipmentHauledInput, EquipmentUncheckedCreateWithoutEquipmentHauledInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutEquipmentHauledInput
    connect?: EquipmentWhereUniqueInput
  }

  export type TruckingLogCreateNestedOneWithoutEquipmentHauledInput = {
    create?: XOR<TruckingLogCreateWithoutEquipmentHauledInput, TruckingLogUncheckedCreateWithoutEquipmentHauledInput>
    connectOrCreate?: TruckingLogCreateOrConnectWithoutEquipmentHauledInput
    connect?: TruckingLogWhereUniqueInput
  }

  export type EquipmentUpdateOneWithoutEquipmentHauledNestedInput = {
    create?: XOR<EquipmentCreateWithoutEquipmentHauledInput, EquipmentUncheckedCreateWithoutEquipmentHauledInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutEquipmentHauledInput
    upsert?: EquipmentUpsertWithoutEquipmentHauledInput
    disconnect?: EquipmentWhereInput | boolean
    delete?: EquipmentWhereInput | boolean
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutEquipmentHauledInput, EquipmentUpdateWithoutEquipmentHauledInput>, EquipmentUncheckedUpdateWithoutEquipmentHauledInput>
  }

  export type TruckingLogUpdateOneWithoutEquipmentHauledNestedInput = {
    create?: XOR<TruckingLogCreateWithoutEquipmentHauledInput, TruckingLogUncheckedCreateWithoutEquipmentHauledInput>
    connectOrCreate?: TruckingLogCreateOrConnectWithoutEquipmentHauledInput
    upsert?: TruckingLogUpsertWithoutEquipmentHauledInput
    disconnect?: TruckingLogWhereInput | boolean
    delete?: TruckingLogWhereInput | boolean
    connect?: TruckingLogWhereUniqueInput
    update?: XOR<XOR<TruckingLogUpdateToOneWithWhereWithoutEquipmentHauledInput, TruckingLogUpdateWithoutEquipmentHauledInput>, TruckingLogUncheckedUpdateWithoutEquipmentHauledInput>
  }

  export type UserCreateNestedOneWithoutTimeSheetChangesInput = {
    create?: XOR<UserCreateWithoutTimeSheetChangesInput, UserUncheckedCreateWithoutTimeSheetChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeSheetChangesInput
    connect?: UserWhereUniqueInput
  }

  export type TimeSheetCreateNestedOneWithoutChangeLogsInput = {
    create?: XOR<TimeSheetCreateWithoutChangeLogsInput, TimeSheetUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: TimeSheetCreateOrConnectWithoutChangeLogsInput
    connect?: TimeSheetWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTimeSheetChangesNestedInput = {
    create?: XOR<UserCreateWithoutTimeSheetChangesInput, UserUncheckedCreateWithoutTimeSheetChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeSheetChangesInput
    upsert?: UserUpsertWithoutTimeSheetChangesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTimeSheetChangesInput, UserUpdateWithoutTimeSheetChangesInput>, UserUncheckedUpdateWithoutTimeSheetChangesInput>
  }

  export type TimeSheetUpdateOneRequiredWithoutChangeLogsNestedInput = {
    create?: XOR<TimeSheetCreateWithoutChangeLogsInput, TimeSheetUncheckedCreateWithoutChangeLogsInput>
    connectOrCreate?: TimeSheetCreateOrConnectWithoutChangeLogsInput
    upsert?: TimeSheetUpsertWithoutChangeLogsInput
    connect?: TimeSheetWhereUniqueInput
    update?: XOR<XOR<TimeSheetUpdateToOneWithWhereWithoutChangeLogsInput, TimeSheetUpdateWithoutChangeLogsInput>, TimeSheetUncheckedUpdateWithoutChangeLogsInput>
  }

  export type AccountSetupTokenCreateNestedOneWithoutUserInput = {
    create?: XOR<AccountSetupTokenCreateWithoutUserInput, AccountSetupTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountSetupTokenCreateOrConnectWithoutUserInput
    connect?: AccountSetupTokenWhereUniqueInput
  }

  export type ContactsCreateNestedOneWithoutUserInput = {
    create?: XOR<ContactsCreateWithoutUserInput, ContactsUncheckedCreateWithoutUserInput>
    connectOrCreate?: ContactsCreateOrConnectWithoutUserInput
    connect?: ContactsWhereUniqueInput
  }

  export type EquipmentCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EquipmentCreateWithoutCreatedByInput, EquipmentUncheckedCreateWithoutCreatedByInput> | EquipmentCreateWithoutCreatedByInput[] | EquipmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutCreatedByInput | EquipmentCreateOrConnectWithoutCreatedByInput[]
    createMany?: EquipmentCreateManyCreatedByInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type FCMTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<FCMTokenCreateWithoutUserInput, FCMTokenUncheckedCreateWithoutUserInput> | FCMTokenCreateWithoutUserInput[] | FCMTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FCMTokenCreateOrConnectWithoutUserInput | FCMTokenCreateOrConnectWithoutUserInput[]
    createMany?: FCMTokenCreateManyUserInputEnvelope
    connect?: FCMTokenWhereUniqueInput | FCMTokenWhereUniqueInput[]
  }

  export type FormApprovalCreateNestedManyWithoutApproverInput = {
    create?: XOR<FormApprovalCreateWithoutApproverInput, FormApprovalUncheckedCreateWithoutApproverInput> | FormApprovalCreateWithoutApproverInput[] | FormApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: FormApprovalCreateOrConnectWithoutApproverInput | FormApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: FormApprovalCreateManyApproverInputEnvelope
    connect?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
  }

  export type FormSubmissionCreateNestedManyWithoutUserInput = {
    create?: XOR<FormSubmissionCreateWithoutUserInput, FormSubmissionUncheckedCreateWithoutUserInput> | FormSubmissionCreateWithoutUserInput[] | FormSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutUserInput | FormSubmissionCreateOrConnectWithoutUserInput[]
    createMany?: FormSubmissionCreateManyUserInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type JobsiteCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<JobsiteCreateWithoutCreatedByInput, JobsiteUncheckedCreateWithoutCreatedByInput> | JobsiteCreateWithoutCreatedByInput[] | JobsiteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: JobsiteCreateOrConnectWithoutCreatedByInput | JobsiteCreateOrConnectWithoutCreatedByInput[]
    createMany?: JobsiteCreateManyCreatedByInputEnvelope
    connect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
  }

  export type MaintenanceLogCreateNestedManyWithoutUserInput = {
    create?: XOR<MaintenanceLogCreateWithoutUserInput, MaintenanceLogUncheckedCreateWithoutUserInput> | MaintenanceLogCreateWithoutUserInput[] | MaintenanceLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutUserInput | MaintenanceLogCreateOrConnectWithoutUserInput[]
    createMany?: MaintenanceLogCreateManyUserInputEnvelope
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
  }

  export type NotificationReadCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationReadCreateWithoutUserInput, NotificationReadUncheckedCreateWithoutUserInput> | NotificationReadCreateWithoutUserInput[] | NotificationReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationReadCreateOrConnectWithoutUserInput | NotificationReadCreateOrConnectWithoutUserInput[]
    createMany?: NotificationReadCreateManyUserInputEnvelope
    connect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
  }

  export type NotificationResponseCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationResponseCreateWithoutUserInput, NotificationResponseUncheckedCreateWithoutUserInput> | NotificationResponseCreateWithoutUserInput[] | NotificationResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationResponseCreateOrConnectWithoutUserInput | NotificationResponseCreateOrConnectWithoutUserInput[]
    createMany?: NotificationResponseCreateManyUserInputEnvelope
    connect?: NotificationResponseWhereUniqueInput | NotificationResponseWhereUniqueInput[]
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type TimeSheetCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeSheetCreateWithoutUserInput, TimeSheetUncheckedCreateWithoutUserInput> | TimeSheetCreateWithoutUserInput[] | TimeSheetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeSheetCreateOrConnectWithoutUserInput | TimeSheetCreateOrConnectWithoutUserInput[]
    createMany?: TimeSheetCreateManyUserInputEnvelope
    connect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
  }

  export type TimeSheetChangeLogCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeSheetChangeLogCreateWithoutUserInput, TimeSheetChangeLogUncheckedCreateWithoutUserInput> | TimeSheetChangeLogCreateWithoutUserInput[] | TimeSheetChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeSheetChangeLogCreateOrConnectWithoutUserInput | TimeSheetChangeLogCreateOrConnectWithoutUserInput[]
    createMany?: TimeSheetChangeLogCreateManyUserInputEnvelope
    connect?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
  }

  export type TopicSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<TopicSubscriptionCreateWithoutUserInput, TopicSubscriptionUncheckedCreateWithoutUserInput> | TopicSubscriptionCreateWithoutUserInput[] | TopicSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TopicSubscriptionCreateOrConnectWithoutUserInput | TopicSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: TopicSubscriptionCreateManyUserInputEnvelope
    connect?: TopicSubscriptionWhereUniqueInput | TopicSubscriptionWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type CrewCreateNestedManyWithoutUsersInput = {
    create?: XOR<CrewCreateWithoutUsersInput, CrewUncheckedCreateWithoutUsersInput> | CrewCreateWithoutUsersInput[] | CrewUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutUsersInput | CrewCreateOrConnectWithoutUsersInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AccountSetupTokenCreateWithoutUserInput, AccountSetupTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountSetupTokenCreateOrConnectWithoutUserInput
    connect?: AccountSetupTokenWhereUniqueInput
  }

  export type ContactsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ContactsCreateWithoutUserInput, ContactsUncheckedCreateWithoutUserInput>
    connectOrCreate?: ContactsCreateOrConnectWithoutUserInput
    connect?: ContactsWhereUniqueInput
  }

  export type EquipmentUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<EquipmentCreateWithoutCreatedByInput, EquipmentUncheckedCreateWithoutCreatedByInput> | EquipmentCreateWithoutCreatedByInput[] | EquipmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutCreatedByInput | EquipmentCreateOrConnectWithoutCreatedByInput[]
    createMany?: EquipmentCreateManyCreatedByInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type FCMTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FCMTokenCreateWithoutUserInput, FCMTokenUncheckedCreateWithoutUserInput> | FCMTokenCreateWithoutUserInput[] | FCMTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FCMTokenCreateOrConnectWithoutUserInput | FCMTokenCreateOrConnectWithoutUserInput[]
    createMany?: FCMTokenCreateManyUserInputEnvelope
    connect?: FCMTokenWhereUniqueInput | FCMTokenWhereUniqueInput[]
  }

  export type FormApprovalUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<FormApprovalCreateWithoutApproverInput, FormApprovalUncheckedCreateWithoutApproverInput> | FormApprovalCreateWithoutApproverInput[] | FormApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: FormApprovalCreateOrConnectWithoutApproverInput | FormApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: FormApprovalCreateManyApproverInputEnvelope
    connect?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
  }

  export type FormSubmissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FormSubmissionCreateWithoutUserInput, FormSubmissionUncheckedCreateWithoutUserInput> | FormSubmissionCreateWithoutUserInput[] | FormSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutUserInput | FormSubmissionCreateOrConnectWithoutUserInput[]
    createMany?: FormSubmissionCreateManyUserInputEnvelope
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
  }

  export type JobsiteUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<JobsiteCreateWithoutCreatedByInput, JobsiteUncheckedCreateWithoutCreatedByInput> | JobsiteCreateWithoutCreatedByInput[] | JobsiteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: JobsiteCreateOrConnectWithoutCreatedByInput | JobsiteCreateOrConnectWithoutCreatedByInput[]
    createMany?: JobsiteCreateManyCreatedByInputEnvelope
    connect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
  }

  export type MaintenanceLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MaintenanceLogCreateWithoutUserInput, MaintenanceLogUncheckedCreateWithoutUserInput> | MaintenanceLogCreateWithoutUserInput[] | MaintenanceLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutUserInput | MaintenanceLogCreateOrConnectWithoutUserInput[]
    createMany?: MaintenanceLogCreateManyUserInputEnvelope
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
  }

  export type NotificationReadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationReadCreateWithoutUserInput, NotificationReadUncheckedCreateWithoutUserInput> | NotificationReadCreateWithoutUserInput[] | NotificationReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationReadCreateOrConnectWithoutUserInput | NotificationReadCreateOrConnectWithoutUserInput[]
    createMany?: NotificationReadCreateManyUserInputEnvelope
    connect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
  }

  export type NotificationResponseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationResponseCreateWithoutUserInput, NotificationResponseUncheckedCreateWithoutUserInput> | NotificationResponseCreateWithoutUserInput[] | NotificationResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationResponseCreateOrConnectWithoutUserInput | NotificationResponseCreateOrConnectWithoutUserInput[]
    createMany?: NotificationResponseCreateManyUserInputEnvelope
    connect?: NotificationResponseWhereUniqueInput | NotificationResponseWhereUniqueInput[]
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type TimeSheetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeSheetCreateWithoutUserInput, TimeSheetUncheckedCreateWithoutUserInput> | TimeSheetCreateWithoutUserInput[] | TimeSheetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeSheetCreateOrConnectWithoutUserInput | TimeSheetCreateOrConnectWithoutUserInput[]
    createMany?: TimeSheetCreateManyUserInputEnvelope
    connect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
  }

  export type TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeSheetChangeLogCreateWithoutUserInput, TimeSheetChangeLogUncheckedCreateWithoutUserInput> | TimeSheetChangeLogCreateWithoutUserInput[] | TimeSheetChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeSheetChangeLogCreateOrConnectWithoutUserInput | TimeSheetChangeLogCreateOrConnectWithoutUserInput[]
    createMany?: TimeSheetChangeLogCreateManyUserInputEnvelope
    connect?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
  }

  export type TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TopicSubscriptionCreateWithoutUserInput, TopicSubscriptionUncheckedCreateWithoutUserInput> | TopicSubscriptionCreateWithoutUserInput[] | TopicSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TopicSubscriptionCreateOrConnectWithoutUserInput | TopicSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: TopicSubscriptionCreateManyUserInputEnvelope
    connect?: TopicSubscriptionWhereUniqueInput | TopicSubscriptionWhereUniqueInput[]
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type CrewUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<CrewCreateWithoutUsersInput, CrewUncheckedCreateWithoutUsersInput> | CrewCreateWithoutUsersInput[] | CrewUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutUsersInput | CrewCreateOrConnectWithoutUsersInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
  }

  export type EnumPermissionFieldUpdateOperationsInput = {
    set?: $Enums.Permission
  }

  export type AccountSetupTokenUpdateOneWithoutUserNestedInput = {
    create?: XOR<AccountSetupTokenCreateWithoutUserInput, AccountSetupTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountSetupTokenCreateOrConnectWithoutUserInput
    upsert?: AccountSetupTokenUpsertWithoutUserInput
    disconnect?: AccountSetupTokenWhereInput | boolean
    delete?: AccountSetupTokenWhereInput | boolean
    connect?: AccountSetupTokenWhereUniqueInput
    update?: XOR<XOR<AccountSetupTokenUpdateToOneWithWhereWithoutUserInput, AccountSetupTokenUpdateWithoutUserInput>, AccountSetupTokenUncheckedUpdateWithoutUserInput>
  }

  export type ContactsUpdateOneWithoutUserNestedInput = {
    create?: XOR<ContactsCreateWithoutUserInput, ContactsUncheckedCreateWithoutUserInput>
    connectOrCreate?: ContactsCreateOrConnectWithoutUserInput
    upsert?: ContactsUpsertWithoutUserInput
    disconnect?: ContactsWhereInput | boolean
    delete?: ContactsWhereInput | boolean
    connect?: ContactsWhereUniqueInput
    update?: XOR<XOR<ContactsUpdateToOneWithWhereWithoutUserInput, ContactsUpdateWithoutUserInput>, ContactsUncheckedUpdateWithoutUserInput>
  }

  export type EquipmentUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EquipmentCreateWithoutCreatedByInput, EquipmentUncheckedCreateWithoutCreatedByInput> | EquipmentCreateWithoutCreatedByInput[] | EquipmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutCreatedByInput | EquipmentCreateOrConnectWithoutCreatedByInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutCreatedByInput | EquipmentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EquipmentCreateManyCreatedByInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutCreatedByInput | EquipmentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutCreatedByInput | EquipmentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type FCMTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<FCMTokenCreateWithoutUserInput, FCMTokenUncheckedCreateWithoutUserInput> | FCMTokenCreateWithoutUserInput[] | FCMTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FCMTokenCreateOrConnectWithoutUserInput | FCMTokenCreateOrConnectWithoutUserInput[]
    upsert?: FCMTokenUpsertWithWhereUniqueWithoutUserInput | FCMTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FCMTokenCreateManyUserInputEnvelope
    set?: FCMTokenWhereUniqueInput | FCMTokenWhereUniqueInput[]
    disconnect?: FCMTokenWhereUniqueInput | FCMTokenWhereUniqueInput[]
    delete?: FCMTokenWhereUniqueInput | FCMTokenWhereUniqueInput[]
    connect?: FCMTokenWhereUniqueInput | FCMTokenWhereUniqueInput[]
    update?: FCMTokenUpdateWithWhereUniqueWithoutUserInput | FCMTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FCMTokenUpdateManyWithWhereWithoutUserInput | FCMTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FCMTokenScalarWhereInput | FCMTokenScalarWhereInput[]
  }

  export type FormApprovalUpdateManyWithoutApproverNestedInput = {
    create?: XOR<FormApprovalCreateWithoutApproverInput, FormApprovalUncheckedCreateWithoutApproverInput> | FormApprovalCreateWithoutApproverInput[] | FormApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: FormApprovalCreateOrConnectWithoutApproverInput | FormApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: FormApprovalUpsertWithWhereUniqueWithoutApproverInput | FormApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: FormApprovalCreateManyApproverInputEnvelope
    set?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
    disconnect?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
    delete?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
    connect?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
    update?: FormApprovalUpdateWithWhereUniqueWithoutApproverInput | FormApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: FormApprovalUpdateManyWithWhereWithoutApproverInput | FormApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: FormApprovalScalarWhereInput | FormApprovalScalarWhereInput[]
  }

  export type FormSubmissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutUserInput, FormSubmissionUncheckedCreateWithoutUserInput> | FormSubmissionCreateWithoutUserInput[] | FormSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutUserInput | FormSubmissionCreateOrConnectWithoutUserInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutUserInput | FormSubmissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FormSubmissionCreateManyUserInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutUserInput | FormSubmissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutUserInput | FormSubmissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type JobsiteUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<JobsiteCreateWithoutCreatedByInput, JobsiteUncheckedCreateWithoutCreatedByInput> | JobsiteCreateWithoutCreatedByInput[] | JobsiteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: JobsiteCreateOrConnectWithoutCreatedByInput | JobsiteCreateOrConnectWithoutCreatedByInput[]
    upsert?: JobsiteUpsertWithWhereUniqueWithoutCreatedByInput | JobsiteUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: JobsiteCreateManyCreatedByInputEnvelope
    set?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    disconnect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    delete?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    connect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    update?: JobsiteUpdateWithWhereUniqueWithoutCreatedByInput | JobsiteUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: JobsiteUpdateManyWithWhereWithoutCreatedByInput | JobsiteUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: JobsiteScalarWhereInput | JobsiteScalarWhereInput[]
  }

  export type MaintenanceLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<MaintenanceLogCreateWithoutUserInput, MaintenanceLogUncheckedCreateWithoutUserInput> | MaintenanceLogCreateWithoutUserInput[] | MaintenanceLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutUserInput | MaintenanceLogCreateOrConnectWithoutUserInput[]
    upsert?: MaintenanceLogUpsertWithWhereUniqueWithoutUserInput | MaintenanceLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MaintenanceLogCreateManyUserInputEnvelope
    set?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    disconnect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    delete?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    update?: MaintenanceLogUpdateWithWhereUniqueWithoutUserInput | MaintenanceLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MaintenanceLogUpdateManyWithWhereWithoutUserInput | MaintenanceLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MaintenanceLogScalarWhereInput | MaintenanceLogScalarWhereInput[]
  }

  export type NotificationReadUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationReadCreateWithoutUserInput, NotificationReadUncheckedCreateWithoutUserInput> | NotificationReadCreateWithoutUserInput[] | NotificationReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationReadCreateOrConnectWithoutUserInput | NotificationReadCreateOrConnectWithoutUserInput[]
    upsert?: NotificationReadUpsertWithWhereUniqueWithoutUserInput | NotificationReadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationReadCreateManyUserInputEnvelope
    set?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    disconnect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    delete?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    connect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    update?: NotificationReadUpdateWithWhereUniqueWithoutUserInput | NotificationReadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationReadUpdateManyWithWhereWithoutUserInput | NotificationReadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationReadScalarWhereInput | NotificationReadScalarWhereInput[]
  }

  export type NotificationResponseUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationResponseCreateWithoutUserInput, NotificationResponseUncheckedCreateWithoutUserInput> | NotificationResponseCreateWithoutUserInput[] | NotificationResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationResponseCreateOrConnectWithoutUserInput | NotificationResponseCreateOrConnectWithoutUserInput[]
    upsert?: NotificationResponseUpsertWithWhereUniqueWithoutUserInput | NotificationResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationResponseCreateManyUserInputEnvelope
    set?: NotificationResponseWhereUniqueInput | NotificationResponseWhereUniqueInput[]
    disconnect?: NotificationResponseWhereUniqueInput | NotificationResponseWhereUniqueInput[]
    delete?: NotificationResponseWhereUniqueInput | NotificationResponseWhereUniqueInput[]
    connect?: NotificationResponseWhereUniqueInput | NotificationResponseWhereUniqueInput[]
    update?: NotificationResponseUpdateWithWhereUniqueWithoutUserInput | NotificationResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationResponseUpdateManyWithWhereWithoutUserInput | NotificationResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationResponseScalarWhereInput | NotificationResponseScalarWhereInput[]
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type TimeSheetUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeSheetCreateWithoutUserInput, TimeSheetUncheckedCreateWithoutUserInput> | TimeSheetCreateWithoutUserInput[] | TimeSheetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeSheetCreateOrConnectWithoutUserInput | TimeSheetCreateOrConnectWithoutUserInput[]
    upsert?: TimeSheetUpsertWithWhereUniqueWithoutUserInput | TimeSheetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeSheetCreateManyUserInputEnvelope
    set?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    disconnect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    delete?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    connect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    update?: TimeSheetUpdateWithWhereUniqueWithoutUserInput | TimeSheetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeSheetUpdateManyWithWhereWithoutUserInput | TimeSheetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeSheetScalarWhereInput | TimeSheetScalarWhereInput[]
  }

  export type TimeSheetChangeLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeSheetChangeLogCreateWithoutUserInput, TimeSheetChangeLogUncheckedCreateWithoutUserInput> | TimeSheetChangeLogCreateWithoutUserInput[] | TimeSheetChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeSheetChangeLogCreateOrConnectWithoutUserInput | TimeSheetChangeLogCreateOrConnectWithoutUserInput[]
    upsert?: TimeSheetChangeLogUpsertWithWhereUniqueWithoutUserInput | TimeSheetChangeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeSheetChangeLogCreateManyUserInputEnvelope
    set?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
    disconnect?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
    delete?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
    connect?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
    update?: TimeSheetChangeLogUpdateWithWhereUniqueWithoutUserInput | TimeSheetChangeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeSheetChangeLogUpdateManyWithWhereWithoutUserInput | TimeSheetChangeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeSheetChangeLogScalarWhereInput | TimeSheetChangeLogScalarWhereInput[]
  }

  export type TopicSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TopicSubscriptionCreateWithoutUserInput, TopicSubscriptionUncheckedCreateWithoutUserInput> | TopicSubscriptionCreateWithoutUserInput[] | TopicSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TopicSubscriptionCreateOrConnectWithoutUserInput | TopicSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: TopicSubscriptionUpsertWithWhereUniqueWithoutUserInput | TopicSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TopicSubscriptionCreateManyUserInputEnvelope
    set?: TopicSubscriptionWhereUniqueInput | TopicSubscriptionWhereUniqueInput[]
    disconnect?: TopicSubscriptionWhereUniqueInput | TopicSubscriptionWhereUniqueInput[]
    delete?: TopicSubscriptionWhereUniqueInput | TopicSubscriptionWhereUniqueInput[]
    connect?: TopicSubscriptionWhereUniqueInput | TopicSubscriptionWhereUniqueInput[]
    update?: TopicSubscriptionUpdateWithWhereUniqueWithoutUserInput | TopicSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TopicSubscriptionUpdateManyWithWhereWithoutUserInput | TopicSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TopicSubscriptionScalarWhereInput | TopicSubscriptionScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type CrewUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CrewCreateWithoutUsersInput, CrewUncheckedCreateWithoutUsersInput> | CrewCreateWithoutUsersInput[] | CrewUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutUsersInput | CrewCreateOrConnectWithoutUsersInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutUsersInput | CrewUpsertWithWhereUniqueWithoutUsersInput[]
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutUsersInput | CrewUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutUsersInput | CrewUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AccountSetupTokenCreateWithoutUserInput, AccountSetupTokenUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountSetupTokenCreateOrConnectWithoutUserInput
    upsert?: AccountSetupTokenUpsertWithoutUserInput
    disconnect?: AccountSetupTokenWhereInput | boolean
    delete?: AccountSetupTokenWhereInput | boolean
    connect?: AccountSetupTokenWhereUniqueInput
    update?: XOR<XOR<AccountSetupTokenUpdateToOneWithWhereWithoutUserInput, AccountSetupTokenUpdateWithoutUserInput>, AccountSetupTokenUncheckedUpdateWithoutUserInput>
  }

  export type ContactsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ContactsCreateWithoutUserInput, ContactsUncheckedCreateWithoutUserInput>
    connectOrCreate?: ContactsCreateOrConnectWithoutUserInput
    upsert?: ContactsUpsertWithoutUserInput
    disconnect?: ContactsWhereInput | boolean
    delete?: ContactsWhereInput | boolean
    connect?: ContactsWhereUniqueInput
    update?: XOR<XOR<ContactsUpdateToOneWithWhereWithoutUserInput, ContactsUpdateWithoutUserInput>, ContactsUncheckedUpdateWithoutUserInput>
  }

  export type EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<EquipmentCreateWithoutCreatedByInput, EquipmentUncheckedCreateWithoutCreatedByInput> | EquipmentCreateWithoutCreatedByInput[] | EquipmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutCreatedByInput | EquipmentCreateOrConnectWithoutCreatedByInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutCreatedByInput | EquipmentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: EquipmentCreateManyCreatedByInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutCreatedByInput | EquipmentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutCreatedByInput | EquipmentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type FCMTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FCMTokenCreateWithoutUserInput, FCMTokenUncheckedCreateWithoutUserInput> | FCMTokenCreateWithoutUserInput[] | FCMTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FCMTokenCreateOrConnectWithoutUserInput | FCMTokenCreateOrConnectWithoutUserInput[]
    upsert?: FCMTokenUpsertWithWhereUniqueWithoutUserInput | FCMTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FCMTokenCreateManyUserInputEnvelope
    set?: FCMTokenWhereUniqueInput | FCMTokenWhereUniqueInput[]
    disconnect?: FCMTokenWhereUniqueInput | FCMTokenWhereUniqueInput[]
    delete?: FCMTokenWhereUniqueInput | FCMTokenWhereUniqueInput[]
    connect?: FCMTokenWhereUniqueInput | FCMTokenWhereUniqueInput[]
    update?: FCMTokenUpdateWithWhereUniqueWithoutUserInput | FCMTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FCMTokenUpdateManyWithWhereWithoutUserInput | FCMTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FCMTokenScalarWhereInput | FCMTokenScalarWhereInput[]
  }

  export type FormApprovalUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<FormApprovalCreateWithoutApproverInput, FormApprovalUncheckedCreateWithoutApproverInput> | FormApprovalCreateWithoutApproverInput[] | FormApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: FormApprovalCreateOrConnectWithoutApproverInput | FormApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: FormApprovalUpsertWithWhereUniqueWithoutApproverInput | FormApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: FormApprovalCreateManyApproverInputEnvelope
    set?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
    disconnect?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
    delete?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
    connect?: FormApprovalWhereUniqueInput | FormApprovalWhereUniqueInput[]
    update?: FormApprovalUpdateWithWhereUniqueWithoutApproverInput | FormApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: FormApprovalUpdateManyWithWhereWithoutApproverInput | FormApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: FormApprovalScalarWhereInput | FormApprovalScalarWhereInput[]
  }

  export type FormSubmissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FormSubmissionCreateWithoutUserInput, FormSubmissionUncheckedCreateWithoutUserInput> | FormSubmissionCreateWithoutUserInput[] | FormSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FormSubmissionCreateOrConnectWithoutUserInput | FormSubmissionCreateOrConnectWithoutUserInput[]
    upsert?: FormSubmissionUpsertWithWhereUniqueWithoutUserInput | FormSubmissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FormSubmissionCreateManyUserInputEnvelope
    set?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    disconnect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    delete?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    connect?: FormSubmissionWhereUniqueInput | FormSubmissionWhereUniqueInput[]
    update?: FormSubmissionUpdateWithWhereUniqueWithoutUserInput | FormSubmissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FormSubmissionUpdateManyWithWhereWithoutUserInput | FormSubmissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
  }

  export type JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<JobsiteCreateWithoutCreatedByInput, JobsiteUncheckedCreateWithoutCreatedByInput> | JobsiteCreateWithoutCreatedByInput[] | JobsiteUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: JobsiteCreateOrConnectWithoutCreatedByInput | JobsiteCreateOrConnectWithoutCreatedByInput[]
    upsert?: JobsiteUpsertWithWhereUniqueWithoutCreatedByInput | JobsiteUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: JobsiteCreateManyCreatedByInputEnvelope
    set?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    disconnect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    delete?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    connect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    update?: JobsiteUpdateWithWhereUniqueWithoutCreatedByInput | JobsiteUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: JobsiteUpdateManyWithWhereWithoutCreatedByInput | JobsiteUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: JobsiteScalarWhereInput | JobsiteScalarWhereInput[]
  }

  export type MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MaintenanceLogCreateWithoutUserInput, MaintenanceLogUncheckedCreateWithoutUserInput> | MaintenanceLogCreateWithoutUserInput[] | MaintenanceLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MaintenanceLogCreateOrConnectWithoutUserInput | MaintenanceLogCreateOrConnectWithoutUserInput[]
    upsert?: MaintenanceLogUpsertWithWhereUniqueWithoutUserInput | MaintenanceLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MaintenanceLogCreateManyUserInputEnvelope
    set?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    disconnect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    delete?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    connect?: MaintenanceLogWhereUniqueInput | MaintenanceLogWhereUniqueInput[]
    update?: MaintenanceLogUpdateWithWhereUniqueWithoutUserInput | MaintenanceLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MaintenanceLogUpdateManyWithWhereWithoutUserInput | MaintenanceLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MaintenanceLogScalarWhereInput | MaintenanceLogScalarWhereInput[]
  }

  export type NotificationReadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationReadCreateWithoutUserInput, NotificationReadUncheckedCreateWithoutUserInput> | NotificationReadCreateWithoutUserInput[] | NotificationReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationReadCreateOrConnectWithoutUserInput | NotificationReadCreateOrConnectWithoutUserInput[]
    upsert?: NotificationReadUpsertWithWhereUniqueWithoutUserInput | NotificationReadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationReadCreateManyUserInputEnvelope
    set?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    disconnect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    delete?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    connect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    update?: NotificationReadUpdateWithWhereUniqueWithoutUserInput | NotificationReadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationReadUpdateManyWithWhereWithoutUserInput | NotificationReadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationReadScalarWhereInput | NotificationReadScalarWhereInput[]
  }

  export type NotificationResponseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationResponseCreateWithoutUserInput, NotificationResponseUncheckedCreateWithoutUserInput> | NotificationResponseCreateWithoutUserInput[] | NotificationResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationResponseCreateOrConnectWithoutUserInput | NotificationResponseCreateOrConnectWithoutUserInput[]
    upsert?: NotificationResponseUpsertWithWhereUniqueWithoutUserInput | NotificationResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationResponseCreateManyUserInputEnvelope
    set?: NotificationResponseWhereUniqueInput | NotificationResponseWhereUniqueInput[]
    disconnect?: NotificationResponseWhereUniqueInput | NotificationResponseWhereUniqueInput[]
    delete?: NotificationResponseWhereUniqueInput | NotificationResponseWhereUniqueInput[]
    connect?: NotificationResponseWhereUniqueInput | NotificationResponseWhereUniqueInput[]
    update?: NotificationResponseUpdateWithWhereUniqueWithoutUserInput | NotificationResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationResponseUpdateManyWithWhereWithoutUserInput | NotificationResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationResponseScalarWhereInput | NotificationResponseScalarWhereInput[]
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type TimeSheetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeSheetCreateWithoutUserInput, TimeSheetUncheckedCreateWithoutUserInput> | TimeSheetCreateWithoutUserInput[] | TimeSheetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeSheetCreateOrConnectWithoutUserInput | TimeSheetCreateOrConnectWithoutUserInput[]
    upsert?: TimeSheetUpsertWithWhereUniqueWithoutUserInput | TimeSheetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeSheetCreateManyUserInputEnvelope
    set?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    disconnect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    delete?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    connect?: TimeSheetWhereUniqueInput | TimeSheetWhereUniqueInput[]
    update?: TimeSheetUpdateWithWhereUniqueWithoutUserInput | TimeSheetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeSheetUpdateManyWithWhereWithoutUserInput | TimeSheetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeSheetScalarWhereInput | TimeSheetScalarWhereInput[]
  }

  export type TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeSheetChangeLogCreateWithoutUserInput, TimeSheetChangeLogUncheckedCreateWithoutUserInput> | TimeSheetChangeLogCreateWithoutUserInput[] | TimeSheetChangeLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeSheetChangeLogCreateOrConnectWithoutUserInput | TimeSheetChangeLogCreateOrConnectWithoutUserInput[]
    upsert?: TimeSheetChangeLogUpsertWithWhereUniqueWithoutUserInput | TimeSheetChangeLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeSheetChangeLogCreateManyUserInputEnvelope
    set?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
    disconnect?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
    delete?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
    connect?: TimeSheetChangeLogWhereUniqueInput | TimeSheetChangeLogWhereUniqueInput[]
    update?: TimeSheetChangeLogUpdateWithWhereUniqueWithoutUserInput | TimeSheetChangeLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeSheetChangeLogUpdateManyWithWhereWithoutUserInput | TimeSheetChangeLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeSheetChangeLogScalarWhereInput | TimeSheetChangeLogScalarWhereInput[]
  }

  export type TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TopicSubscriptionCreateWithoutUserInput, TopicSubscriptionUncheckedCreateWithoutUserInput> | TopicSubscriptionCreateWithoutUserInput[] | TopicSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TopicSubscriptionCreateOrConnectWithoutUserInput | TopicSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: TopicSubscriptionUpsertWithWhereUniqueWithoutUserInput | TopicSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TopicSubscriptionCreateManyUserInputEnvelope
    set?: TopicSubscriptionWhereUniqueInput | TopicSubscriptionWhereUniqueInput[]
    disconnect?: TopicSubscriptionWhereUniqueInput | TopicSubscriptionWhereUniqueInput[]
    delete?: TopicSubscriptionWhereUniqueInput | TopicSubscriptionWhereUniqueInput[]
    connect?: TopicSubscriptionWhereUniqueInput | TopicSubscriptionWhereUniqueInput[]
    update?: TopicSubscriptionUpdateWithWhereUniqueWithoutUserInput | TopicSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TopicSubscriptionUpdateManyWithWhereWithoutUserInput | TopicSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TopicSubscriptionScalarWhereInput | TopicSubscriptionScalarWhereInput[]
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type CrewUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<CrewCreateWithoutUsersInput, CrewUncheckedCreateWithoutUsersInput> | CrewCreateWithoutUsersInput[] | CrewUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: CrewCreateOrConnectWithoutUsersInput | CrewCreateOrConnectWithoutUsersInput[]
    upsert?: CrewUpsertWithWhereUniqueWithoutUsersInput | CrewUpsertWithWhereUniqueWithoutUsersInput[]
    set?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    disconnect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    delete?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    connect?: CrewWhereUniqueInput | CrewWhereUniqueInput[]
    update?: CrewUpdateWithWhereUniqueWithoutUsersInput | CrewUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: CrewUpdateManyWithWhereWithoutUsersInput | CrewUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: CrewScalarWhereInput | CrewScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserSettingsInput = {
    create?: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserSettingsNestedInput = {
    create?: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSettingsInput
    upsert?: UserUpsertWithoutUserSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSettingsInput, UserUpdateWithoutUserSettingsInput>, UserUncheckedUpdateWithoutUserSettingsInput>
  }

  export type UserCreateNestedOneWithoutContactInput = {
    create?: XOR<UserCreateWithoutContactInput, UserUncheckedCreateWithoutContactInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutContactNestedInput = {
    create?: XOR<UserCreateWithoutContactInput, UserUncheckedCreateWithoutContactInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactInput
    upsert?: UserUpsertWithoutContactInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactInput, UserUpdateWithoutContactInput>, UserUncheckedUpdateWithoutContactInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetTokensInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetTokensNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetTokensInput
    upsert?: UserUpsertWithoutPasswordResetTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetTokensInput, UserUpdateWithoutPasswordResetTokensInput>, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserCreateNestedOneWithoutAccountSetupTokenInput = {
    create?: XOR<UserCreateWithoutAccountSetupTokenInput, UserUncheckedCreateWithoutAccountSetupTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountSetupTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAccountSetupTokenNestedInput = {
    create?: XOR<UserCreateWithoutAccountSetupTokenInput, UserUncheckedCreateWithoutAccountSetupTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountSetupTokenInput
    upsert?: UserUpsertWithoutAccountSetupTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountSetupTokenInput, UserUpdateWithoutAccountSetupTokenInput>, UserUncheckedUpdateWithoutAccountSetupTokenInput>
  }

  export type CompanyCreateNestedManyWithoutAddressInput = {
    create?: XOR<CompanyCreateWithoutAddressInput, CompanyUncheckedCreateWithoutAddressInput> | CompanyCreateWithoutAddressInput[] | CompanyUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutAddressInput | CompanyCreateOrConnectWithoutAddressInput[]
    createMany?: CompanyCreateManyAddressInputEnvelope
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type JobsiteCreateNestedManyWithoutAddressInput = {
    create?: XOR<JobsiteCreateWithoutAddressInput, JobsiteUncheckedCreateWithoutAddressInput> | JobsiteCreateWithoutAddressInput[] | JobsiteUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: JobsiteCreateOrConnectWithoutAddressInput | JobsiteCreateOrConnectWithoutAddressInput[]
    createMany?: JobsiteCreateManyAddressInputEnvelope
    connect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
  }

  export type CompanyUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<CompanyCreateWithoutAddressInput, CompanyUncheckedCreateWithoutAddressInput> | CompanyCreateWithoutAddressInput[] | CompanyUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutAddressInput | CompanyCreateOrConnectWithoutAddressInput[]
    createMany?: CompanyCreateManyAddressInputEnvelope
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type JobsiteUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<JobsiteCreateWithoutAddressInput, JobsiteUncheckedCreateWithoutAddressInput> | JobsiteCreateWithoutAddressInput[] | JobsiteUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: JobsiteCreateOrConnectWithoutAddressInput | JobsiteCreateOrConnectWithoutAddressInput[]
    createMany?: JobsiteCreateManyAddressInputEnvelope
    connect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
  }

  export type CompanyUpdateManyWithoutAddressNestedInput = {
    create?: XOR<CompanyCreateWithoutAddressInput, CompanyUncheckedCreateWithoutAddressInput> | CompanyCreateWithoutAddressInput[] | CompanyUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutAddressInput | CompanyCreateOrConnectWithoutAddressInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutAddressInput | CompanyUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: CompanyCreateManyAddressInputEnvelope
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutAddressInput | CompanyUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutAddressInput | CompanyUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type JobsiteUpdateManyWithoutAddressNestedInput = {
    create?: XOR<JobsiteCreateWithoutAddressInput, JobsiteUncheckedCreateWithoutAddressInput> | JobsiteCreateWithoutAddressInput[] | JobsiteUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: JobsiteCreateOrConnectWithoutAddressInput | JobsiteCreateOrConnectWithoutAddressInput[]
    upsert?: JobsiteUpsertWithWhereUniqueWithoutAddressInput | JobsiteUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: JobsiteCreateManyAddressInputEnvelope
    set?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    disconnect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    delete?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    connect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    update?: JobsiteUpdateWithWhereUniqueWithoutAddressInput | JobsiteUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: JobsiteUpdateManyWithWhereWithoutAddressInput | JobsiteUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: JobsiteScalarWhereInput | JobsiteScalarWhereInput[]
  }

  export type CompanyUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<CompanyCreateWithoutAddressInput, CompanyUncheckedCreateWithoutAddressInput> | CompanyCreateWithoutAddressInput[] | CompanyUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutAddressInput | CompanyCreateOrConnectWithoutAddressInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutAddressInput | CompanyUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: CompanyCreateManyAddressInputEnvelope
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutAddressInput | CompanyUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutAddressInput | CompanyUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type JobsiteUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<JobsiteCreateWithoutAddressInput, JobsiteUncheckedCreateWithoutAddressInput> | JobsiteCreateWithoutAddressInput[] | JobsiteUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: JobsiteCreateOrConnectWithoutAddressInput | JobsiteCreateOrConnectWithoutAddressInput[]
    upsert?: JobsiteUpsertWithWhereUniqueWithoutAddressInput | JobsiteUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: JobsiteCreateManyAddressInputEnvelope
    set?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    disconnect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    delete?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    connect?: JobsiteWhereUniqueInput | JobsiteWhereUniqueInput[]
    update?: JobsiteUpdateWithWhereUniqueWithoutAddressInput | JobsiteUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: JobsiteUpdateManyWithWhereWithoutAddressInput | JobsiteUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: JobsiteScalarWhereInput | JobsiteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFCMTokenInput = {
    create?: XOR<UserCreateWithoutFCMTokenInput, UserUncheckedCreateWithoutFCMTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutFCMTokenInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFCMTokenNestedInput = {
    create?: XOR<UserCreateWithoutFCMTokenInput, UserUncheckedCreateWithoutFCMTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutFCMTokenInput
    upsert?: UserUpsertWithoutFCMTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFCMTokenInput, UserUpdateWithoutFCMTokenInput>, UserUncheckedUpdateWithoutFCMTokenInput>
  }

  export type UserCreateNestedOneWithoutTopicSubscriptionsInput = {
    create?: XOR<UserCreateWithoutTopicSubscriptionsInput, UserUncheckedCreateWithoutTopicSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTopicSubscriptionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTopicSubscriptionsNestedInput = {
    create?: XOR<UserCreateWithoutTopicSubscriptionsInput, UserUncheckedCreateWithoutTopicSubscriptionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTopicSubscriptionsInput
    upsert?: UserUpsertWithoutTopicSubscriptionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTopicSubscriptionsInput, UserUpdateWithoutTopicSubscriptionsInput>, UserUncheckedUpdateWithoutTopicSubscriptionsInput>
  }

  export type NotificationReadCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationReadCreateWithoutNotificationInput, NotificationReadUncheckedCreateWithoutNotificationInput> | NotificationReadCreateWithoutNotificationInput[] | NotificationReadUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationReadCreateOrConnectWithoutNotificationInput | NotificationReadCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationReadCreateManyNotificationInputEnvelope
    connect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
  }

  export type NotificationResponseCreateNestedOneWithoutNotificationInput = {
    create?: XOR<NotificationResponseCreateWithoutNotificationInput, NotificationResponseUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: NotificationResponseCreateOrConnectWithoutNotificationInput
    connect?: NotificationResponseWhereUniqueInput
  }

  export type NotificationReadUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationReadCreateWithoutNotificationInput, NotificationReadUncheckedCreateWithoutNotificationInput> | NotificationReadCreateWithoutNotificationInput[] | NotificationReadUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationReadCreateOrConnectWithoutNotificationInput | NotificationReadCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationReadCreateManyNotificationInputEnvelope
    connect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
  }

  export type NotificationResponseUncheckedCreateNestedOneWithoutNotificationInput = {
    create?: XOR<NotificationResponseCreateWithoutNotificationInput, NotificationResponseUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: NotificationResponseCreateOrConnectWithoutNotificationInput
    connect?: NotificationResponseWhereUniqueInput
  }

  export type NotificationReadUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationReadCreateWithoutNotificationInput, NotificationReadUncheckedCreateWithoutNotificationInput> | NotificationReadCreateWithoutNotificationInput[] | NotificationReadUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationReadCreateOrConnectWithoutNotificationInput | NotificationReadCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationReadUpsertWithWhereUniqueWithoutNotificationInput | NotificationReadUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationReadCreateManyNotificationInputEnvelope
    set?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    disconnect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    delete?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    connect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    update?: NotificationReadUpdateWithWhereUniqueWithoutNotificationInput | NotificationReadUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationReadUpdateManyWithWhereWithoutNotificationInput | NotificationReadUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationReadScalarWhereInput | NotificationReadScalarWhereInput[]
  }

  export type NotificationResponseUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<NotificationResponseCreateWithoutNotificationInput, NotificationResponseUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: NotificationResponseCreateOrConnectWithoutNotificationInput
    upsert?: NotificationResponseUpsertWithoutNotificationInput
    disconnect?: NotificationResponseWhereInput | boolean
    delete?: NotificationResponseWhereInput | boolean
    connect?: NotificationResponseWhereUniqueInput
    update?: XOR<XOR<NotificationResponseUpdateToOneWithWhereWithoutNotificationInput, NotificationResponseUpdateWithoutNotificationInput>, NotificationResponseUncheckedUpdateWithoutNotificationInput>
  }

  export type NotificationReadUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationReadCreateWithoutNotificationInput, NotificationReadUncheckedCreateWithoutNotificationInput> | NotificationReadCreateWithoutNotificationInput[] | NotificationReadUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationReadCreateOrConnectWithoutNotificationInput | NotificationReadCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationReadUpsertWithWhereUniqueWithoutNotificationInput | NotificationReadUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationReadCreateManyNotificationInputEnvelope
    set?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    disconnect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    delete?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    connect?: NotificationReadWhereUniqueInput | NotificationReadWhereUniqueInput[]
    update?: NotificationReadUpdateWithWhereUniqueWithoutNotificationInput | NotificationReadUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationReadUpdateManyWithWhereWithoutNotificationInput | NotificationReadUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationReadScalarWhereInput | NotificationReadScalarWhereInput[]
  }

  export type NotificationResponseUncheckedUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<NotificationResponseCreateWithoutNotificationInput, NotificationResponseUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: NotificationResponseCreateOrConnectWithoutNotificationInput
    upsert?: NotificationResponseUpsertWithoutNotificationInput
    disconnect?: NotificationResponseWhereInput | boolean
    delete?: NotificationResponseWhereInput | boolean
    connect?: NotificationResponseWhereUniqueInput
    update?: XOR<XOR<NotificationResponseUpdateToOneWithWhereWithoutNotificationInput, NotificationResponseUpdateWithoutNotificationInput>, NotificationResponseUncheckedUpdateWithoutNotificationInput>
  }

  export type NotificationCreateNestedOneWithoutResponseInput = {
    create?: XOR<NotificationCreateWithoutResponseInput, NotificationUncheckedCreateWithoutResponseInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutResponseInput
    connect?: NotificationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationResponseInput = {
    create?: XOR<UserCreateWithoutNotificationResponseInput, UserUncheckedCreateWithoutNotificationResponseInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationResponseInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationUpdateOneRequiredWithoutResponseNestedInput = {
    create?: XOR<NotificationCreateWithoutResponseInput, NotificationUncheckedCreateWithoutResponseInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutResponseInput
    upsert?: NotificationUpsertWithoutResponseInput
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutResponseInput, NotificationUpdateWithoutResponseInput>, NotificationUncheckedUpdateWithoutResponseInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationResponseNestedInput = {
    create?: XOR<UserCreateWithoutNotificationResponseInput, UserUncheckedCreateWithoutNotificationResponseInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationResponseInput
    upsert?: UserUpsertWithoutNotificationResponseInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationResponseInput, UserUpdateWithoutNotificationResponseInput>, UserUncheckedUpdateWithoutNotificationResponseInput>
  }

  export type NotificationCreateNestedOneWithoutReadsInput = {
    create?: XOR<NotificationCreateWithoutReadsInput, NotificationUncheckedCreateWithoutReadsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutReadsInput
    connect?: NotificationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationReadInput = {
    create?: XOR<UserCreateWithoutNotificationReadInput, UserUncheckedCreateWithoutNotificationReadInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationReadInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationUpdateOneRequiredWithoutReadsNestedInput = {
    create?: XOR<NotificationCreateWithoutReadsInput, NotificationUncheckedCreateWithoutReadsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutReadsInput
    upsert?: NotificationUpsertWithoutReadsInput
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutReadsInput, NotificationUpdateWithoutReadsInput>, NotificationUncheckedUpdateWithoutReadsInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationReadNestedInput = {
    create?: XOR<UserCreateWithoutNotificationReadInput, UserUncheckedCreateWithoutNotificationReadInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationReadInput
    upsert?: UserUpsertWithoutNotificationReadInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationReadInput, UserUpdateWithoutNotificationReadInput>, UserUncheckedUpdateWithoutNotificationReadInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumWorkTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkType | EnumWorkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkType[] | ListEnumWorkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkType[] | ListEnumWorkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTypeFilter<$PrismaModel> | $Enums.WorkType
  }

  export type NestedEnumWorkTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkType | EnumWorkTypeFieldRefInput<$PrismaModel>
    in?: $Enums.WorkType[] | ListEnumWorkTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkType[] | ListEnumWorkTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkTypeWithAggregatesFilter<$PrismaModel> | $Enums.WorkType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkTypeFilter<$PrismaModel>
    _max?: NestedEnumWorkTypeFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Bytes
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Bytes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumEquipmentTagsFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentTags | EnumEquipmentTagsFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentTags[] | ListEnumEquipmentTagsFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentTags[] | ListEnumEquipmentTagsFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentTagsFilter<$PrismaModel> | $Enums.EquipmentTags
  }

  export type NestedEnumEquipmentStateFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentState | EnumEquipmentStateFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentState[] | ListEnumEquipmentStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentState[] | ListEnumEquipmentStateFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStateFilter<$PrismaModel> | $Enums.EquipmentState
  }

  export type NestedEnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCreatedViaFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatedVia | EnumCreatedViaFieldRefInput<$PrismaModel>
    in?: $Enums.CreatedVia[] | ListEnumCreatedViaFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreatedVia[] | ListEnumCreatedViaFieldRefInput<$PrismaModel>
    not?: NestedEnumCreatedViaFilter<$PrismaModel> | $Enums.CreatedVia
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumOwnershipTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnershipType | EnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOwnershipTypeNullableFilter<$PrismaModel> | $Enums.OwnershipType | null
  }

  export type NestedEnumConditionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Condition | EnumConditionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Condition[] | ListEnumConditionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Condition[] | ListEnumConditionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConditionNullableFilter<$PrismaModel> | $Enums.Condition | null
  }

  export type NestedEnumFormTemplateStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FormTemplateStatus | EnumFormTemplateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FormTemplateStatus[] | ListEnumFormTemplateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormTemplateStatus[] | ListEnumFormTemplateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFormTemplateStatusFilter<$PrismaModel> | $Enums.FormTemplateStatus
  }

  export type NestedEnumEquipmentTagsWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentTags | EnumEquipmentTagsFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentTags[] | ListEnumEquipmentTagsFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentTags[] | ListEnumEquipmentTagsFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentTagsWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentTags
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentTagsFilter<$PrismaModel>
    _max?: NestedEnumEquipmentTagsFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentState | EnumEquipmentStateFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentState[] | ListEnumEquipmentStateFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentState[] | ListEnumEquipmentStateFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStateWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentStateFilter<$PrismaModel>
    _max?: NestedEnumEquipmentStateFilter<$PrismaModel>
  }

  export type NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumCreatedViaWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreatedVia | EnumCreatedViaFieldRefInput<$PrismaModel>
    in?: $Enums.CreatedVia[] | ListEnumCreatedViaFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreatedVia[] | ListEnumCreatedViaFieldRefInput<$PrismaModel>
    not?: NestedEnumCreatedViaWithAggregatesFilter<$PrismaModel> | $Enums.CreatedVia
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreatedViaFilter<$PrismaModel>
    _max?: NestedEnumCreatedViaFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumOwnershipTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OwnershipType | EnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OwnershipType[] | ListEnumOwnershipTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOwnershipTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.OwnershipType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOwnershipTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumOwnershipTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumConditionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Condition | EnumConditionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Condition[] | ListEnumConditionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Condition[] | ListEnumConditionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumConditionNullableWithAggregatesFilter<$PrismaModel> | $Enums.Condition | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumConditionNullableFilter<$PrismaModel>
    _max?: NestedEnumConditionNullableFilter<$PrismaModel>
  }

  export type NestedEnumFormTemplateStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormTemplateStatus | EnumFormTemplateStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FormTemplateStatus[] | ListEnumFormTemplateStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormTemplateStatus[] | ListEnumFormTemplateStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFormTemplateStatusWithAggregatesFilter<$PrismaModel> | $Enums.FormTemplateStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormTemplateStatusFilter<$PrismaModel>
    _max?: NestedEnumFormTemplateStatusFilter<$PrismaModel>
  }

  export type NestedEnumFormTemplateCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FormTemplateCategory | EnumFormTemplateCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FormTemplateCategory[] | ListEnumFormTemplateCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormTemplateCategory[] | ListEnumFormTemplateCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFormTemplateCategoryFilter<$PrismaModel> | $Enums.FormTemplateCategory
  }

  export type NestedEnumFormTemplateCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormTemplateCategory | EnumFormTemplateCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FormTemplateCategory[] | ListEnumFormTemplateCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormTemplateCategory[] | ListEnumFormTemplateCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFormTemplateCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FormTemplateCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormTemplateCategoryFilter<$PrismaModel>
    _max?: NestedEnumFormTemplateCategoryFilter<$PrismaModel>
  }

  export type NestedEnumFieldTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldTypeFilter<$PrismaModel> | $Enums.FieldType
  }

  export type NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel> | $Enums.FieldType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFieldTypeFilter<$PrismaModel>
    _max?: NestedEnumFieldTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumFormStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FormStatus | EnumFormStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FormStatus[] | ListEnumFormStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormStatus[] | ListEnumFormStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFormStatusFilter<$PrismaModel> | $Enums.FormStatus
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumFormStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FormStatus | EnumFormStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FormStatus[] | ListEnumFormStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FormStatus[] | ListEnumFormStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFormStatusWithAggregatesFilter<$PrismaModel> | $Enums.FormStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFormStatusFilter<$PrismaModel>
    _max?: NestedEnumFormStatusFilter<$PrismaModel>
  }

  export type NestedEnumReportVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportVisibility | EnumReportVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ReportVisibility[] | ListEnumReportVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportVisibility[] | ListEnumReportVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumReportVisibilityFilter<$PrismaModel> | $Enums.ReportVisibility
  }

  export type NestedEnumReportVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportVisibility | EnumReportVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ReportVisibility[] | ListEnumReportVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportVisibility[] | ListEnumReportVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumReportVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.ReportVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportVisibilityFilter<$PrismaModel>
    _max?: NestedEnumReportVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumLoadTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.LoadType | EnumLoadTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.LoadType[] | ListEnumLoadTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LoadType[] | ListEnumLoadTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLoadTypeNullableFilter<$PrismaModel> | $Enums.LoadType | null
  }

  export type NestedEnumLoadTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LoadType | EnumLoadTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.LoadType[] | ListEnumLoadTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.LoadType[] | ListEnumLoadTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumLoadTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.LoadType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumLoadTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumLoadTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnummaterialUnitNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.materialUnit | EnummaterialUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.materialUnit[] | ListEnummaterialUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.materialUnit[] | ListEnummaterialUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnummaterialUnitNullableFilter<$PrismaModel> | $Enums.materialUnit | null
  }

  export type NestedEnummaterialUnitNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.materialUnit | EnummaterialUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.materialUnit[] | ListEnummaterialUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.materialUnit[] | ListEnummaterialUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnummaterialUnitNullableWithAggregatesFilter<$PrismaModel> | $Enums.materialUnit | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnummaterialUnitNullableFilter<$PrismaModel>
    _max?: NestedEnummaterialUnitNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPermissionFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionFilter<$PrismaModel> | $Enums.Permission
  }

  export type NestedEnumPermissionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Permission | EnumPermissionFieldRefInput<$PrismaModel>
    in?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    notIn?: $Enums.Permission[] | ListEnumPermissionFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionWithAggregatesFilter<$PrismaModel> | $Enums.Permission
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionFilter<$PrismaModel>
    _max?: NestedEnumPermissionFilter<$PrismaModel>
  }

  export type AddressCreateWithoutCompanyInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country?: string
    Jobsite?: JobsiteCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutCompanyInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country?: string
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutCompanyInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutCompanyInput, AddressUncheckedCreateWithoutCompanyInput>
  }

  export type FormTemplateCreateWithoutCompanyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isSignatureRequired?: boolean
    description?: string | null
    isActive?: $Enums.FormTemplateStatus
    formType?: $Enums.FormTemplateCategory
    isApprovalRequired?: boolean
    Submissions?: FormSubmissionCreateNestedManyWithoutFormTemplateInput
    FormGrouping?: FormGroupingCreateNestedManyWithoutFormTemplateInput
  }

  export type FormTemplateUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isSignatureRequired?: boolean
    description?: string | null
    isActive?: $Enums.FormTemplateStatus
    formType?: $Enums.FormTemplateCategory
    isApprovalRequired?: boolean
    Submissions?: FormSubmissionUncheckedCreateNestedManyWithoutFormTemplateInput
    FormGrouping?: FormGroupingUncheckedCreateNestedManyWithoutFormTemplateInput
  }

  export type FormTemplateCreateOrConnectWithoutCompanyInput = {
    where: FormTemplateWhereUniqueInput
    create: XOR<FormTemplateCreateWithoutCompanyInput, FormTemplateUncheckedCreateWithoutCompanyInput>
  }

  export type FormTemplateCreateManyCompanyInputEnvelope = {
    data: FormTemplateCreateManyCompanyInput | FormTemplateCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutCompanyInput = {
    name: string
    description: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.ReportVisibility
    tags?: ReportCreatetagsInput | string[]
    id: number
    ReportRuns?: ReportRunCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutCompanyInput = {
    name: string
    description: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.ReportVisibility
    tags?: ReportCreatetagsInput | string[]
    id: number
    ReportRuns?: ReportRunUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutCompanyInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput>
  }

  export type ReportCreateManyCompanyInputEnvelope = {
    data: ReportCreateManyCompanyInput | ReportCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCompanyInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Contact?: ContactsCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutCompanyInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutCompanyInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserCreateManyCompanyInputEnvelope = {
    data: UserCreateManyCompanyInput | UserCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithoutCompanyInput = {
    update: XOR<AddressUpdateWithoutCompanyInput, AddressUncheckedUpdateWithoutCompanyInput>
    create: XOR<AddressCreateWithoutCompanyInput, AddressUncheckedCreateWithoutCompanyInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutCompanyInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutCompanyInput, AddressUncheckedUpdateWithoutCompanyInput>
  }

  export type AddressUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Jobsite?: JobsiteUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Jobsite?: JobsiteUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type FormTemplateUpsertWithWhereUniqueWithoutCompanyInput = {
    where: FormTemplateWhereUniqueInput
    update: XOR<FormTemplateUpdateWithoutCompanyInput, FormTemplateUncheckedUpdateWithoutCompanyInput>
    create: XOR<FormTemplateCreateWithoutCompanyInput, FormTemplateUncheckedCreateWithoutCompanyInput>
  }

  export type FormTemplateUpdateWithWhereUniqueWithoutCompanyInput = {
    where: FormTemplateWhereUniqueInput
    data: XOR<FormTemplateUpdateWithoutCompanyInput, FormTemplateUncheckedUpdateWithoutCompanyInput>
  }

  export type FormTemplateUpdateManyWithWhereWithoutCompanyInput = {
    where: FormTemplateScalarWhereInput
    data: XOR<FormTemplateUpdateManyMutationInput, FormTemplateUncheckedUpdateManyWithoutCompanyInput>
  }

  export type FormTemplateScalarWhereInput = {
    AND?: FormTemplateScalarWhereInput | FormTemplateScalarWhereInput[]
    OR?: FormTemplateScalarWhereInput[]
    NOT?: FormTemplateScalarWhereInput | FormTemplateScalarWhereInput[]
    id?: StringFilter<"FormTemplate"> | string
    companyId?: StringFilter<"FormTemplate"> | string
    name?: StringFilter<"FormTemplate"> | string
    createdAt?: DateTimeFilter<"FormTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"FormTemplate"> | Date | string
    isSignatureRequired?: BoolFilter<"FormTemplate"> | boolean
    description?: StringNullableFilter<"FormTemplate"> | string | null
    isActive?: EnumFormTemplateStatusFilter<"FormTemplate"> | $Enums.FormTemplateStatus
    formType?: EnumFormTemplateCategoryFilter<"FormTemplate"> | $Enums.FormTemplateCategory
    isApprovalRequired?: BoolFilter<"FormTemplate"> | boolean
  }

  export type ReportUpsertWithWhereUniqueWithoutCompanyInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutCompanyInput, ReportUncheckedUpdateWithoutCompanyInput>
    create: XOR<ReportCreateWithoutCompanyInput, ReportUncheckedCreateWithoutCompanyInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutCompanyInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutCompanyInput, ReportUncheckedUpdateWithoutCompanyInput>
  }

  export type ReportUpdateManyWithWhereWithoutCompanyInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutCompanyInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    name?: StringFilter<"Report"> | string
    description?: StringFilter<"Report"> | string
    companyId?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
    createdBy?: StringFilter<"Report"> | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    parameters?: JsonNullableFilter<"Report">
    visibility?: EnumReportVisibilityFilter<"Report"> | $Enums.ReportVisibility
    tags?: StringNullableListFilter<"Report">
    id?: IntFilter<"Report"> | number
  }

  export type UserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCreateWithoutCompanyInput, UserUncheckedCreateWithoutCompanyInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCompanyInput, UserUncheckedUpdateWithoutCompanyInput>
  }

  export type UserUpdateManyWithWhereWithoutCompanyInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    signature?: StringNullableFilter<"User"> | string | null
    DOB?: DateTimeNullableFilter<"User"> | Date | string | null
    truckView?: BoolFilter<"User"> | boolean
    tascoView?: BoolFilter<"User"> | boolean
    laborView?: BoolFilter<"User"> | boolean
    mechanicView?: BoolFilter<"User"> | boolean
    permission?: EnumPermissionFilter<"User"> | $Enums.Permission
    image?: StringNullableFilter<"User"> | string | null
    startDate?: DateTimeNullableFilter<"User"> | Date | string | null
    terminationDate?: DateTimeNullableFilter<"User"> | Date | string | null
    accountSetup?: BoolFilter<"User"> | boolean
    clockedIn?: BoolFilter<"User"> | boolean
    companyId?: StringFilter<"User"> | string
    passwordResetTokenId?: StringNullableFilter<"User"> | string | null
    workTypeId?: StringNullableFilter<"User"> | string | null
    middleName?: StringNullableFilter<"User"> | string | null
    secondLastName?: StringNullableFilter<"User"> | string | null
    lastSeen?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type TimeSheetCreateWithoutCostCodeInput = {
    date: Date | string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutTimeSheetInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogCreateNestedManyWithoutTimeSheetInput
    Jobsite: JobsiteCreateNestedOneWithoutTimeSheetsInput
    User: UserCreateNestedOneWithoutTimeSheetsInput
    ChangeLogs?: TimeSheetChangeLogCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetUncheckedCreateWithoutCostCodeInput = {
    date: Date | string
    userId: string
    jobsiteId: string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    id?: number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutTimeSheetInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutTimeSheetInput
    ChangeLogs?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogUncheckedCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetCreateOrConnectWithoutCostCodeInput = {
    where: TimeSheetWhereUniqueInput
    create: XOR<TimeSheetCreateWithoutCostCodeInput, TimeSheetUncheckedCreateWithoutCostCodeInput>
  }

  export type TimeSheetCreateManyCostCodeInputEnvelope = {
    data: TimeSheetCreateManyCostCodeInput | TimeSheetCreateManyCostCodeInput[]
    skipDuplicates?: boolean
  }

  export type CCTagCreateWithoutCostCodesInput = {
    id?: string
    name: string
    description?: string | null
    Jobsites?: JobsiteCreateNestedManyWithoutCCTagsInput
  }

  export type CCTagUncheckedCreateWithoutCostCodesInput = {
    id?: string
    name: string
    description?: string | null
    Jobsites?: JobsiteUncheckedCreateNestedManyWithoutCCTagsInput
  }

  export type CCTagCreateOrConnectWithoutCostCodesInput = {
    where: CCTagWhereUniqueInput
    create: XOR<CCTagCreateWithoutCostCodesInput, CCTagUncheckedCreateWithoutCostCodesInput>
  }

  export type TimeSheetUpsertWithWhereUniqueWithoutCostCodeInput = {
    where: TimeSheetWhereUniqueInput
    update: XOR<TimeSheetUpdateWithoutCostCodeInput, TimeSheetUncheckedUpdateWithoutCostCodeInput>
    create: XOR<TimeSheetCreateWithoutCostCodeInput, TimeSheetUncheckedCreateWithoutCostCodeInput>
  }

  export type TimeSheetUpdateWithWhereUniqueWithoutCostCodeInput = {
    where: TimeSheetWhereUniqueInput
    data: XOR<TimeSheetUpdateWithoutCostCodeInput, TimeSheetUncheckedUpdateWithoutCostCodeInput>
  }

  export type TimeSheetUpdateManyWithWhereWithoutCostCodeInput = {
    where: TimeSheetScalarWhereInput
    data: XOR<TimeSheetUpdateManyMutationInput, TimeSheetUncheckedUpdateManyWithoutCostCodeInput>
  }

  export type TimeSheetScalarWhereInput = {
    AND?: TimeSheetScalarWhereInput | TimeSheetScalarWhereInput[]
    OR?: TimeSheetScalarWhereInput[]
    NOT?: TimeSheetScalarWhereInput | TimeSheetScalarWhereInput[]
    date?: DateTimeFilter<"TimeSheet"> | Date | string
    userId?: StringFilter<"TimeSheet"> | string
    jobsiteId?: StringFilter<"TimeSheet"> | string
    costcode?: StringFilter<"TimeSheet"> | string
    nu?: StringFilter<"TimeSheet"> | string
    Fp?: StringFilter<"TimeSheet"> | string
    startTime?: DateTimeFilter<"TimeSheet"> | Date | string
    endTime?: DateTimeNullableFilter<"TimeSheet"> | Date | string | null
    comment?: StringNullableFilter<"TimeSheet"> | string | null
    statusComment?: StringNullableFilter<"TimeSheet"> | string | null
    location?: StringNullableFilter<"TimeSheet"> | string | null
    status?: EnumApprovalStatusFilter<"TimeSheet"> | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFilter<"TimeSheet"> | $Enums.WorkType
    editedByUserId?: StringNullableFilter<"TimeSheet"> | string | null
    newTimeSheetId?: StringNullableFilter<"TimeSheet"> | string | null
    createdByAdmin?: BoolFilter<"TimeSheet"> | boolean
    createdAt?: DateTimeFilter<"TimeSheet"> | Date | string
    updatedAt?: DateTimeFilter<"TimeSheet"> | Date | string
    clockInLat?: FloatNullableFilter<"TimeSheet"> | number | null
    clockInLng?: FloatNullableFilter<"TimeSheet"> | number | null
    clockOutLat?: FloatNullableFilter<"TimeSheet"> | number | null
    clockOutLng?: FloatNullableFilter<"TimeSheet"> | number | null
    withinFenceIn?: BoolNullableFilter<"TimeSheet"> | boolean | null
    withinFenceOut?: BoolNullableFilter<"TimeSheet"> | boolean | null
    wasInjured?: BoolNullableFilter<"TimeSheet"> | boolean | null
    id?: IntFilter<"TimeSheet"> | number
  }

  export type CCTagUpsertWithWhereUniqueWithoutCostCodesInput = {
    where: CCTagWhereUniqueInput
    update: XOR<CCTagUpdateWithoutCostCodesInput, CCTagUncheckedUpdateWithoutCostCodesInput>
    create: XOR<CCTagCreateWithoutCostCodesInput, CCTagUncheckedCreateWithoutCostCodesInput>
  }

  export type CCTagUpdateWithWhereUniqueWithoutCostCodesInput = {
    where: CCTagWhereUniqueInput
    data: XOR<CCTagUpdateWithoutCostCodesInput, CCTagUncheckedUpdateWithoutCostCodesInput>
  }

  export type CCTagUpdateManyWithWhereWithoutCostCodesInput = {
    where: CCTagScalarWhereInput
    data: XOR<CCTagUpdateManyMutationInput, CCTagUncheckedUpdateManyWithoutCostCodesInput>
  }

  export type CCTagScalarWhereInput = {
    AND?: CCTagScalarWhereInput | CCTagScalarWhereInput[]
    OR?: CCTagScalarWhereInput[]
    NOT?: CCTagScalarWhereInput | CCTagScalarWhereInput[]
    id?: StringFilter<"CCTag"> | string
    name?: StringFilter<"CCTag"> | string
    description?: StringNullableFilter<"CCTag"> | string | null
  }

  export type CostCodeCreateWithoutCCTagsInput = {
    id?: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code?: string | null
    Timesheets?: TimeSheetCreateNestedManyWithoutCostCodeInput
  }

  export type CostCodeUncheckedCreateWithoutCCTagsInput = {
    id?: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code?: string | null
    Timesheets?: TimeSheetUncheckedCreateNestedManyWithoutCostCodeInput
  }

  export type CostCodeCreateOrConnectWithoutCCTagsInput = {
    where: CostCodeWhereUniqueInput
    create: XOR<CostCodeCreateWithoutCCTagsInput, CostCodeUncheckedCreateWithoutCCTagsInput>
  }

  export type JobsiteCreateWithoutCCTagsInput = {
    id?: string
    qrId?: string
    name: string
    description: string
    creationReason?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    archiveDate?: Date | string | null
    createdVia?: $Enums.CreatedVia
    code?: string | null
    latitude?: number | null
    longitude?: number | null
    radiusMeters?: number | null
    status?: $Enums.FormTemplateStatus
    Address?: AddressCreateNestedOneWithoutJobsiteInput
    createdBy?: UserCreateNestedOneWithoutJobsiteInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutJobsiteInput
  }

  export type JobsiteUncheckedCreateWithoutCCTagsInput = {
    id?: string
    qrId?: string
    name: string
    description: string
    creationReason?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    addressId?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    archiveDate?: Date | string | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    code?: string | null
    latitude?: number | null
    longitude?: number | null
    radiusMeters?: number | null
    status?: $Enums.FormTemplateStatus
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutJobsiteInput
  }

  export type JobsiteCreateOrConnectWithoutCCTagsInput = {
    where: JobsiteWhereUniqueInput
    create: XOR<JobsiteCreateWithoutCCTagsInput, JobsiteUncheckedCreateWithoutCCTagsInput>
  }

  export type CostCodeUpsertWithWhereUniqueWithoutCCTagsInput = {
    where: CostCodeWhereUniqueInput
    update: XOR<CostCodeUpdateWithoutCCTagsInput, CostCodeUncheckedUpdateWithoutCCTagsInput>
    create: XOR<CostCodeCreateWithoutCCTagsInput, CostCodeUncheckedCreateWithoutCCTagsInput>
  }

  export type CostCodeUpdateWithWhereUniqueWithoutCCTagsInput = {
    where: CostCodeWhereUniqueInput
    data: XOR<CostCodeUpdateWithoutCCTagsInput, CostCodeUncheckedUpdateWithoutCCTagsInput>
  }

  export type CostCodeUpdateManyWithWhereWithoutCCTagsInput = {
    where: CostCodeScalarWhereInput
    data: XOR<CostCodeUpdateManyMutationInput, CostCodeUncheckedUpdateManyWithoutCCTagsInput>
  }

  export type CostCodeScalarWhereInput = {
    AND?: CostCodeScalarWhereInput | CostCodeScalarWhereInput[]
    OR?: CostCodeScalarWhereInput[]
    NOT?: CostCodeScalarWhereInput | CostCodeScalarWhereInput[]
    id?: StringFilter<"CostCode"> | string
    name?: StringFilter<"CostCode"> | string
    isActive?: BoolFilter<"CostCode"> | boolean
    createdAt?: DateTimeFilter<"CostCode"> | Date | string
    updatedAt?: DateTimeFilter<"CostCode"> | Date | string
    code?: StringNullableFilter<"CostCode"> | string | null
  }

  export type JobsiteUpsertWithWhereUniqueWithoutCCTagsInput = {
    where: JobsiteWhereUniqueInput
    update: XOR<JobsiteUpdateWithoutCCTagsInput, JobsiteUncheckedUpdateWithoutCCTagsInput>
    create: XOR<JobsiteCreateWithoutCCTagsInput, JobsiteUncheckedCreateWithoutCCTagsInput>
  }

  export type JobsiteUpdateWithWhereUniqueWithoutCCTagsInput = {
    where: JobsiteWhereUniqueInput
    data: XOR<JobsiteUpdateWithoutCCTagsInput, JobsiteUncheckedUpdateWithoutCCTagsInput>
  }

  export type JobsiteUpdateManyWithWhereWithoutCCTagsInput = {
    where: JobsiteScalarWhereInput
    data: XOR<JobsiteUpdateManyMutationInput, JobsiteUncheckedUpdateManyWithoutCCTagsInput>
  }

  export type JobsiteScalarWhereInput = {
    AND?: JobsiteScalarWhereInput | JobsiteScalarWhereInput[]
    OR?: JobsiteScalarWhereInput[]
    NOT?: JobsiteScalarWhereInput | JobsiteScalarWhereInput[]
    id?: StringFilter<"Jobsite"> | string
    qrId?: StringFilter<"Jobsite"> | string
    name?: StringFilter<"Jobsite"> | string
    description?: StringFilter<"Jobsite"> | string
    creationReason?: StringNullableFilter<"Jobsite"> | string | null
    approvalStatus?: EnumApprovalStatusFilter<"Jobsite"> | $Enums.ApprovalStatus
    addressId?: StringNullableFilter<"Jobsite"> | string | null
    comment?: StringNullableFilter<"Jobsite"> | string | null
    createdAt?: DateTimeFilter<"Jobsite"> | Date | string
    updatedAt?: DateTimeFilter<"Jobsite"> | Date | string
    archiveDate?: DateTimeNullableFilter<"Jobsite"> | Date | string | null
    createdById?: StringNullableFilter<"Jobsite"> | string | null
    createdVia?: EnumCreatedViaFilter<"Jobsite"> | $Enums.CreatedVia
    code?: StringNullableFilter<"Jobsite"> | string | null
    latitude?: FloatNullableFilter<"Jobsite"> | number | null
    longitude?: FloatNullableFilter<"Jobsite"> | number | null
    radiusMeters?: FloatNullableFilter<"Jobsite"> | number | null
    status?: EnumFormTemplateStatusFilter<"Jobsite"> | $Enums.FormTemplateStatus
  }

  export type UserCreateWithoutCrewsInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Contact?: ContactsCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCrewsInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCrewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCrewsInput, UserUncheckedCreateWithoutCrewsInput>
  }

  export type UserUpsertWithWhereUniqueWithoutCrewsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCrewsInput, UserUncheckedUpdateWithoutCrewsInput>
    create: XOR<UserCreateWithoutCrewsInput, UserUncheckedCreateWithoutCrewsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCrewsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCrewsInput, UserUncheckedUpdateWithoutCrewsInput>
  }

  export type UserUpdateManyWithWhereWithoutCrewsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutCrewsInput>
  }

  export type DocumentTagCreateWithoutDocumentsInput = {
    id?: string
    tagName: string
    Equipment?: EquipmentCreateNestedManyWithoutDocumentTagsInput
  }

  export type DocumentTagUncheckedCreateWithoutDocumentsInput = {
    id?: string
    tagName: string
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutDocumentTagsInput
  }

  export type DocumentTagCreateOrConnectWithoutDocumentsInput = {
    where: DocumentTagWhereUniqueInput
    create: XOR<DocumentTagCreateWithoutDocumentsInput, DocumentTagUncheckedCreateWithoutDocumentsInput>
  }

  export type DocumentTagUpsertWithWhereUniqueWithoutDocumentsInput = {
    where: DocumentTagWhereUniqueInput
    update: XOR<DocumentTagUpdateWithoutDocumentsInput, DocumentTagUncheckedUpdateWithoutDocumentsInput>
    create: XOR<DocumentTagCreateWithoutDocumentsInput, DocumentTagUncheckedCreateWithoutDocumentsInput>
  }

  export type DocumentTagUpdateWithWhereUniqueWithoutDocumentsInput = {
    where: DocumentTagWhereUniqueInput
    data: XOR<DocumentTagUpdateWithoutDocumentsInput, DocumentTagUncheckedUpdateWithoutDocumentsInput>
  }

  export type DocumentTagUpdateManyWithWhereWithoutDocumentsInput = {
    where: DocumentTagScalarWhereInput
    data: XOR<DocumentTagUpdateManyMutationInput, DocumentTagUncheckedUpdateManyWithoutDocumentsInput>
  }

  export type DocumentTagScalarWhereInput = {
    AND?: DocumentTagScalarWhereInput | DocumentTagScalarWhereInput[]
    OR?: DocumentTagScalarWhereInput[]
    NOT?: DocumentTagScalarWhereInput | DocumentTagScalarWhereInput[]
    id?: StringFilter<"DocumentTag"> | string
    tagName?: StringFilter<"DocumentTag"> | string
  }

  export type EquipmentCreateWithoutDocumentTagsInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutEquipmentInput
    createdBy?: UserCreateNestedOneWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutDocumentTagsInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogUncheckedCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogUncheckedCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogUncheckedCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutDocumentTagsInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutDocumentTagsInput, EquipmentUncheckedCreateWithoutDocumentTagsInput>
  }

  export type PdfDocumentCreateWithoutDocumentTagsInput = {
    id?: string
    qrId: string
    fileName: string
    description?: string | null
    fileData: Bytes
    contentType?: string
    size: number
    isActive?: boolean
    createdAt?: Date | string
    uploadDate?: Date | string
  }

  export type PdfDocumentUncheckedCreateWithoutDocumentTagsInput = {
    id?: string
    qrId: string
    fileName: string
    description?: string | null
    fileData: Bytes
    contentType?: string
    size: number
    isActive?: boolean
    createdAt?: Date | string
    uploadDate?: Date | string
  }

  export type PdfDocumentCreateOrConnectWithoutDocumentTagsInput = {
    where: PdfDocumentWhereUniqueInput
    create: XOR<PdfDocumentCreateWithoutDocumentTagsInput, PdfDocumentUncheckedCreateWithoutDocumentTagsInput>
  }

  export type EquipmentUpsertWithWhereUniqueWithoutDocumentTagsInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutDocumentTagsInput, EquipmentUncheckedUpdateWithoutDocumentTagsInput>
    create: XOR<EquipmentCreateWithoutDocumentTagsInput, EquipmentUncheckedCreateWithoutDocumentTagsInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutDocumentTagsInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutDocumentTagsInput, EquipmentUncheckedUpdateWithoutDocumentTagsInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutDocumentTagsInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutDocumentTagsInput>
  }

  export type EquipmentScalarWhereInput = {
    AND?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    OR?: EquipmentScalarWhereInput[]
    NOT?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    id?: StringFilter<"Equipment"> | string
    qrId?: StringFilter<"Equipment"> | string
    name?: StringFilter<"Equipment"> | string
    description?: StringNullableFilter<"Equipment"> | string | null
    creationReason?: StringNullableFilter<"Equipment"> | string | null
    equipmentTag?: EnumEquipmentTagsFilter<"Equipment"> | $Enums.EquipmentTags
    state?: EnumEquipmentStateFilter<"Equipment"> | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFilter<"Equipment"> | $Enums.ApprovalStatus
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    overWeight?: BoolNullableFilter<"Equipment"> | boolean | null
    currentWeight?: FloatNullableFilter<"Equipment"> | number | null
    createdById?: StringNullableFilter<"Equipment"> | string | null
    createdVia?: EnumCreatedViaFilter<"Equipment"> | $Enums.CreatedVia
    acquiredDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    code?: StringNullableFilter<"Equipment"> | string | null
    color?: StringNullableFilter<"Equipment"> | string | null
    licensePlate?: StringNullableFilter<"Equipment"> | string | null
    licenseState?: StringNullableFilter<"Equipment"> | string | null
    make?: StringNullableFilter<"Equipment"> | string | null
    memo?: StringNullableFilter<"Equipment"> | string | null
    model?: StringNullableFilter<"Equipment"> | string | null
    ownershipType?: EnumOwnershipTypeNullableFilter<"Equipment"> | $Enums.OwnershipType | null
    registrationExpiration?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    serialNumber?: StringNullableFilter<"Equipment"> | string | null
    year?: StringNullableFilter<"Equipment"> | string | null
    acquiredCondition?: EnumConditionNullableFilter<"Equipment"> | $Enums.Condition | null
    status?: EnumFormTemplateStatusFilter<"Equipment"> | $Enums.FormTemplateStatus
  }

  export type PdfDocumentUpsertWithWhereUniqueWithoutDocumentTagsInput = {
    where: PdfDocumentWhereUniqueInput
    update: XOR<PdfDocumentUpdateWithoutDocumentTagsInput, PdfDocumentUncheckedUpdateWithoutDocumentTagsInput>
    create: XOR<PdfDocumentCreateWithoutDocumentTagsInput, PdfDocumentUncheckedCreateWithoutDocumentTagsInput>
  }

  export type PdfDocumentUpdateWithWhereUniqueWithoutDocumentTagsInput = {
    where: PdfDocumentWhereUniqueInput
    data: XOR<PdfDocumentUpdateWithoutDocumentTagsInput, PdfDocumentUncheckedUpdateWithoutDocumentTagsInput>
  }

  export type PdfDocumentUpdateManyWithWhereWithoutDocumentTagsInput = {
    where: PdfDocumentScalarWhereInput
    data: XOR<PdfDocumentUpdateManyMutationInput, PdfDocumentUncheckedUpdateManyWithoutDocumentTagsInput>
  }

  export type PdfDocumentScalarWhereInput = {
    AND?: PdfDocumentScalarWhereInput | PdfDocumentScalarWhereInput[]
    OR?: PdfDocumentScalarWhereInput[]
    NOT?: PdfDocumentScalarWhereInput | PdfDocumentScalarWhereInput[]
    id?: StringFilter<"PdfDocument"> | string
    qrId?: StringFilter<"PdfDocument"> | string
    fileName?: StringFilter<"PdfDocument"> | string
    description?: StringNullableFilter<"PdfDocument"> | string | null
    fileData?: BytesFilter<"PdfDocument"> | Bytes
    contentType?: StringFilter<"PdfDocument"> | string
    size?: IntFilter<"PdfDocument"> | number
    isActive?: BoolFilter<"PdfDocument"> | boolean
    createdAt?: DateTimeFilter<"PdfDocument"> | Date | string
    uploadDate?: DateTimeFilter<"PdfDocument"> | Date | string
  }

  export type EmployeeEquipmentLogCreateWithoutEquipmentInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    comment?: string | null
    rental?: boolean
    Maintenance?: MaintenanceCreateNestedOneWithoutEmployeeEquipmentLogInput
    TimeSheet: TimeSheetCreateNestedOneWithoutEmployeeEquipmentLogsInput
    RefuelLog?: RefuelLogCreateNestedOneWithoutEmployeeEquipmentLogInput
  }

  export type EmployeeEquipmentLogUncheckedCreateWithoutEquipmentInput = {
    id?: string
    maintenanceId?: string | null
    startTime?: Date | string
    endTime?: Date | string | null
    comment?: string | null
    timeSheetId: number
    rental?: boolean
    RefuelLog?: RefuelLogUncheckedCreateNestedOneWithoutEmployeeEquipmentLogInput
  }

  export type EmployeeEquipmentLogCreateOrConnectWithoutEquipmentInput = {
    where: EmployeeEquipmentLogWhereUniqueInput
    create: XOR<EmployeeEquipmentLogCreateWithoutEquipmentInput, EmployeeEquipmentLogUncheckedCreateWithoutEquipmentInput>
  }

  export type EmployeeEquipmentLogCreateManyEquipmentInputEnvelope = {
    data: EmployeeEquipmentLogCreateManyEquipmentInput | EmployeeEquipmentLogCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutEquipmentInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Contact?: ContactsCreateNestedOneWithoutUserInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutEquipmentInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutEquipmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEquipmentInput, UserUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentHauledCreateWithoutEquipmentInput = {
    id?: string
    createdAt?: Date | string
    endMileage?: number | null
    startMileage?: number | null
    destination?: string | null
    source?: string | null
    TruckingLog?: TruckingLogCreateNestedOneWithoutEquipmentHauledInput
  }

  export type EquipmentHauledUncheckedCreateWithoutEquipmentInput = {
    id?: string
    truckingLogId?: string | null
    createdAt?: Date | string
    endMileage?: number | null
    startMileage?: number | null
    destination?: string | null
    source?: string | null
  }

  export type EquipmentHauledCreateOrConnectWithoutEquipmentInput = {
    where: EquipmentHauledWhereUniqueInput
    create: XOR<EquipmentHauledCreateWithoutEquipmentInput, EquipmentHauledUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentHauledCreateManyEquipmentInputEnvelope = {
    data: EquipmentHauledCreateManyEquipmentInput | EquipmentHauledCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceCreateWithoutEquipmentInput = {
    id?: string
    equipmentIssue?: string | null
    employeeEquipmentLogId?: string | null
    additionalInfo?: string | null
    location?: string | null
    problemDiagnosis?: string | null
    solution?: string | null
    totalHoursLaboured?: number | null
    createdAt?: Date | string
    priority: $Enums.Priority
    delay?: Date | string | null
    delayReasoning?: string | null
    repaired?: boolean
    selected?: boolean
    hasBeenDelayed?: boolean
    createdBy?: string | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogCreateNestedManyWithoutMaintenanceInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutMaintenanceInput
  }

  export type MaintenanceUncheckedCreateWithoutEquipmentInput = {
    id?: string
    equipmentIssue?: string | null
    employeeEquipmentLogId?: string | null
    additionalInfo?: string | null
    location?: string | null
    problemDiagnosis?: string | null
    solution?: string | null
    totalHoursLaboured?: number | null
    createdAt?: Date | string
    priority: $Enums.Priority
    delay?: Date | string | null
    delayReasoning?: string | null
    repaired?: boolean
    selected?: boolean
    hasBeenDelayed?: boolean
    createdBy?: string | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutMaintenanceInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutMaintenanceInput
  }

  export type MaintenanceCreateOrConnectWithoutEquipmentInput = {
    where: MaintenanceWhereUniqueInput
    create: XOR<MaintenanceCreateWithoutEquipmentInput, MaintenanceUncheckedCreateWithoutEquipmentInput>
  }

  export type MaintenanceCreateManyEquipmentInputEnvelope = {
    data: MaintenanceCreateManyEquipmentInput | MaintenanceCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type TascoLogCreateWithoutEquipmentInput = {
    id?: string
    shiftType: string
    laborType?: string | null
    LoadQuantity?: number
    screenType?: $Enums.LoadType | null
    RefuelLogs?: RefuelLogCreateNestedManyWithoutTascoLogInput
    TascoFLoads?: TascoFLoadsCreateNestedManyWithoutTascoLogInput
    TascoMaterialTypes?: TascoMaterialTypesCreateNestedOneWithoutTascoLogInput
    TimeSheet: TimeSheetCreateNestedOneWithoutTascoLogsInput
  }

  export type TascoLogUncheckedCreateWithoutEquipmentInput = {
    id?: string
    shiftType: string
    laborType?: string | null
    materialType?: string | null
    LoadQuantity?: number
    screenType?: $Enums.LoadType | null
    timeSheetId: number
    RefuelLogs?: RefuelLogUncheckedCreateNestedManyWithoutTascoLogInput
    TascoFLoads?: TascoFLoadsUncheckedCreateNestedManyWithoutTascoLogInput
  }

  export type TascoLogCreateOrConnectWithoutEquipmentInput = {
    where: TascoLogWhereUniqueInput
    create: XOR<TascoLogCreateWithoutEquipmentInput, TascoLogUncheckedCreateWithoutEquipmentInput>
  }

  export type TascoLogCreateManyEquipmentInputEnvelope = {
    data: TascoLogCreateManyEquipmentInput | TascoLogCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type TruckingLogCreateWithoutEquipmentInput = {
    id?: string
    laborType: string
    taskName?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutTruckingLogInput
    Materials?: MaterialCreateNestedManyWithoutTruckingLogInput
    RefuelLogs?: RefuelLogCreateNestedManyWithoutTruckingLogInput
    StateMileages?: StateMileageCreateNestedManyWithoutTruckingLogInput
    TimeSheet: TimeSheetCreateNestedOneWithoutTruckingLogsInput
    Trailer?: EquipmentCreateNestedOneWithoutUsedAsTrailerInput
    Truck?: EquipmentCreateNestedOneWithoutUsedAsTruckInput
  }

  export type TruckingLogUncheckedCreateWithoutEquipmentInput = {
    id?: string
    laborType: string
    taskName?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    trailerNumber?: string | null
    truckNumber?: string | null
    timeSheetId: number
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutTruckingLogInput
    Materials?: MaterialUncheckedCreateNestedManyWithoutTruckingLogInput
    RefuelLogs?: RefuelLogUncheckedCreateNestedManyWithoutTruckingLogInput
    StateMileages?: StateMileageUncheckedCreateNestedManyWithoutTruckingLogInput
  }

  export type TruckingLogCreateOrConnectWithoutEquipmentInput = {
    where: TruckingLogWhereUniqueInput
    create: XOR<TruckingLogCreateWithoutEquipmentInput, TruckingLogUncheckedCreateWithoutEquipmentInput>
  }

  export type TruckingLogCreateManyEquipmentInputEnvelope = {
    data: TruckingLogCreateManyEquipmentInput | TruckingLogCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type TruckingLogCreateWithoutTrailerInput = {
    id?: string
    laborType: string
    taskName?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutTruckingLogInput
    Materials?: MaterialCreateNestedManyWithoutTruckingLogInput
    RefuelLogs?: RefuelLogCreateNestedManyWithoutTruckingLogInput
    StateMileages?: StateMileageCreateNestedManyWithoutTruckingLogInput
    Equipment?: EquipmentCreateNestedOneWithoutHauledInLogsInput
    TimeSheet: TimeSheetCreateNestedOneWithoutTruckingLogsInput
    Truck?: EquipmentCreateNestedOneWithoutUsedAsTruckInput
  }

  export type TruckingLogUncheckedCreateWithoutTrailerInput = {
    id?: string
    laborType: string
    taskName?: string | null
    equipmentId?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    truckNumber?: string | null
    timeSheetId: number
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutTruckingLogInput
    Materials?: MaterialUncheckedCreateNestedManyWithoutTruckingLogInput
    RefuelLogs?: RefuelLogUncheckedCreateNestedManyWithoutTruckingLogInput
    StateMileages?: StateMileageUncheckedCreateNestedManyWithoutTruckingLogInput
  }

  export type TruckingLogCreateOrConnectWithoutTrailerInput = {
    where: TruckingLogWhereUniqueInput
    create: XOR<TruckingLogCreateWithoutTrailerInput, TruckingLogUncheckedCreateWithoutTrailerInput>
  }

  export type TruckingLogCreateManyTrailerInputEnvelope = {
    data: TruckingLogCreateManyTrailerInput | TruckingLogCreateManyTrailerInput[]
    skipDuplicates?: boolean
  }

  export type TruckingLogCreateWithoutTruckInput = {
    id?: string
    laborType: string
    taskName?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutTruckingLogInput
    Materials?: MaterialCreateNestedManyWithoutTruckingLogInput
    RefuelLogs?: RefuelLogCreateNestedManyWithoutTruckingLogInput
    StateMileages?: StateMileageCreateNestedManyWithoutTruckingLogInput
    Equipment?: EquipmentCreateNestedOneWithoutHauledInLogsInput
    TimeSheet: TimeSheetCreateNestedOneWithoutTruckingLogsInput
    Trailer?: EquipmentCreateNestedOneWithoutUsedAsTrailerInput
  }

  export type TruckingLogUncheckedCreateWithoutTruckInput = {
    id?: string
    laborType: string
    taskName?: string | null
    equipmentId?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    trailerNumber?: string | null
    timeSheetId: number
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutTruckingLogInput
    Materials?: MaterialUncheckedCreateNestedManyWithoutTruckingLogInput
    RefuelLogs?: RefuelLogUncheckedCreateNestedManyWithoutTruckingLogInput
    StateMileages?: StateMileageUncheckedCreateNestedManyWithoutTruckingLogInput
  }

  export type TruckingLogCreateOrConnectWithoutTruckInput = {
    where: TruckingLogWhereUniqueInput
    create: XOR<TruckingLogCreateWithoutTruckInput, TruckingLogUncheckedCreateWithoutTruckInput>
  }

  export type TruckingLogCreateManyTruckInputEnvelope = {
    data: TruckingLogCreateManyTruckInput | TruckingLogCreateManyTruckInput[]
    skipDuplicates?: boolean
  }

  export type mechanicProjectsCreateWithoutEquipmentInput = {
    hours?: number | null
    description?: string | null
    TimeSheet: TimeSheetCreateNestedOneWithoutMaintenanceInput
  }

  export type mechanicProjectsUncheckedCreateWithoutEquipmentInput = {
    id?: number
    timeSheetId: number
    hours?: number | null
    description?: string | null
  }

  export type mechanicProjectsCreateOrConnectWithoutEquipmentInput = {
    where: mechanicProjectsWhereUniqueInput
    create: XOR<mechanicProjectsCreateWithoutEquipmentInput, mechanicProjectsUncheckedCreateWithoutEquipmentInput>
  }

  export type mechanicProjectsCreateManyEquipmentInputEnvelope = {
    data: mechanicProjectsCreateManyEquipmentInput | mechanicProjectsCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type DocumentTagCreateWithoutEquipmentInput = {
    id?: string
    tagName: string
    Documents?: PdfDocumentCreateNestedManyWithoutDocumentTagsInput
  }

  export type DocumentTagUncheckedCreateWithoutEquipmentInput = {
    id?: string
    tagName: string
    Documents?: PdfDocumentUncheckedCreateNestedManyWithoutDocumentTagsInput
  }

  export type DocumentTagCreateOrConnectWithoutEquipmentInput = {
    where: DocumentTagWhereUniqueInput
    create: XOR<DocumentTagCreateWithoutEquipmentInput, DocumentTagUncheckedCreateWithoutEquipmentInput>
  }

  export type EmployeeEquipmentLogUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: EmployeeEquipmentLogWhereUniqueInput
    update: XOR<EmployeeEquipmentLogUpdateWithoutEquipmentInput, EmployeeEquipmentLogUncheckedUpdateWithoutEquipmentInput>
    create: XOR<EmployeeEquipmentLogCreateWithoutEquipmentInput, EmployeeEquipmentLogUncheckedCreateWithoutEquipmentInput>
  }

  export type EmployeeEquipmentLogUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: EmployeeEquipmentLogWhereUniqueInput
    data: XOR<EmployeeEquipmentLogUpdateWithoutEquipmentInput, EmployeeEquipmentLogUncheckedUpdateWithoutEquipmentInput>
  }

  export type EmployeeEquipmentLogUpdateManyWithWhereWithoutEquipmentInput = {
    where: EmployeeEquipmentLogScalarWhereInput
    data: XOR<EmployeeEquipmentLogUpdateManyMutationInput, EmployeeEquipmentLogUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type EmployeeEquipmentLogScalarWhereInput = {
    AND?: EmployeeEquipmentLogScalarWhereInput | EmployeeEquipmentLogScalarWhereInput[]
    OR?: EmployeeEquipmentLogScalarWhereInput[]
    NOT?: EmployeeEquipmentLogScalarWhereInput | EmployeeEquipmentLogScalarWhereInput[]
    id?: StringFilter<"EmployeeEquipmentLog"> | string
    equipmentId?: StringNullableFilter<"EmployeeEquipmentLog"> | string | null
    maintenanceId?: StringNullableFilter<"EmployeeEquipmentLog"> | string | null
    startTime?: DateTimeFilter<"EmployeeEquipmentLog"> | Date | string
    endTime?: DateTimeNullableFilter<"EmployeeEquipmentLog"> | Date | string | null
    comment?: StringNullableFilter<"EmployeeEquipmentLog"> | string | null
    timeSheetId?: IntFilter<"EmployeeEquipmentLog"> | number
    rental?: BoolFilter<"EmployeeEquipmentLog"> | boolean
  }

  export type UserUpsertWithoutEquipmentInput = {
    update: XOR<UserUpdateWithoutEquipmentInput, UserUncheckedUpdateWithoutEquipmentInput>
    create: XOR<UserCreateWithoutEquipmentInput, UserUncheckedCreateWithoutEquipmentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEquipmentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEquipmentInput, UserUncheckedUpdateWithoutEquipmentInput>
  }

  export type UserUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type EquipmentHauledUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: EquipmentHauledWhereUniqueInput
    update: XOR<EquipmentHauledUpdateWithoutEquipmentInput, EquipmentHauledUncheckedUpdateWithoutEquipmentInput>
    create: XOR<EquipmentHauledCreateWithoutEquipmentInput, EquipmentHauledUncheckedCreateWithoutEquipmentInput>
  }

  export type EquipmentHauledUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: EquipmentHauledWhereUniqueInput
    data: XOR<EquipmentHauledUpdateWithoutEquipmentInput, EquipmentHauledUncheckedUpdateWithoutEquipmentInput>
  }

  export type EquipmentHauledUpdateManyWithWhereWithoutEquipmentInput = {
    where: EquipmentHauledScalarWhereInput
    data: XOR<EquipmentHauledUpdateManyMutationInput, EquipmentHauledUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type EquipmentHauledScalarWhereInput = {
    AND?: EquipmentHauledScalarWhereInput | EquipmentHauledScalarWhereInput[]
    OR?: EquipmentHauledScalarWhereInput[]
    NOT?: EquipmentHauledScalarWhereInput | EquipmentHauledScalarWhereInput[]
    id?: StringFilter<"EquipmentHauled"> | string
    truckingLogId?: StringNullableFilter<"EquipmentHauled"> | string | null
    equipmentId?: StringNullableFilter<"EquipmentHauled"> | string | null
    createdAt?: DateTimeFilter<"EquipmentHauled"> | Date | string
    endMileage?: IntNullableFilter<"EquipmentHauled"> | number | null
    startMileage?: IntNullableFilter<"EquipmentHauled"> | number | null
    destination?: StringNullableFilter<"EquipmentHauled"> | string | null
    source?: StringNullableFilter<"EquipmentHauled"> | string | null
  }

  export type MaintenanceUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: MaintenanceWhereUniqueInput
    update: XOR<MaintenanceUpdateWithoutEquipmentInput, MaintenanceUncheckedUpdateWithoutEquipmentInput>
    create: XOR<MaintenanceCreateWithoutEquipmentInput, MaintenanceUncheckedCreateWithoutEquipmentInput>
  }

  export type MaintenanceUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: MaintenanceWhereUniqueInput
    data: XOR<MaintenanceUpdateWithoutEquipmentInput, MaintenanceUncheckedUpdateWithoutEquipmentInput>
  }

  export type MaintenanceUpdateManyWithWhereWithoutEquipmentInput = {
    where: MaintenanceScalarWhereInput
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type MaintenanceScalarWhereInput = {
    AND?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
    OR?: MaintenanceScalarWhereInput[]
    NOT?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
    id?: StringFilter<"Maintenance"> | string
    equipmentId?: StringFilter<"Maintenance"> | string
    equipmentIssue?: StringNullableFilter<"Maintenance"> | string | null
    employeeEquipmentLogId?: StringNullableFilter<"Maintenance"> | string | null
    additionalInfo?: StringNullableFilter<"Maintenance"> | string | null
    location?: StringNullableFilter<"Maintenance"> | string | null
    problemDiagnosis?: StringNullableFilter<"Maintenance"> | string | null
    solution?: StringNullableFilter<"Maintenance"> | string | null
    totalHoursLaboured?: FloatNullableFilter<"Maintenance"> | number | null
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    priority?: EnumPriorityFilter<"Maintenance"> | $Enums.Priority
    delay?: DateTimeNullableFilter<"Maintenance"> | Date | string | null
    delayReasoning?: StringNullableFilter<"Maintenance"> | string | null
    repaired?: BoolFilter<"Maintenance"> | boolean
    selected?: BoolFilter<"Maintenance"> | boolean
    hasBeenDelayed?: BoolFilter<"Maintenance"> | boolean
    createdBy?: StringNullableFilter<"Maintenance"> | string | null
  }

  export type TascoLogUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: TascoLogWhereUniqueInput
    update: XOR<TascoLogUpdateWithoutEquipmentInput, TascoLogUncheckedUpdateWithoutEquipmentInput>
    create: XOR<TascoLogCreateWithoutEquipmentInput, TascoLogUncheckedCreateWithoutEquipmentInput>
  }

  export type TascoLogUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: TascoLogWhereUniqueInput
    data: XOR<TascoLogUpdateWithoutEquipmentInput, TascoLogUncheckedUpdateWithoutEquipmentInput>
  }

  export type TascoLogUpdateManyWithWhereWithoutEquipmentInput = {
    where: TascoLogScalarWhereInput
    data: XOR<TascoLogUpdateManyMutationInput, TascoLogUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type TascoLogScalarWhereInput = {
    AND?: TascoLogScalarWhereInput | TascoLogScalarWhereInput[]
    OR?: TascoLogScalarWhereInput[]
    NOT?: TascoLogScalarWhereInput | TascoLogScalarWhereInput[]
    id?: StringFilter<"TascoLog"> | string
    shiftType?: StringFilter<"TascoLog"> | string
    equipmentId?: StringNullableFilter<"TascoLog"> | string | null
    laborType?: StringNullableFilter<"TascoLog"> | string | null
    materialType?: StringNullableFilter<"TascoLog"> | string | null
    LoadQuantity?: IntFilter<"TascoLog"> | number
    screenType?: EnumLoadTypeNullableFilter<"TascoLog"> | $Enums.LoadType | null
    timeSheetId?: IntFilter<"TascoLog"> | number
  }

  export type TruckingLogUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: TruckingLogWhereUniqueInput
    update: XOR<TruckingLogUpdateWithoutEquipmentInput, TruckingLogUncheckedUpdateWithoutEquipmentInput>
    create: XOR<TruckingLogCreateWithoutEquipmentInput, TruckingLogUncheckedCreateWithoutEquipmentInput>
  }

  export type TruckingLogUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: TruckingLogWhereUniqueInput
    data: XOR<TruckingLogUpdateWithoutEquipmentInput, TruckingLogUncheckedUpdateWithoutEquipmentInput>
  }

  export type TruckingLogUpdateManyWithWhereWithoutEquipmentInput = {
    where: TruckingLogScalarWhereInput
    data: XOR<TruckingLogUpdateManyMutationInput, TruckingLogUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type TruckingLogScalarWhereInput = {
    AND?: TruckingLogScalarWhereInput | TruckingLogScalarWhereInput[]
    OR?: TruckingLogScalarWhereInput[]
    NOT?: TruckingLogScalarWhereInput | TruckingLogScalarWhereInput[]
    id?: StringFilter<"TruckingLog"> | string
    laborType?: StringFilter<"TruckingLog"> | string
    taskName?: StringNullableFilter<"TruckingLog"> | string | null
    equipmentId?: StringNullableFilter<"TruckingLog"> | string | null
    startingMileage?: IntNullableFilter<"TruckingLog"> | number | null
    endingMileage?: IntNullableFilter<"TruckingLog"> | number | null
    truckLaborLogId?: StringNullableFilter<"TruckingLog"> | string | null
    trailerNumber?: StringNullableFilter<"TruckingLog"> | string | null
    truckNumber?: StringNullableFilter<"TruckingLog"> | string | null
    timeSheetId?: IntFilter<"TruckingLog"> | number
  }

  export type TruckingLogUpsertWithWhereUniqueWithoutTrailerInput = {
    where: TruckingLogWhereUniqueInput
    update: XOR<TruckingLogUpdateWithoutTrailerInput, TruckingLogUncheckedUpdateWithoutTrailerInput>
    create: XOR<TruckingLogCreateWithoutTrailerInput, TruckingLogUncheckedCreateWithoutTrailerInput>
  }

  export type TruckingLogUpdateWithWhereUniqueWithoutTrailerInput = {
    where: TruckingLogWhereUniqueInput
    data: XOR<TruckingLogUpdateWithoutTrailerInput, TruckingLogUncheckedUpdateWithoutTrailerInput>
  }

  export type TruckingLogUpdateManyWithWhereWithoutTrailerInput = {
    where: TruckingLogScalarWhereInput
    data: XOR<TruckingLogUpdateManyMutationInput, TruckingLogUncheckedUpdateManyWithoutTrailerInput>
  }

  export type TruckingLogUpsertWithWhereUniqueWithoutTruckInput = {
    where: TruckingLogWhereUniqueInput
    update: XOR<TruckingLogUpdateWithoutTruckInput, TruckingLogUncheckedUpdateWithoutTruckInput>
    create: XOR<TruckingLogCreateWithoutTruckInput, TruckingLogUncheckedCreateWithoutTruckInput>
  }

  export type TruckingLogUpdateWithWhereUniqueWithoutTruckInput = {
    where: TruckingLogWhereUniqueInput
    data: XOR<TruckingLogUpdateWithoutTruckInput, TruckingLogUncheckedUpdateWithoutTruckInput>
  }

  export type TruckingLogUpdateManyWithWhereWithoutTruckInput = {
    where: TruckingLogScalarWhereInput
    data: XOR<TruckingLogUpdateManyMutationInput, TruckingLogUncheckedUpdateManyWithoutTruckInput>
  }

  export type mechanicProjectsUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: mechanicProjectsWhereUniqueInput
    update: XOR<mechanicProjectsUpdateWithoutEquipmentInput, mechanicProjectsUncheckedUpdateWithoutEquipmentInput>
    create: XOR<mechanicProjectsCreateWithoutEquipmentInput, mechanicProjectsUncheckedCreateWithoutEquipmentInput>
  }

  export type mechanicProjectsUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: mechanicProjectsWhereUniqueInput
    data: XOR<mechanicProjectsUpdateWithoutEquipmentInput, mechanicProjectsUncheckedUpdateWithoutEquipmentInput>
  }

  export type mechanicProjectsUpdateManyWithWhereWithoutEquipmentInput = {
    where: mechanicProjectsScalarWhereInput
    data: XOR<mechanicProjectsUpdateManyMutationInput, mechanicProjectsUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type mechanicProjectsScalarWhereInput = {
    AND?: mechanicProjectsScalarWhereInput | mechanicProjectsScalarWhereInput[]
    OR?: mechanicProjectsScalarWhereInput[]
    NOT?: mechanicProjectsScalarWhereInput | mechanicProjectsScalarWhereInput[]
    id?: IntFilter<"mechanicProjects"> | number
    timeSheetId?: IntFilter<"mechanicProjects"> | number
    hours?: FloatNullableFilter<"mechanicProjects"> | number | null
    equipmentId?: StringFilter<"mechanicProjects"> | string
    description?: StringNullableFilter<"mechanicProjects"> | string | null
  }

  export type DocumentTagUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: DocumentTagWhereUniqueInput
    update: XOR<DocumentTagUpdateWithoutEquipmentInput, DocumentTagUncheckedUpdateWithoutEquipmentInput>
    create: XOR<DocumentTagCreateWithoutEquipmentInput, DocumentTagUncheckedCreateWithoutEquipmentInput>
  }

  export type DocumentTagUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: DocumentTagWhereUniqueInput
    data: XOR<DocumentTagUpdateWithoutEquipmentInput, DocumentTagUncheckedUpdateWithoutEquipmentInput>
  }

  export type DocumentTagUpdateManyWithWhereWithoutEquipmentInput = {
    where: DocumentTagScalarWhereInput
    data: XOR<DocumentTagUpdateManyMutationInput, DocumentTagUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type EquipmentCreateWithoutEmployeeEquipmentLogsInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    createdBy?: UserCreateNestedOneWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutEmployeeEquipmentLogsInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogUncheckedCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogUncheckedCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogUncheckedCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutEmployeeEquipmentLogsInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutEmployeeEquipmentLogsInput, EquipmentUncheckedCreateWithoutEmployeeEquipmentLogsInput>
  }

  export type MaintenanceCreateWithoutEmployeeEquipmentLogInput = {
    id?: string
    equipmentIssue?: string | null
    employeeEquipmentLogId?: string | null
    additionalInfo?: string | null
    location?: string | null
    problemDiagnosis?: string | null
    solution?: string | null
    totalHoursLaboured?: number | null
    createdAt?: Date | string
    priority: $Enums.Priority
    delay?: Date | string | null
    delayReasoning?: string | null
    repaired?: boolean
    selected?: boolean
    hasBeenDelayed?: boolean
    createdBy?: string | null
    Equipment: EquipmentCreateNestedOneWithoutMaintenancesInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutMaintenanceInput
  }

  export type MaintenanceUncheckedCreateWithoutEmployeeEquipmentLogInput = {
    id?: string
    equipmentId: string
    equipmentIssue?: string | null
    employeeEquipmentLogId?: string | null
    additionalInfo?: string | null
    location?: string | null
    problemDiagnosis?: string | null
    solution?: string | null
    totalHoursLaboured?: number | null
    createdAt?: Date | string
    priority: $Enums.Priority
    delay?: Date | string | null
    delayReasoning?: string | null
    repaired?: boolean
    selected?: boolean
    hasBeenDelayed?: boolean
    createdBy?: string | null
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutMaintenanceInput
  }

  export type MaintenanceCreateOrConnectWithoutEmployeeEquipmentLogInput = {
    where: MaintenanceWhereUniqueInput
    create: XOR<MaintenanceCreateWithoutEmployeeEquipmentLogInput, MaintenanceUncheckedCreateWithoutEmployeeEquipmentLogInput>
  }

  export type TimeSheetCreateWithoutEmployeeEquipmentLogsInput = {
    date: Date | string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogCreateNestedManyWithoutTimeSheetInput
    CostCode: CostCodeCreateNestedOneWithoutTimesheetsInput
    Jobsite: JobsiteCreateNestedOneWithoutTimeSheetsInput
    User: UserCreateNestedOneWithoutTimeSheetsInput
    ChangeLogs?: TimeSheetChangeLogCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetUncheckedCreateWithoutEmployeeEquipmentLogsInput = {
    date: Date | string
    userId: string
    jobsiteId: string
    costcode: string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    id?: number
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutTimeSheetInput
    ChangeLogs?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogUncheckedCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetCreateOrConnectWithoutEmployeeEquipmentLogsInput = {
    where: TimeSheetWhereUniqueInput
    create: XOR<TimeSheetCreateWithoutEmployeeEquipmentLogsInput, TimeSheetUncheckedCreateWithoutEmployeeEquipmentLogsInput>
  }

  export type RefuelLogCreateWithoutEmployeeEquipmentLogInput = {
    id?: string
    gallonsRefueled?: number | null
    milesAtFueling?: number | null
    TascoLog?: TascoLogCreateNestedOneWithoutRefuelLogsInput
    TruckingLog?: TruckingLogCreateNestedOneWithoutRefuelLogsInput
  }

  export type RefuelLogUncheckedCreateWithoutEmployeeEquipmentLogInput = {
    id?: string
    truckingLogId?: string | null
    tascoLogId?: string | null
    gallonsRefueled?: number | null
    milesAtFueling?: number | null
  }

  export type RefuelLogCreateOrConnectWithoutEmployeeEquipmentLogInput = {
    where: RefuelLogWhereUniqueInput
    create: XOR<RefuelLogCreateWithoutEmployeeEquipmentLogInput, RefuelLogUncheckedCreateWithoutEmployeeEquipmentLogInput>
  }

  export type EquipmentUpsertWithoutEmployeeEquipmentLogsInput = {
    update: XOR<EquipmentUpdateWithoutEmployeeEquipmentLogsInput, EquipmentUncheckedUpdateWithoutEmployeeEquipmentLogsInput>
    create: XOR<EquipmentCreateWithoutEmployeeEquipmentLogsInput, EquipmentUncheckedCreateWithoutEmployeeEquipmentLogsInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutEmployeeEquipmentLogsInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutEmployeeEquipmentLogsInput, EquipmentUncheckedUpdateWithoutEmployeeEquipmentLogsInput>
  }

  export type EquipmentUpdateWithoutEmployeeEquipmentLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    createdBy?: UserUpdateOneWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutEmployeeEquipmentLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUncheckedUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUncheckedUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUncheckedUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type MaintenanceUpsertWithoutEmployeeEquipmentLogInput = {
    update: XOR<MaintenanceUpdateWithoutEmployeeEquipmentLogInput, MaintenanceUncheckedUpdateWithoutEmployeeEquipmentLogInput>
    create: XOR<MaintenanceCreateWithoutEmployeeEquipmentLogInput, MaintenanceUncheckedCreateWithoutEmployeeEquipmentLogInput>
    where?: MaintenanceWhereInput
  }

  export type MaintenanceUpdateToOneWithWhereWithoutEmployeeEquipmentLogInput = {
    where?: MaintenanceWhereInput
    data: XOR<MaintenanceUpdateWithoutEmployeeEquipmentLogInput, MaintenanceUncheckedUpdateWithoutEmployeeEquipmentLogInput>
  }

  export type MaintenanceUpdateWithoutEmployeeEquipmentLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentIssue?: NullableStringFieldUpdateOperationsInput | string | null
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    problemDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    totalHoursLaboured?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    delay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delayReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    repaired?: BoolFieldUpdateOperationsInput | boolean
    selected?: BoolFieldUpdateOperationsInput | boolean
    hasBeenDelayed?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    Equipment?: EquipmentUpdateOneRequiredWithoutMaintenancesNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutMaintenanceNestedInput
  }

  export type MaintenanceUncheckedUpdateWithoutEmployeeEquipmentLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    equipmentIssue?: NullableStringFieldUpdateOperationsInput | string | null
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    problemDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    totalHoursLaboured?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    delay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delayReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    repaired?: BoolFieldUpdateOperationsInput | boolean
    selected?: BoolFieldUpdateOperationsInput | boolean
    hasBeenDelayed?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutMaintenanceNestedInput
  }

  export type TimeSheetUpsertWithoutEmployeeEquipmentLogsInput = {
    update: XOR<TimeSheetUpdateWithoutEmployeeEquipmentLogsInput, TimeSheetUncheckedUpdateWithoutEmployeeEquipmentLogsInput>
    create: XOR<TimeSheetCreateWithoutEmployeeEquipmentLogsInput, TimeSheetUncheckedCreateWithoutEmployeeEquipmentLogsInput>
    where?: TimeSheetWhereInput
  }

  export type TimeSheetUpdateToOneWithWhereWithoutEmployeeEquipmentLogsInput = {
    where?: TimeSheetWhereInput
    data: XOR<TimeSheetUpdateWithoutEmployeeEquipmentLogsInput, TimeSheetUncheckedUpdateWithoutEmployeeEquipmentLogsInput>
  }

  export type TimeSheetUpdateWithoutEmployeeEquipmentLogsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutTimeSheetNestedInput
    CostCode?: CostCodeUpdateOneRequiredWithoutTimesheetsNestedInput
    Jobsite?: JobsiteUpdateOneRequiredWithoutTimeSheetsNestedInput
    User?: UserUpdateOneRequiredWithoutTimeSheetsNestedInput
    ChangeLogs?: TimeSheetChangeLogUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutTimeSheetNestedInput
  }

  export type TimeSheetUncheckedUpdateWithoutEmployeeEquipmentLogsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    jobsiteId?: StringFieldUpdateOperationsInput | string
    costcode?: StringFieldUpdateOperationsInput | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    ChangeLogs?: TimeSheetChangeLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutTimeSheetNestedInput
  }

  export type RefuelLogUpsertWithoutEmployeeEquipmentLogInput = {
    update: XOR<RefuelLogUpdateWithoutEmployeeEquipmentLogInput, RefuelLogUncheckedUpdateWithoutEmployeeEquipmentLogInput>
    create: XOR<RefuelLogCreateWithoutEmployeeEquipmentLogInput, RefuelLogUncheckedCreateWithoutEmployeeEquipmentLogInput>
    where?: RefuelLogWhereInput
  }

  export type RefuelLogUpdateToOneWithWhereWithoutEmployeeEquipmentLogInput = {
    where?: RefuelLogWhereInput
    data: XOR<RefuelLogUpdateWithoutEmployeeEquipmentLogInput, RefuelLogUncheckedUpdateWithoutEmployeeEquipmentLogInput>
  }

  export type RefuelLogUpdateWithoutEmployeeEquipmentLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    gallonsRefueled?: NullableFloatFieldUpdateOperationsInput | number | null
    milesAtFueling?: NullableIntFieldUpdateOperationsInput | number | null
    TascoLog?: TascoLogUpdateOneWithoutRefuelLogsNestedInput
    TruckingLog?: TruckingLogUpdateOneWithoutRefuelLogsNestedInput
  }

  export type RefuelLogUncheckedUpdateWithoutEmployeeEquipmentLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    tascoLogId?: NullableStringFieldUpdateOperationsInput | string | null
    gallonsRefueled?: NullableFloatFieldUpdateOperationsInput | number | null
    milesAtFueling?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FormSubmissionCreateWithoutFormTemplateInput = {
    title?: string | null
    formType?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    status?: $Enums.FormStatus
    Approvals?: FormApprovalCreateNestedManyWithoutFormSubmissionInput
    User: UserCreateNestedOneWithoutFormSubmissionsInput
  }

  export type FormSubmissionUncheckedCreateWithoutFormTemplateInput = {
    title?: string | null
    userId: string
    formType?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    status?: $Enums.FormStatus
    id?: number
    Approvals?: FormApprovalUncheckedCreateNestedManyWithoutFormSubmissionInput
  }

  export type FormSubmissionCreateOrConnectWithoutFormTemplateInput = {
    where: FormSubmissionWhereUniqueInput
    create: XOR<FormSubmissionCreateWithoutFormTemplateInput, FormSubmissionUncheckedCreateWithoutFormTemplateInput>
  }

  export type FormSubmissionCreateManyFormTemplateInputEnvelope = {
    data: FormSubmissionCreateManyFormTemplateInput | FormSubmissionCreateManyFormTemplateInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutFormTemplatesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubscriptionDate?: Date | string
    Address?: AddressCreateNestedOneWithoutCompanyInput
    Reports?: ReportCreateNestedManyWithoutCompanyInput
    Users?: UserCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutFormTemplatesInput = {
    id?: string
    name: string
    addressId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SubscriptionDate?: Date | string
    Reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    Users?: UserUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutFormTemplatesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutFormTemplatesInput, CompanyUncheckedCreateWithoutFormTemplatesInput>
  }

  export type FormGroupingCreateWithoutFormTemplateInput = {
    id?: string
    title?: string | null
    order: number
    Fields?: FormFieldCreateNestedManyWithoutFormGroupingInput
  }

  export type FormGroupingUncheckedCreateWithoutFormTemplateInput = {
    id?: string
    title?: string | null
    order: number
    Fields?: FormFieldUncheckedCreateNestedManyWithoutFormGroupingInput
  }

  export type FormGroupingCreateOrConnectWithoutFormTemplateInput = {
    where: FormGroupingWhereUniqueInput
    create: XOR<FormGroupingCreateWithoutFormTemplateInput, FormGroupingUncheckedCreateWithoutFormTemplateInput>
  }

  export type FormSubmissionUpsertWithWhereUniqueWithoutFormTemplateInput = {
    where: FormSubmissionWhereUniqueInput
    update: XOR<FormSubmissionUpdateWithoutFormTemplateInput, FormSubmissionUncheckedUpdateWithoutFormTemplateInput>
    create: XOR<FormSubmissionCreateWithoutFormTemplateInput, FormSubmissionUncheckedCreateWithoutFormTemplateInput>
  }

  export type FormSubmissionUpdateWithWhereUniqueWithoutFormTemplateInput = {
    where: FormSubmissionWhereUniqueInput
    data: XOR<FormSubmissionUpdateWithoutFormTemplateInput, FormSubmissionUncheckedUpdateWithoutFormTemplateInput>
  }

  export type FormSubmissionUpdateManyWithWhereWithoutFormTemplateInput = {
    where: FormSubmissionScalarWhereInput
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyWithoutFormTemplateInput>
  }

  export type FormSubmissionScalarWhereInput = {
    AND?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
    OR?: FormSubmissionScalarWhereInput[]
    NOT?: FormSubmissionScalarWhereInput | FormSubmissionScalarWhereInput[]
    title?: StringNullableFilter<"FormSubmission"> | string | null
    formTemplateId?: StringFilter<"FormSubmission"> | string
    userId?: StringFilter<"FormSubmission"> | string
    formType?: StringNullableFilter<"FormSubmission"> | string | null
    data?: JsonNullableFilter<"FormSubmission">
    createdAt?: DateTimeFilter<"FormSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"FormSubmission"> | Date | string
    submittedAt?: DateTimeNullableFilter<"FormSubmission"> | Date | string | null
    status?: EnumFormStatusFilter<"FormSubmission"> | $Enums.FormStatus
    id?: IntFilter<"FormSubmission"> | number
  }

  export type CompanyUpsertWithoutFormTemplatesInput = {
    update: XOR<CompanyUpdateWithoutFormTemplatesInput, CompanyUncheckedUpdateWithoutFormTemplatesInput>
    create: XOR<CompanyCreateWithoutFormTemplatesInput, CompanyUncheckedCreateWithoutFormTemplatesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutFormTemplatesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutFormTemplatesInput, CompanyUncheckedUpdateWithoutFormTemplatesInput>
  }

  export type CompanyUpdateWithoutFormTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubscriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Address?: AddressUpdateOneWithoutCompanyNestedInput
    Reports?: ReportUpdateManyWithoutCompanyNestedInput
    Users?: UserUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutFormTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubscriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    Users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type FormGroupingUpsertWithWhereUniqueWithoutFormTemplateInput = {
    where: FormGroupingWhereUniqueInput
    update: XOR<FormGroupingUpdateWithoutFormTemplateInput, FormGroupingUncheckedUpdateWithoutFormTemplateInput>
    create: XOR<FormGroupingCreateWithoutFormTemplateInput, FormGroupingUncheckedCreateWithoutFormTemplateInput>
  }

  export type FormGroupingUpdateWithWhereUniqueWithoutFormTemplateInput = {
    where: FormGroupingWhereUniqueInput
    data: XOR<FormGroupingUpdateWithoutFormTemplateInput, FormGroupingUncheckedUpdateWithoutFormTemplateInput>
  }

  export type FormGroupingUpdateManyWithWhereWithoutFormTemplateInput = {
    where: FormGroupingScalarWhereInput
    data: XOR<FormGroupingUpdateManyMutationInput, FormGroupingUncheckedUpdateManyWithoutFormTemplateInput>
  }

  export type FormGroupingScalarWhereInput = {
    AND?: FormGroupingScalarWhereInput | FormGroupingScalarWhereInput[]
    OR?: FormGroupingScalarWhereInput[]
    NOT?: FormGroupingScalarWhereInput | FormGroupingScalarWhereInput[]
    id?: StringFilter<"FormGrouping"> | string
    title?: StringNullableFilter<"FormGrouping"> | string | null
    order?: IntFilter<"FormGrouping"> | number
  }

  export type FormFieldCreateWithoutFormGroupingInput = {
    id?: string
    label: string
    type: $Enums.FieldType
    required?: boolean
    order: number
    placeholder?: string | null
    maxLength?: number | null
    content?: string | null
    filter?: string | null
    minLength?: number | null
    multiple?: boolean | null
    Options?: FormFieldOptionCreateNestedManyWithoutFieldInput
  }

  export type FormFieldUncheckedCreateWithoutFormGroupingInput = {
    id?: string
    label: string
    type: $Enums.FieldType
    required?: boolean
    order: number
    placeholder?: string | null
    maxLength?: number | null
    content?: string | null
    filter?: string | null
    minLength?: number | null
    multiple?: boolean | null
    Options?: FormFieldOptionUncheckedCreateNestedManyWithoutFieldInput
  }

  export type FormFieldCreateOrConnectWithoutFormGroupingInput = {
    where: FormFieldWhereUniqueInput
    create: XOR<FormFieldCreateWithoutFormGroupingInput, FormFieldUncheckedCreateWithoutFormGroupingInput>
  }

  export type FormFieldCreateManyFormGroupingInputEnvelope = {
    data: FormFieldCreateManyFormGroupingInput | FormFieldCreateManyFormGroupingInput[]
    skipDuplicates?: boolean
  }

  export type FormTemplateCreateWithoutFormGroupingInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isSignatureRequired?: boolean
    description?: string | null
    isActive?: $Enums.FormTemplateStatus
    formType?: $Enums.FormTemplateCategory
    isApprovalRequired?: boolean
    Submissions?: FormSubmissionCreateNestedManyWithoutFormTemplateInput
    Company: CompanyCreateNestedOneWithoutFormTemplatesInput
  }

  export type FormTemplateUncheckedCreateWithoutFormGroupingInput = {
    id?: string
    companyId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isSignatureRequired?: boolean
    description?: string | null
    isActive?: $Enums.FormTemplateStatus
    formType?: $Enums.FormTemplateCategory
    isApprovalRequired?: boolean
    Submissions?: FormSubmissionUncheckedCreateNestedManyWithoutFormTemplateInput
  }

  export type FormTemplateCreateOrConnectWithoutFormGroupingInput = {
    where: FormTemplateWhereUniqueInput
    create: XOR<FormTemplateCreateWithoutFormGroupingInput, FormTemplateUncheckedCreateWithoutFormGroupingInput>
  }

  export type FormFieldUpsertWithWhereUniqueWithoutFormGroupingInput = {
    where: FormFieldWhereUniqueInput
    update: XOR<FormFieldUpdateWithoutFormGroupingInput, FormFieldUncheckedUpdateWithoutFormGroupingInput>
    create: XOR<FormFieldCreateWithoutFormGroupingInput, FormFieldUncheckedCreateWithoutFormGroupingInput>
  }

  export type FormFieldUpdateWithWhereUniqueWithoutFormGroupingInput = {
    where: FormFieldWhereUniqueInput
    data: XOR<FormFieldUpdateWithoutFormGroupingInput, FormFieldUncheckedUpdateWithoutFormGroupingInput>
  }

  export type FormFieldUpdateManyWithWhereWithoutFormGroupingInput = {
    where: FormFieldScalarWhereInput
    data: XOR<FormFieldUpdateManyMutationInput, FormFieldUncheckedUpdateManyWithoutFormGroupingInput>
  }

  export type FormFieldScalarWhereInput = {
    AND?: FormFieldScalarWhereInput | FormFieldScalarWhereInput[]
    OR?: FormFieldScalarWhereInput[]
    NOT?: FormFieldScalarWhereInput | FormFieldScalarWhereInput[]
    id?: StringFilter<"FormField"> | string
    formGroupingId?: StringFilter<"FormField"> | string
    label?: StringFilter<"FormField"> | string
    type?: EnumFieldTypeFilter<"FormField"> | $Enums.FieldType
    required?: BoolFilter<"FormField"> | boolean
    order?: IntFilter<"FormField"> | number
    placeholder?: StringNullableFilter<"FormField"> | string | null
    maxLength?: IntNullableFilter<"FormField"> | number | null
    content?: StringNullableFilter<"FormField"> | string | null
    filter?: StringNullableFilter<"FormField"> | string | null
    minLength?: IntNullableFilter<"FormField"> | number | null
    multiple?: BoolNullableFilter<"FormField"> | boolean | null
  }

  export type FormTemplateUpsertWithWhereUniqueWithoutFormGroupingInput = {
    where: FormTemplateWhereUniqueInput
    update: XOR<FormTemplateUpdateWithoutFormGroupingInput, FormTemplateUncheckedUpdateWithoutFormGroupingInput>
    create: XOR<FormTemplateCreateWithoutFormGroupingInput, FormTemplateUncheckedCreateWithoutFormGroupingInput>
  }

  export type FormTemplateUpdateWithWhereUniqueWithoutFormGroupingInput = {
    where: FormTemplateWhereUniqueInput
    data: XOR<FormTemplateUpdateWithoutFormGroupingInput, FormTemplateUncheckedUpdateWithoutFormGroupingInput>
  }

  export type FormTemplateUpdateManyWithWhereWithoutFormGroupingInput = {
    where: FormTemplateScalarWhereInput
    data: XOR<FormTemplateUpdateManyMutationInput, FormTemplateUncheckedUpdateManyWithoutFormGroupingInput>
  }

  export type FormGroupingCreateWithoutFieldsInput = {
    id?: string
    title?: string | null
    order: number
    FormTemplate?: FormTemplateCreateNestedManyWithoutFormGroupingInput
  }

  export type FormGroupingUncheckedCreateWithoutFieldsInput = {
    id?: string
    title?: string | null
    order: number
    FormTemplate?: FormTemplateUncheckedCreateNestedManyWithoutFormGroupingInput
  }

  export type FormGroupingCreateOrConnectWithoutFieldsInput = {
    where: FormGroupingWhereUniqueInput
    create: XOR<FormGroupingCreateWithoutFieldsInput, FormGroupingUncheckedCreateWithoutFieldsInput>
  }

  export type FormFieldOptionCreateWithoutFieldInput = {
    id?: string
    value: string
  }

  export type FormFieldOptionUncheckedCreateWithoutFieldInput = {
    id?: string
    value: string
  }

  export type FormFieldOptionCreateOrConnectWithoutFieldInput = {
    where: FormFieldOptionWhereUniqueInput
    create: XOR<FormFieldOptionCreateWithoutFieldInput, FormFieldOptionUncheckedCreateWithoutFieldInput>
  }

  export type FormFieldOptionCreateManyFieldInputEnvelope = {
    data: FormFieldOptionCreateManyFieldInput | FormFieldOptionCreateManyFieldInput[]
    skipDuplicates?: boolean
  }

  export type FormGroupingUpsertWithoutFieldsInput = {
    update: XOR<FormGroupingUpdateWithoutFieldsInput, FormGroupingUncheckedUpdateWithoutFieldsInput>
    create: XOR<FormGroupingCreateWithoutFieldsInput, FormGroupingUncheckedCreateWithoutFieldsInput>
    where?: FormGroupingWhereInput
  }

  export type FormGroupingUpdateToOneWithWhereWithoutFieldsInput = {
    where?: FormGroupingWhereInput
    data: XOR<FormGroupingUpdateWithoutFieldsInput, FormGroupingUncheckedUpdateWithoutFieldsInput>
  }

  export type FormGroupingUpdateWithoutFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    FormTemplate?: FormTemplateUpdateManyWithoutFormGroupingNestedInput
  }

  export type FormGroupingUncheckedUpdateWithoutFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    FormTemplate?: FormTemplateUncheckedUpdateManyWithoutFormGroupingNestedInput
  }

  export type FormFieldOptionUpsertWithWhereUniqueWithoutFieldInput = {
    where: FormFieldOptionWhereUniqueInput
    update: XOR<FormFieldOptionUpdateWithoutFieldInput, FormFieldOptionUncheckedUpdateWithoutFieldInput>
    create: XOR<FormFieldOptionCreateWithoutFieldInput, FormFieldOptionUncheckedCreateWithoutFieldInput>
  }

  export type FormFieldOptionUpdateWithWhereUniqueWithoutFieldInput = {
    where: FormFieldOptionWhereUniqueInput
    data: XOR<FormFieldOptionUpdateWithoutFieldInput, FormFieldOptionUncheckedUpdateWithoutFieldInput>
  }

  export type FormFieldOptionUpdateManyWithWhereWithoutFieldInput = {
    where: FormFieldOptionScalarWhereInput
    data: XOR<FormFieldOptionUpdateManyMutationInput, FormFieldOptionUncheckedUpdateManyWithoutFieldInput>
  }

  export type FormFieldOptionScalarWhereInput = {
    AND?: FormFieldOptionScalarWhereInput | FormFieldOptionScalarWhereInput[]
    OR?: FormFieldOptionScalarWhereInput[]
    NOT?: FormFieldOptionScalarWhereInput | FormFieldOptionScalarWhereInput[]
    id?: StringFilter<"FormFieldOption"> | string
    fieldId?: StringFilter<"FormFieldOption"> | string
    value?: StringFilter<"FormFieldOption"> | string
  }

  export type FormFieldCreateWithoutOptionsInput = {
    id?: string
    label: string
    type: $Enums.FieldType
    required?: boolean
    order: number
    placeholder?: string | null
    maxLength?: number | null
    content?: string | null
    filter?: string | null
    minLength?: number | null
    multiple?: boolean | null
    FormGrouping: FormGroupingCreateNestedOneWithoutFieldsInput
  }

  export type FormFieldUncheckedCreateWithoutOptionsInput = {
    id?: string
    formGroupingId: string
    label: string
    type: $Enums.FieldType
    required?: boolean
    order: number
    placeholder?: string | null
    maxLength?: number | null
    content?: string | null
    filter?: string | null
    minLength?: number | null
    multiple?: boolean | null
  }

  export type FormFieldCreateOrConnectWithoutOptionsInput = {
    where: FormFieldWhereUniqueInput
    create: XOR<FormFieldCreateWithoutOptionsInput, FormFieldUncheckedCreateWithoutOptionsInput>
  }

  export type FormFieldUpsertWithoutOptionsInput = {
    update: XOR<FormFieldUpdateWithoutOptionsInput, FormFieldUncheckedUpdateWithoutOptionsInput>
    create: XOR<FormFieldCreateWithoutOptionsInput, FormFieldUncheckedCreateWithoutOptionsInput>
    where?: FormFieldWhereInput
  }

  export type FormFieldUpdateToOneWithWhereWithoutOptionsInput = {
    where?: FormFieldWhereInput
    data: XOR<FormFieldUpdateWithoutOptionsInput, FormFieldUncheckedUpdateWithoutOptionsInput>
  }

  export type FormFieldUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    minLength?: NullableIntFieldUpdateOperationsInput | number | null
    multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    FormGrouping?: FormGroupingUpdateOneRequiredWithoutFieldsNestedInput
  }

  export type FormFieldUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    formGroupingId?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    minLength?: NullableIntFieldUpdateOperationsInput | number | null
    multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FormApprovalCreateWithoutFormSubmissionInput = {
    id?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    signature?: string | null
    comment?: string | null
    Approver?: UserCreateNestedOneWithoutFormApprovalsInput
  }

  export type FormApprovalUncheckedCreateWithoutFormSubmissionInput = {
    id?: string
    signedBy?: string | null
    submittedAt?: Date | string
    updatedAt?: Date | string
    signature?: string | null
    comment?: string | null
  }

  export type FormApprovalCreateOrConnectWithoutFormSubmissionInput = {
    where: FormApprovalWhereUniqueInput
    create: XOR<FormApprovalCreateWithoutFormSubmissionInput, FormApprovalUncheckedCreateWithoutFormSubmissionInput>
  }

  export type FormApprovalCreateManyFormSubmissionInputEnvelope = {
    data: FormApprovalCreateManyFormSubmissionInput | FormApprovalCreateManyFormSubmissionInput[]
    skipDuplicates?: boolean
  }

  export type FormTemplateCreateWithoutSubmissionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isSignatureRequired?: boolean
    description?: string | null
    isActive?: $Enums.FormTemplateStatus
    formType?: $Enums.FormTemplateCategory
    isApprovalRequired?: boolean
    Company: CompanyCreateNestedOneWithoutFormTemplatesInput
    FormGrouping?: FormGroupingCreateNestedManyWithoutFormTemplateInput
  }

  export type FormTemplateUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    companyId: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isSignatureRequired?: boolean
    description?: string | null
    isActive?: $Enums.FormTemplateStatus
    formType?: $Enums.FormTemplateCategory
    isApprovalRequired?: boolean
    FormGrouping?: FormGroupingUncheckedCreateNestedManyWithoutFormTemplateInput
  }

  export type FormTemplateCreateOrConnectWithoutSubmissionsInput = {
    where: FormTemplateWhereUniqueInput
    create: XOR<FormTemplateCreateWithoutSubmissionsInput, FormTemplateUncheckedCreateWithoutSubmissionsInput>
  }

  export type UserCreateWithoutFormSubmissionsInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Contact?: ContactsCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutFormSubmissionsInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutFormSubmissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFormSubmissionsInput, UserUncheckedCreateWithoutFormSubmissionsInput>
  }

  export type FormApprovalUpsertWithWhereUniqueWithoutFormSubmissionInput = {
    where: FormApprovalWhereUniqueInput
    update: XOR<FormApprovalUpdateWithoutFormSubmissionInput, FormApprovalUncheckedUpdateWithoutFormSubmissionInput>
    create: XOR<FormApprovalCreateWithoutFormSubmissionInput, FormApprovalUncheckedCreateWithoutFormSubmissionInput>
  }

  export type FormApprovalUpdateWithWhereUniqueWithoutFormSubmissionInput = {
    where: FormApprovalWhereUniqueInput
    data: XOR<FormApprovalUpdateWithoutFormSubmissionInput, FormApprovalUncheckedUpdateWithoutFormSubmissionInput>
  }

  export type FormApprovalUpdateManyWithWhereWithoutFormSubmissionInput = {
    where: FormApprovalScalarWhereInput
    data: XOR<FormApprovalUpdateManyMutationInput, FormApprovalUncheckedUpdateManyWithoutFormSubmissionInput>
  }

  export type FormApprovalScalarWhereInput = {
    AND?: FormApprovalScalarWhereInput | FormApprovalScalarWhereInput[]
    OR?: FormApprovalScalarWhereInput[]
    NOT?: FormApprovalScalarWhereInput | FormApprovalScalarWhereInput[]
    id?: StringFilter<"FormApproval"> | string
    signedBy?: StringNullableFilter<"FormApproval"> | string | null
    submittedAt?: DateTimeFilter<"FormApproval"> | Date | string
    updatedAt?: DateTimeFilter<"FormApproval"> | Date | string
    signature?: StringNullableFilter<"FormApproval"> | string | null
    comment?: StringNullableFilter<"FormApproval"> | string | null
    formSubmissionId?: IntFilter<"FormApproval"> | number
  }

  export type FormTemplateUpsertWithoutSubmissionsInput = {
    update: XOR<FormTemplateUpdateWithoutSubmissionsInput, FormTemplateUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<FormTemplateCreateWithoutSubmissionsInput, FormTemplateUncheckedCreateWithoutSubmissionsInput>
    where?: FormTemplateWhereInput
  }

  export type FormTemplateUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: FormTemplateWhereInput
    data: XOR<FormTemplateUpdateWithoutSubmissionsInput, FormTemplateUncheckedUpdateWithoutSubmissionsInput>
  }

  export type FormTemplateUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSignatureRequired?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    formType?: EnumFormTemplateCategoryFieldUpdateOperationsInput | $Enums.FormTemplateCategory
    isApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    Company?: CompanyUpdateOneRequiredWithoutFormTemplatesNestedInput
    FormGrouping?: FormGroupingUpdateManyWithoutFormTemplateNestedInput
  }

  export type FormTemplateUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSignatureRequired?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    formType?: EnumFormTemplateCategoryFieldUpdateOperationsInput | $Enums.FormTemplateCategory
    isApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    FormGrouping?: FormGroupingUncheckedUpdateManyWithoutFormTemplateNestedInput
  }

  export type UserUpsertWithoutFormSubmissionsInput = {
    update: XOR<UserUpdateWithoutFormSubmissionsInput, UserUncheckedUpdateWithoutFormSubmissionsInput>
    create: XOR<UserCreateWithoutFormSubmissionsInput, UserUncheckedCreateWithoutFormSubmissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFormSubmissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFormSubmissionsInput, UserUncheckedUpdateWithoutFormSubmissionsInput>
  }

  export type UserUpdateWithoutFormSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutFormSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type FormSubmissionCreateWithoutApprovalsInput = {
    title?: string | null
    formType?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    status?: $Enums.FormStatus
    FormTemplate: FormTemplateCreateNestedOneWithoutSubmissionsInput
    User: UserCreateNestedOneWithoutFormSubmissionsInput
  }

  export type FormSubmissionUncheckedCreateWithoutApprovalsInput = {
    title?: string | null
    formTemplateId: string
    userId: string
    formType?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    status?: $Enums.FormStatus
    id?: number
  }

  export type FormSubmissionCreateOrConnectWithoutApprovalsInput = {
    where: FormSubmissionWhereUniqueInput
    create: XOR<FormSubmissionCreateWithoutApprovalsInput, FormSubmissionUncheckedCreateWithoutApprovalsInput>
  }

  export type UserCreateWithoutFormApprovalsInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Contact?: ContactsCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutFormApprovalsInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutFormApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFormApprovalsInput, UserUncheckedCreateWithoutFormApprovalsInput>
  }

  export type FormSubmissionUpsertWithoutApprovalsInput = {
    update: XOR<FormSubmissionUpdateWithoutApprovalsInput, FormSubmissionUncheckedUpdateWithoutApprovalsInput>
    create: XOR<FormSubmissionCreateWithoutApprovalsInput, FormSubmissionUncheckedCreateWithoutApprovalsInput>
    where?: FormSubmissionWhereInput
  }

  export type FormSubmissionUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: FormSubmissionWhereInput
    data: XOR<FormSubmissionUpdateWithoutApprovalsInput, FormSubmissionUncheckedUpdateWithoutApprovalsInput>
  }

  export type FormSubmissionUpdateWithoutApprovalsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    formType?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    FormTemplate?: FormTemplateUpdateOneRequiredWithoutSubmissionsNestedInput
    User?: UserUpdateOneRequiredWithoutFormSubmissionsNestedInput
  }

  export type FormSubmissionUncheckedUpdateWithoutApprovalsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    formTemplateId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    formType?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    id?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpsertWithoutFormApprovalsInput = {
    update: XOR<UserUpdateWithoutFormApprovalsInput, UserUncheckedUpdateWithoutFormApprovalsInput>
    create: XOR<UserCreateWithoutFormApprovalsInput, UserUncheckedCreateWithoutFormApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFormApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFormApprovalsInput, UserUncheckedUpdateWithoutFormApprovalsInput>
  }

  export type UserUpdateWithoutFormApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutFormApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type AddressCreateWithoutJobsiteInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country?: string
    Company?: CompanyCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutJobsiteInput = {
    id?: string
    street: string
    city: string
    state: string
    zipCode: string
    country?: string
    Company?: CompanyUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutJobsiteInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutJobsiteInput, AddressUncheckedCreateWithoutJobsiteInput>
  }

  export type UserCreateWithoutJobsiteInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Contact?: ContactsCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutJobsiteInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutJobsiteInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutJobsiteInput, UserUncheckedCreateWithoutJobsiteInput>
  }

  export type TimeSheetCreateWithoutJobsiteInput = {
    date: Date | string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutTimeSheetInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogCreateNestedManyWithoutTimeSheetInput
    CostCode: CostCodeCreateNestedOneWithoutTimesheetsInput
    User: UserCreateNestedOneWithoutTimeSheetsInput
    ChangeLogs?: TimeSheetChangeLogCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetUncheckedCreateWithoutJobsiteInput = {
    date: Date | string
    userId: string
    costcode: string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    id?: number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutTimeSheetInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutTimeSheetInput
    ChangeLogs?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogUncheckedCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetCreateOrConnectWithoutJobsiteInput = {
    where: TimeSheetWhereUniqueInput
    create: XOR<TimeSheetCreateWithoutJobsiteInput, TimeSheetUncheckedCreateWithoutJobsiteInput>
  }

  export type TimeSheetCreateManyJobsiteInputEnvelope = {
    data: TimeSheetCreateManyJobsiteInput | TimeSheetCreateManyJobsiteInput[]
    skipDuplicates?: boolean
  }

  export type CCTagCreateWithoutJobsitesInput = {
    id?: string
    name: string
    description?: string | null
    CostCodes?: CostCodeCreateNestedManyWithoutCCTagsInput
  }

  export type CCTagUncheckedCreateWithoutJobsitesInput = {
    id?: string
    name: string
    description?: string | null
    CostCodes?: CostCodeUncheckedCreateNestedManyWithoutCCTagsInput
  }

  export type CCTagCreateOrConnectWithoutJobsitesInput = {
    where: CCTagWhereUniqueInput
    create: XOR<CCTagCreateWithoutJobsitesInput, CCTagUncheckedCreateWithoutJobsitesInput>
  }

  export type AddressUpsertWithoutJobsiteInput = {
    update: XOR<AddressUpdateWithoutJobsiteInput, AddressUncheckedUpdateWithoutJobsiteInput>
    create: XOR<AddressCreateWithoutJobsiteInput, AddressUncheckedCreateWithoutJobsiteInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutJobsiteInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutJobsiteInput, AddressUncheckedUpdateWithoutJobsiteInput>
  }

  export type AddressUpdateWithoutJobsiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Company?: CompanyUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutJobsiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    street?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    Company?: CompanyUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type UserUpsertWithoutJobsiteInput = {
    update: XOR<UserUpdateWithoutJobsiteInput, UserUncheckedUpdateWithoutJobsiteInput>
    create: XOR<UserCreateWithoutJobsiteInput, UserUncheckedCreateWithoutJobsiteInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutJobsiteInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutJobsiteInput, UserUncheckedUpdateWithoutJobsiteInput>
  }

  export type UserUpdateWithoutJobsiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutJobsiteInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type TimeSheetUpsertWithWhereUniqueWithoutJobsiteInput = {
    where: TimeSheetWhereUniqueInput
    update: XOR<TimeSheetUpdateWithoutJobsiteInput, TimeSheetUncheckedUpdateWithoutJobsiteInput>
    create: XOR<TimeSheetCreateWithoutJobsiteInput, TimeSheetUncheckedCreateWithoutJobsiteInput>
  }

  export type TimeSheetUpdateWithWhereUniqueWithoutJobsiteInput = {
    where: TimeSheetWhereUniqueInput
    data: XOR<TimeSheetUpdateWithoutJobsiteInput, TimeSheetUncheckedUpdateWithoutJobsiteInput>
  }

  export type TimeSheetUpdateManyWithWhereWithoutJobsiteInput = {
    where: TimeSheetScalarWhereInput
    data: XOR<TimeSheetUpdateManyMutationInput, TimeSheetUncheckedUpdateManyWithoutJobsiteInput>
  }

  export type CCTagUpsertWithWhereUniqueWithoutJobsitesInput = {
    where: CCTagWhereUniqueInput
    update: XOR<CCTagUpdateWithoutJobsitesInput, CCTagUncheckedUpdateWithoutJobsitesInput>
    create: XOR<CCTagCreateWithoutJobsitesInput, CCTagUncheckedCreateWithoutJobsitesInput>
  }

  export type CCTagUpdateWithWhereUniqueWithoutJobsitesInput = {
    where: CCTagWhereUniqueInput
    data: XOR<CCTagUpdateWithoutJobsitesInput, CCTagUncheckedUpdateWithoutJobsitesInput>
  }

  export type CCTagUpdateManyWithWhereWithoutJobsitesInput = {
    where: CCTagScalarWhereInput
    data: XOR<CCTagUpdateManyMutationInput, CCTagUncheckedUpdateManyWithoutJobsitesInput>
  }

  export type CompanyCreateWithoutReportsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubscriptionDate?: Date | string
    Address?: AddressCreateNestedOneWithoutCompanyInput
    FormTemplates?: FormTemplateCreateNestedManyWithoutCompanyInput
    Users?: UserCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    addressId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SubscriptionDate?: Date | string
    FormTemplates?: FormTemplateUncheckedCreateNestedManyWithoutCompanyInput
    Users?: UserUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutReportsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutReportsInput, CompanyUncheckedCreateWithoutReportsInput>
  }

  export type ReportRunCreateWithoutReportInput = {
    id?: string
    runAt?: Date | string
    status: $Enums.ReportStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    customParams?: NullableJsonNullValueInput | InputJsonValue
    exportFormats?: ReportRunCreateexportFormatsInput | string[]
    lastExportedAt?: Date | string | null
  }

  export type ReportRunUncheckedCreateWithoutReportInput = {
    id?: string
    runAt?: Date | string
    status: $Enums.ReportStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    customParams?: NullableJsonNullValueInput | InputJsonValue
    exportFormats?: ReportRunCreateexportFormatsInput | string[]
    lastExportedAt?: Date | string | null
  }

  export type ReportRunCreateOrConnectWithoutReportInput = {
    where: ReportRunWhereUniqueInput
    create: XOR<ReportRunCreateWithoutReportInput, ReportRunUncheckedCreateWithoutReportInput>
  }

  export type ReportRunCreateManyReportInputEnvelope = {
    data: ReportRunCreateManyReportInput | ReportRunCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutReportsInput = {
    update: XOR<CompanyUpdateWithoutReportsInput, CompanyUncheckedUpdateWithoutReportsInput>
    create: XOR<CompanyCreateWithoutReportsInput, CompanyUncheckedCreateWithoutReportsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutReportsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutReportsInput, CompanyUncheckedUpdateWithoutReportsInput>
  }

  export type CompanyUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubscriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Address?: AddressUpdateOneWithoutCompanyNestedInput
    FormTemplates?: FormTemplateUpdateManyWithoutCompanyNestedInput
    Users?: UserUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubscriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FormTemplates?: FormTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    Users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type ReportRunUpsertWithWhereUniqueWithoutReportInput = {
    where: ReportRunWhereUniqueInput
    update: XOR<ReportRunUpdateWithoutReportInput, ReportRunUncheckedUpdateWithoutReportInput>
    create: XOR<ReportRunCreateWithoutReportInput, ReportRunUncheckedCreateWithoutReportInput>
  }

  export type ReportRunUpdateWithWhereUniqueWithoutReportInput = {
    where: ReportRunWhereUniqueInput
    data: XOR<ReportRunUpdateWithoutReportInput, ReportRunUncheckedUpdateWithoutReportInput>
  }

  export type ReportRunUpdateManyWithWhereWithoutReportInput = {
    where: ReportRunScalarWhereInput
    data: XOR<ReportRunUpdateManyMutationInput, ReportRunUncheckedUpdateManyWithoutReportInput>
  }

  export type ReportRunScalarWhereInput = {
    AND?: ReportRunScalarWhereInput | ReportRunScalarWhereInput[]
    OR?: ReportRunScalarWhereInput[]
    NOT?: ReportRunScalarWhereInput | ReportRunScalarWhereInput[]
    id?: StringFilter<"ReportRun"> | string
    runAt?: DateTimeFilter<"ReportRun"> | Date | string
    status?: EnumReportStatusFilter<"ReportRun"> | $Enums.ReportStatus
    results?: JsonNullableFilter<"ReportRun">
    duration?: IntNullableFilter<"ReportRun"> | number | null
    startDate?: DateTimeNullableFilter<"ReportRun"> | Date | string | null
    endDate?: DateTimeNullableFilter<"ReportRun"> | Date | string | null
    customParams?: JsonNullableFilter<"ReportRun">
    exportFormats?: StringNullableListFilter<"ReportRun">
    lastExportedAt?: DateTimeNullableFilter<"ReportRun"> | Date | string | null
    reportId?: IntFilter<"ReportRun"> | number
  }

  export type ReportCreateWithoutReportRunsInput = {
    name: string
    description: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.ReportVisibility
    tags?: ReportCreatetagsInput | string[]
    id: number
    Company: CompanyCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutReportRunsInput = {
    name: string
    description: string
    companyId: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.ReportVisibility
    tags?: ReportCreatetagsInput | string[]
    id: number
  }

  export type ReportCreateOrConnectWithoutReportRunsInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReportRunsInput, ReportUncheckedCreateWithoutReportRunsInput>
  }

  export type ReportUpsertWithoutReportRunsInput = {
    update: XOR<ReportUpdateWithoutReportRunsInput, ReportUncheckedUpdateWithoutReportRunsInput>
    create: XOR<ReportCreateWithoutReportRunsInput, ReportUncheckedCreateWithoutReportRunsInput>
    where?: ReportWhereInput
  }

  export type ReportUpdateToOneWithWhereWithoutReportRunsInput = {
    where?: ReportWhereInput
    data: XOR<ReportUpdateWithoutReportRunsInput, ReportUncheckedUpdateWithoutReportRunsInput>
  }

  export type ReportUpdateWithoutReportRunsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumReportVisibilityFieldUpdateOperationsInput | $Enums.ReportVisibility
    tags?: ReportUpdatetagsInput | string[]
    id?: IntFieldUpdateOperationsInput | number
    Company?: CompanyUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutReportRunsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumReportVisibilityFieldUpdateOperationsInput | $Enums.ReportVisibility
    tags?: ReportUpdatetagsInput | string[]
    id?: IntFieldUpdateOperationsInput | number
  }

  export type EmployeeEquipmentLogCreateWithoutTimeSheetInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    comment?: string | null
    rental?: boolean
    Equipment?: EquipmentCreateNestedOneWithoutEmployeeEquipmentLogsInput
    Maintenance?: MaintenanceCreateNestedOneWithoutEmployeeEquipmentLogInput
    RefuelLog?: RefuelLogCreateNestedOneWithoutEmployeeEquipmentLogInput
  }

  export type EmployeeEquipmentLogUncheckedCreateWithoutTimeSheetInput = {
    id?: string
    equipmentId?: string | null
    maintenanceId?: string | null
    startTime?: Date | string
    endTime?: Date | string | null
    comment?: string | null
    rental?: boolean
    RefuelLog?: RefuelLogUncheckedCreateNestedOneWithoutEmployeeEquipmentLogInput
  }

  export type EmployeeEquipmentLogCreateOrConnectWithoutTimeSheetInput = {
    where: EmployeeEquipmentLogWhereUniqueInput
    create: XOR<EmployeeEquipmentLogCreateWithoutTimeSheetInput, EmployeeEquipmentLogUncheckedCreateWithoutTimeSheetInput>
  }

  export type EmployeeEquipmentLogCreateManyTimeSheetInputEnvelope = {
    data: EmployeeEquipmentLogCreateManyTimeSheetInput | EmployeeEquipmentLogCreateManyTimeSheetInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceLogCreateWithoutTimeSheetInput = {
    id?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    Maintenance: MaintenanceCreateNestedOneWithoutMaintenanceLogsInput
    User: UserCreateNestedOneWithoutMaintenanceLogsInput
  }

  export type MaintenanceLogUncheckedCreateWithoutTimeSheetInput = {
    id?: string
    userId: string
    maintenanceId: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
  }

  export type MaintenanceLogCreateOrConnectWithoutTimeSheetInput = {
    where: MaintenanceLogWhereUniqueInput
    create: XOR<MaintenanceLogCreateWithoutTimeSheetInput, MaintenanceLogUncheckedCreateWithoutTimeSheetInput>
  }

  export type MaintenanceLogCreateManyTimeSheetInputEnvelope = {
    data: MaintenanceLogCreateManyTimeSheetInput | MaintenanceLogCreateManyTimeSheetInput[]
    skipDuplicates?: boolean
  }

  export type TascoLogCreateWithoutTimeSheetInput = {
    id?: string
    shiftType: string
    laborType?: string | null
    LoadQuantity?: number
    screenType?: $Enums.LoadType | null
    RefuelLogs?: RefuelLogCreateNestedManyWithoutTascoLogInput
    TascoFLoads?: TascoFLoadsCreateNestedManyWithoutTascoLogInput
    Equipment?: EquipmentCreateNestedOneWithoutTascoLogsInput
    TascoMaterialTypes?: TascoMaterialTypesCreateNestedOneWithoutTascoLogInput
  }

  export type TascoLogUncheckedCreateWithoutTimeSheetInput = {
    id?: string
    shiftType: string
    equipmentId?: string | null
    laborType?: string | null
    materialType?: string | null
    LoadQuantity?: number
    screenType?: $Enums.LoadType | null
    RefuelLogs?: RefuelLogUncheckedCreateNestedManyWithoutTascoLogInput
    TascoFLoads?: TascoFLoadsUncheckedCreateNestedManyWithoutTascoLogInput
  }

  export type TascoLogCreateOrConnectWithoutTimeSheetInput = {
    where: TascoLogWhereUniqueInput
    create: XOR<TascoLogCreateWithoutTimeSheetInput, TascoLogUncheckedCreateWithoutTimeSheetInput>
  }

  export type TascoLogCreateManyTimeSheetInputEnvelope = {
    data: TascoLogCreateManyTimeSheetInput | TascoLogCreateManyTimeSheetInput[]
    skipDuplicates?: boolean
  }

  export type CostCodeCreateWithoutTimesheetsInput = {
    id?: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code?: string | null
    CCTags?: CCTagCreateNestedManyWithoutCostCodesInput
  }

  export type CostCodeUncheckedCreateWithoutTimesheetsInput = {
    id?: string
    name: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    code?: string | null
    CCTags?: CCTagUncheckedCreateNestedManyWithoutCostCodesInput
  }

  export type CostCodeCreateOrConnectWithoutTimesheetsInput = {
    where: CostCodeWhereUniqueInput
    create: XOR<CostCodeCreateWithoutTimesheetsInput, CostCodeUncheckedCreateWithoutTimesheetsInput>
  }

  export type JobsiteCreateWithoutTimeSheetsInput = {
    id?: string
    qrId?: string
    name: string
    description: string
    creationReason?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    archiveDate?: Date | string | null
    createdVia?: $Enums.CreatedVia
    code?: string | null
    latitude?: number | null
    longitude?: number | null
    radiusMeters?: number | null
    status?: $Enums.FormTemplateStatus
    Address?: AddressCreateNestedOneWithoutJobsiteInput
    createdBy?: UserCreateNestedOneWithoutJobsiteInput
    CCTags?: CCTagCreateNestedManyWithoutJobsitesInput
  }

  export type JobsiteUncheckedCreateWithoutTimeSheetsInput = {
    id?: string
    qrId?: string
    name: string
    description: string
    creationReason?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    addressId?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    archiveDate?: Date | string | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    code?: string | null
    latitude?: number | null
    longitude?: number | null
    radiusMeters?: number | null
    status?: $Enums.FormTemplateStatus
    CCTags?: CCTagUncheckedCreateNestedManyWithoutJobsitesInput
  }

  export type JobsiteCreateOrConnectWithoutTimeSheetsInput = {
    where: JobsiteWhereUniqueInput
    create: XOR<JobsiteCreateWithoutTimeSheetsInput, JobsiteUncheckedCreateWithoutTimeSheetsInput>
  }

  export type UserCreateWithoutTimeSheetsInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Contact?: ContactsCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutTimeSheetsInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutTimeSheetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTimeSheetsInput, UserUncheckedCreateWithoutTimeSheetsInput>
  }

  export type TimeSheetChangeLogCreateWithoutTimeSheetInput = {
    id?: string
    changedAt?: Date | string
    changeReason?: string | null
    changes: JsonNullValueInput | InputJsonValue
    wasStatusChange?: boolean
    numberOfChanges?: number
    User: UserCreateNestedOneWithoutTimeSheetChangesInput
  }

  export type TimeSheetChangeLogUncheckedCreateWithoutTimeSheetInput = {
    id?: string
    changedBy: string
    changedAt?: Date | string
    changeReason?: string | null
    changes: JsonNullValueInput | InputJsonValue
    wasStatusChange?: boolean
    numberOfChanges?: number
  }

  export type TimeSheetChangeLogCreateOrConnectWithoutTimeSheetInput = {
    where: TimeSheetChangeLogWhereUniqueInput
    create: XOR<TimeSheetChangeLogCreateWithoutTimeSheetInput, TimeSheetChangeLogUncheckedCreateWithoutTimeSheetInput>
  }

  export type TimeSheetChangeLogCreateManyTimeSheetInputEnvelope = {
    data: TimeSheetChangeLogCreateManyTimeSheetInput | TimeSheetChangeLogCreateManyTimeSheetInput[]
    skipDuplicates?: boolean
  }

  export type TruckingLogCreateWithoutTimeSheetInput = {
    id?: string
    laborType: string
    taskName?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutTruckingLogInput
    Materials?: MaterialCreateNestedManyWithoutTruckingLogInput
    RefuelLogs?: RefuelLogCreateNestedManyWithoutTruckingLogInput
    StateMileages?: StateMileageCreateNestedManyWithoutTruckingLogInput
    Equipment?: EquipmentCreateNestedOneWithoutHauledInLogsInput
    Trailer?: EquipmentCreateNestedOneWithoutUsedAsTrailerInput
    Truck?: EquipmentCreateNestedOneWithoutUsedAsTruckInput
  }

  export type TruckingLogUncheckedCreateWithoutTimeSheetInput = {
    id?: string
    laborType: string
    taskName?: string | null
    equipmentId?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    trailerNumber?: string | null
    truckNumber?: string | null
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutTruckingLogInput
    Materials?: MaterialUncheckedCreateNestedManyWithoutTruckingLogInput
    RefuelLogs?: RefuelLogUncheckedCreateNestedManyWithoutTruckingLogInput
    StateMileages?: StateMileageUncheckedCreateNestedManyWithoutTruckingLogInput
  }

  export type TruckingLogCreateOrConnectWithoutTimeSheetInput = {
    where: TruckingLogWhereUniqueInput
    create: XOR<TruckingLogCreateWithoutTimeSheetInput, TruckingLogUncheckedCreateWithoutTimeSheetInput>
  }

  export type TruckingLogCreateManyTimeSheetInputEnvelope = {
    data: TruckingLogCreateManyTimeSheetInput | TruckingLogCreateManyTimeSheetInput[]
    skipDuplicates?: boolean
  }

  export type mechanicProjectsCreateWithoutTimeSheetInput = {
    hours?: number | null
    description?: string | null
    Equipment: EquipmentCreateNestedOneWithoutMaintenanceInput
  }

  export type mechanicProjectsUncheckedCreateWithoutTimeSheetInput = {
    id?: number
    hours?: number | null
    equipmentId: string
    description?: string | null
  }

  export type mechanicProjectsCreateOrConnectWithoutTimeSheetInput = {
    where: mechanicProjectsWhereUniqueInput
    create: XOR<mechanicProjectsCreateWithoutTimeSheetInput, mechanicProjectsUncheckedCreateWithoutTimeSheetInput>
  }

  export type mechanicProjectsCreateManyTimeSheetInputEnvelope = {
    data: mechanicProjectsCreateManyTimeSheetInput | mechanicProjectsCreateManyTimeSheetInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeEquipmentLogUpsertWithWhereUniqueWithoutTimeSheetInput = {
    where: EmployeeEquipmentLogWhereUniqueInput
    update: XOR<EmployeeEquipmentLogUpdateWithoutTimeSheetInput, EmployeeEquipmentLogUncheckedUpdateWithoutTimeSheetInput>
    create: XOR<EmployeeEquipmentLogCreateWithoutTimeSheetInput, EmployeeEquipmentLogUncheckedCreateWithoutTimeSheetInput>
  }

  export type EmployeeEquipmentLogUpdateWithWhereUniqueWithoutTimeSheetInput = {
    where: EmployeeEquipmentLogWhereUniqueInput
    data: XOR<EmployeeEquipmentLogUpdateWithoutTimeSheetInput, EmployeeEquipmentLogUncheckedUpdateWithoutTimeSheetInput>
  }

  export type EmployeeEquipmentLogUpdateManyWithWhereWithoutTimeSheetInput = {
    where: EmployeeEquipmentLogScalarWhereInput
    data: XOR<EmployeeEquipmentLogUpdateManyMutationInput, EmployeeEquipmentLogUncheckedUpdateManyWithoutTimeSheetInput>
  }

  export type MaintenanceLogUpsertWithWhereUniqueWithoutTimeSheetInput = {
    where: MaintenanceLogWhereUniqueInput
    update: XOR<MaintenanceLogUpdateWithoutTimeSheetInput, MaintenanceLogUncheckedUpdateWithoutTimeSheetInput>
    create: XOR<MaintenanceLogCreateWithoutTimeSheetInput, MaintenanceLogUncheckedCreateWithoutTimeSheetInput>
  }

  export type MaintenanceLogUpdateWithWhereUniqueWithoutTimeSheetInput = {
    where: MaintenanceLogWhereUniqueInput
    data: XOR<MaintenanceLogUpdateWithoutTimeSheetInput, MaintenanceLogUncheckedUpdateWithoutTimeSheetInput>
  }

  export type MaintenanceLogUpdateManyWithWhereWithoutTimeSheetInput = {
    where: MaintenanceLogScalarWhereInput
    data: XOR<MaintenanceLogUpdateManyMutationInput, MaintenanceLogUncheckedUpdateManyWithoutTimeSheetInput>
  }

  export type MaintenanceLogScalarWhereInput = {
    AND?: MaintenanceLogScalarWhereInput | MaintenanceLogScalarWhereInput[]
    OR?: MaintenanceLogScalarWhereInput[]
    NOT?: MaintenanceLogScalarWhereInput | MaintenanceLogScalarWhereInput[]
    id?: StringFilter<"MaintenanceLog"> | string
    userId?: StringFilter<"MaintenanceLog"> | string
    maintenanceId?: StringFilter<"MaintenanceLog"> | string
    startTime?: DateTimeFilter<"MaintenanceLog"> | Date | string
    endTime?: DateTimeNullableFilter<"MaintenanceLog"> | Date | string | null
    comment?: StringNullableFilter<"MaintenanceLog"> | string | null
    timeSheetId?: IntFilter<"MaintenanceLog"> | number
  }

  export type TascoLogUpsertWithWhereUniqueWithoutTimeSheetInput = {
    where: TascoLogWhereUniqueInput
    update: XOR<TascoLogUpdateWithoutTimeSheetInput, TascoLogUncheckedUpdateWithoutTimeSheetInput>
    create: XOR<TascoLogCreateWithoutTimeSheetInput, TascoLogUncheckedCreateWithoutTimeSheetInput>
  }

  export type TascoLogUpdateWithWhereUniqueWithoutTimeSheetInput = {
    where: TascoLogWhereUniqueInput
    data: XOR<TascoLogUpdateWithoutTimeSheetInput, TascoLogUncheckedUpdateWithoutTimeSheetInput>
  }

  export type TascoLogUpdateManyWithWhereWithoutTimeSheetInput = {
    where: TascoLogScalarWhereInput
    data: XOR<TascoLogUpdateManyMutationInput, TascoLogUncheckedUpdateManyWithoutTimeSheetInput>
  }

  export type CostCodeUpsertWithoutTimesheetsInput = {
    update: XOR<CostCodeUpdateWithoutTimesheetsInput, CostCodeUncheckedUpdateWithoutTimesheetsInput>
    create: XOR<CostCodeCreateWithoutTimesheetsInput, CostCodeUncheckedCreateWithoutTimesheetsInput>
    where?: CostCodeWhereInput
  }

  export type CostCodeUpdateToOneWithWhereWithoutTimesheetsInput = {
    where?: CostCodeWhereInput
    data: XOR<CostCodeUpdateWithoutTimesheetsInput, CostCodeUncheckedUpdateWithoutTimesheetsInput>
  }

  export type CostCodeUpdateWithoutTimesheetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    CCTags?: CCTagUpdateManyWithoutCostCodesNestedInput
  }

  export type CostCodeUncheckedUpdateWithoutTimesheetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    CCTags?: CCTagUncheckedUpdateManyWithoutCostCodesNestedInput
  }

  export type JobsiteUpsertWithoutTimeSheetsInput = {
    update: XOR<JobsiteUpdateWithoutTimeSheetsInput, JobsiteUncheckedUpdateWithoutTimeSheetsInput>
    create: XOR<JobsiteCreateWithoutTimeSheetsInput, JobsiteUncheckedCreateWithoutTimeSheetsInput>
    where?: JobsiteWhereInput
  }

  export type JobsiteUpdateToOneWithWhereWithoutTimeSheetsInput = {
    where?: JobsiteWhereInput
    data: XOR<JobsiteUpdateWithoutTimeSheetsInput, JobsiteUncheckedUpdateWithoutTimeSheetsInput>
  }

  export type JobsiteUpdateWithoutTimeSheetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    code?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radiusMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    Address?: AddressUpdateOneWithoutJobsiteNestedInput
    createdBy?: UserUpdateOneWithoutJobsiteNestedInput
    CCTags?: CCTagUpdateManyWithoutJobsitesNestedInput
  }

  export type JobsiteUncheckedUpdateWithoutTimeSheetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    code?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radiusMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    CCTags?: CCTagUncheckedUpdateManyWithoutJobsitesNestedInput
  }

  export type UserUpsertWithoutTimeSheetsInput = {
    update: XOR<UserUpdateWithoutTimeSheetsInput, UserUncheckedUpdateWithoutTimeSheetsInput>
    create: XOR<UserCreateWithoutTimeSheetsInput, UserUncheckedCreateWithoutTimeSheetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTimeSheetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTimeSheetsInput, UserUncheckedUpdateWithoutTimeSheetsInput>
  }

  export type UserUpdateWithoutTimeSheetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutTimeSheetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type TimeSheetChangeLogUpsertWithWhereUniqueWithoutTimeSheetInput = {
    where: TimeSheetChangeLogWhereUniqueInput
    update: XOR<TimeSheetChangeLogUpdateWithoutTimeSheetInput, TimeSheetChangeLogUncheckedUpdateWithoutTimeSheetInput>
    create: XOR<TimeSheetChangeLogCreateWithoutTimeSheetInput, TimeSheetChangeLogUncheckedCreateWithoutTimeSheetInput>
  }

  export type TimeSheetChangeLogUpdateWithWhereUniqueWithoutTimeSheetInput = {
    where: TimeSheetChangeLogWhereUniqueInput
    data: XOR<TimeSheetChangeLogUpdateWithoutTimeSheetInput, TimeSheetChangeLogUncheckedUpdateWithoutTimeSheetInput>
  }

  export type TimeSheetChangeLogUpdateManyWithWhereWithoutTimeSheetInput = {
    where: TimeSheetChangeLogScalarWhereInput
    data: XOR<TimeSheetChangeLogUpdateManyMutationInput, TimeSheetChangeLogUncheckedUpdateManyWithoutTimeSheetInput>
  }

  export type TimeSheetChangeLogScalarWhereInput = {
    AND?: TimeSheetChangeLogScalarWhereInput | TimeSheetChangeLogScalarWhereInput[]
    OR?: TimeSheetChangeLogScalarWhereInput[]
    NOT?: TimeSheetChangeLogScalarWhereInput | TimeSheetChangeLogScalarWhereInput[]
    id?: StringFilter<"TimeSheetChangeLog"> | string
    timeSheetId?: IntFilter<"TimeSheetChangeLog"> | number
    changedBy?: StringFilter<"TimeSheetChangeLog"> | string
    changedAt?: DateTimeFilter<"TimeSheetChangeLog"> | Date | string
    changeReason?: StringNullableFilter<"TimeSheetChangeLog"> | string | null
    changes?: JsonFilter<"TimeSheetChangeLog">
    wasStatusChange?: BoolFilter<"TimeSheetChangeLog"> | boolean
    numberOfChanges?: IntFilter<"TimeSheetChangeLog"> | number
  }

  export type TruckingLogUpsertWithWhereUniqueWithoutTimeSheetInput = {
    where: TruckingLogWhereUniqueInput
    update: XOR<TruckingLogUpdateWithoutTimeSheetInput, TruckingLogUncheckedUpdateWithoutTimeSheetInput>
    create: XOR<TruckingLogCreateWithoutTimeSheetInput, TruckingLogUncheckedCreateWithoutTimeSheetInput>
  }

  export type TruckingLogUpdateWithWhereUniqueWithoutTimeSheetInput = {
    where: TruckingLogWhereUniqueInput
    data: XOR<TruckingLogUpdateWithoutTimeSheetInput, TruckingLogUncheckedUpdateWithoutTimeSheetInput>
  }

  export type TruckingLogUpdateManyWithWhereWithoutTimeSheetInput = {
    where: TruckingLogScalarWhereInput
    data: XOR<TruckingLogUpdateManyMutationInput, TruckingLogUncheckedUpdateManyWithoutTimeSheetInput>
  }

  export type mechanicProjectsUpsertWithWhereUniqueWithoutTimeSheetInput = {
    where: mechanicProjectsWhereUniqueInput
    update: XOR<mechanicProjectsUpdateWithoutTimeSheetInput, mechanicProjectsUncheckedUpdateWithoutTimeSheetInput>
    create: XOR<mechanicProjectsCreateWithoutTimeSheetInput, mechanicProjectsUncheckedCreateWithoutTimeSheetInput>
  }

  export type mechanicProjectsUpdateWithWhereUniqueWithoutTimeSheetInput = {
    where: mechanicProjectsWhereUniqueInput
    data: XOR<mechanicProjectsUpdateWithoutTimeSheetInput, mechanicProjectsUncheckedUpdateWithoutTimeSheetInput>
  }

  export type mechanicProjectsUpdateManyWithWhereWithoutTimeSheetInput = {
    where: mechanicProjectsScalarWhereInput
    data: XOR<mechanicProjectsUpdateManyMutationInput, mechanicProjectsUncheckedUpdateManyWithoutTimeSheetInput>
  }

  export type EquipmentCreateWithoutMaintenanceInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutEquipmentInput
    createdBy?: UserCreateNestedOneWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogCreateNestedManyWithoutTruckInput
    DocumentTags?: DocumentTagCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutMaintenanceInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogUncheckedCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogUncheckedCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogUncheckedCreateNestedManyWithoutTruckInput
    DocumentTags?: DocumentTagUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutMaintenanceInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutMaintenanceInput, EquipmentUncheckedCreateWithoutMaintenanceInput>
  }

  export type TimeSheetCreateWithoutMaintenanceInput = {
    date: Date | string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutTimeSheetInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogCreateNestedManyWithoutTimeSheetInput
    CostCode: CostCodeCreateNestedOneWithoutTimesheetsInput
    Jobsite: JobsiteCreateNestedOneWithoutTimeSheetsInput
    User: UserCreateNestedOneWithoutTimeSheetsInput
    ChangeLogs?: TimeSheetChangeLogCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetUncheckedCreateWithoutMaintenanceInput = {
    date: Date | string
    userId: string
    jobsiteId: string
    costcode: string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    id?: number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutTimeSheetInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutTimeSheetInput
    ChangeLogs?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogUncheckedCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetCreateOrConnectWithoutMaintenanceInput = {
    where: TimeSheetWhereUniqueInput
    create: XOR<TimeSheetCreateWithoutMaintenanceInput, TimeSheetUncheckedCreateWithoutMaintenanceInput>
  }

  export type EquipmentUpsertWithoutMaintenanceInput = {
    update: XOR<EquipmentUpdateWithoutMaintenanceInput, EquipmentUncheckedUpdateWithoutMaintenanceInput>
    create: XOR<EquipmentCreateWithoutMaintenanceInput, EquipmentUncheckedCreateWithoutMaintenanceInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutMaintenanceInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutMaintenanceInput, EquipmentUncheckedUpdateWithoutMaintenanceInput>
  }

  export type EquipmentUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutEquipmentNestedInput
    createdBy?: UserUpdateOneWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUpdateManyWithoutTruckNestedInput
    DocumentTags?: DocumentTagUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUncheckedUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUncheckedUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUncheckedUpdateManyWithoutTruckNestedInput
    DocumentTags?: DocumentTagUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type TimeSheetUpsertWithoutMaintenanceInput = {
    update: XOR<TimeSheetUpdateWithoutMaintenanceInput, TimeSheetUncheckedUpdateWithoutMaintenanceInput>
    create: XOR<TimeSheetCreateWithoutMaintenanceInput, TimeSheetUncheckedCreateWithoutMaintenanceInput>
    where?: TimeSheetWhereInput
  }

  export type TimeSheetUpdateToOneWithWhereWithoutMaintenanceInput = {
    where?: TimeSheetWhereInput
    data: XOR<TimeSheetUpdateWithoutMaintenanceInput, TimeSheetUncheckedUpdateWithoutMaintenanceInput>
  }

  export type TimeSheetUpdateWithoutMaintenanceInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutTimeSheetNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutTimeSheetNestedInput
    CostCode?: CostCodeUpdateOneRequiredWithoutTimesheetsNestedInput
    Jobsite?: JobsiteUpdateOneRequiredWithoutTimeSheetsNestedInput
    User?: UserUpdateOneRequiredWithoutTimeSheetsNestedInput
    ChangeLogs?: TimeSheetChangeLogUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUpdateManyWithoutTimeSheetNestedInput
  }

  export type TimeSheetUncheckedUpdateWithoutMaintenanceInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    jobsiteId?: StringFieldUpdateOperationsInput | string
    costcode?: StringFieldUpdateOperationsInput | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    ChangeLogs?: TimeSheetChangeLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUncheckedUpdateManyWithoutTimeSheetNestedInput
  }

  export type MaintenanceCreateWithoutMaintenanceLogsInput = {
    id?: string
    equipmentIssue?: string | null
    employeeEquipmentLogId?: string | null
    additionalInfo?: string | null
    location?: string | null
    problemDiagnosis?: string | null
    solution?: string | null
    totalHoursLaboured?: number | null
    createdAt?: Date | string
    priority: $Enums.Priority
    delay?: Date | string | null
    delayReasoning?: string | null
    repaired?: boolean
    selected?: boolean
    hasBeenDelayed?: boolean
    createdBy?: string | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogCreateNestedManyWithoutMaintenanceInput
    Equipment: EquipmentCreateNestedOneWithoutMaintenancesInput
  }

  export type MaintenanceUncheckedCreateWithoutMaintenanceLogsInput = {
    id?: string
    equipmentId: string
    equipmentIssue?: string | null
    employeeEquipmentLogId?: string | null
    additionalInfo?: string | null
    location?: string | null
    problemDiagnosis?: string | null
    solution?: string | null
    totalHoursLaboured?: number | null
    createdAt?: Date | string
    priority: $Enums.Priority
    delay?: Date | string | null
    delayReasoning?: string | null
    repaired?: boolean
    selected?: boolean
    hasBeenDelayed?: boolean
    createdBy?: string | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutMaintenanceInput
  }

  export type MaintenanceCreateOrConnectWithoutMaintenanceLogsInput = {
    where: MaintenanceWhereUniqueInput
    create: XOR<MaintenanceCreateWithoutMaintenanceLogsInput, MaintenanceUncheckedCreateWithoutMaintenanceLogsInput>
  }

  export type TimeSheetCreateWithoutMaintenanceLogsInput = {
    date: Date | string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogCreateNestedManyWithoutTimeSheetInput
    CostCode: CostCodeCreateNestedOneWithoutTimesheetsInput
    Jobsite: JobsiteCreateNestedOneWithoutTimeSheetsInput
    User: UserCreateNestedOneWithoutTimeSheetsInput
    ChangeLogs?: TimeSheetChangeLogCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetUncheckedCreateWithoutMaintenanceLogsInput = {
    date: Date | string
    userId: string
    jobsiteId: string
    costcode: string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    id?: number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutTimeSheetInput
    ChangeLogs?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogUncheckedCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetCreateOrConnectWithoutMaintenanceLogsInput = {
    where: TimeSheetWhereUniqueInput
    create: XOR<TimeSheetCreateWithoutMaintenanceLogsInput, TimeSheetUncheckedCreateWithoutMaintenanceLogsInput>
  }

  export type UserCreateWithoutMaintenanceLogsInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Contact?: ContactsCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutMaintenanceLogsInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutMaintenanceLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMaintenanceLogsInput, UserUncheckedCreateWithoutMaintenanceLogsInput>
  }

  export type MaintenanceUpsertWithoutMaintenanceLogsInput = {
    update: XOR<MaintenanceUpdateWithoutMaintenanceLogsInput, MaintenanceUncheckedUpdateWithoutMaintenanceLogsInput>
    create: XOR<MaintenanceCreateWithoutMaintenanceLogsInput, MaintenanceUncheckedCreateWithoutMaintenanceLogsInput>
    where?: MaintenanceWhereInput
  }

  export type MaintenanceUpdateToOneWithWhereWithoutMaintenanceLogsInput = {
    where?: MaintenanceWhereInput
    data: XOR<MaintenanceUpdateWithoutMaintenanceLogsInput, MaintenanceUncheckedUpdateWithoutMaintenanceLogsInput>
  }

  export type MaintenanceUpdateWithoutMaintenanceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentIssue?: NullableStringFieldUpdateOperationsInput | string | null
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    problemDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    totalHoursLaboured?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    delay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delayReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    repaired?: BoolFieldUpdateOperationsInput | boolean
    selected?: BoolFieldUpdateOperationsInput | boolean
    hasBeenDelayed?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogUpdateManyWithoutMaintenanceNestedInput
    Equipment?: EquipmentUpdateOneRequiredWithoutMaintenancesNestedInput
  }

  export type MaintenanceUncheckedUpdateWithoutMaintenanceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    equipmentIssue?: NullableStringFieldUpdateOperationsInput | string | null
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    problemDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    totalHoursLaboured?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    delay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delayReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    repaired?: BoolFieldUpdateOperationsInput | boolean
    selected?: BoolFieldUpdateOperationsInput | boolean
    hasBeenDelayed?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogUncheckedUpdateManyWithoutMaintenanceNestedInput
  }

  export type TimeSheetUpsertWithoutMaintenanceLogsInput = {
    update: XOR<TimeSheetUpdateWithoutMaintenanceLogsInput, TimeSheetUncheckedUpdateWithoutMaintenanceLogsInput>
    create: XOR<TimeSheetCreateWithoutMaintenanceLogsInput, TimeSheetUncheckedCreateWithoutMaintenanceLogsInput>
    where?: TimeSheetWhereInput
  }

  export type TimeSheetUpdateToOneWithWhereWithoutMaintenanceLogsInput = {
    where?: TimeSheetWhereInput
    data: XOR<TimeSheetUpdateWithoutMaintenanceLogsInput, TimeSheetUncheckedUpdateWithoutMaintenanceLogsInput>
  }

  export type TimeSheetUpdateWithoutMaintenanceLogsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutTimeSheetNestedInput
    CostCode?: CostCodeUpdateOneRequiredWithoutTimesheetsNestedInput
    Jobsite?: JobsiteUpdateOneRequiredWithoutTimeSheetsNestedInput
    User?: UserUpdateOneRequiredWithoutTimeSheetsNestedInput
    ChangeLogs?: TimeSheetChangeLogUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutTimeSheetNestedInput
  }

  export type TimeSheetUncheckedUpdateWithoutMaintenanceLogsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    jobsiteId?: StringFieldUpdateOperationsInput | string
    costcode?: StringFieldUpdateOperationsInput | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    ChangeLogs?: TimeSheetChangeLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutTimeSheetNestedInput
  }

  export type UserUpsertWithoutMaintenanceLogsInput = {
    update: XOR<UserUpdateWithoutMaintenanceLogsInput, UserUncheckedUpdateWithoutMaintenanceLogsInput>
    create: XOR<UserCreateWithoutMaintenanceLogsInput, UserUncheckedCreateWithoutMaintenanceLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMaintenanceLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMaintenanceLogsInput, UserUncheckedUpdateWithoutMaintenanceLogsInput>
  }

  export type UserUpdateWithoutMaintenanceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutMaintenanceLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type EmployeeEquipmentLogCreateWithoutMaintenanceInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    comment?: string | null
    rental?: boolean
    Equipment?: EquipmentCreateNestedOneWithoutEmployeeEquipmentLogsInput
    TimeSheet: TimeSheetCreateNestedOneWithoutEmployeeEquipmentLogsInput
    RefuelLog?: RefuelLogCreateNestedOneWithoutEmployeeEquipmentLogInput
  }

  export type EmployeeEquipmentLogUncheckedCreateWithoutMaintenanceInput = {
    id?: string
    equipmentId?: string | null
    startTime?: Date | string
    endTime?: Date | string | null
    comment?: string | null
    timeSheetId: number
    rental?: boolean
    RefuelLog?: RefuelLogUncheckedCreateNestedOneWithoutEmployeeEquipmentLogInput
  }

  export type EmployeeEquipmentLogCreateOrConnectWithoutMaintenanceInput = {
    where: EmployeeEquipmentLogWhereUniqueInput
    create: XOR<EmployeeEquipmentLogCreateWithoutMaintenanceInput, EmployeeEquipmentLogUncheckedCreateWithoutMaintenanceInput>
  }

  export type EmployeeEquipmentLogCreateManyMaintenanceInputEnvelope = {
    data: EmployeeEquipmentLogCreateManyMaintenanceInput | EmployeeEquipmentLogCreateManyMaintenanceInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutMaintenancesInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutEquipmentInput
    createdBy?: UserCreateNestedOneWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutMaintenancesInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogUncheckedCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogUncheckedCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogUncheckedCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutMaintenancesInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutMaintenancesInput, EquipmentUncheckedCreateWithoutMaintenancesInput>
  }

  export type MaintenanceLogCreateWithoutMaintenanceInput = {
    id?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    TimeSheet: TimeSheetCreateNestedOneWithoutMaintenanceLogsInput
    User: UserCreateNestedOneWithoutMaintenanceLogsInput
  }

  export type MaintenanceLogUncheckedCreateWithoutMaintenanceInput = {
    id?: string
    userId: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    timeSheetId: number
  }

  export type MaintenanceLogCreateOrConnectWithoutMaintenanceInput = {
    where: MaintenanceLogWhereUniqueInput
    create: XOR<MaintenanceLogCreateWithoutMaintenanceInput, MaintenanceLogUncheckedCreateWithoutMaintenanceInput>
  }

  export type MaintenanceLogCreateManyMaintenanceInputEnvelope = {
    data: MaintenanceLogCreateManyMaintenanceInput | MaintenanceLogCreateManyMaintenanceInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeEquipmentLogUpsertWithWhereUniqueWithoutMaintenanceInput = {
    where: EmployeeEquipmentLogWhereUniqueInput
    update: XOR<EmployeeEquipmentLogUpdateWithoutMaintenanceInput, EmployeeEquipmentLogUncheckedUpdateWithoutMaintenanceInput>
    create: XOR<EmployeeEquipmentLogCreateWithoutMaintenanceInput, EmployeeEquipmentLogUncheckedCreateWithoutMaintenanceInput>
  }

  export type EmployeeEquipmentLogUpdateWithWhereUniqueWithoutMaintenanceInput = {
    where: EmployeeEquipmentLogWhereUniqueInput
    data: XOR<EmployeeEquipmentLogUpdateWithoutMaintenanceInput, EmployeeEquipmentLogUncheckedUpdateWithoutMaintenanceInput>
  }

  export type EmployeeEquipmentLogUpdateManyWithWhereWithoutMaintenanceInput = {
    where: EmployeeEquipmentLogScalarWhereInput
    data: XOR<EmployeeEquipmentLogUpdateManyMutationInput, EmployeeEquipmentLogUncheckedUpdateManyWithoutMaintenanceInput>
  }

  export type EquipmentUpsertWithoutMaintenancesInput = {
    update: XOR<EquipmentUpdateWithoutMaintenancesInput, EquipmentUncheckedUpdateWithoutMaintenancesInput>
    create: XOR<EquipmentCreateWithoutMaintenancesInput, EquipmentUncheckedCreateWithoutMaintenancesInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutMaintenancesInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutMaintenancesInput, EquipmentUncheckedUpdateWithoutMaintenancesInput>
  }

  export type EquipmentUpdateWithoutMaintenancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutEquipmentNestedInput
    createdBy?: UserUpdateOneWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutMaintenancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUncheckedUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUncheckedUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUncheckedUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type MaintenanceLogUpsertWithWhereUniqueWithoutMaintenanceInput = {
    where: MaintenanceLogWhereUniqueInput
    update: XOR<MaintenanceLogUpdateWithoutMaintenanceInput, MaintenanceLogUncheckedUpdateWithoutMaintenanceInput>
    create: XOR<MaintenanceLogCreateWithoutMaintenanceInput, MaintenanceLogUncheckedCreateWithoutMaintenanceInput>
  }

  export type MaintenanceLogUpdateWithWhereUniqueWithoutMaintenanceInput = {
    where: MaintenanceLogWhereUniqueInput
    data: XOR<MaintenanceLogUpdateWithoutMaintenanceInput, MaintenanceLogUncheckedUpdateWithoutMaintenanceInput>
  }

  export type MaintenanceLogUpdateManyWithWhereWithoutMaintenanceInput = {
    where: MaintenanceLogScalarWhereInput
    data: XOR<MaintenanceLogUpdateManyMutationInput, MaintenanceLogUncheckedUpdateManyWithoutMaintenanceInput>
  }

  export type RefuelLogCreateWithoutTascoLogInput = {
    id?: string
    gallonsRefueled?: number | null
    milesAtFueling?: number | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogCreateNestedOneWithoutRefuelLogInput
    TruckingLog?: TruckingLogCreateNestedOneWithoutRefuelLogsInput
  }

  export type RefuelLogUncheckedCreateWithoutTascoLogInput = {
    id?: string
    employeeEquipmentLogId?: string | null
    truckingLogId?: string | null
    gallonsRefueled?: number | null
    milesAtFueling?: number | null
  }

  export type RefuelLogCreateOrConnectWithoutTascoLogInput = {
    where: RefuelLogWhereUniqueInput
    create: XOR<RefuelLogCreateWithoutTascoLogInput, RefuelLogUncheckedCreateWithoutTascoLogInput>
  }

  export type RefuelLogCreateManyTascoLogInputEnvelope = {
    data: RefuelLogCreateManyTascoLogInput | RefuelLogCreateManyTascoLogInput[]
    skipDuplicates?: boolean
  }

  export type TascoFLoadsCreateWithoutTascoLogInput = {
    weight?: number | null
    screenType?: $Enums.LoadType | null
  }

  export type TascoFLoadsUncheckedCreateWithoutTascoLogInput = {
    id?: number
    weight?: number | null
    screenType?: $Enums.LoadType | null
  }

  export type TascoFLoadsCreateOrConnectWithoutTascoLogInput = {
    where: TascoFLoadsWhereUniqueInput
    create: XOR<TascoFLoadsCreateWithoutTascoLogInput, TascoFLoadsUncheckedCreateWithoutTascoLogInput>
  }

  export type TascoFLoadsCreateManyTascoLogInputEnvelope = {
    data: TascoFLoadsCreateManyTascoLogInput | TascoFLoadsCreateManyTascoLogInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutTascoLogsInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutEquipmentInput
    createdBy?: UserCreateNestedOneWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutTascoLogsInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogUncheckedCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogUncheckedCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogUncheckedCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutTascoLogsInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutTascoLogsInput, EquipmentUncheckedCreateWithoutTascoLogsInput>
  }

  export type TascoMaterialTypesCreateWithoutTascoLogInput = {
    id?: string
    name: string
  }

  export type TascoMaterialTypesUncheckedCreateWithoutTascoLogInput = {
    id?: string
    name: string
  }

  export type TascoMaterialTypesCreateOrConnectWithoutTascoLogInput = {
    where: TascoMaterialTypesWhereUniqueInput
    create: XOR<TascoMaterialTypesCreateWithoutTascoLogInput, TascoMaterialTypesUncheckedCreateWithoutTascoLogInput>
  }

  export type TimeSheetCreateWithoutTascoLogsInput = {
    date: Date | string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutTimeSheetInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutTimeSheetInput
    CostCode: CostCodeCreateNestedOneWithoutTimesheetsInput
    Jobsite: JobsiteCreateNestedOneWithoutTimeSheetsInput
    User: UserCreateNestedOneWithoutTimeSheetsInput
    ChangeLogs?: TimeSheetChangeLogCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetUncheckedCreateWithoutTascoLogsInput = {
    date: Date | string
    userId: string
    jobsiteId: string
    costcode: string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    id?: number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutTimeSheetInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutTimeSheetInput
    ChangeLogs?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogUncheckedCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetCreateOrConnectWithoutTascoLogsInput = {
    where: TimeSheetWhereUniqueInput
    create: XOR<TimeSheetCreateWithoutTascoLogsInput, TimeSheetUncheckedCreateWithoutTascoLogsInput>
  }

  export type RefuelLogUpsertWithWhereUniqueWithoutTascoLogInput = {
    where: RefuelLogWhereUniqueInput
    update: XOR<RefuelLogUpdateWithoutTascoLogInput, RefuelLogUncheckedUpdateWithoutTascoLogInput>
    create: XOR<RefuelLogCreateWithoutTascoLogInput, RefuelLogUncheckedCreateWithoutTascoLogInput>
  }

  export type RefuelLogUpdateWithWhereUniqueWithoutTascoLogInput = {
    where: RefuelLogWhereUniqueInput
    data: XOR<RefuelLogUpdateWithoutTascoLogInput, RefuelLogUncheckedUpdateWithoutTascoLogInput>
  }

  export type RefuelLogUpdateManyWithWhereWithoutTascoLogInput = {
    where: RefuelLogScalarWhereInput
    data: XOR<RefuelLogUpdateManyMutationInput, RefuelLogUncheckedUpdateManyWithoutTascoLogInput>
  }

  export type RefuelLogScalarWhereInput = {
    AND?: RefuelLogScalarWhereInput | RefuelLogScalarWhereInput[]
    OR?: RefuelLogScalarWhereInput[]
    NOT?: RefuelLogScalarWhereInput | RefuelLogScalarWhereInput[]
    id?: StringFilter<"RefuelLog"> | string
    employeeEquipmentLogId?: StringNullableFilter<"RefuelLog"> | string | null
    truckingLogId?: StringNullableFilter<"RefuelLog"> | string | null
    tascoLogId?: StringNullableFilter<"RefuelLog"> | string | null
    gallonsRefueled?: FloatNullableFilter<"RefuelLog"> | number | null
    milesAtFueling?: IntNullableFilter<"RefuelLog"> | number | null
  }

  export type TascoFLoadsUpsertWithWhereUniqueWithoutTascoLogInput = {
    where: TascoFLoadsWhereUniqueInput
    update: XOR<TascoFLoadsUpdateWithoutTascoLogInput, TascoFLoadsUncheckedUpdateWithoutTascoLogInput>
    create: XOR<TascoFLoadsCreateWithoutTascoLogInput, TascoFLoadsUncheckedCreateWithoutTascoLogInput>
  }

  export type TascoFLoadsUpdateWithWhereUniqueWithoutTascoLogInput = {
    where: TascoFLoadsWhereUniqueInput
    data: XOR<TascoFLoadsUpdateWithoutTascoLogInput, TascoFLoadsUncheckedUpdateWithoutTascoLogInput>
  }

  export type TascoFLoadsUpdateManyWithWhereWithoutTascoLogInput = {
    where: TascoFLoadsScalarWhereInput
    data: XOR<TascoFLoadsUpdateManyMutationInput, TascoFLoadsUncheckedUpdateManyWithoutTascoLogInput>
  }

  export type TascoFLoadsScalarWhereInput = {
    AND?: TascoFLoadsScalarWhereInput | TascoFLoadsScalarWhereInput[]
    OR?: TascoFLoadsScalarWhereInput[]
    NOT?: TascoFLoadsScalarWhereInput | TascoFLoadsScalarWhereInput[]
    id?: IntFilter<"TascoFLoads"> | number
    tascoLogId?: StringFilter<"TascoFLoads"> | string
    weight?: FloatNullableFilter<"TascoFLoads"> | number | null
    screenType?: EnumLoadTypeNullableFilter<"TascoFLoads"> | $Enums.LoadType | null
  }

  export type EquipmentUpsertWithoutTascoLogsInput = {
    update: XOR<EquipmentUpdateWithoutTascoLogsInput, EquipmentUncheckedUpdateWithoutTascoLogsInput>
    create: XOR<EquipmentCreateWithoutTascoLogsInput, EquipmentUncheckedCreateWithoutTascoLogsInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutTascoLogsInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutTascoLogsInput, EquipmentUncheckedUpdateWithoutTascoLogsInput>
  }

  export type EquipmentUpdateWithoutTascoLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutEquipmentNestedInput
    createdBy?: UserUpdateOneWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutTascoLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUncheckedUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUncheckedUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUncheckedUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type TascoMaterialTypesUpsertWithoutTascoLogInput = {
    update: XOR<TascoMaterialTypesUpdateWithoutTascoLogInput, TascoMaterialTypesUncheckedUpdateWithoutTascoLogInput>
    create: XOR<TascoMaterialTypesCreateWithoutTascoLogInput, TascoMaterialTypesUncheckedCreateWithoutTascoLogInput>
    where?: TascoMaterialTypesWhereInput
  }

  export type TascoMaterialTypesUpdateToOneWithWhereWithoutTascoLogInput = {
    where?: TascoMaterialTypesWhereInput
    data: XOR<TascoMaterialTypesUpdateWithoutTascoLogInput, TascoMaterialTypesUncheckedUpdateWithoutTascoLogInput>
  }

  export type TascoMaterialTypesUpdateWithoutTascoLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TascoMaterialTypesUncheckedUpdateWithoutTascoLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TimeSheetUpsertWithoutTascoLogsInput = {
    update: XOR<TimeSheetUpdateWithoutTascoLogsInput, TimeSheetUncheckedUpdateWithoutTascoLogsInput>
    create: XOR<TimeSheetCreateWithoutTascoLogsInput, TimeSheetUncheckedCreateWithoutTascoLogsInput>
    where?: TimeSheetWhereInput
  }

  export type TimeSheetUpdateToOneWithWhereWithoutTascoLogsInput = {
    where?: TimeSheetWhereInput
    data: XOR<TimeSheetUpdateWithoutTascoLogsInput, TimeSheetUncheckedUpdateWithoutTascoLogsInput>
  }

  export type TimeSheetUpdateWithoutTascoLogsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutTimeSheetNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutTimeSheetNestedInput
    CostCode?: CostCodeUpdateOneRequiredWithoutTimesheetsNestedInput
    Jobsite?: JobsiteUpdateOneRequiredWithoutTimeSheetsNestedInput
    User?: UserUpdateOneRequiredWithoutTimeSheetsNestedInput
    ChangeLogs?: TimeSheetChangeLogUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutTimeSheetNestedInput
  }

  export type TimeSheetUncheckedUpdateWithoutTascoLogsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    jobsiteId?: StringFieldUpdateOperationsInput | string
    costcode?: StringFieldUpdateOperationsInput | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    ChangeLogs?: TimeSheetChangeLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutTimeSheetNestedInput
  }

  export type TascoLogCreateWithoutTascoFLoadsInput = {
    id?: string
    shiftType: string
    laborType?: string | null
    LoadQuantity?: number
    screenType?: $Enums.LoadType | null
    RefuelLogs?: RefuelLogCreateNestedManyWithoutTascoLogInput
    Equipment?: EquipmentCreateNestedOneWithoutTascoLogsInput
    TascoMaterialTypes?: TascoMaterialTypesCreateNestedOneWithoutTascoLogInput
    TimeSheet: TimeSheetCreateNestedOneWithoutTascoLogsInput
  }

  export type TascoLogUncheckedCreateWithoutTascoFLoadsInput = {
    id?: string
    shiftType: string
    equipmentId?: string | null
    laborType?: string | null
    materialType?: string | null
    LoadQuantity?: number
    screenType?: $Enums.LoadType | null
    timeSheetId: number
    RefuelLogs?: RefuelLogUncheckedCreateNestedManyWithoutTascoLogInput
  }

  export type TascoLogCreateOrConnectWithoutTascoFLoadsInput = {
    where: TascoLogWhereUniqueInput
    create: XOR<TascoLogCreateWithoutTascoFLoadsInput, TascoLogUncheckedCreateWithoutTascoFLoadsInput>
  }

  export type TascoLogUpsertWithoutTascoFLoadsInput = {
    update: XOR<TascoLogUpdateWithoutTascoFLoadsInput, TascoLogUncheckedUpdateWithoutTascoFLoadsInput>
    create: XOR<TascoLogCreateWithoutTascoFLoadsInput, TascoLogUncheckedCreateWithoutTascoFLoadsInput>
    where?: TascoLogWhereInput
  }

  export type TascoLogUpdateToOneWithWhereWithoutTascoFLoadsInput = {
    where?: TascoLogWhereInput
    data: XOR<TascoLogUpdateWithoutTascoFLoadsInput, TascoLogUncheckedUpdateWithoutTascoFLoadsInput>
  }

  export type TascoLogUpdateWithoutTascoFLoadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    RefuelLogs?: RefuelLogUpdateManyWithoutTascoLogNestedInput
    Equipment?: EquipmentUpdateOneWithoutTascoLogsNestedInput
    TascoMaterialTypes?: TascoMaterialTypesUpdateOneWithoutTascoLogNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutTascoLogsNestedInput
  }

  export type TascoLogUncheckedUpdateWithoutTascoFLoadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    materialType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    RefuelLogs?: RefuelLogUncheckedUpdateManyWithoutTascoLogNestedInput
  }

  export type TascoLogCreateWithoutTascoMaterialTypesInput = {
    id?: string
    shiftType: string
    laborType?: string | null
    LoadQuantity?: number
    screenType?: $Enums.LoadType | null
    RefuelLogs?: RefuelLogCreateNestedManyWithoutTascoLogInput
    TascoFLoads?: TascoFLoadsCreateNestedManyWithoutTascoLogInput
    Equipment?: EquipmentCreateNestedOneWithoutTascoLogsInput
    TimeSheet: TimeSheetCreateNestedOneWithoutTascoLogsInput
  }

  export type TascoLogUncheckedCreateWithoutTascoMaterialTypesInput = {
    id?: string
    shiftType: string
    equipmentId?: string | null
    laborType?: string | null
    LoadQuantity?: number
    screenType?: $Enums.LoadType | null
    timeSheetId: number
    RefuelLogs?: RefuelLogUncheckedCreateNestedManyWithoutTascoLogInput
    TascoFLoads?: TascoFLoadsUncheckedCreateNestedManyWithoutTascoLogInput
  }

  export type TascoLogCreateOrConnectWithoutTascoMaterialTypesInput = {
    where: TascoLogWhereUniqueInput
    create: XOR<TascoLogCreateWithoutTascoMaterialTypesInput, TascoLogUncheckedCreateWithoutTascoMaterialTypesInput>
  }

  export type TascoLogCreateManyTascoMaterialTypesInputEnvelope = {
    data: TascoLogCreateManyTascoMaterialTypesInput | TascoLogCreateManyTascoMaterialTypesInput[]
    skipDuplicates?: boolean
  }

  export type TascoLogUpsertWithWhereUniqueWithoutTascoMaterialTypesInput = {
    where: TascoLogWhereUniqueInput
    update: XOR<TascoLogUpdateWithoutTascoMaterialTypesInput, TascoLogUncheckedUpdateWithoutTascoMaterialTypesInput>
    create: XOR<TascoLogCreateWithoutTascoMaterialTypesInput, TascoLogUncheckedCreateWithoutTascoMaterialTypesInput>
  }

  export type TascoLogUpdateWithWhereUniqueWithoutTascoMaterialTypesInput = {
    where: TascoLogWhereUniqueInput
    data: XOR<TascoLogUpdateWithoutTascoMaterialTypesInput, TascoLogUncheckedUpdateWithoutTascoMaterialTypesInput>
  }

  export type TascoLogUpdateManyWithWhereWithoutTascoMaterialTypesInput = {
    where: TascoLogScalarWhereInput
    data: XOR<TascoLogUpdateManyMutationInput, TascoLogUncheckedUpdateManyWithoutTascoMaterialTypesInput>
  }

  export type EquipmentHauledCreateWithoutTruckingLogInput = {
    id?: string
    createdAt?: Date | string
    endMileage?: number | null
    startMileage?: number | null
    destination?: string | null
    source?: string | null
    Equipment?: EquipmentCreateNestedOneWithoutEquipmentHauledInput
  }

  export type EquipmentHauledUncheckedCreateWithoutTruckingLogInput = {
    id?: string
    equipmentId?: string | null
    createdAt?: Date | string
    endMileage?: number | null
    startMileage?: number | null
    destination?: string | null
    source?: string | null
  }

  export type EquipmentHauledCreateOrConnectWithoutTruckingLogInput = {
    where: EquipmentHauledWhereUniqueInput
    create: XOR<EquipmentHauledCreateWithoutTruckingLogInput, EquipmentHauledUncheckedCreateWithoutTruckingLogInput>
  }

  export type EquipmentHauledCreateManyTruckingLogInputEnvelope = {
    data: EquipmentHauledCreateManyTruckingLogInput | EquipmentHauledCreateManyTruckingLogInput[]
    skipDuplicates?: boolean
  }

  export type MaterialCreateWithoutTruckingLogInput = {
    id?: string
    LocationOfMaterial?: string | null
    name?: string | null
    quantity?: number | null
    materialWeight?: number | null
    loadType?: $Enums.LoadType | null
    createdAt?: Date | string | null
    unit?: $Enums.materialUnit | null
  }

  export type MaterialUncheckedCreateWithoutTruckingLogInput = {
    id?: string
    LocationOfMaterial?: string | null
    name?: string | null
    quantity?: number | null
    materialWeight?: number | null
    loadType?: $Enums.LoadType | null
    createdAt?: Date | string | null
    unit?: $Enums.materialUnit | null
  }

  export type MaterialCreateOrConnectWithoutTruckingLogInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutTruckingLogInput, MaterialUncheckedCreateWithoutTruckingLogInput>
  }

  export type MaterialCreateManyTruckingLogInputEnvelope = {
    data: MaterialCreateManyTruckingLogInput | MaterialCreateManyTruckingLogInput[]
    skipDuplicates?: boolean
  }

  export type RefuelLogCreateWithoutTruckingLogInput = {
    id?: string
    gallonsRefueled?: number | null
    milesAtFueling?: number | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogCreateNestedOneWithoutRefuelLogInput
    TascoLog?: TascoLogCreateNestedOneWithoutRefuelLogsInput
  }

  export type RefuelLogUncheckedCreateWithoutTruckingLogInput = {
    id?: string
    employeeEquipmentLogId?: string | null
    tascoLogId?: string | null
    gallonsRefueled?: number | null
    milesAtFueling?: number | null
  }

  export type RefuelLogCreateOrConnectWithoutTruckingLogInput = {
    where: RefuelLogWhereUniqueInput
    create: XOR<RefuelLogCreateWithoutTruckingLogInput, RefuelLogUncheckedCreateWithoutTruckingLogInput>
  }

  export type RefuelLogCreateManyTruckingLogInputEnvelope = {
    data: RefuelLogCreateManyTruckingLogInput | RefuelLogCreateManyTruckingLogInput[]
    skipDuplicates?: boolean
  }

  export type StateMileageCreateWithoutTruckingLogInput = {
    id?: string
    state?: string | null
    stateLineMileage?: number | null
  }

  export type StateMileageUncheckedCreateWithoutTruckingLogInput = {
    id?: string
    state?: string | null
    stateLineMileage?: number | null
  }

  export type StateMileageCreateOrConnectWithoutTruckingLogInput = {
    where: StateMileageWhereUniqueInput
    create: XOR<StateMileageCreateWithoutTruckingLogInput, StateMileageUncheckedCreateWithoutTruckingLogInput>
  }

  export type StateMileageCreateManyTruckingLogInputEnvelope = {
    data: StateMileageCreateManyTruckingLogInput | StateMileageCreateManyTruckingLogInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutHauledInLogsInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutEquipmentInput
    createdBy?: UserCreateNestedOneWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutHauledInLogsInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogUncheckedCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogUncheckedCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutHauledInLogsInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutHauledInLogsInput, EquipmentUncheckedCreateWithoutHauledInLogsInput>
  }

  export type TimeSheetCreateWithoutTruckingLogsInput = {
    date: Date | string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutTimeSheetInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogCreateNestedManyWithoutTimeSheetInput
    CostCode: CostCodeCreateNestedOneWithoutTimesheetsInput
    Jobsite: JobsiteCreateNestedOneWithoutTimeSheetsInput
    User: UserCreateNestedOneWithoutTimeSheetsInput
    ChangeLogs?: TimeSheetChangeLogCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetUncheckedCreateWithoutTruckingLogsInput = {
    date: Date | string
    userId: string
    jobsiteId: string
    costcode: string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    id?: number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutTimeSheetInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutTimeSheetInput
    ChangeLogs?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetCreateOrConnectWithoutTruckingLogsInput = {
    where: TimeSheetWhereUniqueInput
    create: XOR<TimeSheetCreateWithoutTruckingLogsInput, TimeSheetUncheckedCreateWithoutTruckingLogsInput>
  }

  export type EquipmentCreateWithoutUsedAsTrailerInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutEquipmentInput
    createdBy?: UserCreateNestedOneWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogCreateNestedManyWithoutEquipmentInput
    UsedAsTruck?: TruckingLogCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutUsedAsTrailerInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogUncheckedCreateNestedManyWithoutEquipmentInput
    UsedAsTruck?: TruckingLogUncheckedCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutUsedAsTrailerInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutUsedAsTrailerInput, EquipmentUncheckedCreateWithoutUsedAsTrailerInput>
  }

  export type EquipmentCreateWithoutUsedAsTruckInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutEquipmentInput
    createdBy?: UserCreateNestedOneWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogCreateNestedManyWithoutTrailerInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutUsedAsTruckInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogUncheckedCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogUncheckedCreateNestedManyWithoutTrailerInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutUsedAsTruckInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutUsedAsTruckInput, EquipmentUncheckedCreateWithoutUsedAsTruckInput>
  }

  export type EquipmentHauledUpsertWithWhereUniqueWithoutTruckingLogInput = {
    where: EquipmentHauledWhereUniqueInput
    update: XOR<EquipmentHauledUpdateWithoutTruckingLogInput, EquipmentHauledUncheckedUpdateWithoutTruckingLogInput>
    create: XOR<EquipmentHauledCreateWithoutTruckingLogInput, EquipmentHauledUncheckedCreateWithoutTruckingLogInput>
  }

  export type EquipmentHauledUpdateWithWhereUniqueWithoutTruckingLogInput = {
    where: EquipmentHauledWhereUniqueInput
    data: XOR<EquipmentHauledUpdateWithoutTruckingLogInput, EquipmentHauledUncheckedUpdateWithoutTruckingLogInput>
  }

  export type EquipmentHauledUpdateManyWithWhereWithoutTruckingLogInput = {
    where: EquipmentHauledScalarWhereInput
    data: XOR<EquipmentHauledUpdateManyMutationInput, EquipmentHauledUncheckedUpdateManyWithoutTruckingLogInput>
  }

  export type MaterialUpsertWithWhereUniqueWithoutTruckingLogInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutTruckingLogInput, MaterialUncheckedUpdateWithoutTruckingLogInput>
    create: XOR<MaterialCreateWithoutTruckingLogInput, MaterialUncheckedCreateWithoutTruckingLogInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutTruckingLogInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutTruckingLogInput, MaterialUncheckedUpdateWithoutTruckingLogInput>
  }

  export type MaterialUpdateManyWithWhereWithoutTruckingLogInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutTruckingLogInput>
  }

  export type MaterialScalarWhereInput = {
    AND?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    OR?: MaterialScalarWhereInput[]
    NOT?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    id?: StringFilter<"Material"> | string
    truckingLogId?: StringFilter<"Material"> | string
    LocationOfMaterial?: StringNullableFilter<"Material"> | string | null
    name?: StringNullableFilter<"Material"> | string | null
    quantity?: FloatNullableFilter<"Material"> | number | null
    materialWeight?: FloatNullableFilter<"Material"> | number | null
    loadType?: EnumLoadTypeNullableFilter<"Material"> | $Enums.LoadType | null
    createdAt?: DateTimeNullableFilter<"Material"> | Date | string | null
    unit?: EnummaterialUnitNullableFilter<"Material"> | $Enums.materialUnit | null
  }

  export type RefuelLogUpsertWithWhereUniqueWithoutTruckingLogInput = {
    where: RefuelLogWhereUniqueInput
    update: XOR<RefuelLogUpdateWithoutTruckingLogInput, RefuelLogUncheckedUpdateWithoutTruckingLogInput>
    create: XOR<RefuelLogCreateWithoutTruckingLogInput, RefuelLogUncheckedCreateWithoutTruckingLogInput>
  }

  export type RefuelLogUpdateWithWhereUniqueWithoutTruckingLogInput = {
    where: RefuelLogWhereUniqueInput
    data: XOR<RefuelLogUpdateWithoutTruckingLogInput, RefuelLogUncheckedUpdateWithoutTruckingLogInput>
  }

  export type RefuelLogUpdateManyWithWhereWithoutTruckingLogInput = {
    where: RefuelLogScalarWhereInput
    data: XOR<RefuelLogUpdateManyMutationInput, RefuelLogUncheckedUpdateManyWithoutTruckingLogInput>
  }

  export type StateMileageUpsertWithWhereUniqueWithoutTruckingLogInput = {
    where: StateMileageWhereUniqueInput
    update: XOR<StateMileageUpdateWithoutTruckingLogInput, StateMileageUncheckedUpdateWithoutTruckingLogInput>
    create: XOR<StateMileageCreateWithoutTruckingLogInput, StateMileageUncheckedCreateWithoutTruckingLogInput>
  }

  export type StateMileageUpdateWithWhereUniqueWithoutTruckingLogInput = {
    where: StateMileageWhereUniqueInput
    data: XOR<StateMileageUpdateWithoutTruckingLogInput, StateMileageUncheckedUpdateWithoutTruckingLogInput>
  }

  export type StateMileageUpdateManyWithWhereWithoutTruckingLogInput = {
    where: StateMileageScalarWhereInput
    data: XOR<StateMileageUpdateManyMutationInput, StateMileageUncheckedUpdateManyWithoutTruckingLogInput>
  }

  export type StateMileageScalarWhereInput = {
    AND?: StateMileageScalarWhereInput | StateMileageScalarWhereInput[]
    OR?: StateMileageScalarWhereInput[]
    NOT?: StateMileageScalarWhereInput | StateMileageScalarWhereInput[]
    id?: StringFilter<"StateMileage"> | string
    truckingLogId?: StringFilter<"StateMileage"> | string
    state?: StringNullableFilter<"StateMileage"> | string | null
    stateLineMileage?: IntNullableFilter<"StateMileage"> | number | null
  }

  export type EquipmentUpsertWithoutHauledInLogsInput = {
    update: XOR<EquipmentUpdateWithoutHauledInLogsInput, EquipmentUncheckedUpdateWithoutHauledInLogsInput>
    create: XOR<EquipmentCreateWithoutHauledInLogsInput, EquipmentUncheckedCreateWithoutHauledInLogsInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutHauledInLogsInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutHauledInLogsInput, EquipmentUncheckedUpdateWithoutHauledInLogsInput>
  }

  export type EquipmentUpdateWithoutHauledInLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutEquipmentNestedInput
    createdBy?: UserUpdateOneWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutHauledInLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUncheckedUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUncheckedUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type TimeSheetUpsertWithoutTruckingLogsInput = {
    update: XOR<TimeSheetUpdateWithoutTruckingLogsInput, TimeSheetUncheckedUpdateWithoutTruckingLogsInput>
    create: XOR<TimeSheetCreateWithoutTruckingLogsInput, TimeSheetUncheckedCreateWithoutTruckingLogsInput>
    where?: TimeSheetWhereInput
  }

  export type TimeSheetUpdateToOneWithWhereWithoutTruckingLogsInput = {
    where?: TimeSheetWhereInput
    data: XOR<TimeSheetUpdateWithoutTruckingLogsInput, TimeSheetUncheckedUpdateWithoutTruckingLogsInput>
  }

  export type TimeSheetUpdateWithoutTruckingLogsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutTimeSheetNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutTimeSheetNestedInput
    CostCode?: CostCodeUpdateOneRequiredWithoutTimesheetsNestedInput
    Jobsite?: JobsiteUpdateOneRequiredWithoutTimeSheetsNestedInput
    User?: UserUpdateOneRequiredWithoutTimeSheetsNestedInput
    ChangeLogs?: TimeSheetChangeLogUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutTimeSheetNestedInput
  }

  export type TimeSheetUncheckedUpdateWithoutTruckingLogsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    jobsiteId?: StringFieldUpdateOperationsInput | string
    costcode?: StringFieldUpdateOperationsInput | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    ChangeLogs?: TimeSheetChangeLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutTimeSheetNestedInput
  }

  export type EquipmentUpsertWithoutUsedAsTrailerInput = {
    update: XOR<EquipmentUpdateWithoutUsedAsTrailerInput, EquipmentUncheckedUpdateWithoutUsedAsTrailerInput>
    create: XOR<EquipmentCreateWithoutUsedAsTrailerInput, EquipmentUncheckedCreateWithoutUsedAsTrailerInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutUsedAsTrailerInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutUsedAsTrailerInput, EquipmentUncheckedUpdateWithoutUsedAsTrailerInput>
  }

  export type EquipmentUpdateWithoutUsedAsTrailerInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutEquipmentNestedInput
    createdBy?: UserUpdateOneWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUpdateManyWithoutEquipmentNestedInput
    UsedAsTruck?: TruckingLogUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutUsedAsTrailerInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUncheckedUpdateManyWithoutEquipmentNestedInput
    UsedAsTruck?: TruckingLogUncheckedUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUpsertWithoutUsedAsTruckInput = {
    update: XOR<EquipmentUpdateWithoutUsedAsTruckInput, EquipmentUncheckedUpdateWithoutUsedAsTruckInput>
    create: XOR<EquipmentCreateWithoutUsedAsTruckInput, EquipmentUncheckedCreateWithoutUsedAsTruckInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutUsedAsTruckInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutUsedAsTruckInput, EquipmentUncheckedUpdateWithoutUsedAsTruckInput>
  }

  export type EquipmentUpdateWithoutUsedAsTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutEquipmentNestedInput
    createdBy?: UserUpdateOneWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUpdateManyWithoutTrailerNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutUsedAsTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUncheckedUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUncheckedUpdateManyWithoutTrailerNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type TruckingLogCreateWithoutStateMileagesInput = {
    id?: string
    laborType: string
    taskName?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutTruckingLogInput
    Materials?: MaterialCreateNestedManyWithoutTruckingLogInput
    RefuelLogs?: RefuelLogCreateNestedManyWithoutTruckingLogInput
    Equipment?: EquipmentCreateNestedOneWithoutHauledInLogsInput
    TimeSheet: TimeSheetCreateNestedOneWithoutTruckingLogsInput
    Trailer?: EquipmentCreateNestedOneWithoutUsedAsTrailerInput
    Truck?: EquipmentCreateNestedOneWithoutUsedAsTruckInput
  }

  export type TruckingLogUncheckedCreateWithoutStateMileagesInput = {
    id?: string
    laborType: string
    taskName?: string | null
    equipmentId?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    trailerNumber?: string | null
    truckNumber?: string | null
    timeSheetId: number
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutTruckingLogInput
    Materials?: MaterialUncheckedCreateNestedManyWithoutTruckingLogInput
    RefuelLogs?: RefuelLogUncheckedCreateNestedManyWithoutTruckingLogInput
  }

  export type TruckingLogCreateOrConnectWithoutStateMileagesInput = {
    where: TruckingLogWhereUniqueInput
    create: XOR<TruckingLogCreateWithoutStateMileagesInput, TruckingLogUncheckedCreateWithoutStateMileagesInput>
  }

  export type TruckingLogUpsertWithoutStateMileagesInput = {
    update: XOR<TruckingLogUpdateWithoutStateMileagesInput, TruckingLogUncheckedUpdateWithoutStateMileagesInput>
    create: XOR<TruckingLogCreateWithoutStateMileagesInput, TruckingLogUncheckedCreateWithoutStateMileagesInput>
    where?: TruckingLogWhereInput
  }

  export type TruckingLogUpdateToOneWithWhereWithoutStateMileagesInput = {
    where?: TruckingLogWhereInput
    data: XOR<TruckingLogUpdateWithoutStateMileagesInput, TruckingLogUncheckedUpdateWithoutStateMileagesInput>
  }

  export type TruckingLogUpdateWithoutStateMileagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutTruckingLogNestedInput
    Materials?: MaterialUpdateManyWithoutTruckingLogNestedInput
    RefuelLogs?: RefuelLogUpdateManyWithoutTruckingLogNestedInput
    Equipment?: EquipmentUpdateOneWithoutHauledInLogsNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutTruckingLogsNestedInput
    Trailer?: EquipmentUpdateOneWithoutUsedAsTrailerNestedInput
    Truck?: EquipmentUpdateOneWithoutUsedAsTruckNestedInput
  }

  export type TruckingLogUncheckedUpdateWithoutStateMileagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    trailerNumber?: NullableStringFieldUpdateOperationsInput | string | null
    truckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutTruckingLogNestedInput
    Materials?: MaterialUncheckedUpdateManyWithoutTruckingLogNestedInput
    RefuelLogs?: RefuelLogUncheckedUpdateManyWithoutTruckingLogNestedInput
  }

  export type TruckingLogCreateWithoutMaterialsInput = {
    id?: string
    laborType: string
    taskName?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutTruckingLogInput
    RefuelLogs?: RefuelLogCreateNestedManyWithoutTruckingLogInput
    StateMileages?: StateMileageCreateNestedManyWithoutTruckingLogInput
    Equipment?: EquipmentCreateNestedOneWithoutHauledInLogsInput
    TimeSheet: TimeSheetCreateNestedOneWithoutTruckingLogsInput
    Trailer?: EquipmentCreateNestedOneWithoutUsedAsTrailerInput
    Truck?: EquipmentCreateNestedOneWithoutUsedAsTruckInput
  }

  export type TruckingLogUncheckedCreateWithoutMaterialsInput = {
    id?: string
    laborType: string
    taskName?: string | null
    equipmentId?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    trailerNumber?: string | null
    truckNumber?: string | null
    timeSheetId: number
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutTruckingLogInput
    RefuelLogs?: RefuelLogUncheckedCreateNestedManyWithoutTruckingLogInput
    StateMileages?: StateMileageUncheckedCreateNestedManyWithoutTruckingLogInput
  }

  export type TruckingLogCreateOrConnectWithoutMaterialsInput = {
    where: TruckingLogWhereUniqueInput
    create: XOR<TruckingLogCreateWithoutMaterialsInput, TruckingLogUncheckedCreateWithoutMaterialsInput>
  }

  export type TruckingLogUpsertWithoutMaterialsInput = {
    update: XOR<TruckingLogUpdateWithoutMaterialsInput, TruckingLogUncheckedUpdateWithoutMaterialsInput>
    create: XOR<TruckingLogCreateWithoutMaterialsInput, TruckingLogUncheckedCreateWithoutMaterialsInput>
    where?: TruckingLogWhereInput
  }

  export type TruckingLogUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: TruckingLogWhereInput
    data: XOR<TruckingLogUpdateWithoutMaterialsInput, TruckingLogUncheckedUpdateWithoutMaterialsInput>
  }

  export type TruckingLogUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutTruckingLogNestedInput
    RefuelLogs?: RefuelLogUpdateManyWithoutTruckingLogNestedInput
    StateMileages?: StateMileageUpdateManyWithoutTruckingLogNestedInput
    Equipment?: EquipmentUpdateOneWithoutHauledInLogsNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutTruckingLogsNestedInput
    Trailer?: EquipmentUpdateOneWithoutUsedAsTrailerNestedInput
    Truck?: EquipmentUpdateOneWithoutUsedAsTruckNestedInput
  }

  export type TruckingLogUncheckedUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    trailerNumber?: NullableStringFieldUpdateOperationsInput | string | null
    truckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutTruckingLogNestedInput
    RefuelLogs?: RefuelLogUncheckedUpdateManyWithoutTruckingLogNestedInput
    StateMileages?: StateMileageUncheckedUpdateManyWithoutTruckingLogNestedInput
  }

  export type EmployeeEquipmentLogCreateWithoutRefuelLogInput = {
    id?: string
    startTime?: Date | string
    endTime?: Date | string | null
    comment?: string | null
    rental?: boolean
    Equipment?: EquipmentCreateNestedOneWithoutEmployeeEquipmentLogsInput
    Maintenance?: MaintenanceCreateNestedOneWithoutEmployeeEquipmentLogInput
    TimeSheet: TimeSheetCreateNestedOneWithoutEmployeeEquipmentLogsInput
  }

  export type EmployeeEquipmentLogUncheckedCreateWithoutRefuelLogInput = {
    id?: string
    equipmentId?: string | null
    maintenanceId?: string | null
    startTime?: Date | string
    endTime?: Date | string | null
    comment?: string | null
    timeSheetId: number
    rental?: boolean
  }

  export type EmployeeEquipmentLogCreateOrConnectWithoutRefuelLogInput = {
    where: EmployeeEquipmentLogWhereUniqueInput
    create: XOR<EmployeeEquipmentLogCreateWithoutRefuelLogInput, EmployeeEquipmentLogUncheckedCreateWithoutRefuelLogInput>
  }

  export type TascoLogCreateWithoutRefuelLogsInput = {
    id?: string
    shiftType: string
    laborType?: string | null
    LoadQuantity?: number
    screenType?: $Enums.LoadType | null
    TascoFLoads?: TascoFLoadsCreateNestedManyWithoutTascoLogInput
    Equipment?: EquipmentCreateNestedOneWithoutTascoLogsInput
    TascoMaterialTypes?: TascoMaterialTypesCreateNestedOneWithoutTascoLogInput
    TimeSheet: TimeSheetCreateNestedOneWithoutTascoLogsInput
  }

  export type TascoLogUncheckedCreateWithoutRefuelLogsInput = {
    id?: string
    shiftType: string
    equipmentId?: string | null
    laborType?: string | null
    materialType?: string | null
    LoadQuantity?: number
    screenType?: $Enums.LoadType | null
    timeSheetId: number
    TascoFLoads?: TascoFLoadsUncheckedCreateNestedManyWithoutTascoLogInput
  }

  export type TascoLogCreateOrConnectWithoutRefuelLogsInput = {
    where: TascoLogWhereUniqueInput
    create: XOR<TascoLogCreateWithoutRefuelLogsInput, TascoLogUncheckedCreateWithoutRefuelLogsInput>
  }

  export type TruckingLogCreateWithoutRefuelLogsInput = {
    id?: string
    laborType: string
    taskName?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutTruckingLogInput
    Materials?: MaterialCreateNestedManyWithoutTruckingLogInput
    StateMileages?: StateMileageCreateNestedManyWithoutTruckingLogInput
    Equipment?: EquipmentCreateNestedOneWithoutHauledInLogsInput
    TimeSheet: TimeSheetCreateNestedOneWithoutTruckingLogsInput
    Trailer?: EquipmentCreateNestedOneWithoutUsedAsTrailerInput
    Truck?: EquipmentCreateNestedOneWithoutUsedAsTruckInput
  }

  export type TruckingLogUncheckedCreateWithoutRefuelLogsInput = {
    id?: string
    laborType: string
    taskName?: string | null
    equipmentId?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    trailerNumber?: string | null
    truckNumber?: string | null
    timeSheetId: number
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutTruckingLogInput
    Materials?: MaterialUncheckedCreateNestedManyWithoutTruckingLogInput
    StateMileages?: StateMileageUncheckedCreateNestedManyWithoutTruckingLogInput
  }

  export type TruckingLogCreateOrConnectWithoutRefuelLogsInput = {
    where: TruckingLogWhereUniqueInput
    create: XOR<TruckingLogCreateWithoutRefuelLogsInput, TruckingLogUncheckedCreateWithoutRefuelLogsInput>
  }

  export type EmployeeEquipmentLogUpsertWithoutRefuelLogInput = {
    update: XOR<EmployeeEquipmentLogUpdateWithoutRefuelLogInput, EmployeeEquipmentLogUncheckedUpdateWithoutRefuelLogInput>
    create: XOR<EmployeeEquipmentLogCreateWithoutRefuelLogInput, EmployeeEquipmentLogUncheckedCreateWithoutRefuelLogInput>
    where?: EmployeeEquipmentLogWhereInput
  }

  export type EmployeeEquipmentLogUpdateToOneWithWhereWithoutRefuelLogInput = {
    where?: EmployeeEquipmentLogWhereInput
    data: XOR<EmployeeEquipmentLogUpdateWithoutRefuelLogInput, EmployeeEquipmentLogUncheckedUpdateWithoutRefuelLogInput>
  }

  export type EmployeeEquipmentLogUpdateWithoutRefuelLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    rental?: BoolFieldUpdateOperationsInput | boolean
    Equipment?: EquipmentUpdateOneWithoutEmployeeEquipmentLogsNestedInput
    Maintenance?: MaintenanceUpdateOneWithoutEmployeeEquipmentLogNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutEmployeeEquipmentLogsNestedInput
  }

  export type EmployeeEquipmentLogUncheckedUpdateWithoutRefuelLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    rental?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TascoLogUpsertWithoutRefuelLogsInput = {
    update: XOR<TascoLogUpdateWithoutRefuelLogsInput, TascoLogUncheckedUpdateWithoutRefuelLogsInput>
    create: XOR<TascoLogCreateWithoutRefuelLogsInput, TascoLogUncheckedCreateWithoutRefuelLogsInput>
    where?: TascoLogWhereInput
  }

  export type TascoLogUpdateToOneWithWhereWithoutRefuelLogsInput = {
    where?: TascoLogWhereInput
    data: XOR<TascoLogUpdateWithoutRefuelLogsInput, TascoLogUncheckedUpdateWithoutRefuelLogsInput>
  }

  export type TascoLogUpdateWithoutRefuelLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    TascoFLoads?: TascoFLoadsUpdateManyWithoutTascoLogNestedInput
    Equipment?: EquipmentUpdateOneWithoutTascoLogsNestedInput
    TascoMaterialTypes?: TascoMaterialTypesUpdateOneWithoutTascoLogNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutTascoLogsNestedInput
  }

  export type TascoLogUncheckedUpdateWithoutRefuelLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    materialType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    TascoFLoads?: TascoFLoadsUncheckedUpdateManyWithoutTascoLogNestedInput
  }

  export type TruckingLogUpsertWithoutRefuelLogsInput = {
    update: XOR<TruckingLogUpdateWithoutRefuelLogsInput, TruckingLogUncheckedUpdateWithoutRefuelLogsInput>
    create: XOR<TruckingLogCreateWithoutRefuelLogsInput, TruckingLogUncheckedCreateWithoutRefuelLogsInput>
    where?: TruckingLogWhereInput
  }

  export type TruckingLogUpdateToOneWithWhereWithoutRefuelLogsInput = {
    where?: TruckingLogWhereInput
    data: XOR<TruckingLogUpdateWithoutRefuelLogsInput, TruckingLogUncheckedUpdateWithoutRefuelLogsInput>
  }

  export type TruckingLogUpdateWithoutRefuelLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutTruckingLogNestedInput
    Materials?: MaterialUpdateManyWithoutTruckingLogNestedInput
    StateMileages?: StateMileageUpdateManyWithoutTruckingLogNestedInput
    Equipment?: EquipmentUpdateOneWithoutHauledInLogsNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutTruckingLogsNestedInput
    Trailer?: EquipmentUpdateOneWithoutUsedAsTrailerNestedInput
    Truck?: EquipmentUpdateOneWithoutUsedAsTruckNestedInput
  }

  export type TruckingLogUncheckedUpdateWithoutRefuelLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    trailerNumber?: NullableStringFieldUpdateOperationsInput | string | null
    truckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutTruckingLogNestedInput
    Materials?: MaterialUncheckedUpdateManyWithoutTruckingLogNestedInput
    StateMileages?: StateMileageUncheckedUpdateManyWithoutTruckingLogNestedInput
  }

  export type EquipmentCreateWithoutEquipmentHauledInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutEquipmentInput
    createdBy?: UserCreateNestedOneWithoutEquipmentInput
    Maintenances?: MaintenanceCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutEquipmentHauledInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogUncheckedCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogUncheckedCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogUncheckedCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutEquipmentHauledInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutEquipmentHauledInput, EquipmentUncheckedCreateWithoutEquipmentHauledInput>
  }

  export type TruckingLogCreateWithoutEquipmentHauledInput = {
    id?: string
    laborType: string
    taskName?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    Materials?: MaterialCreateNestedManyWithoutTruckingLogInput
    RefuelLogs?: RefuelLogCreateNestedManyWithoutTruckingLogInput
    StateMileages?: StateMileageCreateNestedManyWithoutTruckingLogInput
    Equipment?: EquipmentCreateNestedOneWithoutHauledInLogsInput
    TimeSheet: TimeSheetCreateNestedOneWithoutTruckingLogsInput
    Trailer?: EquipmentCreateNestedOneWithoutUsedAsTrailerInput
    Truck?: EquipmentCreateNestedOneWithoutUsedAsTruckInput
  }

  export type TruckingLogUncheckedCreateWithoutEquipmentHauledInput = {
    id?: string
    laborType: string
    taskName?: string | null
    equipmentId?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    trailerNumber?: string | null
    truckNumber?: string | null
    timeSheetId: number
    Materials?: MaterialUncheckedCreateNestedManyWithoutTruckingLogInput
    RefuelLogs?: RefuelLogUncheckedCreateNestedManyWithoutTruckingLogInput
    StateMileages?: StateMileageUncheckedCreateNestedManyWithoutTruckingLogInput
  }

  export type TruckingLogCreateOrConnectWithoutEquipmentHauledInput = {
    where: TruckingLogWhereUniqueInput
    create: XOR<TruckingLogCreateWithoutEquipmentHauledInput, TruckingLogUncheckedCreateWithoutEquipmentHauledInput>
  }

  export type EquipmentUpsertWithoutEquipmentHauledInput = {
    update: XOR<EquipmentUpdateWithoutEquipmentHauledInput, EquipmentUncheckedUpdateWithoutEquipmentHauledInput>
    create: XOR<EquipmentCreateWithoutEquipmentHauledInput, EquipmentUncheckedCreateWithoutEquipmentHauledInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutEquipmentHauledInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutEquipmentHauledInput, EquipmentUncheckedUpdateWithoutEquipmentHauledInput>
  }

  export type EquipmentUpdateWithoutEquipmentHauledInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutEquipmentNestedInput
    createdBy?: UserUpdateOneWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutEquipmentHauledInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUncheckedUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUncheckedUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUncheckedUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type TruckingLogUpsertWithoutEquipmentHauledInput = {
    update: XOR<TruckingLogUpdateWithoutEquipmentHauledInput, TruckingLogUncheckedUpdateWithoutEquipmentHauledInput>
    create: XOR<TruckingLogCreateWithoutEquipmentHauledInput, TruckingLogUncheckedCreateWithoutEquipmentHauledInput>
    where?: TruckingLogWhereInput
  }

  export type TruckingLogUpdateToOneWithWhereWithoutEquipmentHauledInput = {
    where?: TruckingLogWhereInput
    data: XOR<TruckingLogUpdateWithoutEquipmentHauledInput, TruckingLogUncheckedUpdateWithoutEquipmentHauledInput>
  }

  export type TruckingLogUpdateWithoutEquipmentHauledInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    Materials?: MaterialUpdateManyWithoutTruckingLogNestedInput
    RefuelLogs?: RefuelLogUpdateManyWithoutTruckingLogNestedInput
    StateMileages?: StateMileageUpdateManyWithoutTruckingLogNestedInput
    Equipment?: EquipmentUpdateOneWithoutHauledInLogsNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutTruckingLogsNestedInput
    Trailer?: EquipmentUpdateOneWithoutUsedAsTrailerNestedInput
    Truck?: EquipmentUpdateOneWithoutUsedAsTruckNestedInput
  }

  export type TruckingLogUncheckedUpdateWithoutEquipmentHauledInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    trailerNumber?: NullableStringFieldUpdateOperationsInput | string | null
    truckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    Materials?: MaterialUncheckedUpdateManyWithoutTruckingLogNestedInput
    RefuelLogs?: RefuelLogUncheckedUpdateManyWithoutTruckingLogNestedInput
    StateMileages?: StateMileageUncheckedUpdateManyWithoutTruckingLogNestedInput
  }

  export type UserCreateWithoutTimeSheetChangesInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Contact?: ContactsCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutTimeSheetChangesInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutTimeSheetChangesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTimeSheetChangesInput, UserUncheckedCreateWithoutTimeSheetChangesInput>
  }

  export type TimeSheetCreateWithoutChangeLogsInput = {
    date: Date | string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutTimeSheetInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogCreateNestedManyWithoutTimeSheetInput
    CostCode: CostCodeCreateNestedOneWithoutTimesheetsInput
    Jobsite: JobsiteCreateNestedOneWithoutTimeSheetsInput
    User: UserCreateNestedOneWithoutTimeSheetsInput
    TruckingLogs?: TruckingLogCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetUncheckedCreateWithoutChangeLogsInput = {
    date: Date | string
    userId: string
    jobsiteId: string
    costcode: string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    id?: number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutTimeSheetInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogUncheckedCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetCreateOrConnectWithoutChangeLogsInput = {
    where: TimeSheetWhereUniqueInput
    create: XOR<TimeSheetCreateWithoutChangeLogsInput, TimeSheetUncheckedCreateWithoutChangeLogsInput>
  }

  export type UserUpsertWithoutTimeSheetChangesInput = {
    update: XOR<UserUpdateWithoutTimeSheetChangesInput, UserUncheckedUpdateWithoutTimeSheetChangesInput>
    create: XOR<UserCreateWithoutTimeSheetChangesInput, UserUncheckedCreateWithoutTimeSheetChangesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTimeSheetChangesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTimeSheetChangesInput, UserUncheckedUpdateWithoutTimeSheetChangesInput>
  }

  export type UserUpdateWithoutTimeSheetChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutTimeSheetChangesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type TimeSheetUpsertWithoutChangeLogsInput = {
    update: XOR<TimeSheetUpdateWithoutChangeLogsInput, TimeSheetUncheckedUpdateWithoutChangeLogsInput>
    create: XOR<TimeSheetCreateWithoutChangeLogsInput, TimeSheetUncheckedCreateWithoutChangeLogsInput>
    where?: TimeSheetWhereInput
  }

  export type TimeSheetUpdateToOneWithWhereWithoutChangeLogsInput = {
    where?: TimeSheetWhereInput
    data: XOR<TimeSheetUpdateWithoutChangeLogsInput, TimeSheetUncheckedUpdateWithoutChangeLogsInput>
  }

  export type TimeSheetUpdateWithoutChangeLogsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutTimeSheetNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutTimeSheetNestedInput
    CostCode?: CostCodeUpdateOneRequiredWithoutTimesheetsNestedInput
    Jobsite?: JobsiteUpdateOneRequiredWithoutTimeSheetsNestedInput
    User?: UserUpdateOneRequiredWithoutTimeSheetsNestedInput
    TruckingLogs?: TruckingLogUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutTimeSheetNestedInput
  }

  export type TimeSheetUncheckedUpdateWithoutChangeLogsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    jobsiteId?: StringFieldUpdateOperationsInput | string
    costcode?: StringFieldUpdateOperationsInput | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutTimeSheetNestedInput
  }

  export type AccountSetupTokenCreateWithoutUserInput = {
    id?: string
    code: string
    expiresAt: Date | string
    used?: boolean
  }

  export type AccountSetupTokenUncheckedCreateWithoutUserInput = {
    id?: string
    code: string
    expiresAt: Date | string
    used?: boolean
  }

  export type AccountSetupTokenCreateOrConnectWithoutUserInput = {
    where: AccountSetupTokenWhereUniqueInput
    create: XOR<AccountSetupTokenCreateWithoutUserInput, AccountSetupTokenUncheckedCreateWithoutUserInput>
  }

  export type ContactsCreateWithoutUserInput = {
    id?: string
    phoneNumber?: string | null
    emergencyContact?: string | null
    emergencyContactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactsUncheckedCreateWithoutUserInput = {
    id?: string
    phoneNumber?: string | null
    emergencyContact?: string | null
    emergencyContactNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactsCreateOrConnectWithoutUserInput = {
    where: ContactsWhereUniqueInput
    create: XOR<ContactsCreateWithoutUserInput, ContactsUncheckedCreateWithoutUserInput>
  }

  export type EquipmentCreateWithoutCreatedByInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutCreatedByInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutEquipmentInput
    EquipmentHauled?: EquipmentHauledUncheckedCreateNestedManyWithoutEquipmentInput
    Maintenances?: MaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutEquipmentInput
    HauledInLogs?: TruckingLogUncheckedCreateNestedManyWithoutEquipmentInput
    UsedAsTrailer?: TruckingLogUncheckedCreateNestedManyWithoutTrailerInput
    UsedAsTruck?: TruckingLogUncheckedCreateNestedManyWithoutTruckInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutEquipmentInput
    DocumentTags?: DocumentTagUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutCreatedByInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutCreatedByInput, EquipmentUncheckedCreateWithoutCreatedByInput>
  }

  export type EquipmentCreateManyCreatedByInputEnvelope = {
    data: EquipmentCreateManyCreatedByInput | EquipmentCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type FCMTokenCreateWithoutUserInput = {
    id?: string
    token: string
    platform?: string | null
    lastUsedAt?: Date | string | null
    isValid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FCMTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    platform?: string | null
    lastUsedAt?: Date | string | null
    isValid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FCMTokenCreateOrConnectWithoutUserInput = {
    where: FCMTokenWhereUniqueInput
    create: XOR<FCMTokenCreateWithoutUserInput, FCMTokenUncheckedCreateWithoutUserInput>
  }

  export type FCMTokenCreateManyUserInputEnvelope = {
    data: FCMTokenCreateManyUserInput | FCMTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FormApprovalCreateWithoutApproverInput = {
    id?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    signature?: string | null
    comment?: string | null
    FormSubmission: FormSubmissionCreateNestedOneWithoutApprovalsInput
  }

  export type FormApprovalUncheckedCreateWithoutApproverInput = {
    id?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    signature?: string | null
    comment?: string | null
    formSubmissionId: number
  }

  export type FormApprovalCreateOrConnectWithoutApproverInput = {
    where: FormApprovalWhereUniqueInput
    create: XOR<FormApprovalCreateWithoutApproverInput, FormApprovalUncheckedCreateWithoutApproverInput>
  }

  export type FormApprovalCreateManyApproverInputEnvelope = {
    data: FormApprovalCreateManyApproverInput | FormApprovalCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type FormSubmissionCreateWithoutUserInput = {
    title?: string | null
    formType?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    status?: $Enums.FormStatus
    Approvals?: FormApprovalCreateNestedManyWithoutFormSubmissionInput
    FormTemplate: FormTemplateCreateNestedOneWithoutSubmissionsInput
  }

  export type FormSubmissionUncheckedCreateWithoutUserInput = {
    title?: string | null
    formTemplateId: string
    formType?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    status?: $Enums.FormStatus
    id?: number
    Approvals?: FormApprovalUncheckedCreateNestedManyWithoutFormSubmissionInput
  }

  export type FormSubmissionCreateOrConnectWithoutUserInput = {
    where: FormSubmissionWhereUniqueInput
    create: XOR<FormSubmissionCreateWithoutUserInput, FormSubmissionUncheckedCreateWithoutUserInput>
  }

  export type FormSubmissionCreateManyUserInputEnvelope = {
    data: FormSubmissionCreateManyUserInput | FormSubmissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type JobsiteCreateWithoutCreatedByInput = {
    id?: string
    qrId?: string
    name: string
    description: string
    creationReason?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    archiveDate?: Date | string | null
    createdVia?: $Enums.CreatedVia
    code?: string | null
    latitude?: number | null
    longitude?: number | null
    radiusMeters?: number | null
    status?: $Enums.FormTemplateStatus
    Address?: AddressCreateNestedOneWithoutJobsiteInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutJobsiteInput
    CCTags?: CCTagCreateNestedManyWithoutJobsitesInput
  }

  export type JobsiteUncheckedCreateWithoutCreatedByInput = {
    id?: string
    qrId?: string
    name: string
    description: string
    creationReason?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    addressId?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    archiveDate?: Date | string | null
    createdVia?: $Enums.CreatedVia
    code?: string | null
    latitude?: number | null
    longitude?: number | null
    radiusMeters?: number | null
    status?: $Enums.FormTemplateStatus
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutJobsiteInput
    CCTags?: CCTagUncheckedCreateNestedManyWithoutJobsitesInput
  }

  export type JobsiteCreateOrConnectWithoutCreatedByInput = {
    where: JobsiteWhereUniqueInput
    create: XOR<JobsiteCreateWithoutCreatedByInput, JobsiteUncheckedCreateWithoutCreatedByInput>
  }

  export type JobsiteCreateManyCreatedByInputEnvelope = {
    data: JobsiteCreateManyCreatedByInput | JobsiteCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceLogCreateWithoutUserInput = {
    id?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    Maintenance: MaintenanceCreateNestedOneWithoutMaintenanceLogsInput
    TimeSheet: TimeSheetCreateNestedOneWithoutMaintenanceLogsInput
  }

  export type MaintenanceLogUncheckedCreateWithoutUserInput = {
    id?: string
    maintenanceId: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    timeSheetId: number
  }

  export type MaintenanceLogCreateOrConnectWithoutUserInput = {
    where: MaintenanceLogWhereUniqueInput
    create: XOR<MaintenanceLogCreateWithoutUserInput, MaintenanceLogUncheckedCreateWithoutUserInput>
  }

  export type MaintenanceLogCreateManyUserInputEnvelope = {
    data: MaintenanceLogCreateManyUserInput | MaintenanceLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationReadCreateWithoutUserInput = {
    readAt?: Date | string
    notification: NotificationCreateNestedOneWithoutReadsInput
  }

  export type NotificationReadUncheckedCreateWithoutUserInput = {
    id?: number
    notificationId: number
    readAt?: Date | string
  }

  export type NotificationReadCreateOrConnectWithoutUserInput = {
    where: NotificationReadWhereUniqueInput
    create: XOR<NotificationReadCreateWithoutUserInput, NotificationReadUncheckedCreateWithoutUserInput>
  }

  export type NotificationReadCreateManyUserInputEnvelope = {
    data: NotificationReadCreateManyUserInput | NotificationReadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationResponseCreateWithoutUserInput = {
    response?: string | null
    respondedAt?: Date | string
    notification: NotificationCreateNestedOneWithoutResponseInput
  }

  export type NotificationResponseUncheckedCreateWithoutUserInput = {
    id?: number
    notificationId: number
    response?: string | null
    respondedAt?: Date | string
  }

  export type NotificationResponseCreateOrConnectWithoutUserInput = {
    where: NotificationResponseWhereUniqueInput
    create: XOR<NotificationResponseCreateWithoutUserInput, NotificationResponseUncheckedCreateWithoutUserInput>
  }

  export type NotificationResponseCreateManyUserInputEnvelope = {
    data: NotificationResponseCreateManyUserInput | NotificationResponseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiration: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiration: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TimeSheetCreateWithoutUserInput = {
    date: Date | string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogCreateNestedManyWithoutTimeSheetInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogCreateNestedManyWithoutTimeSheetInput
    CostCode: CostCodeCreateNestedOneWithoutTimesheetsInput
    Jobsite: JobsiteCreateNestedOneWithoutTimeSheetsInput
    ChangeLogs?: TimeSheetChangeLogCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetUncheckedCreateWithoutUserInput = {
    date: Date | string
    jobsiteId: string
    costcode: string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    id?: number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedCreateNestedManyWithoutTimeSheetInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TascoLogs?: TascoLogUncheckedCreateNestedManyWithoutTimeSheetInput
    ChangeLogs?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutTimeSheetInput
    TruckingLogs?: TruckingLogUncheckedCreateNestedManyWithoutTimeSheetInput
    Maintenance?: mechanicProjectsUncheckedCreateNestedManyWithoutTimeSheetInput
  }

  export type TimeSheetCreateOrConnectWithoutUserInput = {
    where: TimeSheetWhereUniqueInput
    create: XOR<TimeSheetCreateWithoutUserInput, TimeSheetUncheckedCreateWithoutUserInput>
  }

  export type TimeSheetCreateManyUserInputEnvelope = {
    data: TimeSheetCreateManyUserInput | TimeSheetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TimeSheetChangeLogCreateWithoutUserInput = {
    id?: string
    changedAt?: Date | string
    changeReason?: string | null
    changes: JsonNullValueInput | InputJsonValue
    wasStatusChange?: boolean
    numberOfChanges?: number
    TimeSheet: TimeSheetCreateNestedOneWithoutChangeLogsInput
  }

  export type TimeSheetChangeLogUncheckedCreateWithoutUserInput = {
    id?: string
    timeSheetId: number
    changedAt?: Date | string
    changeReason?: string | null
    changes: JsonNullValueInput | InputJsonValue
    wasStatusChange?: boolean
    numberOfChanges?: number
  }

  export type TimeSheetChangeLogCreateOrConnectWithoutUserInput = {
    where: TimeSheetChangeLogWhereUniqueInput
    create: XOR<TimeSheetChangeLogCreateWithoutUserInput, TimeSheetChangeLogUncheckedCreateWithoutUserInput>
  }

  export type TimeSheetChangeLogCreateManyUserInputEnvelope = {
    data: TimeSheetChangeLogCreateManyUserInput | TimeSheetChangeLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TopicSubscriptionCreateWithoutUserInput = {
    id?: string
    topic: string
    createdAt?: Date | string
  }

  export type TopicSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    topic: string
    createdAt?: Date | string
  }

  export type TopicSubscriptionCreateOrConnectWithoutUserInput = {
    where: TopicSubscriptionWhereUniqueInput
    create: XOR<TopicSubscriptionCreateWithoutUserInput, TopicSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type TopicSubscriptionCreateManyUserInputEnvelope = {
    data: TopicSubscriptionCreateManyUserInput | TopicSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubscriptionDate?: Date | string
    Address?: AddressCreateNestedOneWithoutCompanyInput
    FormTemplates?: FormTemplateCreateNestedManyWithoutCompanyInput
    Reports?: ReportCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    addressId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    SubscriptionDate?: Date | string
    FormTemplates?: FormTemplateUncheckedCreateNestedManyWithoutCompanyInput
    Reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type UserSettingsCreateWithoutUserInput = {
    id?: string
    language?: string
    generalReminders?: boolean
    personalReminders?: boolean
    cameraAccess?: boolean
    locationAccess?: boolean
    cookiesAccess?: boolean
    createdAt?: Date | string
    lastUpdated?: Date | string
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    language?: string
    generalReminders?: boolean
    personalReminders?: boolean
    cameraAccess?: boolean
    locationAccess?: boolean
    cookiesAccess?: boolean
    createdAt?: Date | string
    lastUpdated?: Date | string
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type CrewCreateWithoutUsersInput = {
    id?: string
    name: string
    leadId: string
    crewType: $Enums.WorkType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrewUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    leadId: string
    crewType: $Enums.WorkType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CrewCreateOrConnectWithoutUsersInput = {
    where: CrewWhereUniqueInput
    create: XOR<CrewCreateWithoutUsersInput, CrewUncheckedCreateWithoutUsersInput>
  }

  export type AccountSetupTokenUpsertWithoutUserInput = {
    update: XOR<AccountSetupTokenUpdateWithoutUserInput, AccountSetupTokenUncheckedUpdateWithoutUserInput>
    create: XOR<AccountSetupTokenCreateWithoutUserInput, AccountSetupTokenUncheckedCreateWithoutUserInput>
    where?: AccountSetupTokenWhereInput
  }

  export type AccountSetupTokenUpdateToOneWithWhereWithoutUserInput = {
    where?: AccountSetupTokenWhereInput
    data: XOR<AccountSetupTokenUpdateWithoutUserInput, AccountSetupTokenUncheckedUpdateWithoutUserInput>
  }

  export type AccountSetupTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AccountSetupTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContactsUpsertWithoutUserInput = {
    update: XOR<ContactsUpdateWithoutUserInput, ContactsUncheckedUpdateWithoutUserInput>
    create: XOR<ContactsCreateWithoutUserInput, ContactsUncheckedCreateWithoutUserInput>
    where?: ContactsWhereInput
  }

  export type ContactsUpdateToOneWithWhereWithoutUserInput = {
    where?: ContactsWhereInput
    data: XOR<ContactsUpdateWithoutUserInput, ContactsUncheckedUpdateWithoutUserInput>
  }

  export type ContactsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutCreatedByInput, EquipmentUncheckedUpdateWithoutCreatedByInput>
    create: XOR<EquipmentCreateWithoutCreatedByInput, EquipmentUncheckedCreateWithoutCreatedByInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutCreatedByInput, EquipmentUncheckedUpdateWithoutCreatedByInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutCreatedByInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type FCMTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: FCMTokenWhereUniqueInput
    update: XOR<FCMTokenUpdateWithoutUserInput, FCMTokenUncheckedUpdateWithoutUserInput>
    create: XOR<FCMTokenCreateWithoutUserInput, FCMTokenUncheckedCreateWithoutUserInput>
  }

  export type FCMTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: FCMTokenWhereUniqueInput
    data: XOR<FCMTokenUpdateWithoutUserInput, FCMTokenUncheckedUpdateWithoutUserInput>
  }

  export type FCMTokenUpdateManyWithWhereWithoutUserInput = {
    where: FCMTokenScalarWhereInput
    data: XOR<FCMTokenUpdateManyMutationInput, FCMTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type FCMTokenScalarWhereInput = {
    AND?: FCMTokenScalarWhereInput | FCMTokenScalarWhereInput[]
    OR?: FCMTokenScalarWhereInput[]
    NOT?: FCMTokenScalarWhereInput | FCMTokenScalarWhereInput[]
    id?: StringFilter<"FCMToken"> | string
    token?: StringFilter<"FCMToken"> | string
    userId?: StringFilter<"FCMToken"> | string
    platform?: StringNullableFilter<"FCMToken"> | string | null
    lastUsedAt?: DateTimeNullableFilter<"FCMToken"> | Date | string | null
    isValid?: BoolFilter<"FCMToken"> | boolean
    createdAt?: DateTimeFilter<"FCMToken"> | Date | string
    updatedAt?: DateTimeFilter<"FCMToken"> | Date | string
  }

  export type FormApprovalUpsertWithWhereUniqueWithoutApproverInput = {
    where: FormApprovalWhereUniqueInput
    update: XOR<FormApprovalUpdateWithoutApproverInput, FormApprovalUncheckedUpdateWithoutApproverInput>
    create: XOR<FormApprovalCreateWithoutApproverInput, FormApprovalUncheckedCreateWithoutApproverInput>
  }

  export type FormApprovalUpdateWithWhereUniqueWithoutApproverInput = {
    where: FormApprovalWhereUniqueInput
    data: XOR<FormApprovalUpdateWithoutApproverInput, FormApprovalUncheckedUpdateWithoutApproverInput>
  }

  export type FormApprovalUpdateManyWithWhereWithoutApproverInput = {
    where: FormApprovalScalarWhereInput
    data: XOR<FormApprovalUpdateManyMutationInput, FormApprovalUncheckedUpdateManyWithoutApproverInput>
  }

  export type FormSubmissionUpsertWithWhereUniqueWithoutUserInput = {
    where: FormSubmissionWhereUniqueInput
    update: XOR<FormSubmissionUpdateWithoutUserInput, FormSubmissionUncheckedUpdateWithoutUserInput>
    create: XOR<FormSubmissionCreateWithoutUserInput, FormSubmissionUncheckedCreateWithoutUserInput>
  }

  export type FormSubmissionUpdateWithWhereUniqueWithoutUserInput = {
    where: FormSubmissionWhereUniqueInput
    data: XOR<FormSubmissionUpdateWithoutUserInput, FormSubmissionUncheckedUpdateWithoutUserInput>
  }

  export type FormSubmissionUpdateManyWithWhereWithoutUserInput = {
    where: FormSubmissionScalarWhereInput
    data: XOR<FormSubmissionUpdateManyMutationInput, FormSubmissionUncheckedUpdateManyWithoutUserInput>
  }

  export type JobsiteUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: JobsiteWhereUniqueInput
    update: XOR<JobsiteUpdateWithoutCreatedByInput, JobsiteUncheckedUpdateWithoutCreatedByInput>
    create: XOR<JobsiteCreateWithoutCreatedByInput, JobsiteUncheckedCreateWithoutCreatedByInput>
  }

  export type JobsiteUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: JobsiteWhereUniqueInput
    data: XOR<JobsiteUpdateWithoutCreatedByInput, JobsiteUncheckedUpdateWithoutCreatedByInput>
  }

  export type JobsiteUpdateManyWithWhereWithoutCreatedByInput = {
    where: JobsiteScalarWhereInput
    data: XOR<JobsiteUpdateManyMutationInput, JobsiteUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type MaintenanceLogUpsertWithWhereUniqueWithoutUserInput = {
    where: MaintenanceLogWhereUniqueInput
    update: XOR<MaintenanceLogUpdateWithoutUserInput, MaintenanceLogUncheckedUpdateWithoutUserInput>
    create: XOR<MaintenanceLogCreateWithoutUserInput, MaintenanceLogUncheckedCreateWithoutUserInput>
  }

  export type MaintenanceLogUpdateWithWhereUniqueWithoutUserInput = {
    where: MaintenanceLogWhereUniqueInput
    data: XOR<MaintenanceLogUpdateWithoutUserInput, MaintenanceLogUncheckedUpdateWithoutUserInput>
  }

  export type MaintenanceLogUpdateManyWithWhereWithoutUserInput = {
    where: MaintenanceLogScalarWhereInput
    data: XOR<MaintenanceLogUpdateManyMutationInput, MaintenanceLogUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationReadUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationReadWhereUniqueInput
    update: XOR<NotificationReadUpdateWithoutUserInput, NotificationReadUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationReadCreateWithoutUserInput, NotificationReadUncheckedCreateWithoutUserInput>
  }

  export type NotificationReadUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationReadWhereUniqueInput
    data: XOR<NotificationReadUpdateWithoutUserInput, NotificationReadUncheckedUpdateWithoutUserInput>
  }

  export type NotificationReadUpdateManyWithWhereWithoutUserInput = {
    where: NotificationReadScalarWhereInput
    data: XOR<NotificationReadUpdateManyMutationInput, NotificationReadUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationReadScalarWhereInput = {
    AND?: NotificationReadScalarWhereInput | NotificationReadScalarWhereInput[]
    OR?: NotificationReadScalarWhereInput[]
    NOT?: NotificationReadScalarWhereInput | NotificationReadScalarWhereInput[]
    id?: IntFilter<"NotificationRead"> | number
    notificationId?: IntFilter<"NotificationRead"> | number
    userId?: StringFilter<"NotificationRead"> | string
    readAt?: DateTimeFilter<"NotificationRead"> | Date | string
  }

  export type NotificationResponseUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationResponseWhereUniqueInput
    update: XOR<NotificationResponseUpdateWithoutUserInput, NotificationResponseUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationResponseCreateWithoutUserInput, NotificationResponseUncheckedCreateWithoutUserInput>
  }

  export type NotificationResponseUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationResponseWhereUniqueInput
    data: XOR<NotificationResponseUpdateWithoutUserInput, NotificationResponseUncheckedUpdateWithoutUserInput>
  }

  export type NotificationResponseUpdateManyWithWhereWithoutUserInput = {
    where: NotificationResponseScalarWhereInput
    data: XOR<NotificationResponseUpdateManyMutationInput, NotificationResponseUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationResponseScalarWhereInput = {
    AND?: NotificationResponseScalarWhereInput | NotificationResponseScalarWhereInput[]
    OR?: NotificationResponseScalarWhereInput[]
    NOT?: NotificationResponseScalarWhereInput | NotificationResponseScalarWhereInput[]
    id?: IntFilter<"NotificationResponse"> | number
    notificationId?: IntFilter<"NotificationResponse"> | number
    userId?: StringFilter<"NotificationResponse"> | string
    response?: StringNullableFilter<"NotificationResponse"> | string | null
    respondedAt?: DateTimeFilter<"NotificationResponse"> | Date | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expiration?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type TimeSheetUpsertWithWhereUniqueWithoutUserInput = {
    where: TimeSheetWhereUniqueInput
    update: XOR<TimeSheetUpdateWithoutUserInput, TimeSheetUncheckedUpdateWithoutUserInput>
    create: XOR<TimeSheetCreateWithoutUserInput, TimeSheetUncheckedCreateWithoutUserInput>
  }

  export type TimeSheetUpdateWithWhereUniqueWithoutUserInput = {
    where: TimeSheetWhereUniqueInput
    data: XOR<TimeSheetUpdateWithoutUserInput, TimeSheetUncheckedUpdateWithoutUserInput>
  }

  export type TimeSheetUpdateManyWithWhereWithoutUserInput = {
    where: TimeSheetScalarWhereInput
    data: XOR<TimeSheetUpdateManyMutationInput, TimeSheetUncheckedUpdateManyWithoutUserInput>
  }

  export type TimeSheetChangeLogUpsertWithWhereUniqueWithoutUserInput = {
    where: TimeSheetChangeLogWhereUniqueInput
    update: XOR<TimeSheetChangeLogUpdateWithoutUserInput, TimeSheetChangeLogUncheckedUpdateWithoutUserInput>
    create: XOR<TimeSheetChangeLogCreateWithoutUserInput, TimeSheetChangeLogUncheckedCreateWithoutUserInput>
  }

  export type TimeSheetChangeLogUpdateWithWhereUniqueWithoutUserInput = {
    where: TimeSheetChangeLogWhereUniqueInput
    data: XOR<TimeSheetChangeLogUpdateWithoutUserInput, TimeSheetChangeLogUncheckedUpdateWithoutUserInput>
  }

  export type TimeSheetChangeLogUpdateManyWithWhereWithoutUserInput = {
    where: TimeSheetChangeLogScalarWhereInput
    data: XOR<TimeSheetChangeLogUpdateManyMutationInput, TimeSheetChangeLogUncheckedUpdateManyWithoutUserInput>
  }

  export type TopicSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: TopicSubscriptionWhereUniqueInput
    update: XOR<TopicSubscriptionUpdateWithoutUserInput, TopicSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<TopicSubscriptionCreateWithoutUserInput, TopicSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type TopicSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: TopicSubscriptionWhereUniqueInput
    data: XOR<TopicSubscriptionUpdateWithoutUserInput, TopicSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type TopicSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: TopicSubscriptionScalarWhereInput
    data: XOR<TopicSubscriptionUpdateManyMutationInput, TopicSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type TopicSubscriptionScalarWhereInput = {
    AND?: TopicSubscriptionScalarWhereInput | TopicSubscriptionScalarWhereInput[]
    OR?: TopicSubscriptionScalarWhereInput[]
    NOT?: TopicSubscriptionScalarWhereInput | TopicSubscriptionScalarWhereInput[]
    id?: StringFilter<"TopicSubscription"> | string
    topic?: StringFilter<"TopicSubscription"> | string
    createdAt?: DateTimeFilter<"TopicSubscription"> | Date | string
    userId?: StringFilter<"TopicSubscription"> | string
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubscriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Address?: AddressUpdateOneWithoutCompanyNestedInput
    FormTemplates?: FormTemplateUpdateManyWithoutCompanyNestedInput
    Reports?: ReportUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubscriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FormTemplates?: FormTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    Reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    generalReminders?: BoolFieldUpdateOperationsInput | boolean
    personalReminders?: BoolFieldUpdateOperationsInput | boolean
    cameraAccess?: BoolFieldUpdateOperationsInput | boolean
    locationAccess?: BoolFieldUpdateOperationsInput | boolean
    cookiesAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    generalReminders?: BoolFieldUpdateOperationsInput | boolean
    personalReminders?: BoolFieldUpdateOperationsInput | boolean
    cameraAccess?: BoolFieldUpdateOperationsInput | boolean
    locationAccess?: BoolFieldUpdateOperationsInput | boolean
    cookiesAccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewUpsertWithWhereUniqueWithoutUsersInput = {
    where: CrewWhereUniqueInput
    update: XOR<CrewUpdateWithoutUsersInput, CrewUncheckedUpdateWithoutUsersInput>
    create: XOR<CrewCreateWithoutUsersInput, CrewUncheckedCreateWithoutUsersInput>
  }

  export type CrewUpdateWithWhereUniqueWithoutUsersInput = {
    where: CrewWhereUniqueInput
    data: XOR<CrewUpdateWithoutUsersInput, CrewUncheckedUpdateWithoutUsersInput>
  }

  export type CrewUpdateManyWithWhereWithoutUsersInput = {
    where: CrewScalarWhereInput
    data: XOR<CrewUpdateManyMutationInput, CrewUncheckedUpdateManyWithoutUsersInput>
  }

  export type CrewScalarWhereInput = {
    AND?: CrewScalarWhereInput | CrewScalarWhereInput[]
    OR?: CrewScalarWhereInput[]
    NOT?: CrewScalarWhereInput | CrewScalarWhereInput[]
    id?: StringFilter<"Crew"> | string
    name?: StringFilter<"Crew"> | string
    leadId?: StringFilter<"Crew"> | string
    crewType?: EnumWorkTypeFilter<"Crew"> | $Enums.WorkType
    createdAt?: DateTimeFilter<"Crew"> | Date | string
    updatedAt?: DateTimeFilter<"Crew"> | Date | string
  }

  export type UserCreateWithoutUserSettingsInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Contact?: ContactsCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutUserSettingsInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutUserSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
  }

  export type UserUpsertWithoutUserSettingsInput = {
    update: XOR<UserUpdateWithoutUserSettingsInput, UserUncheckedUpdateWithoutUserSettingsInput>
    create: XOR<UserCreateWithoutUserSettingsInput, UserUncheckedCreateWithoutUserSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSettingsInput, UserUncheckedUpdateWithoutUserSettingsInput>
  }

  export type UserUpdateWithoutUserSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutContactInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutContactInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutContactInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactInput, UserUncheckedCreateWithoutContactInput>
  }

  export type UserUpsertWithoutContactInput = {
    update: XOR<UserUpdateWithoutContactInput, UserUncheckedUpdateWithoutContactInput>
    create: XOR<UserCreateWithoutContactInput, UserUncheckedCreateWithoutContactInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactInput, UserUncheckedUpdateWithoutContactInput>
  }

  export type UserUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutPasswordResetTokensInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Contact?: ContactsCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutPasswordResetTokensInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutPasswordResetTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
  }

  export type UserUpsertWithoutPasswordResetTokensInput = {
    update: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
    create: XOR<UserCreateWithoutPasswordResetTokensInput, UserUncheckedCreateWithoutPasswordResetTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetTokensInput, UserUncheckedUpdateWithoutPasswordResetTokensInput>
  }

  export type UserUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutAccountSetupTokenInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    Contact?: ContactsCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutAccountSetupTokenInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutAccountSetupTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountSetupTokenInput, UserUncheckedCreateWithoutAccountSetupTokenInput>
  }

  export type UserUpsertWithoutAccountSetupTokenInput = {
    update: XOR<UserUpdateWithoutAccountSetupTokenInput, UserUncheckedUpdateWithoutAccountSetupTokenInput>
    create: XOR<UserCreateWithoutAccountSetupTokenInput, UserUncheckedCreateWithoutAccountSetupTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountSetupTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountSetupTokenInput, UserUncheckedUpdateWithoutAccountSetupTokenInput>
  }

  export type UserUpdateWithoutAccountSetupTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountSetupTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type CompanyCreateWithoutAddressInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubscriptionDate?: Date | string
    FormTemplates?: FormTemplateCreateNestedManyWithoutCompanyInput
    Reports?: ReportCreateNestedManyWithoutCompanyInput
    Users?: UserCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutAddressInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubscriptionDate?: Date | string
    FormTemplates?: FormTemplateUncheckedCreateNestedManyWithoutCompanyInput
    Reports?: ReportUncheckedCreateNestedManyWithoutCompanyInput
    Users?: UserUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutAddressInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutAddressInput, CompanyUncheckedCreateWithoutAddressInput>
  }

  export type CompanyCreateManyAddressInputEnvelope = {
    data: CompanyCreateManyAddressInput | CompanyCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type JobsiteCreateWithoutAddressInput = {
    id?: string
    qrId?: string
    name: string
    description: string
    creationReason?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    archiveDate?: Date | string | null
    createdVia?: $Enums.CreatedVia
    code?: string | null
    latitude?: number | null
    longitude?: number | null
    radiusMeters?: number | null
    status?: $Enums.FormTemplateStatus
    createdBy?: UserCreateNestedOneWithoutJobsiteInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutJobsiteInput
    CCTags?: CCTagCreateNestedManyWithoutJobsitesInput
  }

  export type JobsiteUncheckedCreateWithoutAddressInput = {
    id?: string
    qrId?: string
    name: string
    description: string
    creationReason?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    archiveDate?: Date | string | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    code?: string | null
    latitude?: number | null
    longitude?: number | null
    radiusMeters?: number | null
    status?: $Enums.FormTemplateStatus
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutJobsiteInput
    CCTags?: CCTagUncheckedCreateNestedManyWithoutJobsitesInput
  }

  export type JobsiteCreateOrConnectWithoutAddressInput = {
    where: JobsiteWhereUniqueInput
    create: XOR<JobsiteCreateWithoutAddressInput, JobsiteUncheckedCreateWithoutAddressInput>
  }

  export type JobsiteCreateManyAddressInputEnvelope = {
    data: JobsiteCreateManyAddressInput | JobsiteCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithWhereUniqueWithoutAddressInput = {
    where: CompanyWhereUniqueInput
    update: XOR<CompanyUpdateWithoutAddressInput, CompanyUncheckedUpdateWithoutAddressInput>
    create: XOR<CompanyCreateWithoutAddressInput, CompanyUncheckedCreateWithoutAddressInput>
  }

  export type CompanyUpdateWithWhereUniqueWithoutAddressInput = {
    where: CompanyWhereUniqueInput
    data: XOR<CompanyUpdateWithoutAddressInput, CompanyUncheckedUpdateWithoutAddressInput>
  }

  export type CompanyUpdateManyWithWhereWithoutAddressInput = {
    where: CompanyScalarWhereInput
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyWithoutAddressInput>
  }

  export type CompanyScalarWhereInput = {
    AND?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    OR?: CompanyScalarWhereInput[]
    NOT?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    addressId?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    SubscriptionDate?: DateTimeFilter<"Company"> | Date | string
  }

  export type JobsiteUpsertWithWhereUniqueWithoutAddressInput = {
    where: JobsiteWhereUniqueInput
    update: XOR<JobsiteUpdateWithoutAddressInput, JobsiteUncheckedUpdateWithoutAddressInput>
    create: XOR<JobsiteCreateWithoutAddressInput, JobsiteUncheckedCreateWithoutAddressInput>
  }

  export type JobsiteUpdateWithWhereUniqueWithoutAddressInput = {
    where: JobsiteWhereUniqueInput
    data: XOR<JobsiteUpdateWithoutAddressInput, JobsiteUncheckedUpdateWithoutAddressInput>
  }

  export type JobsiteUpdateManyWithWhereWithoutAddressInput = {
    where: JobsiteScalarWhereInput
    data: XOR<JobsiteUpdateManyMutationInput, JobsiteUncheckedUpdateManyWithoutAddressInput>
  }

  export type UserCreateWithoutFCMTokenInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Contact?: ContactsCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutFCMTokenInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutFCMTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFCMTokenInput, UserUncheckedCreateWithoutFCMTokenInput>
  }

  export type UserUpsertWithoutFCMTokenInput = {
    update: XOR<UserUpdateWithoutFCMTokenInput, UserUncheckedUpdateWithoutFCMTokenInput>
    create: XOR<UserCreateWithoutFCMTokenInput, UserUncheckedCreateWithoutFCMTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFCMTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFCMTokenInput, UserUncheckedUpdateWithoutFCMTokenInput>
  }

  export type UserUpdateWithoutFCMTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutFCMTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserCreateWithoutTopicSubscriptionsInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Contact?: ContactsCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutTopicSubscriptionsInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutTopicSubscriptionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTopicSubscriptionsInput, UserUncheckedCreateWithoutTopicSubscriptionsInput>
  }

  export type UserUpsertWithoutTopicSubscriptionsInput = {
    update: XOR<UserUpdateWithoutTopicSubscriptionsInput, UserUncheckedUpdateWithoutTopicSubscriptionsInput>
    create: XOR<UserCreateWithoutTopicSubscriptionsInput, UserUncheckedCreateWithoutTopicSubscriptionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTopicSubscriptionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTopicSubscriptionsInput, UserUncheckedUpdateWithoutTopicSubscriptionsInput>
  }

  export type UserUpdateWithoutTopicSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutTopicSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type NotificationReadCreateWithoutNotificationInput = {
    readAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationReadInput
  }

  export type NotificationReadUncheckedCreateWithoutNotificationInput = {
    id?: number
    userId: string
    readAt?: Date | string
  }

  export type NotificationReadCreateOrConnectWithoutNotificationInput = {
    where: NotificationReadWhereUniqueInput
    create: XOR<NotificationReadCreateWithoutNotificationInput, NotificationReadUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationReadCreateManyNotificationInputEnvelope = {
    data: NotificationReadCreateManyNotificationInput | NotificationReadCreateManyNotificationInput[]
    skipDuplicates?: boolean
  }

  export type NotificationResponseCreateWithoutNotificationInput = {
    response?: string | null
    respondedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationResponseInput
  }

  export type NotificationResponseUncheckedCreateWithoutNotificationInput = {
    id?: number
    userId: string
    response?: string | null
    respondedAt?: Date | string
  }

  export type NotificationResponseCreateOrConnectWithoutNotificationInput = {
    where: NotificationResponseWhereUniqueInput
    create: XOR<NotificationResponseCreateWithoutNotificationInput, NotificationResponseUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationReadUpsertWithWhereUniqueWithoutNotificationInput = {
    where: NotificationReadWhereUniqueInput
    update: XOR<NotificationReadUpdateWithoutNotificationInput, NotificationReadUncheckedUpdateWithoutNotificationInput>
    create: XOR<NotificationReadCreateWithoutNotificationInput, NotificationReadUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationReadUpdateWithWhereUniqueWithoutNotificationInput = {
    where: NotificationReadWhereUniqueInput
    data: XOR<NotificationReadUpdateWithoutNotificationInput, NotificationReadUncheckedUpdateWithoutNotificationInput>
  }

  export type NotificationReadUpdateManyWithWhereWithoutNotificationInput = {
    where: NotificationReadScalarWhereInput
    data: XOR<NotificationReadUpdateManyMutationInput, NotificationReadUncheckedUpdateManyWithoutNotificationInput>
  }

  export type NotificationResponseUpsertWithoutNotificationInput = {
    update: XOR<NotificationResponseUpdateWithoutNotificationInput, NotificationResponseUncheckedUpdateWithoutNotificationInput>
    create: XOR<NotificationResponseCreateWithoutNotificationInput, NotificationResponseUncheckedCreateWithoutNotificationInput>
    where?: NotificationResponseWhereInput
  }

  export type NotificationResponseUpdateToOneWithWhereWithoutNotificationInput = {
    where?: NotificationResponseWhereInput
    data: XOR<NotificationResponseUpdateWithoutNotificationInput, NotificationResponseUncheckedUpdateWithoutNotificationInput>
  }

  export type NotificationResponseUpdateWithoutNotificationInput = {
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationResponseNestedInput
  }

  export type NotificationResponseUncheckedUpdateWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateWithoutResponseInput = {
    topic?: string | null
    title: string
    body?: string | null
    url?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    pushedAt?: Date | string | null
    pushAttempts?: number
    readAt?: Date | string | null
    referenceId?: string | null
    Reads?: NotificationReadCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutResponseInput = {
    topic?: string | null
    title: string
    body?: string | null
    url?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    pushedAt?: Date | string | null
    pushAttempts?: number
    readAt?: Date | string | null
    id?: number
    referenceId?: string | null
    Reads?: NotificationReadUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationCreateOrConnectWithoutResponseInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutResponseInput, NotificationUncheckedCreateWithoutResponseInput>
  }

  export type UserCreateWithoutNotificationResponseInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Contact?: ContactsCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutNotificationResponseInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationRead?: NotificationReadUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutNotificationResponseInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationResponseInput, UserUncheckedCreateWithoutNotificationResponseInput>
  }

  export type NotificationUpsertWithoutResponseInput = {
    update: XOR<NotificationUpdateWithoutResponseInput, NotificationUncheckedUpdateWithoutResponseInput>
    create: XOR<NotificationCreateWithoutResponseInput, NotificationUncheckedCreateWithoutResponseInput>
    where?: NotificationWhereInput
  }

  export type NotificationUpdateToOneWithWhereWithoutResponseInput = {
    where?: NotificationWhereInput
    data: XOR<NotificationUpdateWithoutResponseInput, NotificationUncheckedUpdateWithoutResponseInput>
  }

  export type NotificationUpdateWithoutResponseInput = {
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushAttempts?: IntFieldUpdateOperationsInput | number
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Reads?: NotificationReadUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutResponseInput = {
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushAttempts?: IntFieldUpdateOperationsInput | number
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Reads?: NotificationReadUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type UserUpsertWithoutNotificationResponseInput = {
    update: XOR<UserUpdateWithoutNotificationResponseInput, UserUncheckedUpdateWithoutNotificationResponseInput>
    create: XOR<UserCreateWithoutNotificationResponseInput, UserUncheckedCreateWithoutNotificationResponseInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationResponseInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationResponseInput, UserUncheckedUpdateWithoutNotificationResponseInput>
  }

  export type UserUpdateWithoutNotificationResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type NotificationCreateWithoutReadsInput = {
    topic?: string | null
    title: string
    body?: string | null
    url?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    pushedAt?: Date | string | null
    pushAttempts?: number
    readAt?: Date | string | null
    referenceId?: string | null
    Response?: NotificationResponseCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutReadsInput = {
    topic?: string | null
    title: string
    body?: string | null
    url?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    pushedAt?: Date | string | null
    pushAttempts?: number
    readAt?: Date | string | null
    id?: number
    referenceId?: string | null
    Response?: NotificationResponseUncheckedCreateNestedOneWithoutNotificationInput
  }

  export type NotificationCreateOrConnectWithoutReadsInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutReadsInput, NotificationUncheckedCreateWithoutReadsInput>
  }

  export type UserCreateWithoutNotificationReadInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenCreateNestedOneWithoutUserInput
    Contact?: ContactsCreateNestedOneWithoutUserInput
    Equipment?: EquipmentCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionCreateNestedManyWithoutUserInput
    Company: CompanyCreateNestedOneWithoutUsersInput
    UserSettings?: UserSettingsCreateNestedOneWithoutUserInput
    Crews?: CrewCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutNotificationReadInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    companyId: string
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedCreateNestedOneWithoutUserInput
    Contact?: ContactsUncheckedCreateNestedOneWithoutUserInput
    Equipment?: EquipmentUncheckedCreateNestedManyWithoutCreatedByInput
    FCMToken?: FCMTokenUncheckedCreateNestedManyWithoutUserInput
    FormApprovals?: FormApprovalUncheckedCreateNestedManyWithoutApproverInput
    FormSubmissions?: FormSubmissionUncheckedCreateNestedManyWithoutUserInput
    Jobsite?: JobsiteUncheckedCreateNestedManyWithoutCreatedByInput
    MaintenanceLogs?: MaintenanceLogUncheckedCreateNestedManyWithoutUserInput
    NotificationResponse?: NotificationResponseUncheckedCreateNestedManyWithoutUserInput
    PasswordResetTokens?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    TimeSheets?: TimeSheetUncheckedCreateNestedManyWithoutUserInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedCreateNestedManyWithoutUserInput
    topicSubscriptions?: TopicSubscriptionUncheckedCreateNestedManyWithoutUserInput
    UserSettings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    Crews?: CrewUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutNotificationReadInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationReadInput, UserUncheckedCreateWithoutNotificationReadInput>
  }

  export type NotificationUpsertWithoutReadsInput = {
    update: XOR<NotificationUpdateWithoutReadsInput, NotificationUncheckedUpdateWithoutReadsInput>
    create: XOR<NotificationCreateWithoutReadsInput, NotificationUncheckedCreateWithoutReadsInput>
    where?: NotificationWhereInput
  }

  export type NotificationUpdateToOneWithWhereWithoutReadsInput = {
    where?: NotificationWhereInput
    data: XOR<NotificationUpdateWithoutReadsInput, NotificationUncheckedUpdateWithoutReadsInput>
  }

  export type NotificationUpdateWithoutReadsInput = {
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushAttempts?: IntFieldUpdateOperationsInput | number
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Response?: NotificationResponseUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutReadsInput = {
    topic?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    body?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pushedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pushAttempts?: IntFieldUpdateOperationsInput | number
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    id?: IntFieldUpdateOperationsInput | number
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    Response?: NotificationResponseUncheckedUpdateOneWithoutNotificationNestedInput
  }

  export type UserUpsertWithoutNotificationReadInput = {
    update: XOR<UserUpdateWithoutNotificationReadInput, UserUncheckedUpdateWithoutNotificationReadInput>
    create: XOR<UserCreateWithoutNotificationReadInput, UserUncheckedCreateWithoutNotificationReadInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationReadInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationReadInput, UserUncheckedUpdateWithoutNotificationReadInput>
  }

  export type UserUpdateWithoutNotificationReadInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationReadInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type FormTemplateCreateManyCompanyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isSignatureRequired?: boolean
    description?: string | null
    isActive?: $Enums.FormTemplateStatus
    formType?: $Enums.FormTemplateCategory
    isApprovalRequired?: boolean
  }

  export type ReportCreateManyCompanyInput = {
    name: string
    description: string
    createdAt?: Date | string
    createdBy: string
    updatedAt?: Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: $Enums.ReportVisibility
    tags?: ReportCreatetagsInput | string[]
    id: number
  }

  export type UserCreateManyCompanyInput = {
    id?: string
    firstName: string
    lastName: string
    username: string
    email?: string | null
    password: string
    signature?: string | null
    DOB?: Date | string | null
    truckView: boolean
    tascoView: boolean
    laborView: boolean
    mechanicView: boolean
    permission?: $Enums.Permission
    image?: string | null
    startDate?: Date | string | null
    terminationDate?: Date | string | null
    accountSetup?: boolean
    clockedIn?: boolean
    passwordResetTokenId?: string | null
    workTypeId?: string | null
    middleName?: string | null
    secondLastName?: string | null
    lastSeen?: Date | string | null
  }

  export type FormTemplateUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSignatureRequired?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    formType?: EnumFormTemplateCategoryFieldUpdateOperationsInput | $Enums.FormTemplateCategory
    isApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    Submissions?: FormSubmissionUpdateManyWithoutFormTemplateNestedInput
    FormGrouping?: FormGroupingUpdateManyWithoutFormTemplateNestedInput
  }

  export type FormTemplateUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSignatureRequired?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    formType?: EnumFormTemplateCategoryFieldUpdateOperationsInput | $Enums.FormTemplateCategory
    isApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    Submissions?: FormSubmissionUncheckedUpdateManyWithoutFormTemplateNestedInput
    FormGrouping?: FormGroupingUncheckedUpdateManyWithoutFormTemplateNestedInput
  }

  export type FormTemplateUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSignatureRequired?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    formType?: EnumFormTemplateCategoryFieldUpdateOperationsInput | $Enums.FormTemplateCategory
    isApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReportUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumReportVisibilityFieldUpdateOperationsInput | $Enums.ReportVisibility
    tags?: ReportUpdatetagsInput | string[]
    id?: IntFieldUpdateOperationsInput | number
    ReportRuns?: ReportRunUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumReportVisibilityFieldUpdateOperationsInput | $Enums.ReportVisibility
    tags?: ReportUpdatetagsInput | string[]
    id?: IntFieldUpdateOperationsInput | number
    ReportRuns?: ReportRunUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parameters?: NullableJsonNullValueInput | InputJsonValue
    visibility?: EnumReportVisibilityFieldUpdateOperationsInput | $Enums.ReportVisibility
    tags?: ReportUpdatetagsInput | string[]
    id?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
    Crews?: CrewUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    Crews?: CrewUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TimeSheetCreateManyCostCodeInput = {
    date: Date | string
    userId: string
    jobsiteId: string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    id?: number
  }

  export type TimeSheetUpdateWithoutCostCodeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutTimeSheetNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutTimeSheetNestedInput
    Jobsite?: JobsiteUpdateOneRequiredWithoutTimeSheetsNestedInput
    User?: UserUpdateOneRequiredWithoutTimeSheetsNestedInput
    ChangeLogs?: TimeSheetChangeLogUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutTimeSheetNestedInput
  }

  export type TimeSheetUncheckedUpdateWithoutCostCodeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    jobsiteId?: StringFieldUpdateOperationsInput | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    ChangeLogs?: TimeSheetChangeLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutTimeSheetNestedInput
  }

  export type TimeSheetUncheckedUpdateManyWithoutCostCodeInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    jobsiteId?: StringFieldUpdateOperationsInput | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type CCTagUpdateWithoutCostCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Jobsites?: JobsiteUpdateManyWithoutCCTagsNestedInput
  }

  export type CCTagUncheckedUpdateWithoutCostCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Jobsites?: JobsiteUncheckedUpdateManyWithoutCCTagsNestedInput
  }

  export type CCTagUncheckedUpdateManyWithoutCostCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CostCodeUpdateWithoutCCTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    Timesheets?: TimeSheetUpdateManyWithoutCostCodeNestedInput
  }

  export type CostCodeUncheckedUpdateWithoutCCTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    Timesheets?: TimeSheetUncheckedUpdateManyWithoutCostCodeNestedInput
  }

  export type CostCodeUncheckedUpdateManyWithoutCCTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type JobsiteUpdateWithoutCCTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    code?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radiusMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    Address?: AddressUpdateOneWithoutJobsiteNestedInput
    createdBy?: UserUpdateOneWithoutJobsiteNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutJobsiteNestedInput
  }

  export type JobsiteUncheckedUpdateWithoutCCTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    code?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radiusMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutJobsiteNestedInput
  }

  export type JobsiteUncheckedUpdateManyWithoutCCTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    code?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radiusMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
  }

  export type UserUpdateWithoutCrewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUpdateOneWithoutUserNestedInput
    Contact?: ContactsUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUpdateManyWithoutUserNestedInput
    Company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
    UserSettings?: UserSettingsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCrewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetupToken?: AccountSetupTokenUncheckedUpdateOneWithoutUserNestedInput
    Contact?: ContactsUncheckedUpdateOneWithoutUserNestedInput
    Equipment?: EquipmentUncheckedUpdateManyWithoutCreatedByNestedInput
    FCMToken?: FCMTokenUncheckedUpdateManyWithoutUserNestedInput
    FormApprovals?: FormApprovalUncheckedUpdateManyWithoutApproverNestedInput
    FormSubmissions?: FormSubmissionUncheckedUpdateManyWithoutUserNestedInput
    Jobsite?: JobsiteUncheckedUpdateManyWithoutCreatedByNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutUserNestedInput
    NotificationRead?: NotificationReadUncheckedUpdateManyWithoutUserNestedInput
    NotificationResponse?: NotificationResponseUncheckedUpdateManyWithoutUserNestedInput
    PasswordResetTokens?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutUserNestedInput
    TimeSheetChanges?: TimeSheetChangeLogUncheckedUpdateManyWithoutUserNestedInput
    topicSubscriptions?: TopicSubscriptionUncheckedUpdateManyWithoutUserNestedInput
    UserSettings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutCrewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    DOB?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    truckView?: BoolFieldUpdateOperationsInput | boolean
    tascoView?: BoolFieldUpdateOperationsInput | boolean
    laborView?: BoolFieldUpdateOperationsInput | boolean
    mechanicView?: BoolFieldUpdateOperationsInput | boolean
    permission?: EnumPermissionFieldUpdateOperationsInput | $Enums.Permission
    image?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    terminationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accountSetup?: BoolFieldUpdateOperationsInput | boolean
    clockedIn?: BoolFieldUpdateOperationsInput | boolean
    companyId?: StringFieldUpdateOperationsInput | string
    passwordResetTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    workTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    secondLastName?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentTagUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    Equipment?: EquipmentUpdateManyWithoutDocumentTagsNestedInput
  }

  export type DocumentTagUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    Equipment?: EquipmentUncheckedUpdateManyWithoutDocumentTagsNestedInput
  }

  export type DocumentTagUncheckedUpdateManyWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
  }

  export type EquipmentUpdateWithoutDocumentTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutEquipmentNestedInput
    createdBy?: UserUpdateOneWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutDocumentTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUncheckedUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUncheckedUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUncheckedUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateManyWithoutDocumentTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
  }

  export type PdfDocumentUpdateWithoutDocumentTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileData?: BytesFieldUpdateOperationsInput | Bytes
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfDocumentUncheckedUpdateWithoutDocumentTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileData?: BytesFieldUpdateOperationsInput | Bytes
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PdfDocumentUncheckedUpdateManyWithoutDocumentTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileData?: BytesFieldUpdateOperationsInput | Bytes
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeEquipmentLogCreateManyEquipmentInput = {
    id?: string
    maintenanceId?: string | null
    startTime?: Date | string
    endTime?: Date | string | null
    comment?: string | null
    timeSheetId: number
    rental?: boolean
  }

  export type EquipmentHauledCreateManyEquipmentInput = {
    id?: string
    truckingLogId?: string | null
    createdAt?: Date | string
    endMileage?: number | null
    startMileage?: number | null
    destination?: string | null
    source?: string | null
  }

  export type MaintenanceCreateManyEquipmentInput = {
    id?: string
    equipmentIssue?: string | null
    employeeEquipmentLogId?: string | null
    additionalInfo?: string | null
    location?: string | null
    problemDiagnosis?: string | null
    solution?: string | null
    totalHoursLaboured?: number | null
    createdAt?: Date | string
    priority: $Enums.Priority
    delay?: Date | string | null
    delayReasoning?: string | null
    repaired?: boolean
    selected?: boolean
    hasBeenDelayed?: boolean
    createdBy?: string | null
  }

  export type TascoLogCreateManyEquipmentInput = {
    id?: string
    shiftType: string
    laborType?: string | null
    materialType?: string | null
    LoadQuantity?: number
    screenType?: $Enums.LoadType | null
    timeSheetId: number
  }

  export type TruckingLogCreateManyEquipmentInput = {
    id?: string
    laborType: string
    taskName?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    trailerNumber?: string | null
    truckNumber?: string | null
    timeSheetId: number
  }

  export type TruckingLogCreateManyTrailerInput = {
    id?: string
    laborType: string
    taskName?: string | null
    equipmentId?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    truckNumber?: string | null
    timeSheetId: number
  }

  export type TruckingLogCreateManyTruckInput = {
    id?: string
    laborType: string
    taskName?: string | null
    equipmentId?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    trailerNumber?: string | null
    timeSheetId: number
  }

  export type mechanicProjectsCreateManyEquipmentInput = {
    id?: number
    timeSheetId: number
    hours?: number | null
    description?: string | null
  }

  export type EmployeeEquipmentLogUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    rental?: BoolFieldUpdateOperationsInput | boolean
    Maintenance?: MaintenanceUpdateOneWithoutEmployeeEquipmentLogNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutEmployeeEquipmentLogsNestedInput
    RefuelLog?: RefuelLogUpdateOneWithoutEmployeeEquipmentLogNestedInput
  }

  export type EmployeeEquipmentLogUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    maintenanceId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    rental?: BoolFieldUpdateOperationsInput | boolean
    RefuelLog?: RefuelLogUncheckedUpdateOneWithoutEmployeeEquipmentLogNestedInput
  }

  export type EmployeeEquipmentLogUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    maintenanceId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    rental?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EquipmentHauledUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startMileage?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    TruckingLog?: TruckingLogUpdateOneWithoutEquipmentHauledNestedInput
  }

  export type EquipmentHauledUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startMileage?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentHauledUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    truckingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startMileage?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentIssue?: NullableStringFieldUpdateOperationsInput | string | null
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    problemDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    totalHoursLaboured?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    delay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delayReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    repaired?: BoolFieldUpdateOperationsInput | boolean
    selected?: BoolFieldUpdateOperationsInput | boolean
    hasBeenDelayed?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogUpdateManyWithoutMaintenanceNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutMaintenanceNestedInput
  }

  export type MaintenanceUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentIssue?: NullableStringFieldUpdateOperationsInput | string | null
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    problemDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    totalHoursLaboured?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    delay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delayReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    repaired?: BoolFieldUpdateOperationsInput | boolean
    selected?: BoolFieldUpdateOperationsInput | boolean
    hasBeenDelayed?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogUncheckedUpdateManyWithoutMaintenanceNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutMaintenanceNestedInput
  }

  export type MaintenanceUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentIssue?: NullableStringFieldUpdateOperationsInput | string | null
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    additionalInfo?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    problemDiagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    totalHoursLaboured?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    delay?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    delayReasoning?: NullableStringFieldUpdateOperationsInput | string | null
    repaired?: BoolFieldUpdateOperationsInput | boolean
    selected?: BoolFieldUpdateOperationsInput | boolean
    hasBeenDelayed?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TascoLogUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    RefuelLogs?: RefuelLogUpdateManyWithoutTascoLogNestedInput
    TascoFLoads?: TascoFLoadsUpdateManyWithoutTascoLogNestedInput
    TascoMaterialTypes?: TascoMaterialTypesUpdateOneWithoutTascoLogNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutTascoLogsNestedInput
  }

  export type TascoLogUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    materialType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    RefuelLogs?: RefuelLogUncheckedUpdateManyWithoutTascoLogNestedInput
    TascoFLoads?: TascoFLoadsUncheckedUpdateManyWithoutTascoLogNestedInput
  }

  export type TascoLogUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    materialType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
  }

  export type TruckingLogUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutTruckingLogNestedInput
    Materials?: MaterialUpdateManyWithoutTruckingLogNestedInput
    RefuelLogs?: RefuelLogUpdateManyWithoutTruckingLogNestedInput
    StateMileages?: StateMileageUpdateManyWithoutTruckingLogNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutTruckingLogsNestedInput
    Trailer?: EquipmentUpdateOneWithoutUsedAsTrailerNestedInput
    Truck?: EquipmentUpdateOneWithoutUsedAsTruckNestedInput
  }

  export type TruckingLogUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    trailerNumber?: NullableStringFieldUpdateOperationsInput | string | null
    truckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutTruckingLogNestedInput
    Materials?: MaterialUncheckedUpdateManyWithoutTruckingLogNestedInput
    RefuelLogs?: RefuelLogUncheckedUpdateManyWithoutTruckingLogNestedInput
    StateMileages?: StateMileageUncheckedUpdateManyWithoutTruckingLogNestedInput
  }

  export type TruckingLogUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    trailerNumber?: NullableStringFieldUpdateOperationsInput | string | null
    truckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
  }

  export type TruckingLogUpdateWithoutTrailerInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutTruckingLogNestedInput
    Materials?: MaterialUpdateManyWithoutTruckingLogNestedInput
    RefuelLogs?: RefuelLogUpdateManyWithoutTruckingLogNestedInput
    StateMileages?: StateMileageUpdateManyWithoutTruckingLogNestedInput
    Equipment?: EquipmentUpdateOneWithoutHauledInLogsNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutTruckingLogsNestedInput
    Truck?: EquipmentUpdateOneWithoutUsedAsTruckNestedInput
  }

  export type TruckingLogUncheckedUpdateWithoutTrailerInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    truckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutTruckingLogNestedInput
    Materials?: MaterialUncheckedUpdateManyWithoutTruckingLogNestedInput
    RefuelLogs?: RefuelLogUncheckedUpdateManyWithoutTruckingLogNestedInput
    StateMileages?: StateMileageUncheckedUpdateManyWithoutTruckingLogNestedInput
  }

  export type TruckingLogUncheckedUpdateManyWithoutTrailerInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    truckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
  }

  export type TruckingLogUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutTruckingLogNestedInput
    Materials?: MaterialUpdateManyWithoutTruckingLogNestedInput
    RefuelLogs?: RefuelLogUpdateManyWithoutTruckingLogNestedInput
    StateMileages?: StateMileageUpdateManyWithoutTruckingLogNestedInput
    Equipment?: EquipmentUpdateOneWithoutHauledInLogsNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutTruckingLogsNestedInput
    Trailer?: EquipmentUpdateOneWithoutUsedAsTrailerNestedInput
  }

  export type TruckingLogUncheckedUpdateWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    trailerNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutTruckingLogNestedInput
    Materials?: MaterialUncheckedUpdateManyWithoutTruckingLogNestedInput
    RefuelLogs?: RefuelLogUncheckedUpdateManyWithoutTruckingLogNestedInput
    StateMileages?: StateMileageUncheckedUpdateManyWithoutTruckingLogNestedInput
  }

  export type TruckingLogUncheckedUpdateManyWithoutTruckInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    trailerNumber?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
  }

  export type mechanicProjectsUpdateWithoutEquipmentInput = {
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutMaintenanceNestedInput
  }

  export type mechanicProjectsUncheckedUpdateWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    timeSheetId?: IntFieldUpdateOperationsInput | number
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mechanicProjectsUncheckedUpdateManyWithoutEquipmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    timeSheetId?: IntFieldUpdateOperationsInput | number
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentTagUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    Documents?: PdfDocumentUpdateManyWithoutDocumentTagsNestedInput
  }

  export type DocumentTagUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
    Documents?: PdfDocumentUncheckedUpdateManyWithoutDocumentTagsNestedInput
  }

  export type DocumentTagUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagName?: StringFieldUpdateOperationsInput | string
  }

  export type FormSubmissionCreateManyFormTemplateInput = {
    title?: string | null
    userId: string
    formType?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    status?: $Enums.FormStatus
    id?: number
  }

  export type FormSubmissionUpdateWithoutFormTemplateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    formType?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    Approvals?: FormApprovalUpdateManyWithoutFormSubmissionNestedInput
    User?: UserUpdateOneRequiredWithoutFormSubmissionsNestedInput
  }

  export type FormSubmissionUncheckedUpdateWithoutFormTemplateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    formType?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    id?: IntFieldUpdateOperationsInput | number
    Approvals?: FormApprovalUncheckedUpdateManyWithoutFormSubmissionNestedInput
  }

  export type FormSubmissionUncheckedUpdateManyWithoutFormTemplateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    formType?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    id?: IntFieldUpdateOperationsInput | number
  }

  export type FormGroupingUpdateWithoutFormTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    Fields?: FormFieldUpdateManyWithoutFormGroupingNestedInput
  }

  export type FormGroupingUncheckedUpdateWithoutFormTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    Fields?: FormFieldUncheckedUpdateManyWithoutFormGroupingNestedInput
  }

  export type FormGroupingUncheckedUpdateManyWithoutFormTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type FormFieldCreateManyFormGroupingInput = {
    id?: string
    label: string
    type: $Enums.FieldType
    required?: boolean
    order: number
    placeholder?: string | null
    maxLength?: number | null
    content?: string | null
    filter?: string | null
    minLength?: number | null
    multiple?: boolean | null
  }

  export type FormFieldUpdateWithoutFormGroupingInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    minLength?: NullableIntFieldUpdateOperationsInput | number | null
    multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Options?: FormFieldOptionUpdateManyWithoutFieldNestedInput
  }

  export type FormFieldUncheckedUpdateWithoutFormGroupingInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    minLength?: NullableIntFieldUpdateOperationsInput | number | null
    multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Options?: FormFieldOptionUncheckedUpdateManyWithoutFieldNestedInput
  }

  export type FormFieldUncheckedUpdateManyWithoutFormGroupingInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    maxLength?: NullableIntFieldUpdateOperationsInput | number | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    filter?: NullableStringFieldUpdateOperationsInput | string | null
    minLength?: NullableIntFieldUpdateOperationsInput | number | null
    multiple?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type FormTemplateUpdateWithoutFormGroupingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSignatureRequired?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    formType?: EnumFormTemplateCategoryFieldUpdateOperationsInput | $Enums.FormTemplateCategory
    isApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    Submissions?: FormSubmissionUpdateManyWithoutFormTemplateNestedInput
    Company?: CompanyUpdateOneRequiredWithoutFormTemplatesNestedInput
  }

  export type FormTemplateUncheckedUpdateWithoutFormGroupingInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSignatureRequired?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    formType?: EnumFormTemplateCategoryFieldUpdateOperationsInput | $Enums.FormTemplateCategory
    isApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
    Submissions?: FormSubmissionUncheckedUpdateManyWithoutFormTemplateNestedInput
  }

  export type FormTemplateUncheckedUpdateManyWithoutFormGroupingInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSignatureRequired?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    formType?: EnumFormTemplateCategoryFieldUpdateOperationsInput | $Enums.FormTemplateCategory
    isApprovalRequired?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FormFieldOptionCreateManyFieldInput = {
    id?: string
    value: string
  }

  export type FormFieldOptionUpdateWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type FormFieldOptionUncheckedUpdateWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type FormFieldOptionUncheckedUpdateManyWithoutFieldInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type FormApprovalCreateManyFormSubmissionInput = {
    id?: string
    signedBy?: string | null
    submittedAt?: Date | string
    updatedAt?: Date | string
    signature?: string | null
    comment?: string | null
  }

  export type FormApprovalUpdateWithoutFormSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    Approver?: UserUpdateOneWithoutFormApprovalsNestedInput
  }

  export type FormApprovalUncheckedUpdateWithoutFormSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FormApprovalUncheckedUpdateManyWithoutFormSubmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    signedBy?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TimeSheetCreateManyJobsiteInput = {
    date: Date | string
    userId: string
    costcode: string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    id?: number
  }

  export type TimeSheetUpdateWithoutJobsiteInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutTimeSheetNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutTimeSheetNestedInput
    CostCode?: CostCodeUpdateOneRequiredWithoutTimesheetsNestedInput
    User?: UserUpdateOneRequiredWithoutTimeSheetsNestedInput
    ChangeLogs?: TimeSheetChangeLogUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutTimeSheetNestedInput
  }

  export type TimeSheetUncheckedUpdateWithoutJobsiteInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    costcode?: StringFieldUpdateOperationsInput | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    ChangeLogs?: TimeSheetChangeLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutTimeSheetNestedInput
  }

  export type TimeSheetUncheckedUpdateManyWithoutJobsiteInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    costcode?: StringFieldUpdateOperationsInput | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type CCTagUpdateWithoutJobsitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    CostCodes?: CostCodeUpdateManyWithoutCCTagsNestedInput
  }

  export type CCTagUncheckedUpdateWithoutJobsitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    CostCodes?: CostCodeUncheckedUpdateManyWithoutCCTagsNestedInput
  }

  export type CCTagUncheckedUpdateManyWithoutJobsitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportRunCreateManyReportInput = {
    id?: string
    runAt?: Date | string
    status: $Enums.ReportStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    customParams?: NullableJsonNullValueInput | InputJsonValue
    exportFormats?: ReportRunCreateexportFormatsInput | string[]
    lastExportedAt?: Date | string | null
  }

  export type ReportRunUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customParams?: NullableJsonNullValueInput | InputJsonValue
    exportFormats?: ReportRunUpdateexportFormatsInput | string[]
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportRunUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customParams?: NullableJsonNullValueInput | InputJsonValue
    exportFormats?: ReportRunUpdateexportFormatsInput | string[]
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportRunUncheckedUpdateManyWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    runAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    results?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    customParams?: NullableJsonNullValueInput | InputJsonValue
    exportFormats?: ReportRunUpdateexportFormatsInput | string[]
    lastExportedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmployeeEquipmentLogCreateManyTimeSheetInput = {
    id?: string
    equipmentId?: string | null
    maintenanceId?: string | null
    startTime?: Date | string
    endTime?: Date | string | null
    comment?: string | null
    rental?: boolean
  }

  export type MaintenanceLogCreateManyTimeSheetInput = {
    id?: string
    userId: string
    maintenanceId: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
  }

  export type TascoLogCreateManyTimeSheetInput = {
    id?: string
    shiftType: string
    equipmentId?: string | null
    laborType?: string | null
    materialType?: string | null
    LoadQuantity?: number
    screenType?: $Enums.LoadType | null
  }

  export type TimeSheetChangeLogCreateManyTimeSheetInput = {
    id?: string
    changedBy: string
    changedAt?: Date | string
    changeReason?: string | null
    changes: JsonNullValueInput | InputJsonValue
    wasStatusChange?: boolean
    numberOfChanges?: number
  }

  export type TruckingLogCreateManyTimeSheetInput = {
    id?: string
    laborType: string
    taskName?: string | null
    equipmentId?: string | null
    startingMileage?: number | null
    endingMileage?: number | null
    truckLaborLogId?: string | null
    trailerNumber?: string | null
    truckNumber?: string | null
  }

  export type mechanicProjectsCreateManyTimeSheetInput = {
    id?: number
    hours?: number | null
    equipmentId: string
    description?: string | null
  }

  export type EmployeeEquipmentLogUpdateWithoutTimeSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    rental?: BoolFieldUpdateOperationsInput | boolean
    Equipment?: EquipmentUpdateOneWithoutEmployeeEquipmentLogsNestedInput
    Maintenance?: MaintenanceUpdateOneWithoutEmployeeEquipmentLogNestedInput
    RefuelLog?: RefuelLogUpdateOneWithoutEmployeeEquipmentLogNestedInput
  }

  export type EmployeeEquipmentLogUncheckedUpdateWithoutTimeSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    rental?: BoolFieldUpdateOperationsInput | boolean
    RefuelLog?: RefuelLogUncheckedUpdateOneWithoutEmployeeEquipmentLogNestedInput
  }

  export type EmployeeEquipmentLogUncheckedUpdateManyWithoutTimeSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    maintenanceId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    rental?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MaintenanceLogUpdateWithoutTimeSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    Maintenance?: MaintenanceUpdateOneRequiredWithoutMaintenanceLogsNestedInput
    User?: UserUpdateOneRequiredWithoutMaintenanceLogsNestedInput
  }

  export type MaintenanceLogUncheckedUpdateWithoutTimeSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    maintenanceId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceLogUncheckedUpdateManyWithoutTimeSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    maintenanceId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TascoLogUpdateWithoutTimeSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    RefuelLogs?: RefuelLogUpdateManyWithoutTascoLogNestedInput
    TascoFLoads?: TascoFLoadsUpdateManyWithoutTascoLogNestedInput
    Equipment?: EquipmentUpdateOneWithoutTascoLogsNestedInput
    TascoMaterialTypes?: TascoMaterialTypesUpdateOneWithoutTascoLogNestedInput
  }

  export type TascoLogUncheckedUpdateWithoutTimeSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    materialType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    RefuelLogs?: RefuelLogUncheckedUpdateManyWithoutTascoLogNestedInput
    TascoFLoads?: TascoFLoadsUncheckedUpdateManyWithoutTascoLogNestedInput
  }

  export type TascoLogUncheckedUpdateManyWithoutTimeSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    materialType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
  }

  export type TimeSheetChangeLogUpdateWithoutTimeSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    wasStatusChange?: BoolFieldUpdateOperationsInput | boolean
    numberOfChanges?: IntFieldUpdateOperationsInput | number
    User?: UserUpdateOneRequiredWithoutTimeSheetChangesNestedInput
  }

  export type TimeSheetChangeLogUncheckedUpdateWithoutTimeSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    wasStatusChange?: BoolFieldUpdateOperationsInput | boolean
    numberOfChanges?: IntFieldUpdateOperationsInput | number
  }

  export type TimeSheetChangeLogUncheckedUpdateManyWithoutTimeSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    wasStatusChange?: BoolFieldUpdateOperationsInput | boolean
    numberOfChanges?: IntFieldUpdateOperationsInput | number
  }

  export type TruckingLogUpdateWithoutTimeSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutTruckingLogNestedInput
    Materials?: MaterialUpdateManyWithoutTruckingLogNestedInput
    RefuelLogs?: RefuelLogUpdateManyWithoutTruckingLogNestedInput
    StateMileages?: StateMileageUpdateManyWithoutTruckingLogNestedInput
    Equipment?: EquipmentUpdateOneWithoutHauledInLogsNestedInput
    Trailer?: EquipmentUpdateOneWithoutUsedAsTrailerNestedInput
    Truck?: EquipmentUpdateOneWithoutUsedAsTruckNestedInput
  }

  export type TruckingLogUncheckedUpdateWithoutTimeSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    trailerNumber?: NullableStringFieldUpdateOperationsInput | string | null
    truckNumber?: NullableStringFieldUpdateOperationsInput | string | null
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutTruckingLogNestedInput
    Materials?: MaterialUncheckedUpdateManyWithoutTruckingLogNestedInput
    RefuelLogs?: RefuelLogUncheckedUpdateManyWithoutTruckingLogNestedInput
    StateMileages?: StateMileageUncheckedUpdateManyWithoutTruckingLogNestedInput
  }

  export type TruckingLogUncheckedUpdateManyWithoutTimeSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    laborType?: StringFieldUpdateOperationsInput | string
    taskName?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    endingMileage?: NullableIntFieldUpdateOperationsInput | number | null
    truckLaborLogId?: NullableStringFieldUpdateOperationsInput | string | null
    trailerNumber?: NullableStringFieldUpdateOperationsInput | string | null
    truckNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mechanicProjectsUpdateWithoutTimeSheetInput = {
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    Equipment?: EquipmentUpdateOneRequiredWithoutMaintenanceNestedInput
  }

  export type mechanicProjectsUncheckedUpdateWithoutTimeSheetInput = {
    id?: IntFieldUpdateOperationsInput | number
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mechanicProjectsUncheckedUpdateManyWithoutTimeSheetInput = {
    id?: IntFieldUpdateOperationsInput | number
    hours?: NullableFloatFieldUpdateOperationsInput | number | null
    equipmentId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeEquipmentLogCreateManyMaintenanceInput = {
    id?: string
    equipmentId?: string | null
    startTime?: Date | string
    endTime?: Date | string | null
    comment?: string | null
    timeSheetId: number
    rental?: boolean
  }

  export type MaintenanceLogCreateManyMaintenanceInput = {
    id?: string
    userId: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    timeSheetId: number
  }

  export type EmployeeEquipmentLogUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    rental?: BoolFieldUpdateOperationsInput | boolean
    Equipment?: EquipmentUpdateOneWithoutEmployeeEquipmentLogsNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutEmployeeEquipmentLogsNestedInput
    RefuelLog?: RefuelLogUpdateOneWithoutEmployeeEquipmentLogNestedInput
  }

  export type EmployeeEquipmentLogUncheckedUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    rental?: BoolFieldUpdateOperationsInput | boolean
    RefuelLog?: RefuelLogUncheckedUpdateOneWithoutEmployeeEquipmentLogNestedInput
  }

  export type EmployeeEquipmentLogUncheckedUpdateManyWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    rental?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MaintenanceLogUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutMaintenanceLogsNestedInput
    User?: UserUpdateOneRequiredWithoutMaintenanceLogsNestedInput
  }

  export type MaintenanceLogUncheckedUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
  }

  export type MaintenanceLogUncheckedUpdateManyWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
  }

  export type RefuelLogCreateManyTascoLogInput = {
    id?: string
    employeeEquipmentLogId?: string | null
    truckingLogId?: string | null
    gallonsRefueled?: number | null
    milesAtFueling?: number | null
  }

  export type TascoFLoadsCreateManyTascoLogInput = {
    id?: number
    weight?: number | null
    screenType?: $Enums.LoadType | null
  }

  export type RefuelLogUpdateWithoutTascoLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    gallonsRefueled?: NullableFloatFieldUpdateOperationsInput | number | null
    milesAtFueling?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogUpdateOneWithoutRefuelLogNestedInput
    TruckingLog?: TruckingLogUpdateOneWithoutRefuelLogsNestedInput
  }

  export type RefuelLogUncheckedUpdateWithoutTascoLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    truckingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    gallonsRefueled?: NullableFloatFieldUpdateOperationsInput | number | null
    milesAtFueling?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RefuelLogUncheckedUpdateManyWithoutTascoLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    truckingLogId?: NullableStringFieldUpdateOperationsInput | string | null
    gallonsRefueled?: NullableFloatFieldUpdateOperationsInput | number | null
    milesAtFueling?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TascoFLoadsUpdateWithoutTascoLogInput = {
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
  }

  export type TascoFLoadsUncheckedUpdateWithoutTascoLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
  }

  export type TascoFLoadsUncheckedUpdateManyWithoutTascoLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
  }

  export type TascoLogCreateManyTascoMaterialTypesInput = {
    id?: string
    shiftType: string
    equipmentId?: string | null
    laborType?: string | null
    LoadQuantity?: number
    screenType?: $Enums.LoadType | null
    timeSheetId: number
  }

  export type TascoLogUpdateWithoutTascoMaterialTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    RefuelLogs?: RefuelLogUpdateManyWithoutTascoLogNestedInput
    TascoFLoads?: TascoFLoadsUpdateManyWithoutTascoLogNestedInput
    Equipment?: EquipmentUpdateOneWithoutTascoLogsNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutTascoLogsNestedInput
  }

  export type TascoLogUncheckedUpdateWithoutTascoMaterialTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
    RefuelLogs?: RefuelLogUncheckedUpdateManyWithoutTascoLogNestedInput
    TascoFLoads?: TascoFLoadsUncheckedUpdateManyWithoutTascoLogNestedInput
  }

  export type TascoLogUncheckedUpdateManyWithoutTascoMaterialTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftType?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    laborType?: NullableStringFieldUpdateOperationsInput | string | null
    LoadQuantity?: IntFieldUpdateOperationsInput | number
    screenType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
  }

  export type EquipmentHauledCreateManyTruckingLogInput = {
    id?: string
    equipmentId?: string | null
    createdAt?: Date | string
    endMileage?: number | null
    startMileage?: number | null
    destination?: string | null
    source?: string | null
  }

  export type MaterialCreateManyTruckingLogInput = {
    id?: string
    LocationOfMaterial?: string | null
    name?: string | null
    quantity?: number | null
    materialWeight?: number | null
    loadType?: $Enums.LoadType | null
    createdAt?: Date | string | null
    unit?: $Enums.materialUnit | null
  }

  export type RefuelLogCreateManyTruckingLogInput = {
    id?: string
    employeeEquipmentLogId?: string | null
    tascoLogId?: string | null
    gallonsRefueled?: number | null
    milesAtFueling?: number | null
  }

  export type StateMileageCreateManyTruckingLogInput = {
    id?: string
    state?: string | null
    stateLineMileage?: number | null
  }

  export type EquipmentHauledUpdateWithoutTruckingLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startMileage?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    Equipment?: EquipmentUpdateOneWithoutEquipmentHauledNestedInput
  }

  export type EquipmentHauledUncheckedUpdateWithoutTruckingLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startMileage?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentHauledUncheckedUpdateManyWithoutTruckingLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endMileage?: NullableIntFieldUpdateOperationsInput | number | null
    startMileage?: NullableIntFieldUpdateOperationsInput | number | null
    destination?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaterialUpdateWithoutTruckingLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    LocationOfMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    materialWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    loadType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: NullableEnummaterialUnitFieldUpdateOperationsInput | $Enums.materialUnit | null
  }

  export type MaterialUncheckedUpdateWithoutTruckingLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    LocationOfMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    materialWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    loadType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: NullableEnummaterialUnitFieldUpdateOperationsInput | $Enums.materialUnit | null
  }

  export type MaterialUncheckedUpdateManyWithoutTruckingLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    LocationOfMaterial?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableFloatFieldUpdateOperationsInput | number | null
    materialWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    loadType?: NullableEnumLoadTypeFieldUpdateOperationsInput | $Enums.LoadType | null
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unit?: NullableEnummaterialUnitFieldUpdateOperationsInput | $Enums.materialUnit | null
  }

  export type RefuelLogUpdateWithoutTruckingLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    gallonsRefueled?: NullableFloatFieldUpdateOperationsInput | number | null
    milesAtFueling?: NullableIntFieldUpdateOperationsInput | number | null
    EmployeeEquipmentLog?: EmployeeEquipmentLogUpdateOneWithoutRefuelLogNestedInput
    TascoLog?: TascoLogUpdateOneWithoutRefuelLogsNestedInput
  }

  export type RefuelLogUncheckedUpdateWithoutTruckingLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    tascoLogId?: NullableStringFieldUpdateOperationsInput | string | null
    gallonsRefueled?: NullableFloatFieldUpdateOperationsInput | number | null
    milesAtFueling?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RefuelLogUncheckedUpdateManyWithoutTruckingLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeEquipmentLogId?: NullableStringFieldUpdateOperationsInput | string | null
    tascoLogId?: NullableStringFieldUpdateOperationsInput | string | null
    gallonsRefueled?: NullableFloatFieldUpdateOperationsInput | number | null
    milesAtFueling?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StateMileageUpdateWithoutTruckingLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    stateLineMileage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StateMileageUncheckedUpdateWithoutTruckingLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    stateLineMileage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StateMileageUncheckedUpdateManyWithoutTruckingLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    stateLineMileage?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EquipmentCreateManyCreatedByInput = {
    id?: string
    qrId: string
    name: string
    description?: string | null
    creationReason?: string | null
    equipmentTag?: $Enums.EquipmentTags
    state?: $Enums.EquipmentState
    approvalStatus?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    overWeight?: boolean | null
    currentWeight?: number | null
    createdVia?: $Enums.CreatedVia
    acquiredDate?: Date | string | null
    code?: string | null
    color?: string | null
    licensePlate?: string | null
    licenseState?: string | null
    make?: string | null
    memo?: string | null
    model?: string | null
    ownershipType?: $Enums.OwnershipType | null
    registrationExpiration?: Date | string | null
    serialNumber?: string | null
    year?: string | null
    acquiredCondition?: $Enums.Condition | null
    status?: $Enums.FormTemplateStatus
  }

  export type FCMTokenCreateManyUserInput = {
    id?: string
    token: string
    platform?: string | null
    lastUsedAt?: Date | string | null
    isValid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FormApprovalCreateManyApproverInput = {
    id?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    signature?: string | null
    comment?: string | null
    formSubmissionId: number
  }

  export type FormSubmissionCreateManyUserInput = {
    title?: string | null
    formTemplateId: string
    formType?: string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    submittedAt?: Date | string | null
    status?: $Enums.FormStatus
    id?: number
  }

  export type JobsiteCreateManyCreatedByInput = {
    id?: string
    qrId?: string
    name: string
    description: string
    creationReason?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    addressId?: string | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    archiveDate?: Date | string | null
    createdVia?: $Enums.CreatedVia
    code?: string | null
    latitude?: number | null
    longitude?: number | null
    radiusMeters?: number | null
    status?: $Enums.FormTemplateStatus
  }

  export type MaintenanceLogCreateManyUserInput = {
    id?: string
    maintenanceId: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    timeSheetId: number
  }

  export type NotificationReadCreateManyUserInput = {
    id?: number
    notificationId: number
    readAt?: Date | string
  }

  export type NotificationResponseCreateManyUserInput = {
    id?: number
    notificationId: number
    response?: string | null
    respondedAt?: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: string
    token: string
    expiration: Date | string
  }

  export type TimeSheetCreateManyUserInput = {
    date: Date | string
    jobsiteId: string
    costcode: string
    nu?: string
    Fp?: string
    startTime: Date | string
    endTime?: Date | string | null
    comment?: string | null
    statusComment?: string | null
    location?: string | null
    status?: $Enums.ApprovalStatus
    workType: $Enums.WorkType
    editedByUserId?: string | null
    newTimeSheetId?: string | null
    createdByAdmin?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clockInLat?: number | null
    clockInLng?: number | null
    clockOutLat?: number | null
    clockOutLng?: number | null
    withinFenceIn?: boolean | null
    withinFenceOut?: boolean | null
    wasInjured?: boolean | null
    id?: number
  }

  export type TimeSheetChangeLogCreateManyUserInput = {
    id?: string
    timeSheetId: number
    changedAt?: Date | string
    changeReason?: string | null
    changes: JsonNullValueInput | InputJsonValue
    wasStatusChange?: boolean
    numberOfChanges?: number
  }

  export type TopicSubscriptionCreateManyUserInput = {
    id?: string
    topic: string
    createdAt?: Date | string
  }

  export type EquipmentUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutEquipmentNestedInput
    EquipmentHauled?: EquipmentHauledUncheckedUpdateManyWithoutEquipmentNestedInput
    Maintenances?: MaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutEquipmentNestedInput
    HauledInLogs?: TruckingLogUncheckedUpdateManyWithoutEquipmentNestedInput
    UsedAsTrailer?: TruckingLogUncheckedUpdateManyWithoutTrailerNestedInput
    UsedAsTruck?: TruckingLogUncheckedUpdateManyWithoutTruckNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutEquipmentNestedInput
    DocumentTags?: DocumentTagUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    equipmentTag?: EnumEquipmentTagsFieldUpdateOperationsInput | $Enums.EquipmentTags
    state?: EnumEquipmentStateFieldUpdateOperationsInput | $Enums.EquipmentState
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overWeight?: NullableBoolFieldUpdateOperationsInput | boolean | null
    currentWeight?: NullableFloatFieldUpdateOperationsInput | number | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    acquiredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    licensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    licenseState?: NullableStringFieldUpdateOperationsInput | string | null
    make?: NullableStringFieldUpdateOperationsInput | string | null
    memo?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    ownershipType?: NullableEnumOwnershipTypeFieldUpdateOperationsInput | $Enums.OwnershipType | null
    registrationExpiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    acquiredCondition?: NullableEnumConditionFieldUpdateOperationsInput | $Enums.Condition | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
  }

  export type FCMTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FCMTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FCMTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isValid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormApprovalUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    FormSubmission?: FormSubmissionUpdateOneRequiredWithoutApprovalsNestedInput
  }

  export type FormApprovalUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    formSubmissionId?: IntFieldUpdateOperationsInput | number
  }

  export type FormApprovalUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    signature?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    formSubmissionId?: IntFieldUpdateOperationsInput | number
  }

  export type FormSubmissionUpdateWithoutUserInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    formType?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    Approvals?: FormApprovalUpdateManyWithoutFormSubmissionNestedInput
    FormTemplate?: FormTemplateUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type FormSubmissionUncheckedUpdateWithoutUserInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    formTemplateId?: StringFieldUpdateOperationsInput | string
    formType?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    id?: IntFieldUpdateOperationsInput | number
    Approvals?: FormApprovalUncheckedUpdateManyWithoutFormSubmissionNestedInput
  }

  export type FormSubmissionUncheckedUpdateManyWithoutUserInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    formTemplateId?: StringFieldUpdateOperationsInput | string
    formType?: NullableStringFieldUpdateOperationsInput | string | null
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumFormStatusFieldUpdateOperationsInput | $Enums.FormStatus
    id?: IntFieldUpdateOperationsInput | number
  }

  export type JobsiteUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    code?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radiusMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    Address?: AddressUpdateOneWithoutJobsiteNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutJobsiteNestedInput
    CCTags?: CCTagUpdateManyWithoutJobsitesNestedInput
  }

  export type JobsiteUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    code?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radiusMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutJobsiteNestedInput
    CCTags?: CCTagUncheckedUpdateManyWithoutJobsitesNestedInput
  }

  export type JobsiteUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    addressId?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    code?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radiusMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
  }

  export type MaintenanceLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    Maintenance?: MaintenanceUpdateOneRequiredWithoutMaintenanceLogsNestedInput
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutMaintenanceLogsNestedInput
  }

  export type MaintenanceLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    maintenanceId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
  }

  export type MaintenanceLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    maintenanceId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    timeSheetId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationReadUpdateWithoutUserInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutReadsNestedInput
  }

  export type NotificationReadUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationReadUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationResponseUpdateWithoutUserInput = {
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutResponseNestedInput
  }

  export type NotificationResponseUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationResponseUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    notificationId?: IntFieldUpdateOperationsInput | number
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiration?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiration?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiration?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeSheetUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUpdateManyWithoutTimeSheetNestedInput
    MaintenanceLogs?: MaintenanceLogUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUpdateManyWithoutTimeSheetNestedInput
    CostCode?: CostCodeUpdateOneRequiredWithoutTimesheetsNestedInput
    Jobsite?: JobsiteUpdateOneRequiredWithoutTimeSheetsNestedInput
    ChangeLogs?: TimeSheetChangeLogUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUpdateManyWithoutTimeSheetNestedInput
  }

  export type TimeSheetUncheckedUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobsiteId?: StringFieldUpdateOperationsInput | string
    costcode?: StringFieldUpdateOperationsInput | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
    EmployeeEquipmentLogs?: EmployeeEquipmentLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    MaintenanceLogs?: MaintenanceLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TascoLogs?: TascoLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    ChangeLogs?: TimeSheetChangeLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    TruckingLogs?: TruckingLogUncheckedUpdateManyWithoutTimeSheetNestedInput
    Maintenance?: mechanicProjectsUncheckedUpdateManyWithoutTimeSheetNestedInput
  }

  export type TimeSheetUncheckedUpdateManyWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    jobsiteId?: StringFieldUpdateOperationsInput | string
    costcode?: StringFieldUpdateOperationsInput | string
    nu?: StringFieldUpdateOperationsInput | string
    Fp?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    statusComment?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    workType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    editedByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    newTimeSheetId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByAdmin?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clockInLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockInLng?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLat?: NullableFloatFieldUpdateOperationsInput | number | null
    clockOutLng?: NullableFloatFieldUpdateOperationsInput | number | null
    withinFenceIn?: NullableBoolFieldUpdateOperationsInput | boolean | null
    withinFenceOut?: NullableBoolFieldUpdateOperationsInput | boolean | null
    wasInjured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type TimeSheetChangeLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    wasStatusChange?: BoolFieldUpdateOperationsInput | boolean
    numberOfChanges?: IntFieldUpdateOperationsInput | number
    TimeSheet?: TimeSheetUpdateOneRequiredWithoutChangeLogsNestedInput
  }

  export type TimeSheetChangeLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeSheetId?: IntFieldUpdateOperationsInput | number
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    wasStatusChange?: BoolFieldUpdateOperationsInput | boolean
    numberOfChanges?: IntFieldUpdateOperationsInput | number
  }

  export type TimeSheetChangeLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    timeSheetId?: IntFieldUpdateOperationsInput | number
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changeReason?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: JsonNullValueInput | InputJsonValue
    wasStatusChange?: BoolFieldUpdateOperationsInput | boolean
    numberOfChanges?: IntFieldUpdateOperationsInput | number
  }

  export type TopicSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TopicSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    topic?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    crewType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    crewType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CrewUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    crewType?: EnumWorkTypeFieldUpdateOperationsInput | $Enums.WorkType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateManyAddressInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    SubscriptionDate?: Date | string
  }

  export type JobsiteCreateManyAddressInput = {
    id?: string
    qrId?: string
    name: string
    description: string
    creationReason?: string | null
    approvalStatus?: $Enums.ApprovalStatus
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    archiveDate?: Date | string | null
    createdById?: string | null
    createdVia?: $Enums.CreatedVia
    code?: string | null
    latitude?: number | null
    longitude?: number | null
    radiusMeters?: number | null
    status?: $Enums.FormTemplateStatus
  }

  export type CompanyUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubscriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FormTemplates?: FormTemplateUpdateManyWithoutCompanyNestedInput
    Reports?: ReportUpdateManyWithoutCompanyNestedInput
    Users?: UserUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubscriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    FormTemplates?: FormTemplateUncheckedUpdateManyWithoutCompanyNestedInput
    Reports?: ReportUncheckedUpdateManyWithoutCompanyNestedInput
    Users?: UserUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateManyWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    SubscriptionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobsiteUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    code?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radiusMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    createdBy?: UserUpdateOneWithoutJobsiteNestedInput
    TimeSheets?: TimeSheetUpdateManyWithoutJobsiteNestedInput
    CCTags?: CCTagUpdateManyWithoutJobsitesNestedInput
  }

  export type JobsiteUncheckedUpdateWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    code?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radiusMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
    TimeSheets?: TimeSheetUncheckedUpdateManyWithoutJobsiteNestedInput
    CCTags?: CCTagUncheckedUpdateManyWithoutJobsitesNestedInput
  }

  export type JobsiteUncheckedUpdateManyWithoutAddressInput = {
    id?: StringFieldUpdateOperationsInput | string
    qrId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    creationReason?: NullableStringFieldUpdateOperationsInput | string | null
    approvalStatus?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archiveDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdVia?: EnumCreatedViaFieldUpdateOperationsInput | $Enums.CreatedVia
    code?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    radiusMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumFormTemplateStatusFieldUpdateOperationsInput | $Enums.FormTemplateStatus
  }

  export type NotificationReadCreateManyNotificationInput = {
    id?: number
    userId: string
    readAt?: Date | string
  }

  export type NotificationReadUpdateWithoutNotificationInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationReadNestedInput
  }

  export type NotificationReadUncheckedUpdateWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationReadUncheckedUpdateManyWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}